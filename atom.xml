<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>How 2 Play Life</title>
  
  <subtitle>Java后端开发之路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://h2pl.github.io/"/>
  <updated>2018-07-09T15:10:03.929Z</updated>
  <id>http://h2pl.github.io/</id>
  
  <author>
    <name>h2pl</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式学习总结</title>
    <link href="http://h2pl.github.io/2018/07/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://h2pl.github.io/2018/07/09/设计模式学习总结/</id>
    <published>2018-07-09T15:05:07.000Z</published>
    <updated>2018-07-09T15:10:03.929Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式基础学习总结<br>这篇总结主要是基于我之前设计模式基础系列文章而形成的的。主要是把重要的知识点用自己的话说了一遍，可能会有一些错误，还望见谅和指点。谢谢</p><p>更多详细内容可以查看我的专栏文章：设计模式学习<br><a href="https://blog.csdn.net/a724888/article/category/6780980" target="_blank" rel="noopener">https://blog.csdn.net/a724888/article/category/6780980</a><br><a id="more"></a></p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>创建型模式<br>创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。</p><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><pre><code>单例模式保证全局的单例类只有一个实例，这样的话使用的时候直接获取即可，比如数据库的一个连接，Spring里的bean，都可以是单例的。单例模式一般有5种写法。第一种是饿汉模式，先把单例进行实例化，获取的时候通过静态方法直接获取即可。缺点是类加载后就完成了类的实例化，浪费部分空间。第二种是饱汉模式，先把单例置为null，然后通过静态方法获取单例时再进行实例化，但是可能有多线程同时进行实例化，会出现并发问题。第三种是逐步改进的方法，一开始可以用synchronized关键字进行同步，但是开销太大，而后改成使用volatile修饰单例，然后通过一次检查判断单例是否已初始化，如果未初始化就使用synchronized代码块，再次检查单例防止在这期间被初始化，而后才真正进行初始化。第四种是使用静态内部类来实现，静态内部类只在被使用的时候才进行初始化，所以在内部类中进行单例的实例化，只有用到的时候才会运行实例化代码。然后外部类再通过静态方法返回静态内部类的单例即可。第五种是枚举类，枚举类的底层实现其实也是内部类。枚举类确保每个类对象在全局是唯一的。所以保证它是单例，这个方法是最简单的。</code></pre><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><pre><code>简单工厂一般是用一个工厂创建多个类的实例。工厂模式一般是指一个工厂服务一个接口，为这个接口的实现类进行实例化抽象工厂模式是指一个工厂服务于一个产品族，一个产品族可能包含多个接口，接口又会包含多个实现类，通过一个工厂就可以把这些绑定在一起，非常方便。</code></pre><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><pre><code>一般通过一个实例进行克隆从而获得更多同一原型的实例。使用实例的clone方法即可完成。</code></pre><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><pre><code>建造者模式中有一个概念叫做链式调用，链式调用为一个类的实例化提供便利，一般提供系列的方法进行实例化，实际上就是将set方法改造一下，将原本返回为空的set方法改为返回this实例，从而实现链式调用。建造者模式在此基础上加入了builder方法，提供给外部进行调用，同样使用链式调用来完成参数注入。</code></pre><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>结构型模式<br>前面创建型模式介绍了创建对象的一些设计模式，这节介绍的结构型模式旨在通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展。</p><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>有点复杂。建议参考原文</p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式用于将两个不同的类进行适配。</p><p>适配器模式和代理模式的异同</p><p> 比较这两种模式，其实是比较对象适配器模式和代理模式，在代码结构上，<br> 它们很相似，都需要一个具体的实现类的实例。<br> 但是它们的目的不一样，代理模式做的是增强原方法的活；<br> 适配器做的是适配的活，为的是提供“把鸡包装成鸭，然后当做鸭来使用”，<br> 而鸡和鸭它们之间原本没有继承关系。</p><p> 适配器模式可以分为类适配器，对象适配器等。</p><p> 类适配器通过继承父类就可以把自己适配成父类了。<br> 而对象适配器则需要把对象传入另一个对象的构造方法中，以便进行包装。</p><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>/ 享元模式的核心在于享元工厂类，<br>// 享元工厂类的作用在于提供一个用于存储享元对象的享元池，<br>// 用户需要对象时，首先从享元池中获取，<br>// 如果享元池中不存在，则创建一个新的享元对象返回给用户，<br>// 在享元池中保存该新增对象。</p><p>//享元模式<br>//        英文是 Flyweight Pattern，不知道是谁最先翻译的这个词，感觉这翻译真的不好理解，我们试着强行关联起来吧。Flyweight 是轻量级的意思，享元分开来说就是 共享 元器件，也就是复用已经生成的对象，这种做法当然也就是轻量级的了。<br>//<br>//        复用对象最简单的方式是，用一个 HashMap 来存放每次新生成的对象。每次需要一个对象的时候，先到 HashMap 中看看有没有，如果没有，再生成新的对象，然后将这个对象放入 HashMap 中。<br>//<br>//        这种简单的代码我就不演示了。</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>//    我们发现没有，代理模式说白了就是做 “方法包装” 或做 “方法增强”。<br>// 在面向切面编程中，算了还是不要吹捧这个名词了，在 AOP 中，<br>// 其实就是动态代理的过程。比如 Spring 中，<br>// 我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，<br>// 然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。</p><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式一般封装具体的实现细节，为用户提供一个更加简单的接口。</p><p>通过一个方法调用就可以获取需要的内容。</p><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>//组合模式用于表示具有层次结构的数据，使得我们对单个对象和组合对象的访问具有一致性。</p><p>//直接看一个例子吧，每个员工都有姓名、部门、薪水这些属性，<br>// 同时还有下属员工集合（虽然可能集合为空），<br>// 而下属员工和自己的结构是一样的，<br>// 也有姓名、部门这些属性，<br>// 同时也有他们的下属员工集合。</p><pre><code>class Employee {    private String name;    private String dept;    private int salary;    private List&lt;Employee&gt; subordinates; // 下属}</code></pre><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><h2 id="装饰者"><a href="#装饰者" class="headerlink" title="装饰者"></a>装饰者</h2><p>装饰者模式把每个增强类都继承最高级父类。然后需要功能增强时把类实例传入增强类即可，然后增强类在使用时就可以增强原有类的功能了。</p><p>和代理模式不同的是，装饰者模式每个装饰类都继承父类，并且可以进行多级封装。</p><h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><p>行为型模式<br>行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰。</p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式一般把一个策略作为一个类，并且在需要指定策略的时候传入实例，于是我们可以在需要使用算法的地方传入指定算法。</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式一般分为命令发起者，命令以及命令接受者三个角色。</p><p>命令发起者在使用时需要注入命令实例。然后执行命令调用。</p><p>命令调用实际上会调用命令接收者的方法进行实际调用。</p><p>比如遥控器按钮相当于一条命令，点击按钮时命令运行，自动调用电视机提供的方法即可。</p><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>模板方法一般指提供了一个方法模板，并且其中有部分实现类和部分抽象类，并且规定了执行顺序。</p><p>实现类是模板提供好的方法。而抽象类则需要用户自行实现。</p><p>模板方法规定了一个模板中方法的执行顺序，非常适合一些开发框架，于是模板方法也广泛运用在开源框架中。</p><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>少见。</p><h2 id="观察者模式和事件监听机制"><a href="#观察者模式和事件监听机制" class="headerlink" title="观察者模式和事件监听机制"></a>观察者模式和事件监听机制</h2><p>观察者模式一般用于订阅者和消息发布者之间的数据订阅。</p><p>一般分为观察者和主题，观察者订阅主题，把实例注册到主题维护的观察者列表上。</p><p>而主题更新数据时自动把数据推给观察者或者通知观察者数据已经更新。</p><p>但是由于这样的方式消息推送耦合关系比较紧。并且很难在不打开数据的情况下知道数据类型是什么。</p><p>知道后来为了使数据格式更加灵活，使用了事件和事件监听器的模式，事件包装的事件类型和事件数据，从主题和观察者中解耦。</p><p>主题当事件发生时，触发该事件的所有监听器，把该事件通过监听器列表发给每个监听器，监听得到事件以后，首先根据自己支持处理的事件类型中找到对应的事件处理器，再用处理器处理对应事件。</p><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。比如流程审批就是一个很好的例子，只要终端用户提交申请，根据申请的内容信息，自动建立一条责任链，然后就可以开始流转了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式基础学习总结&lt;br&gt;这篇总结主要是基于我之前设计模式基础系列文章而形成的的。主要是把重要的知识点用自己的话说了一遍，可能会有一些错误，还望见谅和指点。谢谢&lt;/p&gt;
&lt;p&gt;更多详细内容可以查看我的专栏文章：设计模式学习&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/a724888/article/category/6780980&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888/article/category/6780980&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="技术总结" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="设计模式" scheme="http://h2pl.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核与基础命令学习总结</title>
    <link href="http://h2pl.github.io/2018/07/09/Linux%E5%86%85%E6%A0%B8%E4%B8%8E%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://h2pl.github.io/2018/07/09/Linux内核与基础命令学习总结/</id>
    <published>2018-07-09T14:33:14.000Z</published>
    <updated>2018-07-09T15:07:50.014Z</updated>
    
    <content type="html"><![CDATA[<p>这部分内容主要是基于一些关于Linux系统的内核基础和基本命令的学习总结，内容不全面，只讲述了其中的一小部分，后续会再补充，如有错误，还请见谅。</p><p>Linux操作系统</p><p>Linux操作系统博大精深，其中对线程，IO，文件系统等概念的实现都很有借鉴意义。<br><a id="more"></a></p><h2 id="文件系统和VFS"><a href="#文件系统和VFS" class="headerlink" title="文件系统和VFS"></a>文件系统和VFS</h2><p>文件系统的inode上面讲过了。VFS主要用于屏蔽底层的不同文件系统，比如接入网络中的nfs文件系统，亦或是windows文件系统，正常情况下难以办到，而vfs通过使用IO操作的posix规范来规定所有文件读写操作，每个文件系统只需要实现这些操作就可以接入VFS，不需要重新安装文件系统。</p><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><pre><code>&gt; 进程、程序与线程&gt; &gt; 程序&gt; &gt;  程序，简单的来说就是存在磁盘上的二进制文件，是可以内核所执行的代码 &gt; &gt; 进程&gt; &gt;  当一个用户启动一个程序，将会在内存中开启一块空间，这就创造了一个进程，一个进程包含一个独一无二的PID，和执行者的权限属性参数，以及程序所需代码与相关的资料。&gt;  进程是系统分配资源的基本单位。&gt;  一个进程可以衍生出其他的子进程，子进程的相关权限将会沿用父进程的相关权限。&gt; &gt; 线程&gt; &gt;  每个进程包含一个或多个线程，线程是进程内的活动单元，是负责执行代码和管理进程运行状态的抽象。&gt;  线程是独立运行和调度的基本单位。</code></pre><blockquote><p> 子进程和父进程<br>进程的层次结构（父进程与子进程）在进程执行的过程中可能会衍生出其他的进程，称之为子进程，子进程拥有一个指明其父进程PID的PPID。子进程可以继承父进程的环境变量和权限参数。</p><p>于是，linux系统中就诞生了进程的层次结构——进程树。<br>进程树的根是第一个进程（init进程）。</p><p>过程调用的流程： fork &amp; exec一个进程生成子进程的过程是，系统首先复制(fork)一份父进程，生成一个暂存进程，这个暂存进程和父进程的区别是pid不一样，而且拥有一个ppid，这时候系统再去执行(exec)这个暂存进程，让他加载实际要运行的程序，最终成为一个子进程的存在。</p><p>服务与进程</p><p>简单的说服务(daemon)就是常驻内存的进程，通常服务会在开机时通过init.d中的一段脚本被启动。</p><p>进程通信</p><p>进程通信的几种基本方式：管道，信号量，消息队列，共享内存，快速用户控件互斥。 </p></blockquote><h2 id="fork方法"><a href="#fork方法" class="headerlink" title="fork方法"></a>fork方法</h2><p>  一个进程，包括代码、数据和分配给进程的资源。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，</p><p>也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。</p><pre><code>一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都</code></pre><p>复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。</p><pre><code>fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：    1）在父进程中，fork返回新创建子进程的进程ID；    2）在子进程中，fork返回0；    3）如果出现错误，fork返回一个负值；</code></pre><p>如何理解pid在父子进程中不同？</p><p>其实就相当于链表，进程形成了链表，父进程的pid指向了子进程的pid，因为子进程没有子进程，所以pid为0。</p><h2 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h2><pre><code>传统的fork机制是，调用fork时，内核会复制所有的内部数据结构，复制进程的页表项，然后把父进程的地址空间按页复制给子进程（非常耗时）。现代的fork机制采用了一种惰性算法的优化策略。为了避免复制时系统开销，就尽可能的减少“复制”操作，当多个进程需要读取他们自己那部分资源的副本时，并不复制多个副本出来，而是为每个进程设定一个文件指针，让它们读取同一个实际文件。显然这样的方式会在写入时产生冲突（类似并发），于是当某个进程想要修改自己的那个副本时，再去复制该资源，（只有写入时才复制，所以叫写时复制）这样就减少了复制的频率。</code></pre><h2 id="父子进程，僵尸进程，孤儿进程，守护进程"><a href="#父子进程，僵尸进程，孤儿进程，守护进程" class="headerlink" title="父子进程，僵尸进程，孤儿进程，守护进程"></a>父子进程，僵尸进程，孤儿进程，守护进程</h2><p>父进程通过fork产生子进程。</p><p>孤儿进程：当子进程未结束时父进程异常退出，原本需要由父进程进行处理的子进程变成了孤儿进程，init系统进程会把这些进程领养，避免他们成为孤儿。</p><p>僵尸进程：当子进程结束时，会在内存中保留一部分数据结构等待父亲进程显式结束，如果父进程没有执行结束操作，则会导致子进程的剩余结构无法被释放，占用空间造成严重后果。</p><p>守护进程：守护进程用于监控其他进程，当发现大量僵尸进程时，会找到他们的父节点并杀死，同时让init线程认养他们以便释放这些空间。</p><p>僵尸进程是有害的，孤儿进程由于内核进程的认养不会造成危害。</p><h2 id="进程组和会话"><a href="#进程组和会话" class="headerlink" title="进程组和会话"></a>进程组和会话</h2><blockquote><p>会话和进程组进程组每个进程都属于某个进程组，进程组就是由一个或者多个为了实现作业控制而相互关联的进程组成的。</p><p>一个进程组的id是进程组首进程的pid（如果一个进程组只有一个进程，那进程组和进程其实没啥区别）。</p><p>进程组的意义在于，信号可以发送给进程组中的所有进程。这样可以实现对多个进程的同时操作。<br>会话会话是一个或者多个进程组的集合。</p><p>一般来说，会话(session)和shell没有什么本质上的区别。<br>我们通常使用用户登录一个终端进行一系列操作这样的例子来描述一次会话。</p></blockquote><p>举例</p><p>$cat ship-inventory.txt | grep</p><p>booty|sort上面就是在某次会话中的一个shell命令，它会产生一个由3个进程组成的进程组。</p><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>守护进程（服务）守护进程(daemon)运行在后台，不与任何控制终端相关联。通常在系统启动时通过init脚本被调用而开始运行。</p><p>在linux系统中，守护进程和服务没有什么区别。<br>对于一个守护进程，有两个基本的要求：其一：必须作为init进程的子进程运行，其二：不与任何控制终端交互。</p><h2 id="硬连接和软连接"><a href="#硬连接和软连接" class="headerlink" title="硬连接和软连接"></a>硬连接和软连接</h2><p>硬链接指的是不同的文件名指向同一个inode节点，比如某个目录下的a和另一个目录下的b，建立一个软连接让a指向b，则a和b共享同一个inode。</p><p>软连接是指一个文件的inode节点不存数据，而是存储着另一个文件的绝对路径，访问文件内容时实际上是去访问对应路径下的文件inode，这样的话文件发生改动或者移动都会导致软连接失效。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程基础概念线程是进程内的执行单元（比进程更低一层的概念），具体包括 虚拟处理器，堆栈，程序状态等。<br>可以认为 线程是操作系统调度的最小执行单元。</p><p>现代操作系统对用户空间做两个基础抽象:虚拟内存和虚拟处理器。这使得进程内部“感觉”自己独占机器资源。</p><p>虚拟内存系统会为每个进程分配独立的内存空间，这会让进程以为自己独享全部的RAM。</p><p>但是同一个进程内的所有线程共享该进程的内存空间。<br>虚拟处理器这是一个针对线程的概念，它让每个线程都“感觉”自己独享CPU。实际上对于进程也是一样的。</p><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p>线程模型线程的概念同时存在于内核和用户空间中。下面介绍三种线程模型。</p><pre><code>内核级线程模型每个内核线程直接转换成用户空间的线程。即内核线程：用户空间线程=1：1用户级线程模型这种模型下，一个保护了n个线程的用户进程只会映射到一个内核进程。即n:1。可以减少上下文切换的成本，但在linux下没什么意义，因为linux下进程间的上下文切换本身就没什么消耗，所以很少使用。混合式线程模型上述两种模型的混合，即n:m型。很难实现。</code></pre><h2 id="内核线程实现"><a href="#内核线程实现" class="headerlink" title="内核线程实现"></a>内核线程实现</h2><p>系统线程实现：PThreads<br>原始的linux系统调用中，没有像C++11或者是Java那样完整的线程库。</p><p>整体看来pthread的api比较冗余和复杂，但是基本操作也主要是 创建、退出等。</p><p>1.创建线程</p><pre><code>int pthread_create(若线程创建成功，则返回0。若线程创建失败，则返回出错编号)　　注意:线程创建者和新建线程之间没有fork()调用那样的父子关系，它们是对等关系。调用pthread_create()创建线程后，线程创建者和新建线程哪个先运行是不确定的，特别是在多处理机器上。</code></pre><p>　　<br>2.终止线程</p><pre><code>void pthread_exit(void *value_ptr);   线程调用pthread_exit()结束自己，参数value_ptr作为线程的返回值被调用pthread_join的线程使用。由于一个进程中的多个线程是共享数据段的，因此通常在线程退出之后，退出线程所占用的资源并不会随着线程的终止而得到释放，但是可以用pthread_join()函数来同步并释放资源</code></pre><p>3.取消线程</p><pre><code>int pthread_cancel(pthread_t thread);　　注意：若是在整个程序退出时，要终止各个线程，应该在成功发送 CANCEL指令后，使用 pthread_join函数，等待指定的线程已经完全退出以后，再继续执行；否则，很容易产生 “段错误”。</code></pre><p>　　<br>4.连接线程（阻塞）</p><pre><code>  int pthread_join(pthread_t thread, void **value_ptr);　　等待线程thread结束，并设置*value_ptr为thread的返回值。pthread_join阻塞调用者，一直到线程thread结束为止。当函数返回时，被等待线程的资源被收回。如果进程已经结束，那么该函数会立即返回。并且thread指定的线程必须是joinable的。需要留意的一点是linux机制下，线程存在一个被称为joinable的状态。下面简要了解一下：</code></pre><p>Join和Detach<br>这块的概念，非常类似于之前父子进程那部分，等待子进程退出的内容（一系列的wait函数）。</p><p>linux机制下，线程存在两种不同的状态：joinable和unjoinable。</p><pre><code>如果一个线程被标记为joinable时，即便它的线程函数执行完了，或者使用了pthread_exit()结束了该线程，它所占用的堆栈资源和进程描述符都不会被释放（类似僵尸进程），这种情况应该由线程的创建者调用pthread_join()来等待线程的结束并回收其资源（类似wait系函数）。默认情况下创建的线程都是这种状态。如果一个线程被标记成unjoinable，称它被分离(detach)了，这时候如果该线程结束，所有它的资源都会被自动回收。省去了给它擦屁股的麻烦。因为创建的线程默认都是joinable的，所以要么在父线程调用pthread_detach(thread_id)将其分离，要么在线程内部，调用pthread_detach(pthread_self())来把自己标记成分离的。</code></pre><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><pre><code>文件描述符在linux内核中，文件是用一个整数来表示的，称为 文件描述符，通俗的来说，你可以理解它是文件的id（唯一标识符）普通文件普通文件就是字节流组织的数据。文件并不是通过和文件名关联来实现的，而是通过关联索引节点来实现的，文件节点拥有文件系统为普通文件分配的唯一整数值(ino)，并且存放着一些文件的相关元数据。目录与链接正常情况下文件是通过文件名来打开的。目录是可读名称到索引编号之间的映射，名称和索引节点之间的配对称为链接。可以把目录看做普通文件，只是它包含着文件名称到索引节点的映射（链接）</code></pre><p>文件系统是基于底层存储建立的一个树形文件结构。比较经典的是Linux的文件系统，首先在硬盘的超级块中安装文件系统，磁盘引导时会加载文件系统的信息。</p><p>linux使用inode来标识任意一个文件。inode存储除了文件名以外的文件信息，包括创建时间，权限，以及一个指向磁盘存储位置的指针，那里才是真正存放数据的地方。</p><p>一个目录也是一个inode节点。</p><p>详细阐述一次文件访问的过程：</p><pre><code>首先用户ls查看目录。由于一个目录也是一个文件，所以相当于是看目录文件下有哪些东西。实际上目录文件是一个特殊的inode节点，它不需要存储实际数据，而只是维护一个文件名到inode的映射表。于是我们ls到另一个目录。同理他也是一个inode。我们在这个inode下执行vi操作打开某个文件，于是linux通过inode中的映射表找到了我们请求访问的文件名对应的inode。然后寻道到对应的磁盘位置，读取内容到缓冲区，通过系统调用把内容读到内存中，最后进行访问。</code></pre><h2 id="IO操作"><a href="#IO操作" class="headerlink" title="IO操作"></a>IO操作</h2><h1 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h1><p>　　对于内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负整数。当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。当读或写一个文件时，使用open或create返回的文件描述符表示该文件，将其作为参数传给read或write函数。</p><h1 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h1><p> 　　write函数定义如下：</p><pre>#include <unistd> ssize_t write(int filedes, void *buf, size_t nbytes); // 返回：若成功则返回写入的字节数，若出错则返回-1 // filedes：文件描述符 // buf:待写入数据缓存区 // nbytes:要写入的字节数</unistd></pre><p>　　同样，为了保证写入数据的完整性，在《UNIX网络编程 卷1》中，作者将该函数进行了封装，具体程序如下：</p><p><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre> 1 ssize_t                        /* Write "n" bytes to a descriptor. */ 2 writen(int fd, const void *vptr, size_t n) 3 { 4     size_t nleft; 5     ssize_t nwritten; 6     const char *ptr; 7  8     ptr = vptr; 9     nleft = n; 10     while (nleft > 0) { 11         if ( (nwritten = write(fd, ptr, nleft)) <= 0="" 12="" 13="" 14="" 15="" 16="" 17="" 18="" 19="" 20="" 21="" 22="" 23="" 24="" 25="" 26="" 27="" 28="" 29="" 30="" 0)="" {="" if="" (nwritten="" <="" &&="" errno="=" eintr)="" nwritten="0;" *="" and="" call="" write()="" again="" else="" return(-1);="" error="" }="" nleft="" -="nwritten;" ptr="" +="nwritten;" return(n);="" end="" writen="" void="" writen(int="" fd,="" *ptr,="" size_t="" nbytes)="" (writen(fd,="" ptr,="" !="nbytes)" err_sys("writen="" error");="" }<="" pre=""><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><h1 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h1><p>　　read函数定义如下：</p><pre>#include <unistd> ssize_t read(int filedes, void *buf, size_t nbytes); // 返回：若成功则返回读到的字节数，若已到文件末尾则返回0，若出错则返回-1 // filedes：文件描述符 // buf:读取数据缓存区 // nbytes:要读取的字节数</unistd></pre><p> 　　有几种情况可使实际读到的字节数少于要求读的字节数：</p><p>　　1）读普通文件时，在读到要求字节数之前就已经达到了文件末端。例如，若在到达文件末端之前还有30个字节，而要求读100个字节，则read返回30，下一次再调用read时，它将返回0（文件末端）。</p><p>　　2）当从终端设备读时，通常一次最多读一行。</p><p>　　3）当从网络读时，网络中的缓存机构可能造成返回值小于所要求读的字结束。</p><p>　　4）当从管道或FIFO读时，如若管道包含的字节少于所需的数量，那么read将只返回实际可用的字节数。</p><p>　　5）当从某些面向记录的设备（例如磁带）读时，一次最多返回一个记录。</p><p>　　6）当某一个信号造成中断，而已经读取了部分数据。</p><p>　　在《UNIX网络编程 卷1》中，作者将该函数进行了封装，以确保数据读取的完整，具体程序如下：</p><p><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre> 1 ssize_t                        /* Read "n" bytes from a descriptor. */ 2 readn(int fd, void *vptr, size_t n) 3 { 4     size_t nleft; 5     ssize_t nread; 6     char *ptr; 7  8     ptr = vptr; 9     nleft = n; 10     while (nleft > 0) { 11         if ( (nread = read(fd, ptr, nleft)) < 0) { 12             if (errno == EINTR) 13                 nread = 0;        /* and call read() again */14             else15                 return(-1); 16         } else if (nread == 0) 17             break;                /* EOF */18 19         nleft -= nread; 20         ptr   += nread; 21 } 22     return(n - nleft);        /* return >= 0 */23 } 24 /* end readn */25 26 ssize_t 27 Readn(int fd, void *ptr, size_t nbytes) 28 { 29 ssize_t        n; 30 31     if ( (n = readn(fd, ptr, nbytes)) < 0) 32         err_sys("readn error"); 33     return(n); 34 }</pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>本文下半部分摘自博文<a href="http://www.cnblogs.com/promise6522/archive/2012/03/03/2377935.html" target="_blank" rel="noopener">浅谈TCP/IP网络编程中socket的行为</a>。</p><h1 id="read-write的语义：为什么会阻塞？"><a href="#read-write的语义：为什么会阻塞？" class="headerlink" title="read/write的语义：为什么会阻塞？"></a><strong>read/write的语义：为什么会阻塞？</strong></h1><p>　　先从write说起：</p><pre>#include <unistd.h> ssize_t write(int fd, const void *buf, size_t count);</unistd.h></pre><p>　　首先，write成功返回，<strong>只是buf中的数据被复制到了kernel中的TCP发送缓冲区。</strong>至于数据什么时候被发往网络，什么时候被对方主机接收，什么时候被对方进程读取，系统调用层面不会给予任何保证和通知。</p><p>　　write在什么情况下会阻塞？当kernel的该socket的发送缓冲区已满时。对于每个socket，拥有自己的send buffer和receive buffer。从Linux 2.6开始，两个缓冲区大小都由系统来自动调节（autotuning），但一般在default和max之间浮动。</p><pre># 获取socket的发送/接受缓冲区的大小：（后面的值是在Linux 2.6.38 x86_64上测试的结果）</pre><pre>sysctl net.core.wmem_default       #126976sysctl net.core.wmem_max　　　　    #131071</pre><p>　　已经发送到网络的数据依然需要暂存在send buffer中，只有收到对方的ack后，kernel才从buffer中清除这一部分数据，为后续发送数据腾出空间。接收端将收到的数据暂存在receive buffer中，自动进行确认。但如果socket所在的进程不及时将数据从receive buffer中取出，最终导致receive buffer填满，由于TCP的滑动窗口和拥塞控制，接收端会阻止发送端向其发送数据。这些控制皆发生在TCP/IP栈中，对应用程序是透明的，应用程序继续发送数据，最终导致send buffer填满，write调用阻塞。</p><p>　　一般来说，由于<strong>接收端进程从socket读数据的速度</strong>跟不上<strong>发送端进程向socket写数据的速度</strong>，最终导致<strong>发送端write调用阻塞。</strong></p><p>　　而read调用的行为相对容易理解，从socket的receive buffer中拷贝数据到应用程序的buffer中。read调用阻塞，通常是发送端的数据没有到达。</p><h2 id="Linux常用命令和基础知识"><a href="#Linux常用命令和基础知识" class="headerlink" title="Linux常用命令和基础知识"></a>Linux常用命令和基础知识</h2><h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><pre><code>1. ps查看某个时间点的进程信息示例一：查看自己的进程# ps -l示例二：查看系统所有进程# ps aux示例三：查看特定的进程# ps aux | grep threadx2. top实时显示进程信息示例：两秒钟刷新一次# top -d 23. pstree查看进程树示例：查看所有进程树# pstree -A4. netstat查看占用端口的进程示例：查看特定端口的进程# netstat -anp | grep port</code></pre><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>ls -a  ,all列出全部文件包括隐藏</p><p>ls -l，list显示文件的全部属性</p><p>ls -d,仅列出目录本身</p><p>cd mkdir rmdir 常用不解释 rm -rf永久删除 cp复制 mv移动或改名</p><p>touch，更新文件时间或者建立新文件。</p><h3 id="权限操作"><a href="#权限操作" class="headerlink" title="权限操作"></a>权限操作</h3><pre><code>chmod rwx 分别对应 421 chmod 754 .bashrc 将权限改为rwxr-xr--对应权限分配是对于 拥有者，所属群组，以及其他人。</code></pre><p>文件默认权限</p><p>文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。</p><p>目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。</p><p>目录的权限</p><p>ps:拥有目录权限才能修改文件名，拥有文件权限是没用的</p><pre><code>文件名不是存储在一个文件的内容中，而是存储在一个文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。</code></pre><p>目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了。</p><h2 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h2><p>硬链接：</p><pre><code>使用ln建立了一个硬连接，通过ll -i获得他们的inode节点。发现他们的inode节点是相同的。符合硬连接规定。# ln /etc/crontab .# ll -i /etc/crontab crontab34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab</code></pre><p>软连接：</p><pre><code>符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。当源文件被删除了或者被移动到其他位置了，链接文件就打不开了。可以为目录建立链接。# ll -i /etc/crontab /root/crontab234474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -&gt; /etc/crontab</code></pre><h2 id="获取内容"><a href="#获取内容" class="headerlink" title="获取内容"></a>获取内容</h2><p>cat 读取内容 加上-n 按行打印</p><p>tac是cat的反向操作</p><p>more允许翻页查看，而不像cat一次显示全部内容</p><p>less可以先前翻页和向后翻页，more只能向前翻页</p><p>head 和tail 负责取得文件的前几行和后几行</p><h2 id="搜索和定位"><a href="#搜索和定位" class="headerlink" title="搜索和定位"></a>搜索和定位</h2><pre><code>1 which负责指令搜索，并显示第一条 比如which pwd，会找到pwd对应的程序。加-a 打印全部。2 whereis负责搜索文件， 后面接上dirname/filename文件搜索。速度比较快，因为它只搜索几个特定的目录。比如 whereis /bin hello.c3 locate文件搜索。可以用关键字或者正则表达式进行搜索。locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。# locate [-ir] keyword-r：正则表达式locate hello locate he*vi heeeeupdatedblocate he?4. find文件搜索。可以使用文件的属性和权限进行搜索。# find [basedir] [option]example: find . -name &quot;shadow*&quot;find -name &quot;hike&quot;find +属性后缀 &quot;属性&quot;（一）与时间有关的选项-mtime  n ：列出在 n 天前的那一天修改过内容的文件（二）与文件拥有者和所属群组有关的选项-uid n-gid n-user name（三）与文件权限和名称有关的选项-name filename-size [+-]SIZE：搜寻比 SIZE 还要大 (+) 或小 (-) 的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k-type TYPE</code></pre><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><pre><code>gzip压缩和解压，还有bzip，xz等压缩而tar可以用打包，打包的时候也可以执行压缩压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gip、bzip2、xz 将打包文件进行压缩。$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename...  ==打包压缩$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件]              ==查看$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录]    ==解压缩</code></pre><h2 id="管道指令"><a href="#管道指令" class="headerlink" title="管道指令"></a>管道指令</h2><p>1 |</p><p>2 cut切分数据，分成多列，last显示登陆者信息</p><h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><p>grep</p><pre><code>g/re/p（globally search a regular expression and print)，使用正则表示式进行全局查找并打印。$ grep [-acinv] [--color=auto] 搜寻字符串 filename-c ： 计算找到个数-i ： 忽略大小写-n ： 输出行号-v ： 反向选择，亦即显示出没有 搜寻字符串 内容的那一行--color=auto ：找到的关键字加颜色显示</code></pre><p>awk</p><pre><code>$ awk &apos;条件类型 1 {动作 1} 条件类型 2 {动作 2} ...&apos; filename示例 2：/etc/passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。$ cat /etc/passwd | awk &apos;BEGIN {FS=&quot;:&quot;} $3 &lt; 10 {print $1 &quot;\t &quot; $3}&apos;root 0bin 1daemon 2sed示例 3：输出正在处理的行号，并显示每一行有多少字段$ last -n 5 | awk &apos;{print $1 &quot;\t lines: &quot; NR &quot;\t columns: &quot; NF}&apos;dmtsai lines: 1 columns: 10dmtsai lines: 2 columns: 10dmtsai lines: 3 columns: 10dmtsai lines: 4 columns: 10dmtsai lines: 5 columns: 9</code></pre><p>sed:</p><pre><code>awk用于匹配每一行中的内容并打印而sed负责把文件内容重定向到输出，所以sed读取完文件并重定向到输出并且通过awk匹配这些内容并打印。他们俩经常搭配使用。</code></pre><h2 id="linux指令实践和常见场景"><a href="#linux指令实践和常见场景" class="headerlink" title="linux指令实践和常见场景"></a>linux指令实践和常见场景</h2><h2 id="查看进程状态"><a href="#查看进程状态" class="headerlink" title="查看进程状态"></a>查看进程状态</h2><p>Linux进程状态(ps stat)之R、S、D、T、Z、X</p><pre><code>D    不可中断     Uninterruptible sleep (usually IO)R    正在运行，或在队列中的进程S    处于休眠状态T    停止或被追踪Z    僵尸进程W    进入内存交换（从内核2.6开始无效）X    死掉的进程&lt;    高优先级N    低优先级L    有些页被锁进内存s    包含子进程+    位于后台的进程组；l    多线程，克隆线程  multi-threaded (using CLONE_THREAD, like NPTL pthreads do)</code></pre><p>ps aux</p><p><img src="https://img-blog.csdn.net/20180703221736541?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3MjQ4ODg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><h2 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h2><p>strace用于跟踪程序执行过程中的系统调用，如跟踪test进程，只需要：</p><p>strace -p [test_pid] 或直接strace ./test</p><p>比如，跟踪pid为12345的进程中所有线程的read和write系统调用，输出字符串的长度限制为1024：</p><p>strace -s 1024 -f -e trace=read,write -p 12345</p><h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><p>tcpdump是Linux上的抓包工具，如抓取eth0网卡上的包，使用:</p><p>sudo tcpdump -i eth0</p><p>比如，抓取80端口的HTTP报文，以文本形式展示：</p><p>sudo tcpdump -i any port 80 -A<br>这样你就可以清楚看到GET、POST请求的内容了。</p><h2 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h2><p>nc可以在Linux上开启TCP Server、TCP Client、UDP Server、UDP Client。</p><p>如在端口号12345上开启TCP Server和Client模拟TCP通信：</p><p>Server:  nc -l 127.0.0.1 12345<br>Client:  nc 127.0.0.1 12345<br>在端口号12345上开启UDP Server和Client模拟TCP通信：</p><p>Server:  nc -ul 127.0.0.1 12345<br>Client:  nc -u 127.0.0.1 12345<br>Unix Socket通信示例:</p><p>Server:  nc -Ul /tmp/1.sock<br>Client:  nc -U /tmp/1.sock</p><h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><p>curl用于模拟HTTP请求，在终端模拟请求时常用，如最基本的用法：</p><p>curl <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></p><h2 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h2><p>lsof命令主要用法包括：</p><p>sudo lsof -i :[port] 查看端口占用进程信息，经常用于端口绑定失败时确认端口被哪个进程占用</p><p>sudo lsof -p [pid] 查看进程打开了哪些文件或套接字</p><h2 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h2><p>Linux上的ss命令可以用于替换netstat，ss直接读取解析/proc/net下的统计信息，相比netstat遍历/proc下的每个PID目录，速度快很多。</p><h2 id="awk-sed"><a href="#awk-sed" class="headerlink" title="awk/sed"></a>awk/sed</h2><p>awk和sed在文本处理方面十分强大，其中，awk按列进行处理，sed按行进行处理。</p><p>如采用冒号分隔数据，输出第一列数据（$0代表行全部列数据，$1代表第一列，$2代表第二列…）</p><p>awk -F “:” ‘{print $1}’<br>在awk的结果基础上，结合sort、uniq和head等命令可以轻松完成频率统计等功能</p><p>查看文件的第100行到第200行：<br>sed -n ‘100,200p’ log.txt<br>替换字符串中的特定子串<br>echo “int charset=gb2312 float”|sed “s/charset=gb2312/charset=UTF-8/g”<br>替换test文件每行匹配ab的部分为cd<br>sed -i ‘s/ab/cd/g’ test</p><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p>打开文件并跳到第10行</p><p>$ vim +10 filename.txt<br>打开文件跳到第一个匹配的行</p><p>$ vim +/search-term filename.txt<br>以只读模式打开文件</p><p>$ vim -R /etc/passwd</p><h2 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h2><p>查看某个用户的crontab入口</p><p>$ crontab -u john -l<br>设置一个每十分钟执行一次的计划任务</p><p><em>/10 </em> <em> </em> * /home/ramesh/check-disk-space<br>更多示例：Linux Crontab: 15 Awesome Cron Job Examples</p><h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>service命令用于运行System V init脚本，这些脚本一般位于/etc/init.d文件下，这个命令可以直接运行这个文件夹里面的脚本，而不用加上路径</p><p>查看服务状态</p><p>$ service ssh status<br>查看所有服务状态</p><p>$ service –status-all<br>重启服务</p><p>$ service ssh restart</p><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>这个命令用于显示系统当前内存的使用情况，包括已用内存、可用内存和交换内存的情况</p><p>默认情况下free会以字节为单位输出内存的使用量</p><pre><code>$ free             total       used       free     shared    buffers     cachedMem:       3566408    1580220    1986188          0     203988     902960-/+ buffers/cache:     473272    3093136Swap:      4000176          0    4000176</code></pre><p>如果你想以其他单位输出内存的使用量，需要加一个选项，-g为GB，-m为MB，-k为KB，-b为字节</p><pre><code>$ free -g             total       used       free     shared    buffers     cachedMem:             3          1          1          0          0          0-/+ buffers/cache:          0          2Swap:            3          0          3</code></pre><p>如果你想查看所有内存的汇总，请使用-t选项，使用这个选项会在输出中加一个汇总行</p><pre><code>ramesh@ramesh-laptop:~$ free -t             total       used       free     shared    buffers     cachedMem:       3566408    1592148    1974260          0     204260     912556-/+ buffers/cache:     475332    3091076Swap:      4000176          0    4000176Total:     7566584    1592148    5974436</code></pre><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>top命令会显示当前系统中占用资源最多的一些进程（默认以CPU占用率排序）如果你想改变排序方式，可以在结果列表中点击O（大写字母O）会显示所有可用于排序的列，这个时候你就可以选择你想排序的列</p><pre><code>Current Sort Field:  P  for window 1:DefSelect sort field via field letter, type any other key to return  a: PID        = Process Id              v: nDRT       = Dirty Pages count  d: UID        = User Id                 y: WCHAN      = Sleeping in Function  e: USER       = User Name               z: Flags      = Task Flags  ........</code></pre><p>如果只想显示某个特定用户的进程，可以使用-u选项</p><p>$ top -u oracle</p><h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><p>显示文件系统的磁盘使用情况，默认情况下df -k 将以字节为单位输出磁盘的使用量</p><p>$ df -k</p><pre><code>Filesystem           1K-blocks      Used Available Use% Mounted on/dev/sda1             29530400   3233104  24797232  12% //dev/sda2            120367992  50171596  64082060  44% /home</code></pre><p>使用-h选项可以以更符合阅读习惯的方式显示磁盘使用量</p><p>$ df -h</p><pre><code>Filesystem                  Size   Used  Avail Capacity  iused      ifree %iused  Mounted on/dev/disk0s2               232Gi   84Gi  148Gi    37% 21998562   38864868   36%   /devfs                      187Ki  187Ki    0Bi   100%      648          0  100%   /devmap -hosts                   0Bi    0Bi    0Bi   100%        0          0  100%   /netmap auto_home                0Bi    0Bi    0Bi   100%        0          0  100%   /home/dev/disk0s4               466Gi   45Gi  421Gi    10%   112774  440997174    0%   /Volumes/BOOTCAMP//app@izenesoft.cn/public  2.7Ti  1.3Ti  1.4Ti    48% </code></pre><h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><p>kill用于终止一个进程。一般我们会先用ps -ef查找某个进程得到它的进程号，然后再使用kill -9 进程号终止该进程。你还可以使用killall、pkill、xkill来终止进程</p><p>$ ps -ef | grep vim<br>ramesh    7243  7222  9 22:43 pts/2    00:00:00 vim</p><p>$ kill -9 7243</p><h2 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h2><p>如果要挂载一个文件系统，需要先创建一个目录，然后将这个文件系统挂载到这个目录上</p><p>mkdir /u01<br>mount /dev/sdb1 /u01<br>也可以把它添加到fstab中进行自动挂载，这样任何时候系统重启的时候，文件系统都会被加载</p><p>/dev/sdb1 /u01 ext2 defaults 0 2</p><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><p>chmod用于改变文件和目录的权限</p><p>给指定文件的属主和属组所有权限(包括读、写、执行)</p><p>$ chmod ug+rwx file.txt<br>删除指定文件的属组的所有权限</p><p>$ chmod g-rwx file.txt<br>修改目录的权限，以及递归修改目录下面所有文件和子目录的权限</p><p>$ chmod -R ug+rwx file.txt<br>更多示例：7 Chmod Command Examples for Beginners</p><h2 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h2><p>chown用于改变文件属主和属组</p><p>同时将某个文件的属主改为oracle，属组改为db</p><p>$ chown oracle:dba dbora.sh<br>使用-R选项对目录和目录下的文件进行递归修改</p><p>$ chown -R oracle:dba /home/oracle</p><h2 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h2><p>ifconfig用于查看和配置Linux系统的网络接口</p><h2 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h2><p>uname可以显示一些重要的系统信息，例如内核名称、主机名、内核版本号、处理器类型之类的信息 </p><h2 id="实际场景问题"><a href="#实际场景问题" class="headerlink" title="实际场景问题"></a>实际场景问题</h2><pre><code>1 cpu占用率top可以看ps看不了但是ps -aux可以看到各个线程的cpu和内存占用2 进程状态：ps -ef看不了ps aux可以看进程状态S R之类3 IOiostat查看io状态4网络netstat查看tcp连接状态和socket情况，ipconfig查看网络设备lsof可以查看端口使用情况5内存free</code></pre></=></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这部分内容主要是基于一些关于Linux系统的内核基础和基本命令的学习总结，内容不全面，只讲述了其中的一小部分，后续会再补充，如有错误，还请见谅。&lt;/p&gt;
&lt;p&gt;Linux操作系统&lt;/p&gt;
&lt;p&gt;Linux操作系统博大精深，其中对线程，IO，文件系统等概念的实现都很有借鉴意义。&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="技术总结" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Linux" scheme="http://h2pl.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>操作系统学习总结</title>
    <link href="http://h2pl.github.io/2018/07/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://h2pl.github.io/2018/07/09/操作系统学习总结/</id>
    <published>2018-07-09T14:33:03.000Z</published>
    <updated>2018-07-09T15:09:19.339Z</updated>
    
    <content type="html"><![CDATA[<p>这部分内容主要是基于一些关于操作系统基础的学习总结，内容不全面，只讲述了其中的一小部分，后续会再补充，如有错误，还请见谅。<br>操作系统<br><a id="more"></a></p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>cpu是中央处理器，他是计算机的核心。<br>cpu通过和寄存器，高速缓存，以及内存交互来执行程序。</p><p>主板分为南桥和北桥，北桥主要是内存总线，通往内存。<br>而南桥主要是慢速设备的IO总线，包括硬盘，网卡等IO设备。</p><p>32位cpu最多寻址4g内存，而64位cpu目前来说没有上限。</p><h3 id="程序执行过程"><a href="#程序执行过程" class="headerlink" title="程序执行过程"></a>程序执行过程</h3><p>cpu发出指令，将硬盘上的一段程序读入内存，由于cpu和硬盘的速度差距更大，一般使用中断，dma等方式来将硬盘数据载入内存。<br>然后cpu通过寄存器以及指令集执行指令，cpu读取内存上的代码，内存上的方法执行是一个栈调用的过程。</p><h3 id="高速缓存-读写缓冲区"><a href="#高速缓存-读写缓冲区" class="headerlink" title="高速缓存 读写缓冲区"></a>高速缓存 读写缓冲区</h3><p>为了弥补cpu和内存的速度差，cpu配有多级缓存。</p><p>一般有一级缓存和二级缓存，缓存根据局部性原理把经常使用的代码加载如缓存，能比直接访问内存快上几百倍。</p><p>同样的，内存和硬盘间的速度差距也很大，需要通过读写缓冲区来进行速度匹配，内存写入磁盘时先写入缓冲区，读数据时从缓冲区读取硬盘准备好的数据。</p><h2 id="内存管理和虚拟内存"><a href="#内存管理和虚拟内存" class="headerlink" title="内存管理和虚拟内存"></a>内存管理和虚拟内存</h2><p>由于程序的大小越来越大，而计算机想要支持多道程序，当一个程序遇到IO操作时转而去执行另一个程序，这就要求内存中装有多个程序的代码了。</p><p>然而程序的内存消耗与日俱增，同时装载多个程序越来越困难，所以人们提出了，只在程序需要使用到的时候再把他装入内存，平时把代码放在硬盘中即可。</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>由于内存需要装载硬盘中的数据，所以需要约定一个存储单元，操作系统把它叫做页，一个页一般长度是8kb或者16kb。内存从硬盘读取数据时读取的是一个页或多个页。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>由于这些代码持久化在硬盘中，占用了一部分空间，并且需要运行时会加载到内存中，所以这部分的空间一般也成为虚拟内存的空间（大小）。</p><h3 id="页表和页面置换算法"><a href="#页表和页面置换算法" class="headerlink" title="页表和页面置换算法"></a>页表和页面置换算法</h3><p>为了知道每个程序对应的代码存在硬盘中的位置，操作系统需要维护一个程序到页面的映射表，cpu要内存加载一个页面时，首先要访问页表，来得知页面在硬盘中的位置，然后让内存去该位置把对应的页面调入内存中。</p><p>为了提升页面调入的效率，也使用了多种的页面置换算法，比如lru最近最久未使用，fifo先进先出，时钟法，多级队列法等。</p><p>当然，为了进一步提高效率，还会使用多级页表的方式，不过一般需要硬件维护一个页表映射页面的快速转换结构，以便能迅速地完成页面解析和调度。</p><h3 id="中断和缺页中断"><a href="#中断和缺页中断" class="headerlink" title="中断和缺页中断"></a>中断和缺页中断</h3><p>计算机提供一系列中断指令与硬件进行交互，操作系统可以使用这些中断去控制硬件，比如使用中断通知cpu硬盘的IO操作已经准备好，键盘通过一次又一次的中断来输入字符。</p><p>中断一般适用于快速返回的字符设备，比如鼠标键盘，而硬盘这类耗时IO操作，使用中断后cpu仍然需要等待硬盘把数据装入内存。是非常缓慢的。</p><p>于是才会使用DMA来完成IO操作，DMA额外提供一个处理器去处理IO操作，当硬盘数据加载到内存中后再去通知CPU操作已完成。</p><pre><code>缺页中断就是因为内存中没有cpu需要访问的页面，必须根据页表到硬盘中获取页面，并根据置换算法进行页面调度。如果找不到对应页面，则程序执行会报错。</code></pre><h3 id="分页和分段"><a href="#分页和分段" class="headerlink" title="分页和分段"></a>分页和分段</h3><p>分页是上述所说的，通过内存和硬盘的约定，将调度单元设定为一个页面。</p><pre><code>分段则不同，分段并不是物理意义上的分段，而是逻辑上把代码使用到的空间划分成多个部分，比如受保护部分，公开部分，核心部分等，这样可以更好地描述每个段的代码信息，为使用者提供便利，为了支持程序员的这种需求，操作系统加入了分段的概念，将代码对应的一段虚拟内存划分为不同的逻辑段。同时为了根据不同段来以不同方式访问内存，操作系统需要另外维护一个段表，以用于段的映射。</code></pre><p>由于分段只是逻辑上的概念，所以底层的内存分页仍然是必不可少的，因此在逻辑段的基础上，物理上又会划分为多个页，一个段中可能包含了多个页面。</p><p>因此，完善的虚拟内存管理器需要支持段页表，先映射段，再映射页面。</p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是资源分配的资本单位，操作系统为进程开辟一段内存空间，内存空间从高位向低位，包括函数调用栈，变量以及其他区域。cpu根据这些信息配合寄存器进行函数调用和程序执行。</p><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>由于计算机是分时系统，所以多进程的使用不可避免，操作系统需要进行进程的切换，方法是内存指针指向新位置，保存原来的进程信息，同时刷新寄存器等数据。然后开始执行新的进程.</p><p>一般操作系统会使用pcb结构来记录进程的信息和上下文。通过他和cpu配合来完成进程切换。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是系统调度的基本单位，没有线程以前，一般会使用多进程模型，一个程序往往需要多个进程配合使用，但是多进程之间并没有共享内存，导致进程间通信非常麻烦。</p><p>比如文本输入工具，一边键入文字一边需要保存数据，如果是单进程执行，则每次输入都触发IO操作，非常费时，如果一个进程负责输入展示一个进程负责输入保存，确实速度很快，但是两个进程没办法共享数据。除非使用额外的通讯手段。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>而多线程就好办了，多线程都是基于进程产生的，线程被创建后只需要分配少量空间支持堆栈操作即可，同时线程还共享进程中的内存，所以一般使用进程分配资源，线程进行调度的方式。</p><pre><code>操作系统对线程的支持：一般情况下操作系统都支持线程，并且可以创建内核级线程，内核可以识别线程并且为其分配空间，进行线程调度。但是内核级线程实现比较复杂，使用起来也不甚方便。所以往往开发人员会使用用户级线程，用户级线程比如Java的多线程，通过简单的api实现，当需要操作系统支持时，才使用底层调用api接口进行内核级的系统调用。但是一般情况下用户级线程是不被内核识别的，也就是说，用户级线程会被内核认为是一个进程，从而执行进程的调度。这样的话就没有意义了。所以一般情况下用户级线程会映射到对应的内核级线程中，内核为进程创建一定数量的内核级线程以供使用。Java中的线程基本上都是使用这种方式实现的。</code></pre><h3 id="线程通信和进程通信"><a href="#线程通信和进程通信" class="headerlink" title="线程通信和进程通信"></a>线程通信和进程通信</h3><p>线程通信一般只需要使用共享内存的方式即可实现。</p><p>而进程通信则需要额外的通信机制。</p><blockquote><p>1 信号量，一般多进程间的同步使用信号量来完成，系统为临界区添加支持并发量为n的信号量,多进程访问临界区资源时，首先需要执行p操作来减少信号量，如果信号量等于0则操作失败，并且挂起进程，否则成功进入临界区执行。</p><p>当进程退出临界区时，执行v操作，将信号量加一，并唤醒挂起的进程进行操作。</p><p>2 管程，管程是对信号量的一个包装，避免使用信号量时出错。</p><p>3 管道，直接连接两个进程，一个进程写入管道，另一个进程可以读取管道，但是他不支持全双工，并且只能在父子进程间使用，所以局限性比较大</p><p>4 消息队列</p><p>操作系统维护一个消息队列，进程将消息写入队列中，其他进程轮询消息队列看是否有自己的消息，增加了轮询的开销，但是提高了消息的可靠性和易用性，同时支持了订阅消息。</p><p>5 socket</p><p>socket一般用于不同主机上的进程通信，双方通过ip和port的方式寻址到对方主机并找到监听该端口的进程，为了完成通信，他们先建立tcp连接，在此基础上交换数据，也就完成了进程间的通信。</p></blockquote><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>不小心把这茬忘了，进程调度算法有几种，fifo先来先服务，短作业优先，时间片轮转，优先级调度，多级反馈队列等。<br>基本上可以通过名字知道算法的大概实现。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁的必要条件：</p><pre><code>1互斥：资源必须是互斥的，只能给一个进程使用2占有和等待：占有资源时可以请求其他资源3不可抢占：资源占有时不会被抢4环路等待：有两个以上的进程组成一个环路，每个进程都在等待下一个进程的资源释放。</code></pre><p>死锁的处理方法：</p><p>1鸵鸟</p><p>2死锁预防</p><p>在程序运行之前预防发生死锁。</p><pre><code>（一）破坏互斥条件例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。这样子就破坏了互斥条件，转而使用单个队列串行执行操作。（二）破坏占有和等待条件一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。分配了全部资源就不需要去等待其他资源。（三）破坏不可抢占条件允许抢占式调度。（四）破坏环路等待给资源统一编号，进程只能按编号顺序来请求资源。按正确顺序请求资源，就不会发生死锁。</code></pre><p>3死锁避免</p><p>==银行家算法用于在程序运行时避免发生死锁。==</p><p>银行家算法用于在程序运行时判断资源的分配情况是否是安全状态，如果某一步骤使程序可能发生死锁，银行家算法会拒绝该操作执行，从而避免进入不安全状态。</p><p>（一）安全状态</p><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/ed523051-608f-4c3f-b343-383e2d194470.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/ed523051-608f-4c3f-b343-383e2d194470.png" alt=""></a></p><p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p><p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p><p>（二）单个资源的银行家算法</p><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png" alt=""></a></p><p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p><p>4死锁检测和恢复</p><p>==银行家算法检测程序并且阻止死锁发生，而死锁检测和恢复则<br>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。==</p><p>（一）每种类型一个资源的死锁检测</p><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/b1fa0453-a4b0-4eae-a352-48acca8fff74.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/b1fa0453-a4b0-4eae-a352-48acca8fff74.png" alt=""></a></p><p>上图为==资源分配图==，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p><p>如果有环则说明有死锁。</p><p>（二）每种类型多个资源的死锁检测</p><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png" alt=""></a></p><p>==资源分配矩阵==</p><p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p><ul><li>E 向量：资源总量</li><li>A 向量：资源剩余量</li><li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li><li>R 矩阵：每个进程请求的资源数量</li></ul><p>如果存在请求数量无法被满足时，就会出现死锁。</p><p>==（三）死锁恢复==</p><p>利用抢占恢复，允许其他进程抢占资源。</p><p>利用回滚恢复，回滚进程操作，释放其资源。</p><p>通过杀死进程恢复，杀死进程后释放资源。</p><h2 id="IO和磁盘"><a href="#IO和磁盘" class="headerlink" title="IO和磁盘"></a>IO和磁盘</h2><p>磁盘是块设备，键盘是字符设备，网卡是网络设备。他们都接在IO总线上，属于慢速设备。</p><h3 id="磁盘和寻址"><a href="#磁盘和寻址" class="headerlink" title="磁盘和寻址"></a>磁盘和寻址</h3><p>磁盘的结构比较复杂，主要通过扇区，盘面和磁头位置决定当前访问的磁盘位置。</p><p>cpu为了能够访问磁盘内容，首先要把磁盘的内容载入内存中，于是要和内存约定统一的寻址单元，cpu指定一个起始位置，访问该位置以后的n个存储单元，一般存储单元是一个页，16K或者8K。</p><p>这一操作中，指向起始位置需要随机寻址，而接下来的访问操作是顺序访问，磁盘的随机读写和顺序读写的速度差距是很大的。所以一般会通过缓冲区来缓存IO数据。</p><pre><code>磁盘内部一般也会分为很多部分，比如操作系统会将磁盘做一个分区，使用磁盘的一些位置存储元数据信息，以保证磁盘能够支持操作系统以及文件系统。一般在物理分区的起始位置会有一个引导区和分区表,BIOS自动将磁盘中引导区的内核程序载入内存，此时操作系统才开始运行，并且根据分区表操作系统可以知道每个分区的起始位置在哪。</code></pre><p>读写一个磁盘块的时间的影响因素有：</p><p>旋转时间（主轴旋转磁盘，使得磁头移动到适当的扇区上）<br>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）<br>实际的数据传输时间<br>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p><ol><li>先来先服务<br>FCFS, First Come First Served</li></ol><p>按照磁盘请求的顺序进行调度。</p><p>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p><ol start="2"><li>最短寻道时间优先<br>SSTF, Shortest Seek Time First</li></ol><p>优先调度与当前磁头所在磁道距离最近的磁道。</p><p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两边的磁道请求更容易出现饥饿现象。</p><ol start="3"><li>电梯算法<br>SCAN</li></ol><p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p><p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p><p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p><h3 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h3><p>除了硬盘以外，还有键盘，网卡等IO设备，这些设备需要操作系统通过驱动程序来进行交互，驱动程序用于适配这些设备。</p><p>为了执行IO操作，内核一般要为IO设备提供一个缓存区，比如网卡的IO操作，会为socket提供一个缓存区，当多个socket使用一个缓冲区进行通信，就是复用了缓冲区，也就是IO复用的一种方式。</p><p>同时，内核还会维护一个IO请求的列表，当IO请求就绪时，让几个线程去执行IO操作，实现了线程的复用。</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件系统是基于底层存储建立的一个树形文件结构。比较经典的是Linux的文件系统，首先在硬盘的超级块中安装文件系统，磁盘引导时会加载文件系统的信息。</p><p>linux使用inode来标识任意一个文件。inode存储除了文件名以外的文件信息，包括创建时间，权限，以及一个指向磁盘存储位置的指针，那里才是真正存放数据的地方。</p><p>一个目录也是一个inode节点。</p><p>详细阐述一次文件访问的过程：</p><pre><code>首先用户ls查看目录。由于一个目录也是一个文件，所以相当于是看目录文件下有哪些东西。实际上目录文件是一个特殊的inode节点，它不需要存储实际数据，而只是维护一个文件名到inode的映射表。于是我们ls到另一个目录。同理他也是一个inode。我们在这个inode下执行vi操作打开某个文件，于是linux通过inode中的映射表找到了我们请求访问的文件名对应的inode。然后寻道到对应的磁盘位置，读取内容到缓冲区，通过系统调用把内容读到内存中，最后进行访问。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这部分内容主要是基于一些关于操作系统基础的学习总结，内容不全面，只讲述了其中的一小部分，后续会再补充，如有错误，还请见谅。&lt;br&gt;操作系统&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="技术总结" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="操作系统" scheme="http://h2pl.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络学习总结</title>
    <link href="http://h2pl.github.io/2018/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://h2pl.github.io/2018/07/09/计算机网络学习总结/</id>
    <published>2018-07-09T14:32:57.000Z</published>
    <updated>2018-07-09T15:09:25.864Z</updated>
    
    <content type="html"><![CDATA[<p>这部分内容主要是基于一些关于计算机网络基础的学习总结，内容不全面，只讲述了其中的一小部分，后续会再补充，如有错误，还请见谅。</p><a id="more"></a><p> 计算机网络常见概念</p><h2 id="网卡和路由器"><a href="#网卡和路由器" class="headerlink" title="网卡和路由器"></a>网卡和路由器</h2><p>网卡是一个有mac地址的物理设备，通过mac地址与局域网内的交换机通信，交换机可以识别mac地址。</p><p>而单纯的中继器，集线器，双绞线等设备只识别物理层设备。</p><p>路由器则工作在3层ip层，必须要有ip才能工作，所以路由器每一个接口都对应一个ip，维护一个可以识别ip的路由表，进行ip数据报转发。</p><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机具有自学习能力，学习的是交换表的内容。交换表中存储着 MAC 地址到接口的映射。</p><h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p>以太网是一种星型拓扑结构局域网。</p><p>早期使用集线器进行连接，它是一种物理层设备，作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离。之后再将这个比特向其它所有接口。特别是，如果集线器同时收到同时从两个不同接口的帧，那么就发生了碰撞。</p><p>目前以太网使用交换机替代了集线器，它不会发生碰撞，能根据 MAC 地址进行存储转发。</p><h2 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a>虚拟局域网VLAN</h2><p>正常情况下，局域网中的链路层广播在整个局域网可达，而vlan可以在物理局域网中划分虚拟局域网，使广播帧只有在vlan当中的主机才能收到。</p><p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息，例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。</p><h2 id="DHCP协议-动态主机配置协议"><a href="#DHCP协议-动态主机配置协议" class="headerlink" title="DHCP协议(动态主机配置协议)"></a>DHCP协议(动态主机配置协议)</h2><p>首先DHCP是为了让主机获得一个ip地址，所以主机会发一个0.0.0.0为发送方，255.255.255.255为接收方的ip数据报，也就是广播数据报，并且广播数据包只在局域网中有效，然后链路层解析为数据帧，发送给局域网内的DHCP服务器。</p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>arp负责把ip地址解析成局域网内的一个mac地址，只在局域网中有效。逆arp则把mac地址解析成ip地址。</p><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/66192382-558b-4b05-a35d-ac4a2b1a9811.jpg" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/66192382-558b-4b05-a35d-ac4a2b1a9811.jpg" alt=""></a></p><p>ARP 实现由 IP 地址得到 MAC 地址。</p><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/b9d79a5a-e7af-499b-b989-f10483e71b8b.jpg" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/b9d79a5a-e7af-499b-b989-f10483e71b8b.jpg" alt=""></a></p><p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。</p><blockquote><p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p></blockquote><h2 id="网关和NAT"><a href="#网关和NAT" class="headerlink" title="网关和NAT"></a>网关和NAT</h2><p>当需要和外部局域网访问时，需要经过网关服务器以便兼容不同协议栈。局域网内部使用内网ip，经过网关时要转成外网ip，网关会帮你完成改写操作，当收到数据报时，网关又会帮你把ip改为内网ip。这种修改ip隐藏内部网络的方式叫做NAT。</p><p>nat穿透的方式是主机和网关服务器协定一个ip地址作为主机服务的ip，所以主机可以通过这个ip和外网交流。</p><h2 id="DNS协议和http请求过程"><a href="#DNS协议和http请求过程" class="headerlink" title="DNS协议和http请求过程"></a>DNS协议和http请求过程</h2><p>访问一个域名时，会发送dns报文请求（应用层）给本地的DNS服务器，解析出域名对应的ip，然后三次握手建立连接，（当然TCP数据报由本地局域网经过网关转给外网，再经过多次路由才到达目标主机），然后发送http请求获得响应报文</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/e3124763-f75e-46c3-ba82-341e6c98d862.jpg" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/e3124763-f75e-46c3-ba82-341e6c98d862.jpg" alt=""></a></p><p>ICMP 报文分为差错报告报文和询问报文。</p><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/aa29cc88-7256-4399-8c7f-3cf4a6489559.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/aa29cc88-7256-4399-8c7f-3cf4a6489559.png" alt=""></a></p><pre><code>1. PingPing 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。Ping 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报。2. TracerouteTraceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径，事实上，traceroute也封装着无法交付的udp，和ping类似。。</code></pre><p>源主机向目的主机发送一连串的 IP 数据报，每个数据包的ttl时间不同，所以可以跟踪每一跳路由的信息。</p><p>==但是因为数据报封装的是无法交付的UDP报文，因此目的主机要向源主机发送 ICMP终点不可达差错报告报文。之后源主机知道了到达目的主机所经过的路由器 IP地址以及到达每个路由器的往返时间。==</p><h2 id="虚拟专用网VPN和内网ip"><a href="#虚拟专用网VPN和内网ip" class="headerlink" title="虚拟专用网VPN和内网ip"></a>虚拟专用网VPN和内网ip</h2><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p><p>有三个专用地址块：</p><ul><li>10.0.0.0 ~ 10.255.255.255</li><li>172.16.0.0 ~ 172.31.255.255</li><li>192.168.0.0 ~ 192.168.255.255</li></ul><p>这些ip也称为内网ip，用于局域网间的通信，只能通过网关抵达公网。</p><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/1556770b-8c01-4681-af10-46f1df69202c.jpg" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/1556770b-8c01-4681-af10-46f1df69202c.jpg" alt=""></a></p><p>使用隧道技术实现vpn。</p><pre><code>原理是；普通的内网ip无法被访问到，一般可以使用nat技术让网关作为中转人，而ip数据报也会改写成网关服务器的地址。如果想让数据报保留内网地址，并且实现跨公网访问，那么只能通过隧道技术，把内网数据报加密包装在公网ip数据报中，然后通过公网ip抵达对方的专用网络，进行拆包和发送。为什么vpn能翻墙呢，因为我们通过对vpn服务器的连接，可以将内网ip数据报装在里面，发送给vpn，vpn解析后再发送给真正的服务器。由于本地网关阻拦了某些网站的请求，所以我们要把这个请求加密封装，然后通过隧道把数据发给一个海外服务器，让他真正完成请求。</code></pre><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层的协议主要是http，ftp这类协议，http访问超文本html，而ftp访问文件系统。</p><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><p>通过浏览器可以方便地进行dns解析，建立tcp连接，发送http请求，得到http响应，这些工作都是浏览器完成的。</p><h3 id="http1-0-1-1和2-0"><a href="#http1-0-1-1和2-0" class="headerlink" title="http1.0 1.1和2.0"></a>http1.0 1.1和2.0</h3><h4 id="1-0和1-1的主要变化"><a href="#1-0和1-1的主要变化" class="headerlink" title="1.0和1.1的主要变化"></a>1.0和1.1的主要变化</h4><pre><code>1 http1.0经过多年发展，在1.1提出了改进。首先是提出了长连接，http请求可以在一次tcp连接中不断发送。2 然后是http1.1支持只发送header而不发送body。原因是先用header判断能否成功，再发数据，节约带宽，事实上，post请求默认就是这样做的。3 http1.1的host字段。由于虚拟主机可以支持多个域名，所以一般将域名解析后得到host。</code></pre><h4 id="http1-0和http2-0的区别。"><a href="#http1-0和http2-0的区别。" class="headerlink" title="http1.0和http2.0的区别。"></a>http1.0和http2.0的区别。</h4><pre><code>http2.0变化巨大。1 http支持多路复用，同一个连接可以并发处理多个请求，方法是把http数据包拆为多个帧，并发有序的发送，根据序号在另一端进行重组，而不需要一个个http请求顺序到达。2 http2.0支持服务端推送，就是服务端在http请求到达后，除了返回数据之外，还推送了额外的内容给客户端。3HTTP2.0压缩了请求头，同时基本单位是二进制帧流，这样的数据占用空间更少。4http2.0只适用于https场景，因为其在http和tcp中间加了一层ssl层。</code></pre><h3 id="get和post"><a href="#get和post" class="headerlink" title="get和post"></a>get和post</h3><pre><code>get和post本质都是http请求，只不过对他们的作用做了界定和适配，并且让他们适应各自的场景。1本质区别是get只是一次http请求，post先发请求体再发请求体，实际上是两次请求2表面区别：get可以cache而post不能，因为浏览器是这么安排的一般设计get是幂等的而post不是get的参数放在url传递，而post放在请求体里，因为get没有请求体。所以get请求不安全，并且有长度限制（url不能太长），而post几乎没有限制，请求体可以很大。</code></pre><p>### </p><h4 id="session和cookie"><a href="#session和cookie" class="headerlink" title="session和cookie"></a>session和cookie</h4><p>并且浏览器还维护了cookie以便记录用于对网站的一些信息，下次请求时在http报文中带上这些数据，服务器接收以后根据cookie中的sessionid获取对应的session即可</p><h4 id="token"><a href="#token" class="headerlink" title="token"></a>token</h4><p>session一般维护在内存中，有时候也会持久化到数据库，但是如果session由单点维护可能出现宕机等情况，于是一般会采用分布式的方案。</p><pre><code>session存放的几种方案。0 存在内存中。用sessionid标识用户。这样的session十分依赖于cookie。如果浏览器禁用了cookie则session无用武之地。当然也可以把内容存在数据库里，缺点是数据库访问压力较大。1有做法会将session内容存在cookie中，但前提是经过了加密，然后下次服务器对其进行解密，但是这样浏览器需要维护太多内容了。2当用户登录或者执行某些操作，则使用用户的一部分字段信息进行加密算法得到一串字符串成为token，用于唯一标识用户，或者是某些操作，比如登录，支付，服务端生成该token返回给用户，用户提交请求时必须带上这个token，就可以确认用户信息以及操作是否合法了。这样我们不需要存session，只需要在想得到用户信息时解密token即可。token还有一个好处就是可以在移动端和pc端兼容，因为移动端不支持cookie。3token和oauth。经常有第三方授权登录的例子，本质就是使用token。首先我们打开授权登录页，登陆后服务端返回token，我们提交第三方的请求时，带上这个token，第三方不知道他是啥意思，并且token过段时间就过期了。</code></pre><h4 id="cas单点登录"><a href="#cas单点登录" class="headerlink" title="cas单点登录"></a>cas单点登录</h4><p>单点登录是为了多个平台之间公用一个授权系统，做法是，所有登录都要指向统一登录服务，登陆成功以后在认证中心建立session，并且得到ticket，然后重定向页面，此时页面也会向认证中心确认ticket是否合法，然后就可以访问其他系统的页面了。</p><p>从而访问其他系统时，由于已经有了认证中心的cookie，所以直接带上ticket访问即可。</p><p>每次访问新系统时需要在认证中心注册session，然后单点退出时再把这些session退出，才能实现用户登出。</p><h2 id="web安全和https"><a href="#web安全和https" class="headerlink" title="web安全和https"></a>web安全和https</h2><h3 id="密码加密"><a href="#密码加密" class="headerlink" title="密码加密"></a>密码加密</h3><p>MD5等加密方法可以用来对密码进行加密。一般还会加盐</p><h3 id="xss跨站脚本攻击"><a href="#xss跨站脚本攻击" class="headerlink" title="xss跨站脚本攻击"></a>xss跨站脚本攻击</h3><p>利用有输入功能网站的输入框来注入JavaScript脚本代码，用户访问该页面时会自动执行某些脚本代码，导致cookie等个人信息泄露，可能会被转发到其他网站。</p><p>解决办法是对输入进行检验，利用一个些工具类就可以做到。</p><h3 id="跨站点请求伪造csrf"><a href="#跨站点请求伪造csrf" class="headerlink" title="跨站点请求伪造csrf"></a>跨站点请求伪造csrf</h3><p>首先用户访问了一个网站并登陆，会把cookie保留在浏览器，<br>然后某些网站用一些隐性链接诱导用户点击，点击时发送请求会携带浏览器中的cookie，比如支付宝的账号密码，通过该cookie再去伪造一个支付宝支付请求，达到伪造请求的目的。 </p><p>解决这个问题的办法就是禁止js请求跨域名。但是他为ajax提供了特殊定制。</p><h3 id="SQL-注入攻击"><a href="#SQL-注入攻击" class="headerlink" title="SQL 注入攻击"></a>SQL 注入攻击</h3><ol><li><p>概念<br>服务器上的数据库运行非法的 SQL 语句，主要通过拼接来完成。</p></li><li><p>防范手段<br>（一）使用参数化查询</p></li></ol><p>以下以 Java 中的 PreparedStatement 为例，它是预先编译的 SQL 语句，可以传入适当参数并且多次执行。由于没有拼接的过程，因此可以防止 SQL 注入的发生。</p><p>（二）单引号转换</p><p>将传入的参数中的单引号转换为连续两个单引号，PHP 中的 Magic quote 可以完成这个功能。</p><h3 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h3><p>拒绝服务攻击（denial-of-service attack，DoS），亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p><p>分布式拒绝服务攻击（distributed denial-of-service attack，DDoS），指攻击者使用网络上两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击。</p><p>DDoS攻击通过大量合法的请求占用大量网络资源，以达到瘫痪网络的目的。 </p><p>这种攻击方式可分为以下几种：</p><pre><code>通过使网络过载来干扰甚至阻断正常的网络通讯；通过向服务器提交大量请求，使服务器超负荷；阻断某一用户访问服务器；阻断某服务与特定系统或个人的通讯。</code></pre><p>攻击现象</p><pre><code>被攻击主机上有大量等待的TCP连接；网络中充斥着大量的无用的数据包；源地址为假 制造高流量无用数据，造成网络拥塞，使受害主机无法正常和外界通讯；利用受害主机提供的传输协议上的缺陷反复高速的发出特定的服务请求，使主机无法处理所有正常请求；严重时会造成系统死机。</code></pre><p>总体来说，对DoS和DDoS的防范主要从下面几个方面考虑：</p><pre><code>尽可能对系统加载最新补丁，并采取有效的合规性配置，降低漏洞利用风险；采取合适的安全域划分，配置防火墙、入侵检测和防范系统，减缓攻击。采用分布式组网、负载均衡、提升系统容量等可靠性措施，增强总体服务能力。</code></pre><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>https博大精深，首先先来看看他的基础知识</p><pre><code>1对称加密和非对称加密对称加密两方使用同一把密钥加密和解密，传输密钥时如果丢失就会被破解。2非对称加密两方各有一把私钥，而公钥公开，A用私钥加密，把公钥和数据传给B，B用公钥解密。同理，B用私钥对数据进行加密，返回给A，A也用公钥进行解密。3非对称加密只要私钥不丢就很安全，但是效率比较低，所以一般使用非对称加密传输对称加密的密钥，使用对称加密完成数据传输。4数字签名，为了避免数据在传输过程中被替换，比如黑客修改了你的报文内容，但是你并不知道，所以我们让发送端做一个数字签名，把数据的摘要消息进行一个加密，比如MD5，得到一个签名，和数据一起发送。然后接收端把数据摘要进行md5加密，如果和签名一样，则说明数据确实是真的。5数字证书，对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但是数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥其实是假的。所以为了保证发送方的公钥是真的，CA证书机构会负责颁发一个证书，里面的公钥保证是真的，用户请求服务器时，服务器将证书发给用户，这个证书是经由系统内置证书的备案的。6 https过程用户发送请求，服务器返回一个数字证书。用户在浏览器端生成一个随机数，使用证书中的公钥加密，发送给服务端。服务端使用公钥解密该密文，得到随机数。往后两者使用该随机数作为公钥进行对称加密。番外：关于公钥加密私钥解密与私钥加密公钥解密说明第一种是签名,使用私钥加密,公钥解密,用于让所有公钥所有者验证私钥所有者的身份并且用来防止私钥所有者发布的内容被篡改.但是不用来保证内容不被他人获得. 第二种是加密,用公钥加密,私钥解密,用于向公钥所有者发布信息,这个信息可能被他人篡改,但是无法被他人获得.搜索 </code></pre><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><pre><code>UDP 和 TCP 的特点用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</code></pre><p>TCP是传输层最重要的协议。</p><blockquote><p>由于网络层只提供最大交付的服务，尽可能地完成路由转发，以及把链路层报文传送给任意一台主机。他做的工作很专注，所以不会提供其他的可靠性保证。</p><p>但是真实网络环境下随时会发生丢包，乱序，数据内容出错等情况，这些情况必须得到处理，于是我们使用传输层tcp来解决这些问题。</p></blockquote><h3 id="UDP报文"><a href="#UDP报文" class="headerlink" title="UDP报文"></a>UDP报文</h3><p>伪首部的意义：伪首部并非TCP&amp;UDP数据报中实际的有效成分。伪首部是一个虚拟的数据结构，其中的信息是从数据报所在IP分组头的分组头中提取的，既不向下传送也不向上递交，而仅仅是为计算校验和。</p><p><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg" alt="image"></p><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p><h3 id="TCP-首部格式"><a href="#TCP-首部格式" class="headerlink" title="TCP 首部格式"></a>TCP 首部格式</h3><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" alt=""></a></p><ul><li><p><strong>序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p></li><li><p><strong>确认号</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p></li><li><p><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p></li><li><p><strong>确认 ACK</strong> ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p></li><li><p><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p></li><li><p><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</p></li><li><p><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p></li><li></li></ul><h3 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h3><pre><code>为了保证tcp的可靠传输，需要建立起一条通路，也就是所谓连接。这条通路必须保证有效并且能正确结束。</code></pre><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/e92d0ebc-7d46-413b-aec1-34a39602f787.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/e92d0ebc-7d46-413b-aec1-34a39602f787.png" alt=""></a></p><pre><code>三次握手1 首先客户端发送连接请求syn，携带随机数x。2 服务端返回请求ack，x + 1,说明服务端对x进行了回复。3 客户端返回请求ack，y，说明接受到了信息并且开始传输数据，起始数据为y。客户端状态时syn_send和establish服务端则是从listen到syn_rcvd，再到establish</code></pre><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" alt=""></a></p><pre><code>四次挥手1 首先客户端请求断开连接，发送fin请求，服务端返回fin的ack，继续处理断开前需要处理完的数据。2 过了一会，服务端处理完数据发送给客户端ack，表明已经关闭，客户端最后再发一个ack给服务端，如果服务端已关闭则无反应，客户端经过两个ttl后挥手完毕，确认服务端断开。这两个ttl成为time wait状态，用于确定服务端真的关闭。3 客户端发完fin后的状态从establish变为fin1——wait，服务端发完ack后的状态从establish变为closewait。4 客户端收到第一个ack后进入fin_2wait状态，服务端过了一会发送last——ack给客户端，说明关闭好了，客户端收到ack后进入timewait，然后发送ack。双方都closed。</code></pre><h3 id="半连接syn和洪泛法攻击"><a href="#半连接syn和洪泛法攻击" class="headerlink" title="半连接syn和洪泛法攻击"></a>半连接syn和洪泛法攻击</h3><p>黑客开启大量的syn请求而不发送ack，服务端开启半连接等待ack，直到资源耗尽，所以必须检测来访ip</p><h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><p>三次握手的原因</p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>也就是说，如果只有两次握手，服务端返回ack后直接通信，那么如果客户端因为网络问题没有收到ack，可能会再次请求连接，但时服务端不知道这其实是同一个请求，于是又打开了一个连接，相当于维护了很多的无用连接。</p><h3 id="time-wait的作用"><a href="#time-wait的作用" class="headerlink" title="time wait的作用"></a>time wait的作用</h3><p>1 需要服务端可靠地终止连接，如果处于time_wait客户端发给服务端的ack报文丢失，则服务端会再发一次fin，此时客户端不应该关闭。</p><p>2 保证迟来的tcp报文有时间被丢弃，因为2msl里超时抵达的报文都会被丢弃。</p><h2 id="可靠传输协议"><a href="#可靠传输协议" class="headerlink" title="可靠传输协议"></a>可靠传输协议</h2><p>TCP协议有三个重要属性。</p><pre><code>可靠传输，主要通过有序接收，确认后发送，以及超时重传来实现，并且使用分片来提高发送效率，通过检验和避免错误。流量控制，主要通过窗口限制接收和发送速率。拥塞控制，主要通过不同拥塞状态的算法来处理拥塞，一开始发的比较慢，然后指数增加，当丢包时再降低速度，重新开始第一阶段，避免拥塞。</code></pre><p>总结以下就是几个特点：</p><p>TCP 可靠传输</p><pre><code>TCP 使用超时重传来实现可靠传输：1 如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。2 滑动窗口可以连续发送多个数据再统一进行确认。   因为发送端希望在收到确认前，继续发送其它报文段。比如说在收到0号报文的确认前还发出了1-3号的报文，这样提高了信道的利用率。3 滑动窗口只重传丢失的数据报但可以想想，0-4发出去后可能要重传，所以需要一个缓冲区维护这些报文，所以就有了窗口。4每当完成一个确认窗口往前滑动一格，可以传新的一个数据，因此可以顺序发送顺序确认</code></pre><p>TCP 流量控制</p><pre><code>流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</code></pre><p>TCP 拥塞控制</p><pre><code>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接受，而拥塞控制是为了降低整个网络的拥塞程度。TCP 主要通过四种算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。一般刚开始时慢开始，然后拥塞避免，出现个别丢包时（连续三个包序号不对），则执行快重传，然后进入快恢复阶段，接着继续拥塞避免。如果发生多次超时也就是拥塞时，直接进入慢开始。</code></pre><blockquote><p>这种情况下，只是丢失个别报文段，而不是网络拥塞，因此执行快恢复，令 ssthresh = cwnd/2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p></blockquote><p> ==发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口==。</p><p>滑动窗口协议综合实现了上述这一些内容：</p><p>为什么要使用滑动窗口，因为滑动窗口可以实现可靠传输，流量控制和拥塞控制（拥塞控制用的是拥塞窗口变量）</p><h3 id="tcp的粘包拆包"><a href="#tcp的粘包拆包" class="headerlink" title="tcp的粘包拆包"></a>tcp的粘包拆包</h3><p>tcp报文是流式的数据，没有标识数据结束，只有序号等字段，tcp协议自动完成数据报的切分。由于tcp使用缓冲区发送，又没有标识结束，当缓冲区的数据没清空又有新数据进来，就会发生粘包，如果数据太大存装不下，就会被拆包。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h2 id="IP-数据报格式"><a href="#IP-数据报格式" class="headerlink" title="IP 数据报格式"></a>IP 数据报格式</h2><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" alt=""></a></p><ul><li><p><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</p></li><li><p><strong>首部长度</strong> : 占 4 位，因此最大值为 15。</p></li><li><p><strong>总长度</strong> : 包括首部长度和数据部分长度。</p></li><li><p><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</p></li></ul><p>==*   <strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。==</p><ul><li><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li></ul><ul><li><strong>片偏移</strong> : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li></ul><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/23ba890e-e11c-45e2-a20c-64d217f83430.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/23ba890e-e11c-45e2-a20c-64d217f83430.png" alt=""></a></p><p>总结：</p><pre><code>ip层只保证尽最大努力交付，他所承载的一切都是对路由，转发，已经网络传输最友好的设计。路由器负责记录路由表和转发ip数据报，路由表记录着ip地址和下一跳路由的端口的对应关系。由于路由聚合的缘故，一般用170.177.233.0/24就可以标识好几个网络了。以前会使用A，B，C类地址，和子网，现在直接使用地址聚合，前24位是网络号，后面8位是主机号。## 某个聚合路由地址划分网络给n台机器，是否符合要求。。要看这个网络中的主机号能否达到n个。</code></pre><h3 id="IP-地址编址方式"><a href="#IP-地址编址方式" class="headerlink" title="IP 地址编址方式"></a>IP 地址编址方式</h3><p>IP 地址的编址方式经历了三个历史阶段：</p><ul><li>分类</li><li>子网划分</li><li>无分类</li></ul><h3 id="1-分类"><a href="#1-分类" class="headerlink" title="1. 分类"></a><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#1-%E5%88%86%E7%B1%BB" target="_blank" rel="noopener"></a>1. 分类</h3><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/cbf50eb8-22b4-4528-a2e7-d187143d57f7.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/cbf50eb8-22b4-4528-a2e7-d187143d57f7.png" alt=""></a>  </p><ol start="2"><li>子网划分</li></ol><pre><code>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。注意，外部网络看不到子网的存在。IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</code></pre><ol start="3"><li>无分类</li></ol><pre><code>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</code></pre><p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。</p><p>把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。</p><p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p><p>总结</p><pre><code>使用分类法的ip必须标识是哪一类地址，比较麻烦，而且一旦设置为某类地址它就只能使用那一部分地址空间了。使用子网掩码可以避免使用分类并且更灵活地决定网络号和主机号的划分。但是需要配置子网掩码，比较复杂。CIDR 138.1.2.11/24使用CIDR避免了子网划分，直接使用后n位作为网络号，简化了子网的配置（实际上用n代替了子网掩码）。并且在路由器中可以使用地址聚合，一个ip可以聚合多个网络号。</code></pre><h3 id="ip分片详谈"><a href="#ip分片详谈" class="headerlink" title="ip分片详谈"></a>ip分片详谈</h3><p>在TCP/IP分层中，数据链路层用MTU（Maximum Transmission Unit，最大传输单元）来限制所能传输的数据包大小，MTU是指一次传送的数据最大长度，不包括数据链路层数据帧的帧头，如以太网的MTU为1500字节，实际上数据帧的最大长度为1512字节，其中以太网数据帧的帧头为12字节。</p><p>当发送的IP数据报的大小超过了MTU时，IP层就需要对数据进行分片，否则数据将无法发送成功。</p><p>IP分片的实现</p><blockquote><p>IP分片发生在IP层，不仅源端主机会进行分片，中间的路由器也有可能分片，因为不同的网络的MTU是不一样的，如果传输路径上的某个网络的MTU比源端网络的MTU要小，路由器就可能对IP数据报再次进行分片。而分片数据的重组只会发生在目的端的IP层。</p></blockquote><p>==避免IP分片==</p><blockquote><p>在网络编程中，我们要避免出现IP分片，那么为什么要避免呢？原因是IP层是没有超时重传机制的，如果IP层对一个数据包进行了分片，只要有一个分片丢失了，只能依赖于传输层进行重传，结果是所有的分片都要重传一遍，这个代价有点大。由此可见，IP分片会大大降低传输层传送数据的成功率，所以我们要避免IP分片。</p></blockquote><pre><code>对于UDP包，我们需要在应用层去限制每个包的大小，一般不要超过1472字节，即以太网MTU（1500）—UDP首部（8）—IP首部（20）。对于TCP数据，应用层就不需要考虑这个问题了，因为传输层已经帮我们做了。</code></pre><p>在建立连接的三次握手的过程中，连接双方会相互通告MSS（Maximum Segment =Size，最大报文段长度），MSS一般是MTU—IP首部（20）—TCP首部（20），每次发送的TCP数据都不会超过双方MSS的最小值，所以就保证了IP数据报不会超过MTU，避免了IP分片。</p><ol start="3"><li>外部网关协议 BGP</li></ol><pre><code>BGP（Border Gateway Protocol，边界网关协议）AS 之间的路由选择很困难，主要是因为互联网规模很大。并且各个 AS 内部使用不同的路由选择协议，就无法准确定义路径的度量。并且 AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。BGP 只能寻找一条比较好的路由，而不是最佳路由。每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</code></pre><h3 id="路由选择协议和算法"><a href="#路由选择协议和算法" class="headerlink" title="路由选择协议和算法"></a>路由选择协议和算法</h3><blockquote><p>路由选择协议<br>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p><p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p><p>可以把路由选择协议划分为两大类：</p><p>自治系统内部的路由选择：RIP 和 OSPF<br>自治系统间的路由选择：BGP</p></blockquote><p>总结：</p><pre><code>1. 内部网关协议 RIPRIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1，跳数最多为 15，超过 15 表示不可达。RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。2. 内部网关协议 OSPF开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</code></pre><p>OSPF 具有以下特点：</p><pre><code>计算出最短路径，然后向本自治系统中的所有路由器发送信息，这种方法是洪泛法。发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。变化时，路由器才会发送信息。所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</code></pre><p>总结：</p><pre><code>AS是一个自治域，一般是指相似度很大公用一个协议的路由器族，比如同一个运营商的网络。因特网中AS之间的路由选择协议是BGP。AS内的路由选择协议有RIP和OSPF。RIP两两交换，最后大家都同步。OSPF找到最短路径。告诉大家。</code></pre><h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><p>链路层最主要是指局域网内的网络交互了，使用mac地址通过交换机进行通信，其中用得最多的局域网协议就是以太网。</p><p>链路层使用MTU表示最大传输帧长度，报文长度不能超过MTU,否则会进行分片，比如比较大的IP数据报就会被分片，为了避免被分片。一般要控制IP报文长度。</p><p>广播：</p><p>要理解什么是广播风暴，就必须先理解网络通信技术。 网络上的一个节点，它发送一个数据帧或包，被传输到由广播域定义的本地网段上的每个节点就是广播。</p><blockquote><p>网络广播分为第2层广播和第3层广播。第2层广播也称硬件广播，用于在局域网内向所有的结点发送数据，通常不会穿过局域网的边界（路由器），除非它变成一个单播。广播将是一个二进制的全1或者十六进制全F的地址。而第3层广播用于在这个网络内向所有的结点发送数据。</p></blockquote><p>帧的传输方式，即单播帧（Unicast Frame）、多播帧（Multicast Frame）和广播帧（Broadcast Frame）。</p><pre><code>1、单播帧单播帧也称“点对点”通信。此时帧的接收和传递只在两个节点之间进行，帧的目的MAC地址就是对方的MAC地址，网络设备（指交换机和路由器）根据帧中的目的MAC地址，将帧转发出去。2、多播帧多播帧可以理解为一个人向多个人（但不是在场的所有人）说话，这样能够提高通话的效率。多播占网络中的比重并不多，主要应用于网络设备内部通信、网上视频会议、网上视频点播等。3、广播帧广播帧可以理解为一个人对在场的所有人说话，这样做的好处是通话效率高，信息一下子就可以传递到全体。在广播帧中，帧头中的目的MAC地址是“FF.FF.FF.FF.FF.FF”，代表网络上所有主机网卡的MAC地址。广播帧在网络中是必不可少的，如客户机通过DHCP自动获得IP地址的过程就是通过广播帧来实现的。而且，由于设备之间也需要相互通信，因此在网络中即使没有用户人为地发送广播帧，网络上也会出现一定数量的广播帧。同单播和多播相比，广播几乎占用了子网内网络的所有带宽。网络中不能长时间出现大量的广播帧，否则就会出现所谓的“广播风暴”（每秒的广播帧数在1000以上）。拿开会打一个比方，在会场上只能有一个人发言，如果所有人都同时发言的话，会场上就会乱成一锅粥。广播风暴就是网络长时间被大量的广播数据包所占用，使正常的点对点通信无法正常进行，其外在表现为网络速度奇慢无比。出现广播风暴的原因有很多，一块故障网卡就可能长时间地在网络上发送广播包而导致广播风暴。使用路由器或三层交换机能够实现在不同子网间隔离广播风暴的作用。当路由器或三层交换机收到广播帧时并不处理它，使它无法再传递到其他子网中，从而达到隔离广播风暴的目的。因此在由几百台甚至上千台电脑构成的大中型局域网中，为了隔离广播风暴，都要进行子网划分。使用vlan完全可以隔离广播风暴。</code></pre><blockquote><p>在交换以太网上运行TCP/IP环境下：<br>二层广播是在数据链路层的广播，它 的广播范围是二层交换机连接的所有端口；二层广播不能通过路由器。</p><p>三层广播就是在网络层的广播，它的范围是同一IP子网内的设备，子网广播也不能通过路由器。</p><p>第三层的数据必须通过第二层的封装再发送，所以三层广播必然通过二层广播来实现。</p><p>设想在同一台二层交换机上连接2个ip子网的设备，所有的设备都可以接收到二层广播，但三层广播只对本子网设备有效，非本子网的设备也会接收到广播包，但会被丢弃。</p></blockquote><p>广播风暴（broadcast storm）</p><p>简单的讲是指当广播数据充斥网络无法处理，并占用大量网络带宽，导致正常业务不能运行，甚至彻底瘫痪，这就发生了“广播风暴”</p><p>。一个数据帧或包被传输到本地网段 （由广播域定义）上的每个节点就是广播；由于网络拓扑的设计和连接问题，或其他原因导致广播在网段内大量复制，传播数据帧，导致网络性能下降，甚至网络瘫痪，这就是广播风暴。</p><p>要避免广播风暴，可以采用恰当划分VLAN、缩小广播域、隔离广播风暴，还可在千兆以太网口上启用广播风暴控制，最大限度地避免网络再次陷入瘫痪。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这部分内容主要是基于一些关于计算机网络基础的学习总结，内容不全面，只讲述了其中的一小部分，后续会再补充，如有错误，还请见谅。&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="技术总结" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="计算机网络" scheme="http://h2pl.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer算法学习总结</title>
    <link href="http://h2pl.github.io/2018/07/09/%E5%89%91%E6%8C%87offer/"/>
    <id>http://h2pl.github.io/2018/07/09/剑指offer/</id>
    <published>2018-07-09T14:32:40.000Z</published>
    <updated>2018-07-09T14:36:30.356Z</updated>
    
    <content type="html"><![CDATA[<p>##节选剑指offer比较经典和巧妙的一些题目，以便复习使用。一部分题目给出了完整代码，一部分题目比较简单直接给出思路。但是不保证我说的思路都是正确的，个人对算法也不是特别在行，只不过这本书的算法多看了几遍多做了几遍多了点心得体会。于是想总结一下。如果有错误也希望能指出，谢谢。</p><p>#具体代码可以参考我的GitHub仓库：</p><p>#<a href="https://github.com/h2pl/SwordToOffer" target="_blank" rel="noopener">https://github.com/h2pl/SwordToOffer</a></p><h1 id="数论和数字规律"><a href="#数论和数字规律" class="headerlink" title="数论和数字规律"></a>数论和数字规律</h1><h2 id="从1到n整数中1出现的次数"><a href="#从1到n整数中1出现的次数" class="headerlink" title="从1到n整数中1出现的次数"></a>从1到n整数中1出现的次数</h2><p>题目描述<br>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。</p><p>1暴力办法，把整数转为字符串，依次枚举相加。复杂度是O（N * k）k为数字长度。</p><p>2第二种办法看不懂，需要数学推导，太长不看</p><h2 id="排数组排成最小的数"><a href="#排数组排成最小的数" class="headerlink" title="排数组排成最小的数"></a>排数组排成最小的数</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><p>解析：本题的关键是，两个数如何排成最小的，答案是，如果把数字看成字符串a,b那么如果a+b&gt;b+a，则a应该放在b后面。<br>例如 3和32 3 + 32 = 332,32 + 3 = 323,332&gt;323,所以32要放在前面。</p><p>根据这个规律，构造一个比较器，使用排序方法即可。</p><h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><p>题目描述<br>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><p>解析</p><p>1 暴力枚举每个丑数，找出第N个即可。</p><p>2 这个思路比较巧妙，由于丑数一定是由2,3,5三个因子构成的，所以我们每次构造出一个比前面丑数大但是比后面小的丑数，构造N次即可。</p><pre><code>public class Solution {    public static int GetUglyNumber_Solution(int index) {            if (index == 0) return 0;            int []res = new int[index];            res[0] = 1;            int i2,i3,i5;            i2 = i3 = i5 = 0;            for (int i = 1;i &lt; index;i ++) {                res[i] = Math.min(res[i2] * 2, Math.min(res[i3] * 3, res[i5] * 5));                if (res[i] == res[i2] * 2) i2 ++;                if (res[i] == res[i3] * 3) i3 ++;                if (res[i] == res[i5] * 5) i5 ++;            }            return res[index - 1];        }    }}i2,i3,i5分别代表目前有几个2,3,5的因子，每次选一个最小的丑数，然后开始找下一个。当然i2，i3，i5也要跟着变。</code></pre><h1 id="数组和矩阵"><a href="#数组和矩阵" class="headerlink" title="数组和矩阵"></a>数组和矩阵</h1><h2 id="二维数组的查找"><a href="#二维数组的查找" class="headerlink" title="二维数组的查找"></a>二维数组的查找</h2><pre><code>/** * Created by 周杰伦 on 2018/2/25. * 题目描述 在一个二维数组中，每一行都按照从左到右递增的顺序排序， 每一列都按照从上到下递增的顺序排序。请完成一个函数， 输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 1 2 3 2 3 4 3 4 5 */ 解析：比较经典的一题，解法也比较巧妙，由于数组从左向右和从上到下的都是递增的，所以找一个数可以先从最右开始找。 假设最右值为a，待查数为x，那么如果x &lt; a说明x在a的左边，往左找即可，如果x &gt; a，说明x 在 a的下面一行，到下面一行继续按照该规则查找，就可以遍历所有数。算法的时间复杂度是O(M * N)public class 二维数组中的查找 {    public static boolean Find(int target, int[][] array) {        if(array[0][0] &gt; target) {            return false;        }        int row = 0;        int col = 0;        while (row &lt; array.length &amp;&amp; col &gt;0) {            if (target == array[row][col]) {                return true;            }            else if (target &lt;array[row][col]) {                col --;            }            else if (target &gt; array[row][col]) {                col ++;            }            else row++;        }        return false;    }}</code></pre><h2 id="顺时针打印矩阵。"><a href="#顺时针打印矩阵。" class="headerlink" title="顺时针打印矩阵。"></a>顺时针打印矩阵。</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p><p>这题还是有点麻烦的，因为要顺时针打印，所以实际上是由外向内打印，边界的处理和递归调用需要谨慎。</p><p>这题我自己没写出标准答案。参考一个答案吧。关键在于四个循环中的分界点设置。</p><pre><code>//主体循环部分才5行。其实是有规律可循的。将每一层的四个边角搞清楚就可以打印出来了    import java.util.ArrayList;    public class Solution {        public ArrayList&lt;Integer&gt; printMatrix(int [][] array) {            ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt; ();            if(array.length==0) return result;            int n = array.length,m = array[0].length;            if(m==0) return result;            int layers = (Math.min(n,m)-1)/2+1;//这个是层数            for(int i=0;i&lt;layers;i++){                for(int k = i;k&lt;m-i;k++) result.add(array[i][k]);//左至右                for(int j=i+1;j&lt;n-i;j++) result.add(array[j][m-i-1]);//右上至右下                for(int k=m-i-2;(k&gt;=i)&amp;&amp;(n-i-1!=i);k--) result.add(array[n-i-1][k]);//右至左                for(int j=n-i-2;(j&gt;i)&amp;&amp;(m-i-1!=i);j--) result.add(array[j][i]);//左下至左上            }            return result;               }    }</code></pre><h2 id="调整数组中数字的顺序，使正数在负数的前面"><a href="#调整数组中数字的顺序，使正数在负数的前面" class="headerlink" title="调整数组中数字的顺序，使正数在负数的前面"></a>调整数组中数字的顺序，使正数在负数的前面</h2><p>双指针即可以解决，变式有正负，奇偶等等。</p><h2 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h2><p>本题有很多种解法。</p><p>1 最笨的解法，统计每个数的出现次数，O（n2)</p><p>2 使用hashmap，空间换时间O（n)</p><p>3 由于出现超过一半的数字一定也是中位数，所以可以先排序，再找到第n/2位置上的节点。</p><p>4 使用快速排序的复杂度是O（nlogn)，基于快排的特性，每一轮的过程都会把一个数放到最终位置，所以我们可以判断一下这个数的位置是不是n/2，如果是的话，那么就直接返回即可。这样就优化了快排的步骤。</p><p>4.5事实上，上述办法的复杂度仍然是O（nlogn）</p><pre><code>快速排序的partition函数将一个数组分为左右两边，并且我们可以知道，如果flag值在k位置左边，那么往左找，如果在k位置右边，那么往左找。这里科普一下经典快排中的一个方法partition，剑指offer书中直接跳过了这部分，让我摸不着头脑。虽然快排用到了经典的分而治之的思想，但是快排实现的前提还是在于 partition 函数。正是有了 partition 的存在，才使得可以将整个大问题进行划分，进而分别进行处理。除了用来进行快速排序，partition 还可以用 O(N) 的平均时间复杂度从无序数组中寻找第K大的值。和快排一样，这里也用到了分而治之的思想。首先用 partition 将数组分为两部分，得到分界点下标 pos，然后分三种情况：pos == k-1，则找到第 K 大的值，arr[pos]；pos &gt; k-1，则第 K 大的值在左边部分的数组。pos &lt; k-1，则第 K 大的值在右边部分的数组。下面给出基于迭代的实现（用来寻找第 K 小的数）：int find_kth_number(vector&lt;int&gt; &amp;arr, int k){    int begin = 0, end = arr.size();    assert(k&gt;0 &amp;&amp; k&lt;=end);    int target_num = 0;    while (begin &lt; end){        int pos = partition(arr, begin, end);        if(pos == k-1){            target_num = arr[pos];            break;        }        else if(pos &gt; k-1){            end = pos;        }        else{            begin = pos + 1;        }    }    return target_num;}该算法的时间复杂度是多少呢？考虑最坏情况下，每次 partition 将数组分为长度为 N-1 和 1 的两部分，然后在长的一边继续寻找第 K 大，此时时间复杂度为 O(N^2 )。不过如果在开始之前将数组进行随机打乱，那么可以尽量避免最坏情况的出现。而在最好情况下，每次将数组均分为长度相同的两半，运行时间 T(N) = N + T(N/2)，时间复杂度是 O(N)。</code></pre><p>所以也就是说，本题用这个方法解的话，复杂度只需要O（n),因为第一次交换需要N/2,j接下来的交换的次数越来越少，最后加起来就是O（N）了。</p><p>5 由于数字出现次数超过长度的一半，也就是平均每两个数字就有一个该数字，但他们不一定连续，所以变量time保存一个数的出现次数，然后变量x代表目前选择的数字，遍历中，如果x与后一位不相等则time–，time=0时x改为后一位，time重新变为1。最终x指向的数字就是出现次数最多的。</p><p>举两个例子，比如1,2,3,4,5,6,6,6,6,6,6。明显符合。1,6,2,6,3,6,4,6,5,6,6 遍历到最后得到x=6，以此类推，可以满足要求。</p><h2 id="找出前k小的数"><a href="#找出前k小的数" class="headerlink" title="找出前k小的数"></a>找出前k小的数</h2><ul><li>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。<br>*/</li></ul><p>解析：</p><p>1如果允许改变数组，那么则可以继承上一题的思想。，使用快速排序中的partition方法，只需要O（N）的复杂度</p><p>2使用堆排序</p><pre><code>解析：用前k个数构造一个大小为k的大顶堆，然后遍历余下数字，如果比堆顶大，则跳过，如果比堆顶小，则替换掉堆顶元素，然后执行一次堆排序（即根节点向下调整)。此时的堆顶元素已被替换，然后遍历完所有元素，堆中的元素就是最小的k个元素了。如果要求最大的k个元素，则构造小顶堆就可以了。构造堆的方法是，数组的第N/2号元素到0号元素依次向下调整，此时数组就构成了堆。实际上我们可以使用现成的集合类，红黑树是一棵搜索树，他是排序的，所以可以得到最大和最小值，那么我们每次和最小值比较，符合条件就进行替换即可。复杂度是O（nlogn)public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) {        ArrayList&lt;Integer&gt;arrayList=new ArrayList&lt;&gt;();        if(input==null || input.length==0 ||k==0 ||k&gt;input.length)return arrayList;        TreeSet&lt;Integer&gt; treeSet=new TreeSet&lt;&gt;();        for(int i=0;i&lt;input.length;i++){            if(treeSet.size()&lt;k){                treeSet.add(input[i]);            }            else {                if(input[i]&lt;treeSet.last()){                    treeSet.pollLast();                    treeSet.add(input[i]);                }            }        }        for(Integer x:treeSet){        arrayList.add(x);        }        return arrayList;    }</code></pre><h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h2><p>**</p><ul><li>Created by 周杰伦 on 2017/3/23.</li><li>题目描述<br>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。<br>今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。<br>但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？<br>例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。<br>你会不会被他忽悠住？(子向量的长度至少是1)</li></ul><p>解析：笨办法需要O（n2）的复杂度。</p><p>1 但是实际上只需要<br>一次遍历即可解决。通过sum保存当前和，然后如果当前和为正，那么继续往后加，如果当前和为负，则直接丢弃，令当前和等于一个新值。并且每一步都要比较当前和与最大值。</p><pre><code> */public class 连续数字序列的最大和 {    public int FindGreatestSumOfSubArray(int[] array) {       if(array==null || array.length==0)return 0;        int sum=0;int max=array[0];        for(int i=0;i&lt;array.length;i++){           //如果当前和&lt;0，那就不加，直接赋新值            if(sum&lt;=0){               sum=array[i];           }//如果当前和大于零，则继续加。           else {               sum+=array[i];           }           if(max&lt;sum){            max=sum;           }        }        return max;    }</code></pre><p>2 本题也可以使用DP解法      </p><p>DP数组代表以i为结尾元素的连续最大和</p><p>DP[i] = arr[i] (DP[i-1] &lt; 0)<br>      = DP[i] + arr[i] (DP[i -1] &gt; 0)</p><h2 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h2><p>/**</p><ul><li>Created by 周杰伦 on 2017/3/23.</li><li><p>题目描述<br>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。<br>输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。<br>即输出P%1000000007<br>*/</p><p> 解析：本题采用归并排序的框架，只是在归并的时候做出逆序对查找，具体参见下面代码。<br> 核心点是，在归并两个有序数组时，如果a数组的元素a1比b数组的元素b1大时，说明有mid - i + 1个数都比b1大。i为a1元素的位置。<br> 这样子我们就可以统计逆序对的个数了。经典巧妙。！</p><p> public class 逆序对 {</p><pre><code>public double Pairs = 0;public int InversePairs(int [] array) {    if (array.length==0 ||array==null)        return 0;    mergesort(array,0,array.length-1);    Pairs = Pairs + 1000000007;    return (int) (Pairs % 1000000007);}public void merge(int []array,int left,int mid,int right){    //有一点很重要的是，归并分成两部分，其中一段是left到mid，第二段是mid+1到right。    //不能从0到mid-1，然后mid到right。因为这样左右不均分，会出错。千万注意。    //mid=(left+right)/2    if (array.length==0 ||array==null ||left&gt;=right)        return ;    int p=left,q=mid+1,k=0;    int []temp=new int[right-left+1];    while (p&lt;=mid &amp;&amp; q&lt;=right){        if(array[p]&gt;array[q]){            temp[k++]=array[q++];            //当前半数组中有一个数p比后半个数组中的一个数q大时，由于两个数组            //已经分别有序，所以说明p到中间数之间的所有数都比q大。            Pairs+=mid-p+1;        }        else temp[k++]=array[p++];    }    while (p&lt;=mid){        temp[k++]=array[p++];}    while (q&lt;=right){        temp[k++]=array[q++];}</code></pre></li></ul><pre><code>    for (int m = 0; m &lt; temp.length; m++)        array[left + m] = temp[m];}public void mergesort(int []arr,int left,int right){    if (arr.length==0 ||arr==null)        return ;    int mid=(right+left)/2;    if(left&lt;right) {        mergesort(arr, left, mid);        mergesort(arr, mid + 1, right);        merge(arr, left,mid, right);    }}</code></pre><h2 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h2><p>1 顺序扫描</p><p>鲁迅说过：看到排序数组要想到二分法！</p><p>2 通过二分查找找到数字k第一次出现的位置，即先比较k和中间值，再依次二分，如果中间值等于k并且中间值左边！=k，则是第一个k。<br>反之可以找到最后一次出现k的位置。然后相减即可。复杂度是logn</p><h2 id="和为s的两个整数，和为s的连续正数序列"><a href="#和为s的两个整数，和为s的连续正数序列" class="headerlink" title="和为s的两个整数，和为s的连续正数序列"></a>和为s的两个整数，和为s的连续正数序列</h2><p>1 和为s的两个整数，双指针遍历即可</p><p>2 和为s的连续正数序列。维护一个范围，start到end表示目前的数字序列。大于S则start++,小于S则start–</p><h2 id="n个色子的点数"><a href="#n个色子的点数" class="headerlink" title="n个色子的点数"></a>n个色子的点数</h2><p>求n个色子点数之和等于s的概率</p><p>1 递归实现</p><p>2 循环实现，所有可能值存成一个数组，大小为6n，然后把每个出现数字次数存入数组，遍历一遍即可得到概率。</p><h2 id="扑克牌的顺子"><a href="#扑克牌的顺子" class="headerlink" title="扑克牌的顺子"></a>扑克牌的顺子</h2><p>题目描述<br>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。</p><p>把扑克牌存到数组中，并且A看作1,J为11,Q为12,K为13，然后进行排序，如果有不连续的数字，不存在顺子，如果都连续，则是顺子</p><pre><code>Arrays.sort(arr);       for (int i = 1 ;i &lt; arr.length;i ++) {           if (arr[i] == arr[i - 1]) {               return false;           }           if (arr[i] - arr[i - 1] == 1) {               continue;           }else if (arr[i] - arr[i - 1]  - 1 &lt;= cnt) {               cnt -= arr[i] - arr[i - 1] - 1;           }else {               return false;           }       }       return true;   }</code></pre><h2 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><h2 id="数组中重复的数字-1"><a href="#数组中重复的数字-1" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><p>解析：一般使用hashmap即可达到O（n)</p><p>但剑指offer的解法可以只用O(1)的空间做到。</p><p>实际上当每个数字a和他们所在的位置n相同时，每个数字只出现一次，但如果n + 1的位置上的数也是a，那么a就是第一个重复出现的数字。</p><p>根据这个思路。我们在循环中当第i个数a与arr[a]相等时，不变，如果不相等，则两者互换，然后开始下一轮遍历。接下来继续交换，如果出现相等的情况，则就是第一个重复出现的数。</p><p>举例 2 3 1 0 2 5 3<br>1 arr[0] = 2 != 0,所以arr[0]与arr[2]做交换，得1 3 2 0 2 5 3<br>2 arr[0] = 1 != 0，所以arr[0]和arr[1]交换，的3 1 2 0 2 5 3<br>3 arr[0] = 3 != 0,所以arr[0]和arr[3]交换，得0 1 2 3 2 5 3<br>4 arr[0]到arr[3]都符合要求,arr[4] = 2 != 4，所以arr[4]和arr[2]交换，发现两者相等，所以他就是第一个重复的数。</p><pre><code>public boolean duplicate(int array[],int length,int [] duplication) {    if ( array==null ) return false;    // key step    for( int i=0; i&lt;length; i++ ){        while( i!=array[i] ){            if ( array[i] == array[array[i]] ) {                duplication[0] = array[i];                return true;            }            int temp = array[i];            array[i] = array[array[i]];            array[array[i]] = temp;        }    }    return false;}</code></pre><p>从上述例子可以看到，一个数最多被交换两次。所以复杂度为O（N)</p><h2 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h2><p>题目描述<br>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。</p><p>不能用除法，那么就两个循环，一个从0乘到i - 1，一个从i + 1乘到n-1</p><h2 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a>数据流的中位数</h2><p>题目描述<br>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>解析，与字符流第一个不重复的字符类似，每次添加数字都要输出一次结果。</p><pre><code>public class Solution {    static ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();    public static void Insert(Integer num) {        list.add(num);        Collections.sort(list);    }    public static Double GetMedian() {        if (list.size() % 2 == 0) {            int l = list.get(list.size()/2);            int r = list.get(list.size()/2 - 1);            return (l + r)/2.0;        }        else {            return list.get(list.size()/2)/1.0;        }    }}</code></pre><h2 id="滑动窗口中的最大值"><a href="#滑动窗口中的最大值" class="headerlink" title="滑动窗口中的最大值"></a>滑动窗口中的最大值</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><p>解析：<br>1 保持窗口为3进行右移，每次计算出一个最大值即可。</p><p>2 使用两个栈实现一个队列，复杂度O（N）,使用两个栈实现最大值栈，复杂度O（1）。两者结合可以完成本题。但是太麻烦了。</p><p>3 使用双端队列解决该问题。</p><pre><code>import java.util.*;/**用一个双端队列，队列第一个位置（队头）保存当前窗口的最大值，当窗口滑动一次1.判断当前最大值是否过期（如果最大值所在的下标已经不在窗口范围内，则过期）2.对于一个新加入的值，首先一定要先放入队列，即使他比队头元素小，因为队头元素可能过期。3.新增加的值从队尾开始比较，把所有比他小的值丢掉(因为队列只存最大值，所以之前比他小的可以丢掉)*/public class Solution {   public ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size)    {        ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();        if(size == 0) return res;        int begin;         ArrayDeque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();        for(int i = 0; i &lt; num.length; i++){            begin = i - size + 1;            if(q.isEmpty())                q.add(i);            else if(begin &gt; q.peekFirst())                q.pollFirst();            while((!q.isEmpty()) &amp;&amp; num[q.peekLast()] &lt;= num[i])                q.pollLast();            q.add(i);              if(begin &gt;= 0)                res.add(num[q.peekFirst()]);        }        return res;    }}</code></pre><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><pre><code>解析：这是一个全排列问题，也就是N个不同的数排成所有不同的序列，只不过把数换成了字符串。全排列的过程就是，第一个元素与后续的某个元素交换，然后第二个元素也这么做，直到最后一个元素为之，过程是一个递归的过程，也是一个dfs的过程。注意元素也要和自己做一次交换，要不然会漏掉自己作为头部的情况。然后再进行一次字典序的排序即可。public static ArrayList&lt;String&gt; Permutation(String str) {        char []arr = str.toCharArray();        List&lt;char []&gt; list = new ArrayList&lt;&gt;();        all(arr, 0, arr.length - 1, list);        Collections.sort(list, (o1, o2) -&gt; String.valueOf(o1).compareTo(String.valueOf(o2)));        ArrayList&lt;String&gt; res = new ArrayList&lt;&gt;();        for (char[] c : list) {            if (!res.contains(String.valueOf(c)))            res.add(String.valueOf(c));        }        return res;    }    //注意要换完为之，因为每换一次可以去掉头部一个数字，这样可以避免重复    public static void all(char []arr, int cur, int end, List&lt;char[]&gt; list) {        if (cur == end) {//            System.out.println(Arrays.toString(arr));            list.add(Arrays.copyOf(arr, arr.length));        }        for (int i = cur;i &lt;= end;i ++) {            //这里的交换包括跟自己换，所以只有一轮换完才能确定一个结果            swap(arr, cur, i);            all(arr, cur + 1, end, list);            swap(arr, cur, i);        }    }    public static void swap(char []arr, int i, int j) {        if (i &gt; arr.length || j &gt; arr.length || i &gt;= j)return;        char temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    }</code></pre><h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><pre><code>/** * Created by 周杰伦 on 2018/2/25. * 请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 */ 解析：如果单纯地按顺序替换空格，每次替换完还要将数组扩容，再右移，这部操作的时间复杂度就是O（2*N）=O（N)，所以总的复杂度是O（n^2)，所以应该采取先扩容的办法，统计出空格数，然后扩容，接下来按顺序添加字符，遇到空格直接改成添加%20即可，这样避免了右移操作和多次扩容，复杂度是O（N)public class 替换空格 {    public static String replaceSpace(StringBuffer str) {        int newlen = 0;        for(int i = 0; i &lt; str.length(); i++) {            if(str.charAt(i) == &apos; &apos;) {                newlen = newlen + 3;            }            else {                newlen ++;            }        }        char []newstr = new char[newlen];        int j = 0;        for(int i = 0 ; i &lt; str.length(); i++) {            if (str.charAt(i) == &apos; &apos;) {                newstr[j++] = &apos;%&apos;;                newstr[j++] = &apos;2&apos;;                newstr[j++] = &apos;0&apos;;            }else {                newstr[j++] = str.charAt(i);            }        }        return String.valueOf(newstr);    }</code></pre><h2 id="第一次只出现一次的字符"><a href="#第一次只出现一次的字符" class="headerlink" title="第一次只出现一次的字符"></a>第一次只出现一次的字符</h2><p>哈希表可解</p><h2 id="翻转单词顺序和左旋转字符串"><a href="#翻转单词顺序和左旋转字符串" class="headerlink" title="翻转单词顺序和左旋转字符串"></a>翻转单词顺序和左旋转字符串</h2><p>1<br>题目描述<br>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p><pre><code>这个解法很经典，先把每个单词逆序，再把整个字符串逆序，结果就是把每个单词都进行了翻转。</code></pre><p>2<br>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p><pre><code>字符串循环左移N位的处理方法也很经典，先把前N位逆序，再把剩余字符串逆序，最后整体逆序。abcXYZdef -&gt; cbafedZYX -&gt; XYZdefabc</code></pre><h2 id="把字符串转换为整数"><a href="#把字符串转换为整数" class="headerlink" title="把字符串转换为整数"></a>把字符串转换为整数</h2><p>题目描述<br>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</p><p>解析：首先需要判断正负号，然后判断每一位是否是数字，然后判断是否溢出，判断溢出可以通过加完第n位的和与未加第n位的和进行比较。最后可以得出结果。所以需要3-4步判断。</p><h2 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p><pre><code>不得不说这种题型太恶心了，就是需要一直判断边界条件参考一个答案。比较完整    bool isNumeric(char* str) {        // 标记符号、小数点、e是否出现过        bool sign = false, decimal = false, hasE = false;        for (int i = 0; i &lt; strlen(str); i++) {            if (str[i] == &apos;e&apos; || str[i] == &apos;E&apos;) {                if (i == strlen(str)-1) return false; // e后面一定要接数字                if (hasE) return false;  // 不能同时存在两个e                hasE = true;            } else if (str[i] == &apos;+&apos; || str[i] == &apos;-&apos;) {                // 第二次出现+-符号，则必须紧接在e之后                if (sign &amp;&amp; str[i-1] != &apos;e&apos; &amp;&amp; str[i-1] != &apos;E&apos;) return false;                // 第一次出现+-符号，且不是在字符串开头，则也必须紧接在e之后                if (!sign &amp;&amp; i &gt; 0 &amp;&amp; str[i-1] != &apos;e&apos; &amp;&amp; str[i-1] != &apos;E&apos;) return false;                sign = true;            } else if (str[i] == &apos;.&apos;) {              // e后面不能接小数点，小数点不能出现两次                if (hasE || decimal) return false;                decimal = true;            } else if (str[i] &lt; &apos;0&apos; || str[i] &gt; &apos;9&apos;) // 不合法字符                return false;        }        return true;    }</code></pre><h2 id="字符流中第一个不重复的字符"><a href="#字符流中第一个不重复的字符" class="headerlink" title="字符流中第一个不重复的字符"></a>字符流中第一个不重复的字符</h2><p>题目描述<br>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p><p>本题主要要注意的是流。也就是说每次输入一个字符就要做一次判断。比如输入aaaabbbcd，输出就是a###b##cd</p><pre><code>StringBuilder sb = new StringBuilder();    int []map = new int[256];    public  void Insert(char ch)    {        sb.append(ch);        if (map[ch] == 0) {            map[ch] = 1;        }else {            map[ch] ++;        }        System.out.println(FirstAppearingOnce());    }    //return the first appearence once char in current stringstream    public char FirstAppearingOnce()    {        for (int i = 0;i &lt; sb.length();i ++) {            if (map[sb.charAt(i)] == 1) {                return sb.charAt(i);            }        }        return &apos;#&apos;;    }</code></pre><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><p>考查递归，递归可以使输出的顺序倒置</p><pre><code>public static void printReverse(Node node) {        if (node.next != null) {            printReverse(node.next);        }        System.out.print(node.val + &quot; &quot;);}</code></pre><h2 id="链表倒数第k个节点"><a href="#链表倒数第k个节点" class="headerlink" title="链表倒数第k个节点"></a>链表倒数第k个节点</h2><p>使用两个指针，一个先走k步。然后一起走即可。</p><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>老生常谈，但是容易写错。</p><pre><code>public ListNode ReverseList(ListNode head) {        if(head==null || head.next==null)return head;        ListNode pre,next;        pre=null;        next=null;        while(head!=null){            //保存下一个结点            next=head.next;            //连接下一个结点            head.next=pre;            pre=head;            head=next;        }        return pre;    }}</code></pre><h2 id="合并两个排序链表"><a href="#合并两个排序链表" class="headerlink" title="合并两个排序链表"></a>合并两个排序链表</h2><p>与归并排序的合并类似</p><h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h2><p>题目描述<br>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><p>这题比较恶心。</p><p>解析：</p><p>1 直接复制链表，然后再去复制特殊指针，复杂度是O(n2)</p><p>2 使用hash表保存特殊指针的映射关系，第二步简化操作，复杂度是O（n）</p><p>3 复制每个节点并且连成一个大链表A-A’-B-B’，然后从头到尾判断特殊指针，如果有特殊指针，则让后续节点的特殊指针指向原节点特殊指针指向的节点的后置节点，晕了吧，其实就是原来是A指向B，现在是A’指向B‘。</p><p>最后我们根据奇偶序号把链表拆开，复杂度是O（N)且不用额外空间。</p><h2 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h2><p>1 逆置链表，反向找第一个不同节点，前一个就是公共节点</p><p>2 求长度并相减得n，短的链表先走n步，然后一起走即可。</p><h2 id="孩子们的游戏-圆圈中最后剩下的数"><a href="#孩子们的游戏-圆圈中最后剩下的数" class="headerlink" title="孩子们的游戏(圆圈中最后剩下的数)"></a>孩子们的游戏(圆圈中最后剩下的数)</h2><p>这是一个约瑟夫环问题。</p><p>1 使用循环链表求解，每次走n步摘取一个节点，然后继续，直到最后一个节点就是剩下的数，空间复杂度为O（n)</p><p>2 使用数组来做<br>public static int LastRemaining_Solution(int n, int m) {<br>        int []arr = new int[n];<br>        for (int i = 0;i &lt; n;i ++) {<br>            arr[i] = i;<br>        }</p><pre><code>    int cnt = 0;    int sum = 0;    for (int i = 0;i &lt; n;i = (i + 1) % n) {        if (arr[i] == -1) {            continue;        }        cnt ++;        if (cnt == m) {            arr[i] = -1;            cnt = 0;            sum ++;        }        if (sum == n) {            return i;        }    }    return n - 1;}</code></pre><p>3 使用余数法求解</p><pre><code>int LastRemaining_Solution(int n, int m) {        if (m == 0 || n == 0) {            return -1;        }        ArrayList&lt;Integer&gt; data = new ArrayList&lt;Integer&gt;();        for (int i = 0; i &lt; n; i++) {            data.add(i);        }        int index = -1;        while (data.size() &gt; 1) {//          System.out.println(data);            index = (index + m) % data.size();//          System.out.println(data.get(index));            data.remove(index);            index--;        }        return data.get(0);    }</code></pre><h2 id="链表的环的入口结点"><a href="#链表的环的入口结点" class="headerlink" title="链表的环的入口结点"></a>链表的环的入口结点</h2><p>一个链表中包含环，请找出该链表的环的入口结点。</p><p>解析：</p><p>1 指定两个指针，一个一次走两步，一个一次走一步，然后当两个节点相遇时，这个节点必定在环中。既然这个节点在环中，那么让这个节点走一圈直到与自己相等为之，可以得到环的长度n。</p><p>2 得到了环的长度以后，根据数学推导的结果，我们可以指定两个指针，一个先走n步，然后两者同时走，这样的话，当慢节点到达入口节点时，快节点也转了一圈刚好又到达入口节点，所以也就是他们相等的时候就是入口节点了。</p><h2 id="删除链表中重复的节点"><a href="#删除链表中重复的节点" class="headerlink" title="删除链表中重复的节点"></a>删除链表中重复的节点</h2><p>题目描述<br>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><p>保留头结点，然后找到下一个不重复的节点，与他相连，重复的节点直接跳过即可。</p><p>#二叉树</p><h2 id="二叉搜索树转换为双向链表"><a href="#二叉搜索树转换为双向链表" class="headerlink" title="二叉搜索树转换为双向链表"></a>二叉搜索树转换为双向链表</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><p>二叉搜索树要转换成有序的双向链表，实际上就是使用中序遍历把节点连入链表中，并且题目要求在原来节点上进行操作，也就是使用左指针和右指针表示链表的前置节点和后置节点。</p><p>使用栈实现中序遍历的非递归算法，便可以找出节点的先后关系，依次连接即可。</p><pre><code>public TreeNode Convert(TreeNode root) {        if(root==null)            return null;        Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();        TreeNode p = root;        TreeNode pre = null;// 用于保存中序遍历序列的上一节点        boolean isFirst = true;        while(p!=null||!stack.isEmpty()){            while(p!=null){                stack.push(p);                p = p.left;            }            p = stack.pop();            if(isFirst){                root = p;// 将中序遍历序列中的第一个节点记为root                pre = root;                isFirst = false;            }else{                pre.right = p;                p.left = pre;                pre = p;            }                  p = p.right;        }        return root;    }}</code></pre><h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><pre><code>     * 题目描述 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 */ 解析：首先，头结点一定是先序遍历的首位，并且该节点把中序分为左右子树，根据这个规则，左子树由左边数组来完成，右子树由右边数组来完成，根节点由中间节点来构建，于是便有了如下的递归代码。该题的难点就在于边界的判断。public TreeNode reConstructBinaryTree(int [] pre, int [] in) {    if(pre.length == 0||in.length == 0){        return null;    }    TreeNode node = new TreeNode(pre[0]);    for(int i = 0; i &lt; in.length; i++){        if(pre[0] == in[i]){            node.left = reConstructBinaryTree(Arrays.copyOfRange(pre, 1, i+1), Arrays.copyOfRange(in, 0, i));//为什么不是i和i-1呢，因为要避免出错，中序找的元素需要再用一次。            node.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i+1, pre.length), Arrays.copyOfRange(in, i+1,in.length));        }    }    return node;}</code></pre><h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><pre><code>/** * Created by 周杰伦 on 2018/3/27. * 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） */    解析：本题还是有点难度的，子结构要求节点完全相同，所以先判断节点是否相同，然后使用先序遍历进行递判断，判断的依据是如果子树为空，则说明节点都找到了，如果原树节点为空，说明找不到对应节点,接着递归地判断该节点的左右子树是否符合要求.    public class 树的子结构 {        public boolean HasSubtree(TreeNode root1, TreeNode root2) {            boolean res = false;            if (root1 != null &amp;&amp; root2 != null) {                if (root1.val == root2.val) {                    res = aHasb(root1, root2);                }                if (res == false) {                    res = HasSubtree(root1.left,root2);                }                if (res == false) {                    res = HasSubtree(root1.right,root2);                }                return res;            }            else return false;        }        public boolean aHasb(TreeNode t1, TreeNode t2){            if (t2 == null) return true;            if (t1 == null) return false;            if (t1.val != t2.val) return false;            return aHasb(t1.left,t2.left) &amp;&amp; aHasb(t1.right,t2.right);        }    }</code></pre><h2 id="镜像二叉树"><a href="#镜像二叉树" class="headerlink" title="镜像二叉树"></a>镜像二叉树</h2><pre><code>/** * Created by 周杰伦 on 2017/3/19.操作给定的二叉树，将其变换为源二叉树的镜像。 输入描述: 二叉树的镜像定义：源二叉树  8 /  \ 6   10 / \  / \ 5  7 9 11 镜像二叉树   8 /  \ 10   6 / \  / \ 11 9 7  5 */解析：其实镜像二叉树就是交换所有节点的左右子树，所以使用遍历并且进行交换即可。/** public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */public class 镜像二叉树 {    public void Mirror(TreeNode root) {        if(root == null)return;        if(root.left!=null || root.right!=null)        {            TreeNode temp=root.left;            root.left=root.right;            root.right=temp;        }        Mirror(root.left);        Mirror(root.right);    }</code></pre><h2 id="树的层次遍历"><a href="#树的层次遍历" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h2><p>也就是从上到下打印节点，使用队列即可完成。</p><h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><p>经典遍历。</p><h2 id="判断是否平衡二叉树"><a href="#判断是否平衡二叉树" class="headerlink" title="判断是否平衡二叉树"></a>判断是否平衡二叉树</h2><p>判断左右子树的高度差是否 &lt;= 1即可。</p><h2 id="二叉搜索树的后序遍历"><a href="#二叉搜索树的后序遍历" class="headerlink" title="二叉搜索树的后序遍历"></a>二叉搜索树的后序遍历</h2><p>题目描述<br>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><p>解析：这题其实也非常巧妙。二叉搜索树的特点就是他的左子树都比根节点小，右子树都比跟节点大。而后序遍历的根节点在最后，所以后续遍历的第1到N-1个节点应该是左右子树的节点（不一定左右子树都存在）。</p><p>后续遍历的序列是先左子树，再右子树，最后根节点，那么就要求，左半部分比根节点小，右半部分比根节点大，当然，左右部分不一定都存在。</p><p>所以，找出根节点后，首先找出左半部分，要求小于根节点，然后找出右半部分，要求大于根节点，如果符合，则递归地判断左右子树到的根节点（本步骤已经将左右部分划分，割据中间节点进行递归），如果不符合，直接返回false。</p><p>同理也可以判断前序遍历和中序遍历。</p><pre><code>public class 二叉搜索树的后序遍历序列 {    public static void main(String[] args) {        int []a = {7,4,6,5};        System.out.println(VerifySquenceOfBST(a));    }    public static boolean VerifySquenceOfBST(int [] sequence) {        if (sequence == null || sequence.length == 0) {            return false;        }        return isBST(sequence, 0, sequence.length - 1);    }    public static boolean isBST(int []arr, int start, int end) {        if (start &gt;= end) return true;        int root = arr[end];        int mid = start;        for (mid  = start;mid &lt; end &amp;&amp; arr[mid] &lt; root;mid ++) {        }        for (int i = mid;i &lt; end; i ++) {            if (arr[i] &lt; root)return false;        }        return isBST(arr, start, mid - 1) &amp;&amp; isBST(arr, mid, end - 1);    }}</code></pre><h2 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h2><p>/**</p><ul><li>Created by 周杰伦 on 2018/3/29.</li><li><p>题目描述<br>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。<br>*/</p><p> 解析：由于要求从根节点到达叶子节点，并且要打印出所有路径，所以实际上用到了回溯的思想。</p><p> 通过target跟踪当前和，进行先序遍历，当和满足要求时，加入集合，由于有多种结果，所以需要回溯，将访问过的节点弹出访问序列，才能继续访问下一个节点。</p><p> 终止条件是和满足要求，并且节点是叶节点，或者已经访问到空节点也会返回。</p></li></ul><pre><code>public class 二叉树中和为某一值的路径 {    private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();    private ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();    public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) {        if(root == null) return listAll;        list.add(root.val);        target -= root.val;        if(target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null)            listAll.add(new ArrayList&lt;Integer&gt;(list));        FindPath(root.left, target);        FindPath(root.right, target);        list.remove(list.size()-1);        return listAll;    }    static int count = 0;    static Stack&lt;Integer&gt; path = new Stack&lt;&gt;();    static Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();    static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();}</code></pre><h2 id="二叉树的下一个节点"><a href="#二叉树的下一个节点" class="headerlink" title="二叉树的下一个节点"></a>二叉树的下一个节点</h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><pre><code>解析：给出一个比较好懂的解法，中序遍历的结果存在集合中，找到根节点，进行中序遍历，然后找到该节点，下一个节点就是集合后一位public TreeLinkNode GetNext(TreeLinkNode TreeLinkNode)    {        return findNextNode(TreeLinkNode);    }    public TreeLinkNode findNextNode(TreeLinkNode anynode) {        if (anynode == null) return null;        TreeLinkNode p = anynode;        while (p.next != null) {            p = p.next;        }        ArrayList&lt;TreeLinkNode&gt; list = inOrderSeq(p);        for (int i = 0;i &lt; list.size();i ++) {            if (list.get(i) == anynode) {                if (i + 1 &lt; list.size()) {                    return list.get(i + 1);                }                else return null;            }        }        return null;    }    static ArrayList&lt;TreeLinkNode&gt; list = new ArrayList&lt;&gt;();    public static ArrayList&lt;TreeLinkNode&gt; inOrderSeq(TreeLinkNode TreeLinkNode) {        if (TreeLinkNode == null) return null;        inOrderSeq(TreeLinkNode.left);        list.add(TreeLinkNode);        inOrderSeq(TreeLinkNode.right);        return list;    }</code></pre><h2 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h2><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><p>解析，之前有一题是二叉树的镜像，递归交换左右子树即可求出镜像，然后递归比较两个树的每一个节点，则可以判断是否对称。</p><pre><code>boolean isSymmetrical(TreeNode pRoot)    {        TreeNode temp = copyTree(pRoot);        Mirror(pRoot);        return isSameTree(temp, pRoot);    }    void Mirror(TreeNode root) {        if(root == null)return;        Mirror(root.left);        Mirror(root.right);        if(root.left!=null || root.right!=null)        {            TreeNode temp=root.left;            root.left=root.right;            root.right=temp;        }    }    boolean isSameTree(TreeNode t1,TreeNode t2){        if(t1==null &amp;&amp; t2==null)return true;        else if(t1!=null &amp;&amp; t2!=null &amp;&amp; t1.val==t2.val) {            boolean left = isSameTree(t1.left, t2.left);            boolean right = isSameTree(t1.right, t2.right);            return left &amp;&amp; right;        }        else return false;    }    TreeNode copyTree (TreeNode root) {        if (root == null) return null;        TreeNode t = new TreeNode(root.val);        t.left = copyTree(root.left);        t.right = copyTree(root.right);        return t;    }</code></pre><h2 id="把二叉树打印成多行"><a href="#把二叉树打印成多行" class="headerlink" title="把二叉树打印成多行"></a>把二叉树打印成多行</h2><p>题目描述<br>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p><p>解析：1 首先要知道到本题的基础思想，层次遍历。</p><p>2 然后是进阶的思想，按行打印二叉树并输出行号，方法是，一个节点last指向当前行的最后一个节点，一个节点nlast指向下一行最后一个节点。使用t表示现在遍历的节点，当t = last时，表示本行结束。此时last = nlast，开始下一行遍历。</p><p>同时，当t的左右子树不为空时，令nlast = t的左子树和右子树。每当last 赋值为nlast时，行号加一即可。</p><h2 id="按之字形顺序打印二叉树"><a href="#按之字形顺序打印二叉树" class="headerlink" title="按之字形顺序打印二叉树"></a>按之字形顺序打印二叉树</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><p>解析：1 首先要知道到本题的基础思想，层次遍历。</p><p>2 然后是进阶的思想，按行打印二叉树并输出行号，方法是，一个节点last指向当前行的最后一个节点，一个节点nlast指向下一行最后一个节点。使用t表示现在遍历的节点，当t = last时，表示本行结束。此时last = nlast，开始下一行遍历。</p><p>同时，当t的左右子树不为空时，令nlast = t的左子树和右子树。每当last 赋值为nlast时，行号加一即可。</p><p>3 基于第2步的思想，现在要z字型打印，只需把偶数行逆序即可。所以把每一行的数存起来，然后偶数行逆置即可。</p><pre><code>ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) {        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        TreeNode root = pRoot;        if(root == null) {            return new ArrayList&lt;&gt;();        }        TreeNode last = root;        TreeNode nlast = root;        queue.offer(root);        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();        list.add(root.val);        ArrayList&lt;Integer&gt; one = new ArrayList&lt;&gt;();        one.addAll(list);        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();        lists.add(one);        list.clear();        int row = 1;        while (!queue.isEmpty()){            TreeNode t = queue.poll();            if(t.left != null) {                queue.offer(t.left);                list.add(t.left.val);                nlast = t.left;            }            if(t.right != null) {                queue.offer(t.right);                list.add(t.right.val);                nlast = t.right;            }            if(t == last) {                if(!queue.isEmpty()) {                    last = nlast;                    row ++;                    ArrayList&lt;Integer&gt; temp = new ArrayList&lt;&gt;();                    temp.addAll(list);                    list.clear();                    if (row % 2 == 0) {                        Collections.reverse(temp);                    }                    lists.add(temp);                }            }        }        return lists;    }</code></pre><h2 id="序列化和反序列化二叉树"><a href="#序列化和反序列化二叉树" class="headerlink" title="序列化和反序列化二叉树"></a>序列化和反序列化二叉树</h2><p>解析：序列化和反序列化关键是要确定序列化方式。我么使用字符串来序列化。</p><p>用#代表空，用!分隔左右子树。</p><p>比如 1<br>    2 3<br>   4   5</p><p>使用先序遍历<br>序列化结果是1!2!4!###3!#5!##</p><p>反序列化先让根节点指向第一位字符，然后左子树递归进行连接，右子树</p><pre><code>public class Solution {public int index = -1;StringBuffer sb = new StringBuffer();String Serialize(TreeNode root) {       if(root == null) {        sb.append(&quot;#!&quot;) ;    }    else {        sb.append(root.val + &quot;!&quot;);        Serialize(root.left);        Serialize(root.right);    }    return sb.toString();  }    TreeNode Deserialize(String str) {        index ++;        int len = str.length();        if(index &gt;= len) {            return null;        }        String[] strr = str.split(&quot;!&quot;);        TreeNode node = null;        if(!strr[index].equals(&quot;#&quot;)) {            node = new TreeNode(Integer.valueOf(strr[index]));            node.left = Deserialize(str);            node.right = Deserialize(str);        }        return node;  }}</code></pre><h2 id="二叉搜索树的第k个结点"><a href="#二叉搜索树的第k个结点" class="headerlink" title="二叉搜索树的第k个结点"></a>二叉搜索树的第k个结点</h2><pre><code>解析：二叉搜索树的中序遍历是有序的，只需要在中序中判断数字是否在第k个位置即可。如果在左子树中发现了，那么递归返回该节点，如果在右子树出现，也递归返回该节点。注意必须要返回，否则结果会被递归抛弃掉。TreeNode KthNode(TreeNode pRoot, int k)    {        count = 0;        return inOrderSeq(pRoot, k);    }    static int count = 0;    public TreeNode inOrderSeq(TreeNode treeNode, int k) {        if (treeNode == null) return null;        TreeNode left = inOrderSeq(treeNode.left, k);        if (left != null) return left;        if (++ count == k) return treeNode;        TreeNode right = inOrderSeq(treeNode.right, k);        if (right != null) return right;        return null;    }</code></pre><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="用两个队列实现栈，用两个栈实现队列。"><a href="#用两个队列实现栈，用两个栈实现队列。" class="headerlink" title="用两个队列实现栈，用两个栈实现队列。"></a>用两个队列实现栈，用两个栈实现队列。</h2><p>简单说下思路</p><p>1 两个栈实现队列，要求先进先出，入队时节点先进入栈A，如果栈A满并且栈B空则把全部节点压入栈B。</p><p>出队时，如果栈B为空，那么直接把栈A节点全部压入栈B，再从栈B出栈，如果栈B不为空，则从栈B出栈。</p><p>2 两个队列实现栈，要求后进先出。入栈时，节点先加入队列A，出栈时，如果队列B不为空，则把头结点以后的节点出队并加入到队列B，然后自己出队。</p><p>如果出栈时队列B不为空，则把B头结点以后的节点移到队列A，然后出队头结点，以此类推。</p><h2 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h2><p>/**</p><ul><li>设计一个返回最小值的栈</li><li>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</li><li><p>Created by 周杰伦 on 2017/3/22.<br>*/</p><p> 解析：这道题的解法也是非常巧妙的。因为每次进栈和出栈都有可能导致最小值发生改变。而我们要维护的是整个栈的最小值。</p><p> 如果单纯使用一个数来保存最小值，会出现一种情况，最小值出栈时，你此时的最小值只能改成栈顶元素，但这个元素不一定时最小值。</p><p> 所以需要一个数组来存放最小值，或者是一个栈。</p><p> 使用另一个栈B存放最小值，每次压栈时比较节点值和栈B顶端节点值，如果比它小则压栈，否则不压栈，这样就可以从b的栈顶到栈顶依次访问最小值，次小值。以此类推。</p><p> 当最小值节点出栈时，判断栈B顶部的节点和出栈节点是否相同，相同则栈B也出栈。</p><p> 这样就可以维护一个最小值的函数了。</p><p> 同理，最大值也是这样。</p></li></ul><pre><code>public class 包含min函数的栈 {    Stack&lt;Integer&gt; stack=new Stack&lt;&gt;();    Stack&lt;Integer&gt; minstack=new Stack&lt;&gt;();    public void push(int node) {        if(stack.isEmpty())        {            stack.push(node);            minstack.push(node);        }        else if(node&lt;stack.peek()){            stack.push(node);            minstack.push(node);        }        else {            stack.push(node);        }    }    public void pop() {        if(stack.isEmpty())return;        if(stack.peek()==minstack.peek()){           stack.pop();           minstack.pop();        }        else {            stack.pop();        }    }    public int top() {      return stack.peek();    }    public int min() {        if(minstack.isEmpty())return 0;     return minstack.peek();    }}</code></pre><h2 id="栈的压入和弹出序列"><a href="#栈的压入和弹出序列" class="headerlink" title="栈的压入和弹出序列"></a>栈的压入和弹出序列</h2><pre><code>    题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）解析：本题是比较抽象的，首先，根据入栈出栈的规则，我们可以建立一个栈A，用于保存压栈序列，然后压入第一个元素，比较出栈序列的第一个元素，如果不相等，继续压栈，直到二者相等，此时栈A元素出栈，然后重复上一步的操作。如果在每次压栈过程中，入栈序列已经全部入栈A但是还是找不到出栈序列的第一个元素时，则说明不是出栈序列。当栈A的元素全部压入并出栈后，如果出栈序列也出栈完毕，则满足题意。public static boolean IsPopOrder(int[] pushA, int[] popA) {        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();        int j = 0;        int i = 0;        while (i &lt; pushA.length) {            stack.push(pushA[i]);            i++;            while (!stack.empty() &amp;&amp; stack.peek() == popA[j]) {                stack.pop();                j++;            }            if (i == pushA.length) {                if (!stack.empty()) {                    return false;                } else return true;            }        }        return false;    }</code></pre><h1 id="排序和查找"><a href="#排序和查找" class="headerlink" title="排序和查找"></a>排序和查找</h1><h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h2><pre><code>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。解析：这题的思路很巧妙，如果直接遍历复杂度为O（N），但是使用二分查找可以加快速度，因为两边的数组都是递增的最小值一定在两边数组的边缘，于是通过二分查找，逐渐缩短左右指针的距离，知道左指针和右指针只差一步，那么右指针所在的数就是最小值了。复杂度是O（logN)//这段代码忽略了三者相等的情况public int minNumberInRotateArray(int [] array) {        if (array.length == 0) return 0;        if (array.length == 1) return array[0];        int min = 0;        int left = 0, right = array.length - 1;        //只有左边值大于右边值时，最小值才可能出现在中间        while (array[left] &gt; array[right]) {            int mid = (left + right)/2;            if (right - left == 1) {                min = array[right];                break;            }            //如果左半部分递增，则最小值在右侧            if (array[left] &lt; array[mid]) {                left = mid;            }            //如果右半部分递增，则最小值在左侧。            //由于左边值比右边值大，所以两种情况不会同时发生            else if (array[right] &gt; array[mid]) {                right = mid ;            }        }        return array[min];    }    注意：但是当arr[left] = arr[right] = arr[min]时。三个数都相等无法确定最小值，此时只能遍历。</code></pre><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>1递归做法</p><p>2记忆搜索，用数组存放使用过的元素。</p><p>3DP，本题中dp就是记忆化搜索</p><h2 id="青蛙跳台阶"><a href="#青蛙跳台阶" class="headerlink" title="青蛙跳台阶"></a>青蛙跳台阶</h2><p>一次跳两步或者跳一步，问一共多少种跳法到达n级，所以和斐波那契数列是一样的。</p><h2 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h2><p>一次跳1到n步，问一共几种跳法，这题是找数字规律的，一共有2^(n-1)种方法</p><h2 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h2><p>和上题一样，也是找规律，答案也是2^(n-1)</p><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h2><ul><li>Created by 周杰伦 on 2018/6/29.</li><li>题目描述</li><li><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><p> 解析:<br> 1 循环右移数字n，每次判断最低位是否为1，但是可能会导致死循环。</p><p> 2 使用数字a = 1和n相与，a每次左移一位，再与n相与得到次低位，最多循环32次，当数字1左移32次也会等于0，所以结束循环。</p><p> 3 非常奇葩的做法，把一个整数减去1，再与原整数相与，会把最右边的一个1变成0，于是统计可以完成该操作的次数即可知道有多少1了。</p><pre><code>public class 二进制中1的个数 {    public static int NumberOf1(int n) {        int count = 0;        while (n != 0) {            ++count;            n = (n - 1) &amp; n;        }        return count;    }}</code></pre></li></ul><h2 id="数组中只出现一次的数字"><a href="#数组中只出现一次的数字" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h2><p>题目描述<br>一个整型数组里除了一个数字之外，其他的数字都出现了两次。请写程序找出这一个只出现一次的数字。</p><p>解析：左神称之为神仙题。</p><p>利用位运算的异或操作^。<br>由于a^a = 0,0^b=b，所以。所有数执行异或操作，结果就是只出现一次的数。</p><h2 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h2><p>解析：不用加减乘，那么只能用二进制了。</p><p>两个数a和b，如果不考虑进位，则0 + 1 = 1,1 + 1 = 0，0 + 0 = 0，这就相当于异或操作。<br>如果考虑进位，则只有1 + 1有进位，所以使用相与左移的方法得到每一位的进位值，再通过异或操作和原来的数相加。当没有进位值的时候，运算结束。<br>    public static int Add(int num1,int num2) {<br>        if( num2 == 0 )return num1;<br>        if( num1 == 0 )return num2;</p><pre><code>    int temp = num2;    while(num2!=0) {        temp = num1 ^num2;        num2 = (num1 &amp; num2)&lt;&lt;1;        num1 = temp;    }    return num1;}</code></pre><h1 id="回溯和DFS"><a href="#回溯和DFS" class="headerlink" title="回溯和DFS"></a>回溯和DFS</h1><h2 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h2><p>题目描述<br>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p><p>解析：回溯法也就是特殊的dfs，需要找到所有的路径，所以每当到达边界条件或抵达目标时，递归返回，由于需要保存路径中的字母，所以递归返回时需要删除路径最后的节点，来保证路径合法。不过本题只有一个解，所以找到即可返回。</p><pre><code>public class 矩阵中的路径 {    public static void main(String[] args) {        char[][]arr = {{'a','b','c','e'},{'s','f','c','s'},{'a','d','e','e'}};        char []str = {&apos;b&apos;,&apos;c&apos;,&apos;c&apos;,&apos;e&apos;,&apos;d&apos;};        System.out.println(hasPath(arr, arr.length, arr[0].length, str));    }    static int flag = 0;    public static boolean hasPath(char[][] matrix, int rows, int cols, char[] str)    {        int [][]visit = new int[rows][cols];        StringBuilder sb = new StringBuilder();        for (int i = 0;i &lt; rows;i ++) {            for (int j = 0;j &lt; cols;j ++) {                if (matrix[i][j] == str[0]) {                    visit[i][j] = 1;                    sb.append(str[0]);                    dfs(matrix, i, j, visit, str, 1, sb);                    visit[i][j] = 0;                    sb.deleteCharAt(sb.length() - 1);                }            }        }        return flag == 1;    }    public static void dfs(char [][]matrix, int row, int col, int [][]visit, char []str, int cur, StringBuilder sb) {        if (sb.length() == str.length) {//            System.out.println(sb.toString());            flag = 1;            return;        }        int [][]pos = {{1,0},{-1,0},{0,1},{0,-1}};        for (int i = 0;i &lt; pos.length;i ++) {            int x = row + pos[i][0];            int y = col + pos[i][1];            if (x &gt;= matrix.length || x &lt; 0 || y &gt;= matrix[0].length || y &lt; 0) {                continue;            }            if (visit[x][y] == 0 &amp;&amp; matrix[x][y] == str[cur]) {                sb.append(matrix[x][y]);                visit[x][y] = 1;                dfs(matrix, x, y, visit, str, cur + 1, sb);                sb.deleteCharAt(sb.length() - 1);                visit[x][y] = 0;            }        }    }</code></pre><h2 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h2><p>题目描述<br>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><p> 解析：这是一个可达性问题，使用dfs方法，走到的每一格标记为走过，走到无路可走时就是最终的结果。每次都有四个方向可以选择，所以写四个递归即可。</p><pre><code>public class Solution {    static int count = 0;    public static int movingCount(int threshold, int rows, int cols)    {        count = 0;        int [][]visit = new int[rows][cols];        dfs(0, 0, visit, threshold);        return count;    }    public static void dfs(int row, int col, int[][]visit, int k) {        if (row &gt;= visit.length || row &lt; 0 || col &gt;= visit[0].length || col &lt; 0) {            return;        }        if (sum(row) + sum(col) &gt; k) {            return;        }        if (visit[row][col] == 1){            return;        }        visit[row][col] = 1;        count ++;        dfs(row + 1,col,visit, k);        dfs(row - 1,col,visit, k);        dfs(row,col + 1,visit, k);        dfs(row,col - 1,visit, k);    }    public static int sum(int num) {        String s = String.valueOf(num);        int sum = 0;        for (int i = 0;i &lt; s.length();i ++) {            sum += Integer.valueOf(s.substring(i, i + 1));        }        return sum;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##节选剑指offer比较经典和巧妙的一些题目，以便复习使用。一部分题目给出了完整代码，一部分题目比较简单直接给出思路。但是不保证我说的思路都是正确的，个人对算法也不是特别在行，只不过这本书的算法多看了几遍多做了几遍多了点心得体会。于是想总结一下。如果有错误也希望能指出，谢
      
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="技术总结" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="算法" scheme="http://h2pl.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop生态学习总结</title>
    <link href="http://h2pl.github.io/2018/07/08/Hadoop%E7%94%9F%E6%80%81%E6%80%BB%E7%BB%93/"/>
    <id>http://h2pl.github.io/2018/07/08/Hadoop生态总结/</id>
    <published>2018-07-08T14:15:53.000Z</published>
    <updated>2018-07-09T00:25:18.287Z</updated>
    
    <content type="html"><![CDATA[<p>这篇总结主要是基于我之前Hadoop生态基础系列文章而形成的的。主要是把重要的知识点用自己的话说了一遍，可能会有一些错误，还望见谅和指点。谢谢</p><p>更多详细内容可以查看我的专栏文章：Hadoop生态学习</p><p><a href="https://blog.csdn.net/a724888/article/category/7779280" target="_blank" rel="noopener">https://blog.csdn.net/a724888/article/category/7779280</a><br><a id="more"></a></p><h1 id="Hadoop生态"><a href="#Hadoop生态" class="headerlink" title="Hadoop生态"></a>Hadoop生态</h1><h2 id="hdfs"><a href="#hdfs" class="headerlink" title="hdfs"></a>hdfs</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>hdfs是一个分布式文件系统。底层的存储采用廉价的磁盘阵列RAID，由于可以并发读写所以效率很高。</p><p>基本架构是一个namenode和多个dataNode。node的意思是节点，一般指主机，也可以是虚拟机。</p><p>每个文件都会有两个副本存放在datanode中。</p><h3 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h3><p>客户端写入文件时，先把请求发送到namenode，namenode会返回datanode的服务地址，接着客户端去访问datanode，进行文件写入，然后通知namenode，namenode接收到写入完成的消息以后，会另外选两个datanode存放冗余副本。</p><p>读取文件时，从namenode获取一个datanode的地址，然后自己去读取即可。</p><p>当一个文件的副本不足两份时，namenode自动会完成副本复制。并且，由于datanode一般会放在各个机架。namenode一般会把副本一个放在同一机架，一个放在其他机架，防止某个机架出问题导致整个文件读写不可用。</p><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>namenode节点是单点，所以宕机了就没救了，所以我们可以使用zookeeper来保证namenode的高可用。可以使用zookeeper选主来实现故障切换，namenode先注册一个节点在zk上，表示自己是主，宕机时zk会通知备份节点进行切换。</p><p>Hadoop2.0中加入了hdfs namenode高可用的方案，也叫HDFS HA。namenode和一个备份节点绑定在一起，并且通过一个共享数据区域进行数据同步。同时支持故障切换。</p><h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><h3 id="架构和流程"><a href="#架构和流程" class="headerlink" title="架构和流程"></a>架构和流程</h3><p>MapReduce是基于Hadoop集群的分布式计算方案。一般先编写map函数进行数据分片，然后通过shuffle进行相同分片的整合，最后通过reduce把所有的数据结果进行整理。</p><p>具体来说，用户提交一个MapReduce程序给namenode节点，namenode节点启动一个jobtracker进行子任务的调度和监控，然后派发每个子任务tasktracker到datanode进行任务执行，由于数据分布在各个节点，每个tasktracker只需要执行自己的那一部分即可。最后再将结果汇总给tasktracker。</p><h3 id="wordcount"><a href="#wordcount" class="headerlink" title="wordcount"></a>wordcount</h3><p>首先是一个文本文件:hi hello good hello hi hi。<br>三个节点，则进行三次map。hi hello，good hello，hi hi分别由三个节点处理。结果分别是hi 1 hello 1,good 1 hello 1,hi 1,hi 1。<br>shuffle时进行combine操作，得到hi 1,hello 1,good 1 hello 1,hi 2。最终reduce的结果是hi 3 hello 2 good 1.</p><h2 id="hive"><a href="#hive" class="headerlink" title="hive"></a>hive</h2><p>hive是一个基于hdfs文件系统的数据仓库。可以通过hive sql语句执行对hdfs上文件的数据查询。原理是hive把hdfs上的数据文件看成一张张数据表，把表结构信息存在关系数据库如mysql中。然后执行sql时通过对表结构的解析再去hdfs上查询真正的数据，最后也会以结构化的形式返回。</p><h2 id="hbase"><a href="#hbase" class="headerlink" title="hbase"></a>hbase</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>hbase是基于列的数据库。</p><p>他与传统关系数据库有很大不同。</p><p>首先在表结构上，hbase使用rowkey行键作为唯一主键，通过行键唯一确定一行数据。</p><p>同时，hbase使用列族的概念，每个表都有固定的列族，每一行的数据的列族都一样，但是每一行所在列族的实际列都可以不一样。<br>比如列族是info，列可以是name age，也可以是sex address等。也就是说具体列可以在插入数据时再进行确认。</p><p>并且，hbase的每一行数据还可以有多个版本，通过时间戳来表示不同的数据版本。</p><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>一般情况下hbase使用hdfs作为底层存储，所以hdfs提供了数据的可靠性以及并发读写的高效率。</p><p>hbase一个表的 每n行数据会存在一个region中，并且，对于列来说，每一个列族都会用一个region来存储，假设有m个列族，那么就会有n * m个region需要存储在hdfs上。</p><p>同时hbase使用regionserver来管理这些region，他们可能存在不同的datanode里，所以通过regionserver可以找出每一个region的位置。</p><p>hbase使用zookeeper来保证regionserver的高可用，会自动进行故障切换。</p><h2 id="zk"><a href="#zk" class="headerlink" title="zk"></a>zk</h2><p>zk在Hadoop的作用有几个，通过选主等机制保证主节点高可用。</p><p>使用zk进行配置资源的统一管理，保证服务器节点无状态，所有服务信息直接从zk获取即可。</p><p>使用zookeeper进行节点间的通信等，也可以使用zk的目录顺序节点实现分布式锁，以及服务器选主。不仅在Hadoop中，zk在分布式系统中总能有用武之地。</p><p>zookeeper本身的部署方式就是一个集群,一个master和多个slave。</p><p>使用zab协议保证一致性和高可用。</p><p>zab协议实现原理：</p><p>1 使用两段式提交的方式确保一个协议需要半数以上节点同意以后再进行广播执行。</p><p>2 使用基于机器编号加时间戳的id来表示每个事务，通过这个方式当初始选举或者主节点宕机时进行一轮选主，每个节点优先选择自己当主节点，在选举过程中节点优先采纳比较新的事务，将自己的选票更新，然后反馈个其他机器，最后当一个机器获得超过半数选票时当选为master。</p><p>3选主结束以后，主节点与slave进行主从同步，保证数据一致性，然后对外提供服务，并且写入只能通过master而读取可以通过任意一台机器。</p><h2 id="sqoop"><a href="#sqoop" class="headerlink" title="sqoop"></a>sqoop</h2><p>将hive表中的内容导入到MySQL数据库，也可以将MySQL中的数据导入hive中。</p><h2 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h2><p>没有yarn之前，hdfs使用jobtracker和tasktracker来执行和跟踪任务，jobtracker的任务太重，又要执行又要监控还要获取结果。<br>并且不同机器的资源情况没有被考虑在内。</p><p>yarn是一个资源调度系统。提供applicationmaster对一个调度任务进行封装，然后有一个resourcemanager专门负责各节点资源的管理和监控。同时nodemanager则运行每个节点中用于监控节点状态和向rm汇报。还有一个container则是对节点资源的一个抽象，applicationmaster任务将由节点上的一个container进行执行。rm会将他调度到最合适的机器上。</p><h2 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h2><p>架构</p><blockquote><p>kafka是一个分布式的消息队列。</p><p>它组成一般包括kafka broker，每个broker中有多个的partition作为存储消息的队列。</p><p>并且向上提供服务时抽象为一个topic，我们访问topic时实际上执行的是对partition的写入和读取操作。</p></blockquote><p>读写和高可用</p><blockquote><p>partition支持顺序写入，效率比较高，并且支持零拷贝机制，通过内存映射磁盘mmap的方式，写入partition的数据顺序写入到映射的磁盘中，比传统的IO要快。</p><p>由于partition可能会宕机，所以一般也要支持partition的备份，1个broker ，master通常会有多个<br>broker slave，是主从关系，通过zookeeper进行选主和故障切换。</p><p>当数据写入队列时，一般也会通过日志文件的方式进行数据备份，会把broker中的partition被分在各个slave中以便于均匀分布和恢复。</p></blockquote><p>生产者和消费者</p><blockquote><p>生产者消费者需要访问kafka的队列时，如果是写入，直接向zk发送请求，一般是向一个topic写入消息，broker会自动分配partition进行写入。然后zk会告诉生产者写入的partition所在的broker地址，然后进行写入。</p><p>如果是读取的话，也是通过zk获取partition所在位置，然后通过给定的offset进行读取，读取完后更新offset。</p><p>由于kafka的partition支持顺序读写。所以保证一个partition中的读取和写入时是顺序的，但是如果是多个partition则不保证顺序。</p><p>正常情况下kafka使用topic来实现消息点对点发送，并且每个consumer都要在一个consumer group中，而且comsumer group中每次只能有一个消费者能接受对应topic的消息。因为为了实现订阅也就是一对多发送，我们让每个consumer在一个单独的group，于是每个consumer都可以接受到该消息。</p></blockquote><h2 id="flume"><a href="#flume" class="headerlink" title="flume"></a>flume</h2><p>flume用于数据的收集和分发，flume可以监听端口的数据流入，监视文件的变动以及各种数据形式的数据流入，然后再把数据重新转发到其他需要数据的节点或存储中。</p><p>1、Flume的概念 </p><p>flume是分布式的日志收集系统，它将各个服务器中的数据收集起来并送到指定的地方去，比如说送到图中的HDFS，简单来说flume就是收集日志的。 </p><p>2、Event的概念<br>在这里有必要先介绍一下flume中event的相关概念：flume的核心是把数据从数据源(source)收集过来，在将收集到的数据送到指定的目的地(sink)。为了保证输送的过程一定成功，在送到目的地(sink)之前，会先缓存数据(channel),待数据真正到达目的地(sink)后，flume在删除自己缓存的数据。 </p><p>在整个数据的传输的过程中，流动的是event，即事务保证是在event级别进行的。那么什么是event呢？—–event将传输的数据进行封装，是flume传输数据的基本单位，如果是文本文件，通常是一行记录，event也是事务的基本单位。event从source，流向channel，再到sink，本身为一个字节数组，并可携带headers(头信息)信息。event代表着一个数据的最小完整单元，从外部数据源来，向外部的目的地去。       </p><p>flume使用   </p><h2 id="ambari"><a href="#ambari" class="headerlink" title="ambari"></a>ambari</h2><p>ambari就是一个Hadoop的Web应用。</p><h2 id="spark"><a href="#spark" class="headerlink" title="spark"></a>spark</h2><p>spark和MapReduce不同的地方就是，把计算过程放在内存中运行。</p><p>spark提出了抽象的RDD分布式内存模型，把每一步的计算操作转换成一个RDD结构，然后形成一个RDD连接而成的有向图。</p><p>比如data.map().filter().reduce();<br>程序提交到master以后，会解析成多个RDD，并且形成一个有向图，然后spark再根据这些RD结构在内存中执行对应的操作。当然这个拓扑结构会被拆分为各个子任务分发到各个spark节点上，然后计算完以后再形成下一个rdd。最后汇总结果即可。</p><p>由于是在内存中对数据进行操作，省去了不必要的IO操作，，不需要像Mapreduce一样还得先去hdfs读取文件再完成计算。</p><h2 id="storm"><a href="#storm" class="headerlink" title="storm"></a>storm</h2><p>在运行一个Storm任务之前，需要了解一些概念：</p><ol><li>Topologies</li><li>Streams</li><li>Spouts</li><li>Bolts</li><li>Stream groupings</li><li>Reliability</li><li>Tasks</li><li>Workers</li><li>Configuration</li></ol><p>Storm集群和Hadoop集群表面上看很类似。但是Hadoop上运行的是MapReduce jobs，而在Storm上运行的是拓扑（topology），这两者之间是非常不一样的。一个关键的区别是： 一个MapReduce job最终会结束， 而一个topology永远会运行（除非你手动kill掉）。</p><p>在Storm的集群里面有两种节点： 控制节点（master node）和工作节点（worker node）。控制节点上面运行一个叫Nimbus后台程序，它的作用类似Hadoop里面的JobTracker。Nimbus负责在集群里面分发代码，分配计算任务给机器， 并且监控状态。</p><p>每一个工作节点上面运行一个叫做Supervisor的节点。Supervisor会监听分配给它那台机器的工作，根据需要启动/关闭工作进程。每一个工作进程执行一个topology的一个子集；一个运行的topology由运行在很多机器上的很多工作进程组成。 </p><p><img src="https://img-blog.csdn.net/20160107221357281?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><p>Nimbus和Supervisor之间的所有协调工作都是通过Zookeeper集群完成。另外，Nimbus进程和Supervisor进程都是快速失败（fail-fast)和无状态的。所有的状态要么在zookeeper里面， 要么在本地磁盘上。这也就意味着你可以用kill -9来杀死Nimbus和Supervisor进程， 然后再重启它们，就好像什么都没有发生过。这个设计使得Storm异常的稳定。</p><p>storm比起spark它的实时性能更高更强，storm可以做到亚秒级别的数据输入分析。而spark的方式是通过秒级的数据切分，来形成spark rdd数据集，然后再按照DAG有向图进行执行的。</p><p>storm则不然。</p><p>一：介绍Storm设计模型</p><p>1.Topology</p><p>　　Storm对任务的抽象，其实 就是将实时数据分析任务 分解为 不同的阶段　　　　</p><p>　　点： 计算组件   Spout   Bolt</p><p>　　边： 数据流向    数据从上一个组件流向下一个组件  带方向</p><p>2.tuple</p><p>　　Storm每条记录 封装成一个tuple</p><p>　　其实就是一些keyvalue对按顺序排列</p><p>　　方便组件获取数据</p><p>3.Spout</p><p>　　数据采集器</p><p>　　源源不断的日志记录  如何被topology接收进行处理？</p><p>　　Spout负责从数据源上获取数据，简单处理 封装成tuple向后面的bolt发射</p><p>4.Bolt</p><p>　　数据处理器<br>　　<br>二：开发wordcount案例</p><p>1.书写整个大纲的点线图</p><p>　　<img src="https://images2015.cnblogs.com/blog/1027015/201701/1027015-20170126164121691-1448959654.png" alt=""><br>　　<br>topology就是一个拓扑图，类似于spark中的dag有向图，只不过storm执行的流式的数据，比dag执行更加具有实时性。</p><p>topology包含了spout和bolt。<br>spout负责获取数据，并且将数据发送给bolt，这个过程就是把任务派发到多个节点，bolt则负责对数据进行处理，比如splitbolt负责把每个单词提取出来，countbolt负责单词数量的统计，最后的printbolt将每个结果集tuple打印出来。</p><p>这就形成了一个完整的流程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇总结主要是基于我之前Hadoop生态基础系列文章而形成的的。主要是把重要的知识点用自己的话说了一遍，可能会有一些错误，还望见谅和指点。谢谢&lt;/p&gt;
&lt;p&gt;更多详细内容可以查看我的专栏文章：Hadoop生态学习&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888/article/category/7779280&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888/article/category/7779280&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="技术总结" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Hadoop" scheme="http://h2pl.github.io/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>分布式技术实践总结</title>
    <link href="http://h2pl.github.io/2018/07/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
    <id>http://h2pl.github.io/2018/07/08/分布式技术实践总结/</id>
    <published>2018-07-08T14:15:36.000Z</published>
    <updated>2018-07-09T00:28:20.904Z</updated>
    
    <content type="html"><![CDATA[<p>本文基于之前的分布式系统理论系列文章总结而成，本部分主要是实践内容，详细内容可见我的专栏：分布式系统理论与实践</p><p><a href="https://blog.csdn.net/column/details/24090.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/24090.html</a></p><p>本文主要是按照我自己的理解以及参考之前文章综合而成的，其中可能会有一些错误，还请见谅，也请指出。<br><a id="more"></a></p><h1 id="分布式技术"><a href="#分布式技术" class="headerlink" title="分布式技术"></a>分布式技术</h1><h2 id="分布式数据和nosql"><a href="#分布式数据和nosql" class="headerlink" title="分布式数据和nosql"></a>分布式数据和nosql</h2><p>分布式一般是指分布式部署的数据库。</p><p>比如Hbase基于HDFS分布式部署，所以他是一个分布式数据库。</p><p>当然MySQL也可以分布式部署，比如按照不同业务部署，或者把单表内容拆成多个表乃至多个库进行部署。</p><p>一般MySQL的扩展方式有：</p><p>1 主从复制 使用冗余保证可用</p><p>2 读写分离 主库负责写从库负责读，分担压力，并且保证数据一致性和备份。</p><p>3 分表分库，横向拆分数据表放到多个表中或者多个库中，一般多个表或者多个库会使用不同节点部署，也就是一种分布式方案，提高并发的读写量。</p><p>Nosql的话就比较多了，redis，memcache等。<br>当然hbase也是，hbase按照region将数据文件分布在hdfs上，并且hdfs提供高可用和备份，同时hbase的regionserver也保证高可用，于是hbase的分布式方案也是比较成熟的。</p><h2 id="缓存-分布式缓存"><a href="#缓存-分布式缓存" class="headerlink" title="缓存 分布式缓存"></a>缓存 分布式缓存</h2><p>一般作为缓存的软件有redis，memcache等。当然我本地写一个hashmap也可以作为缓存。</p><p>memcache提出了一致性哈希的算法，但是本身不支持数据持久化，也没有提供分布式方案，需要自己完成持久化以及分布式部署并且保证其可用性。</p><p>redis作为新兴的内存数据库，提供了比memcache更多的数据结构，以及各种分布式方案。当然它也支持持久化。</p><h3 id="redis的部署方案："><a href="#redis的部署方案：" class="headerlink" title="redis的部署方案："></a>redis的部署方案：</h3><blockquote><p>1 redis的主从复制结构，和MySQL类似，使用日志aof或者持久化文件rdb进行主从同步。</p><p>2 读写分离，也可以做，但一般不需要。因为redis够快。</p><p>3 redis的哨兵方案，主节点配置哨兵，每当宕机时自动完成主从切换。</p><p>4 redis的集群方案，p2p的Redis Cluster部署了多台Redis服务器，每台Redis拥有全局的分片信息，所以任意节点都可以对外提供服务，当然每个节点只保存一部分分片，所以某台机器宕机时不会影响整个集群，当然每个节点也有slave，哨兵自动进行故障切换。</p><p>5 codis方案，codis屏蔽了集群的内部实现，可以不更改redis api的情况下使用代理的方式提供集群访问。并且使用 group的概念封装一组节点。</p></blockquote><h3 id="缓存需要解决的问题："><a href="#缓存需要解决的问题：" class="headerlink" title="缓存需要解决的问题："></a>缓存需要解决的问题：</h3><pre><code>命中：缓存有数据不命中：去数据库读取失效：过期替换：缓存淘汰算法。一般有lru，fifo，随机缓存等。</code></pre><h3 id="缓存更新的方法"><a href="#缓存更新的方法" class="headerlink" title="缓存更新的方法"></a>缓存更新的方法</h3><p>缓存更新可以先更新数据库再更新缓存，也可以先更新缓存再更新数据库。</p><p>一般推荐先更新数据库，否则写一条数据时刚好有人读到缓存，把旧数据读到缓存中，此时新数据在数据库确不在缓存中。</p><p>还有一种方法，就是让缓存自己去完成数据库更新，而不是让应用去选择如何更新数据库，这样的话缓存和数据库的更新操作就是透明的了，我们只需要操作缓存即可。</p><h3 id="缓存在springboot中的使用"><a href="#缓存在springboot中的使用" class="headerlink" title="缓存在springboot中的使用"></a>缓存在springboot中的使用</h3><pre><code>springboot支持将缓存的curd操作配置在注解中，只需要在对应方法上配置好键和更新策略。则redis会根据该方法的操作类型执行对应操作，非常方便。</code></pre><h3 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h3><p>分布式部署时，经常要面对的问题是，一个服务集群由谁来提供给这个客户度服务，需要一种算法来完成这一步映射。</p><p>如果直接使用hash显然分布非常不均匀。那如果使用余数法呢，一共有N台机器，我对N取余可以映射到任意一台机器上。</p><p>这种方法的缺点在于，当取余的值集中在某一范围时，就容易集中访问某些机器，导致热点问题。</p><blockquote><p>于是memcache推出了一个叫做一致性哈希的算法，一个哈希环，环上支持2^32次方个节点，也就是包含了所有的ip。</p><p>然后我们把主机通过hash值分布到这个环上，请求到来时会映射到某一个节点，如果该节点没有主机，则顺时针寻找真正主机。</p><p>当节点加入或者节点删除时，并不会影响服务的可用性，只是某些请求会被映射到别的节点。</p></blockquote><p>但是当请求集中到某个区域时，会产生倾斜，我们引入了虚拟节点来改善这个问题，虚拟节点对应到真实节点，所以加入虚拟节点可以更好地转移请求。</p><h2 id="session和分布式session"><a href="#session和分布式session" class="headerlink" title="session和分布式session"></a>session和分布式session</h2><p>session是web应用必备的一个结构。<br>一般有几种方案来管理session。</p><p>1 web应用保存session到内存中，但是宕机会丢失</p><p>2 web应用持久化到数据库或者redis，增加数据库负担。</p><p>3 使用cookie保存加密后的session，浏览器压力大，可能被破解</p><p>4 使用单独的session服务集群提供session服务，并且本身也可以采用分布式部署，部署的时候可以主从。</p><p>保证session一致性的解决方法（客户端可以访问到自己的session）：</p><p>1 客户端cookie保存</p><p>2 多个webserver进行同步，效率低</p><p>3 反向代理绑定ip映射同一个服务器，但是宕机时出错</p><p>4 后端统一存储，比如redis，或则部署session服务。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>负载均衡一般可以分为七层，四层负载均衡。</p><p>Nginx</p><p>七层的负载均衡也就是http负载均衡，主要使用Nginx完成。</p><blockquote><p>配置Nginx进行反向代理的url，然后转发请求到上游服务器，请求进来时自动转发到上游服务器，通过url进行负载均衡，所以是七层负载均衡。既然是七层负载，那么上游服务器提供了http服务，也可以解析该请求。</p><p>四层负载均衡主要是tcp请求的负载均衡，因为tcp请求是绑定到一个端口上的，所以我们根据端口进行请求转发到上游服务器的。既然是四层负载，上游服务器监听该端口的服务就可以处理该请求。</p></blockquote><p>LVS</p><p>LVS术语定义：</p><pre><code>DS：Director Server，前端负载均衡器节点（后文用Director称呼）；RS：Real Server，后端真实服务器；VIP：用户请求的目标的IP地址，一般是公网IP地址；DIP：Director Server IP，Director和Real Server通讯的内网IP地址；RIP：Real Server IP，Director和Real Server通讯的内网IP地址；</code></pre><p>LVS有三种实现负载均衡的方式</p><p>NAT 四层负载均衡</p><blockquote><p>NAT支持四层负载均衡，NAT中只有DS提供公网ip，并且VIP绑定在DS的mac地址上，客户端只能访问DS。同时DS和RS通过内网ip进行网络连接。当TCP数据报到达DS时，DS修改数据报，指向RS的ip和port。进行转发即可。</p><p>同时，RS处理完请求后，由于网关时DS，所以仍然要返回给DS处理。</p><p>NAT模式中，RS返回数据包是返回给Director，Director再返回给客户端；事实上这跟NAT网络协议没什么关系。</p></blockquote><p>DR 二层负载均衡</p><blockquote><p>DR模式中，DS负责接收请求。接收请求后把数据报的mac地址改成指向RS的mac地址，并且由于三台机器拥有同样的vip地址。<br>所以RS接收请求后认为该数据报应该由自己处理并相应。</p><p>同时为了避免RS再把相应转发会DS，我们禁用了对DS的arp，所以此时RS就会通过vip把响应通过vip网关返回给客户端。</p><p>Director通过修改请求中目标地址MAC为选定的RS实现数据转发，这就要求Diretor和Real Server必须在同一个广播域内，也就是他们的mac地址是可达的。<br>DR（Direct Routing）模式中，RS返回数据是直接返回给客户端（通过额外的路由）；</p></blockquote><p>TUN</p><blockquote><p>TUN中使用了IP隧道技术，客户端请求发给DS时，DS会通过隧道技术把数据报通过隧道发给实际的RS，然后RS解析数据以后可以直接响应给客户端，因为他有客户端的ip地址。这就不要求DS和RS在同一网段了，当然前提是RS有公网ip。</p><p>TUN（IP Tunneling）模式中，RS返回的数据也是直接返回给客户端，这种模式通过Overlay协议（把一个IP数据包封装到另一个数据包内部叫Overlay）避免了DR的限制。</p></blockquote><h2 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h2><p>zookeeper集群自身的特性：</p><blockquote><p>1 一个zookeeper服务器集群，一开始就会进行选主，主节点挂掉后也会进行选主。</p><p>使用zab协议中的选主机制进行选主，也就是每个节点进行一次提议，刚开始提议自己，如果有新的提议则覆盖自己原来的提议，不断重复，直到有节点获得过半的投票。完成一轮选主。</p><p>2 选主结束后，开始进行消息广播和数据同步，保证每一台服务器的数据都和leader同步。</p><p>3 开始提供服务，客户端向leader发送请求，leader首先发出提议，当有半数以上节点响应时，leader会发送commit信息，于是所有节点执行该操作。当有机器宕机时重启后会和leader同步。这是一个类似2pc的提交方式。</p></blockquote><p>zookeeper提供了分布式环境中常用的服务</p><blockquote><p>1 配置服务，多个机器可以通过文件节点共享配置。</p><p>2 选主服务，通过添加顺序节点，可以进行选主。</p><p>3 分布式锁，顺序节点和watcher</p><p>4 全局id，使用机器号+时间戳可以生成一个transactionid，是全局唯一的。</p></blockquote><h2 id="数据库的分布式事务"><a href="#数据库的分布式事务" class="headerlink" title="数据库的分布式事务"></a>数据库的分布式事务</h2><p>分布式事务的实现一般可以用2PC和3PC解决。</p><p>成熟的方案有：</p><blockquote><p>1 TCC 补偿式事务，对每一个步骤都有一个补偿措施。</p><p>2 全局事务实现。</p><p>3 事务消息：rocketmq的事务实现，先发消息到队列中，然后本地执行事务并通知消息队列，若成功则消息主动推给另一个服务，直到服务二执行成功，消息从队列中删除。如果超时不成功，则消息要求事务A回滚。</p><p>如果过程中失败了，本地事务也会回滚。消息队列可以回调本地接口判断事务是否执行成功，防止超时。</p><p>4 本地实现消息表：<br>本地实现消息表并且和事务记录存在一起，自己实现消息的轮询发送。<br>首先把本地事务操作和消息增加放在一个事务里执行，然后轮询消息表进行发送，如果执行成功则消息达到服务B，通知其执行。执行成功后消息被删除，否则回滚事务删除消息。</p></blockquote><h2 id="分布式锁问题"><a href="#分布式锁问题" class="headerlink" title="分布式锁问题"></a>分布式锁问题</h2><p>分布式锁用于分布式环境中的资源互斥，因为单机可以通过共享内存实现，而分布式环境只能通过网络实现。</p><h3 id="MySQL实现分布式锁"><a href="#MySQL实现分布式锁" class="headerlink" title="MySQL实现分布式锁"></a>MySQL实现分布式锁</h3><pre><code>insert加锁，锁没有失效时间，容易产生死锁</code></pre><h3 id="redis实现分布式锁"><a href="#redis实现分布式锁" class="headerlink" title="redis实现分布式锁"></a>redis实现分布式锁</h3><pre><code>1. 基于setnx、expire两个命令来实现基于setnx（set if not exist）的特点，当缓存里key不存在时，才会去set，否则直接返回false。如果返回true则获取到锁，否则获取锁失败，为了防止死锁，我们再用expire命令对这个key设置一个超时时间来避免。但是这里看似完美，实则有缺陷，当我们setnx成功后，线程发生异常中断，expire还没来的及设置，那么就会产生死锁。2 使用getset实现，可以判断自己是否获得了锁，但是可能会出现并发的原子性问题。拆分成两个操作。3 避免原子性问题可以使用lua脚本保证事务的原子性。4 上述都是单点的redis，如果是分布式环境的redis集群，可以使用redlock，要求节点向半数以上redis机器请求锁。才算成功。</code></pre><h3 id="zookeeper实现分布式锁"><a href="#zookeeper实现分布式锁" class="headerlink" title="zookeeper实现分布式锁"></a>zookeeper实现分布式锁</h3><p>创建有序节点，最小的抢到锁，其他的监听他的上一个节点即可。并且抢到锁的节点释放时只会通知下一个节点。</p><p>小结</p><p>在分布式系统中，共享资源互斥访问问题非常普遍，而针对访问共享资源的互斥问题，常用的解决方案就是使用分布式锁，这里只介绍了几种常用的分布式锁，分布式锁的实现方式还有有很多种，根据业务选择合适的分布式锁，下面对上述几种锁进行一下比较：</p><pre><code>数据库锁：优点：直接使用数据库，使用简单。缺点：分布式系统大多数瓶颈都在数据库，使用数据库锁会增加数据库负担。缓存锁：优点：性能高，实现起来较为方便，在允许偶发的锁失效情况，不影响系统正常使用，建议采用缓存锁。缺点：通过锁超时机制不是十分可靠，当线程获得锁后，处理时间过长导致锁超时，就失效了锁的作用。zookeeper锁：优点：不依靠超时时间释放锁；可靠性高；系统要求高可靠性时，建议采用zookeeper锁。缺点：性能比不上缓存锁，因为要频繁的创建节点删除节点。并且zookeeper只能单点写入。而Redis可以并发写入。</code></pre><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>适合场景：</p><p>1 服务之间解耦，比如淘宝的买家服务和物流服务，中间需要消息传递订单信息。但又不需要强耦合。便于服务的划分和独立部署</p><p>2 控制流量，大流量访问某服务时，避免服务出现问题，将其先存入队列，均匀释放流量。</p><p>3 削峰，当某一个服务如秒杀，如果直接集中访问，服务器可能会冲垮，所以先存到队列中，控制访问量，避免服务器冲击。</p><p>4 事务，消息事务</p><p>5 异步请求处理，比如一些不重要的服务可以延缓执行，比如卖家评价，站内信等。</p><p>常用消息队列：</p><p>rabbitmq：使用consumer和producer的模型，并且使用了broker，broker中包含路由功能的exchanger，每个key绑定一个queue，应用通过key进行队列消费和生产。</p><p>一般是点对点的消息，也可以支持一对多的消息，当然也可以支持消息的订阅。还有就是主题模式，和key的区别就是主题模式是多级的key表示。</p><p>kafka：</p><h2 id="微服务和Dubbo"><a href="#微服务和Dubbo" class="headerlink" title="微服务和Dubbo"></a>微服务和Dubbo</h2><p>分布式架构意味着服务的拆分，最早的SOA架构已经进行了服务拆分，但是每个服务还是太过庞大，不适合扩展和修改。</p><p>微服务的拆分粒度更加细，服务可以独立部署和快速迭代，通知支持扩展。</p><p>服务之间一般使用rpc调用进行访问，可以使用自定义协议也可以使用http服务，当然通过netty 实现TCP服务并且搭配合理的序列化方案也可以完成rpc功能。rpc是微服务的基础。</p><p>微服务一般需要配置中心来进行服务注册和发现，以便服务信息更新和配置，dubbo中使用的是zookeeper，用于配置服务信息提供给生产者使用。</p><p>一般情况下微服务需要有监控中心，心跳检测每一台服务器，及时完成故障切换和通知。同时监控服务的性能和使用情况。</p><p>序列化方式一般可以使用protobuf，http服务一般使用json。</p><p>微服务还支持更多的包括权限控制，流量控制，灰度发布，服务降级等内容，这里就不再细谈。</p><h3 id="全局id"><a href="#全局id" class="headerlink" title="全局id"></a>全局id</h3><p>方法一：使用数据库的 auto_increment 来生成全局唯一递增ID</p><pre><code>优点：简单，使用数据库已有的功能能够保证唯一性能够保证递增性步长固定缺点：可用性难以保证：数据库常见架构是一主多从+读写分离，生成自增ID是写请求，主库挂了就玩不转了扩展性差，性能有上限：因为写入是单点，数据库主库的写性能决定ID的生成性能上限，并且难以扩展</code></pre><p>方法三：uuid/guid</p><p>不管是通过数据库，还是通过服务来生成ID，业务方Application都需要进行一次远程调用，比较耗时。</p><p>有没有一种本地生成ID的方法，即高性能，又时延低呢？</p><p>uuid是一种常见的方案：</p><p>string ID =GenUUID();</p><p>优点：</p><p>本地生成ID，不需要进行远程调用，时延低</p><p>扩展性好，基本可以认为没有性能上限</p><p>缺点：</p><p>无法保证趋势递增</p><p>uuid过长，往往用字符串表示，作为主键建立索引查询效率低，常见优化方案为“转化为两个uint64整数存储”或者“折半存储”（折半后不能保证唯一性）</p><p>方法四：取当前毫秒数</p><p>uuid是一个本地算法，生成性能高，但无法保证趋势递增，且作为字符串ID检索效率低，有没有一种能保证递增的本地算法呢？</p><p>取当前毫秒数是一种常见方案：</p><p>uint64 ID = GenTimeMS();</p><p>优点：</p><p>本地生成ID，不需要进行远程调用，时延低</p><p>生成的ID趋势递增</p><p>生成的ID是整数，建立索引后查询效率高</p><p>缺点：</p><p>如果并发量超过1000，会生成重复的ID  </p><p>方法五：类snowflake算法</p><p>snowflake是twitter开源的分布式ID生成算法，其核心思想为，一个long型的ID：</p><p>41bit作为毫秒数</p><p>10bit作为机器编号</p><p>12bit作为毫秒内序列号</p><p>算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。</p><h2 id="秒杀系统"><a href="#秒杀系统" class="headerlink" title="秒杀系统"></a>秒杀系统</h2><p><img src="http://i2.51cto.com/images/blog/201803/11/9eda905930f00090d55b5ae3f6796d2b.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="image"></p><h3 id="第一层，客户端怎么优化（浏览器层，APP层）"><a href="#第一层，客户端怎么优化（浏览器层，APP层）" class="headerlink" title="第一层，客户端怎么优化（浏览器层，APP层）"></a>第一层，客户端怎么优化（浏览器层，APP层）</h3><p>（a）产品层面，用户点击“查询”或者“购票”后，按钮置灰，禁止用户重复提交请求；</p><p>（b）JS层面，限制用户在x秒之内只能提交一次请求；</p><h3 id="第二层，站点层面的请求拦截"><a href="#第二层，站点层面的请求拦截" class="headerlink" title="第二层，站点层面的请求拦截"></a>第二层，站点层面的请求拦截</h3><blockquote><p>怎么拦截？怎么防止程序员写for循环调用，有去重依据么？ip？cookie-id？…想复杂了，这类业务都需要登录，用uid即可。在站点层面，对uid进行请求计数和去重，甚至不需要统一存储计数，直接站点层内存存储（这样计数会不准，但最简单）。一个uid，5秒只准透过1个请求，这样又能拦住99%的for循环请求。</p><p>5s只透过一个请求，其余的请求怎么办？缓存，页面缓存，同一个uid，限制访问频度，做页面缓存，x秒内到达站点层的请求，均返回同一页面。同一个item的查询，例如车次，做页面缓存，x秒内到达站点层的请求，均返回同一页面。如此限流，既能保证用户有良好的用户体验（没有返回404）又能保证系统的健壮性（利用页面缓存，把请求拦截在站点层了）。</p></blockquote><p>好，这个方式拦住了写for循环发http请求的程序员，有些高端程序员（黑客）控制了10w个肉鸡，手里有10w个uid，同时发请求（先不考虑实名制的问题，小米抢手机不需要实名制），这下怎么办，站点层按照uid限流拦不住了。</p><h3 id="第三层-服务层来拦截（反正就是不要让请求落到数据库上去）消息队列-缓存"><a href="#第三层-服务层来拦截（反正就是不要让请求落到数据库上去）消息队列-缓存" class="headerlink" title="第三层 服务层来拦截（反正就是不要让请求落到数据库上去）消息队列+缓存"></a>第三层 服务层来拦截（反正就是不要让请求落到数据库上去）消息队列+缓存</h3><p>服务层怎么拦截？大哥，我是服务层，我清楚的知道小米只有1万部手机，我清楚的知道一列火车只有2000张车票，我透10w个请求去数据库有什么意义呢？没错，请求队列！</p><p>对于写请求，做请求队列，每次只透有限的写请求去数据层（下订单，支付这样的写业务）</p><p>1w部手机，只透1w个下单请求去db</p><p>3k张火车票，只透3k个下单请求去db</p><p>如果均成功再放下一批，如果库存不够则队列里的写请求全部返回“已售完”。</p><p>对于读请求，怎么优化？cache抗，不管是memcached还是redis，单机抗个每秒10w应该都是没什么问题的。如此限流，只有非常少的写请求，和非常少的读缓存mis的请求会透到数据层去，又有99.9%的请求被拦住了。</p><h3 id="好了，最后是数据库层"><a href="#好了，最后是数据库层" class="headerlink" title="好了，最后是数据库层"></a>好了，最后是数据库层</h3><p>浏览器拦截了80%，站点层拦截了99.9%并做了页面缓存，服务层又做了写请求队列与数据缓存，每次透到数据库层的请求都是可控的。db基本就没什么压力了，闲庭信步，单机也能扛得住，还是那句话，库存是有限的，小米的产能有限，透这么多请求来数据库没有意义。</p><p>全部透到数据库，100w个下单，0个成功，请求有效率0%。透3k个到数据，全部成功，请求有效率100%。</p><p><img src="http://i2.51cto.com/images/blog/201803/11/bf7107f82e635020a43f12aa4a8dc856.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="image"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上文应该描述的非常清楚了，没什么总结了，对于秒杀系统，再次重复下我个人经验的两个架构优化思路：</p><p>（1）尽量将请求拦截在系统上游（越上游越好）；</p><p>（2）读多写少的常用多使用缓存（缓存抗读压力）；</p><p>浏览器和APP：做限速</p><p>站点层：按照uid做限速，做页面缓存</p><p>服务层：按照业务做写请求队列控制流量，做数据缓存</p><p>数据层：闲庭信步</p><p>并且：结合业务做优化</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文基于之前的分布式系统理论系列文章总结而成，本部分主要是实践内容，详细内容可见我的专栏：分布式系统理论与实践&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/24090.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/24090.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文主要是按照我自己的理解以及参考之前文章综合而成的，其中可能会有一些错误，还请见谅，也请指出。&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="技术总结" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="分布式系统" scheme="http://h2pl.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>分布式理论学习总结</title>
    <link href="http://h2pl.github.io/2018/07/08/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA%E6%80%BB%E7%BB%93/"/>
    <id>http://h2pl.github.io/2018/07/08/分布式理论总结/</id>
    <published>2018-07-08T14:15:23.000Z</published>
    <updated>2018-07-09T00:28:39.127Z</updated>
    
    <content type="html"><![CDATA[<p>本文基于之前的分布式系统理论系列文章总结而成,主要是理论部分，详细内容可见我的专栏：分布式系统理论与实践</p><p><a href="https://blog.csdn.net/column/details/24090.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/24090.html</a></p><p>本文主要是按照我自己的理解以及参考之前文章综合而成的，其中可能会有一些错误，还请见谅，也请指出。<br><a id="more"></a></p><h1 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h1><h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><p>CAP定理讲的是三个性。consistency数据一致性，availability可用性，partition tolerance分区容错性。</p><p>三者只能选其中两者。为什么呢，看看这三个性质意味着什么吧。</p><p>首先看看分区容错性，分区容错性指的是网络出现分区（丢包，断网，超时等情况都属于网络分区）时，整个服务仍然可用。</p><p>由于网络分区在实际环境下一定存在，所以必须首先被考虑。于是分区容错性是必须要保证的，否则一旦出现分区服务就不可用，那就没办法弄了。</p><p>所以实际上是2选1的问题。在可用性和一致性中做出选择。</p><p>在一个分布式环境下，多个节点一起对外提供服务，如果要保证可用性，那么一台机器宕机了仍然有其他机器能提供服务。<br>但是宕机的机器重启以后就会发现数据和其他机器存在不一致，那么一致性就无法得到保证。</p><p>如果保证一致性，如果有机器宕机，那么其他节点就不能工作了，否则一定会产生数据不一致。</p><h2 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h2><p>在这么严苛的规定下，CAP一般很难实现一个健壮的系统。于是提出了BASE来削弱这些要求。</p><p>BASE是基本可用basically available，soft state软状态，eventually consistent最终一致性。</p><p>基本可用就是允许服务在某些时候降级，比如淘宝在高峰时期会关闭退货等服务。</p><p>软状态就是允许数据出现中间状态，比如支付宝提交转账以后并不是立刻到账，中间经过了多次消息传递和转发。</p><p>最终一致性就是指数据最终要是一致的，比如多个节点的数据需要定期同步，支付宝转账最终一定会到账。</p><h2 id="分布式系统关键词"><a href="#分布式系统关键词" class="headerlink" title="分布式系统关键词"></a>分布式系统关键词</h2><h3 id="时钟，时间，事件顺序"><a href="#时钟，时间，事件顺序" class="headerlink" title="时钟，时间，事件顺序"></a>时钟，时间，事件顺序</h3><p>分布式系统的一个问题在与缺少全局时钟，所以大家没有一个统一的时间，就很难用时间去确定各个节点事件的发生顺序，为了保证事件的顺序执行，</p><h3 id="Lamport-timestamps"><a href="#Lamport-timestamps" class="headerlink" title="Lamport timestamps"></a>Lamport timestamps</h3><p>Leslie Lamport 在1978年提出逻辑时钟的概念，并描述了一种逻辑时钟的表示方法，这个方法被称为Lamport时间戳(Lamport timestamps)[3]。</p><p><img src="https://images2015.cnblogs.com/blog/116770/201605/116770-20160501174922566-1686627384.png" alt="image"></p><p>分布式系统中按是否存在节点交互可分为三类事件，一类发生于节点内部，二是发送事件，三是接收事件。Lamport时间戳原理如下：</p><pre><code>每个事件对应一个Lamport时间戳，初始值为0如果事件在节点内发生，时间戳加1如果事件属于发送事件，时间戳加1并在消息中带上该时间戳如果事件属于接收事件，时间戳 = Max(本地时间戳，消息中的时间戳) + 1</code></pre><p>这样的话，节点内的事件有序，发送事件有序，接收事件一定在发送事件以后发生。再加上人为的一些规定，因此根据时间戳可以确定一个全序排列。</p><h3 id="Vector-clock"><a href="#Vector-clock" class="headerlink" title="Vector clock"></a>Vector clock</h3><p>Lamport时间戳帮助我们得到事件顺序关系，但还有一种顺序关系不能用Lamport时间戳很好地表示出来，那就是同时发生关系(concurrent)[4]。<br>Vector clock是在Lamport时间戳基础上演进的另一种逻辑时钟方法，它通过vector结构不但记录本节点的Lamport时间戳，同时也记录了其他节点的Lamport时间戳[5][6]。</p><p><img src="https://images2015.cnblogs.com/blog/116770/201605/116770-20160502134654404-1109556515.png" alt="image"></p><p>如果 Tb[Q] &gt; Ta[Q] 并且 Tb[P] &lt; Ta[P]，则认为a、b同时发生，记作 a <-> b。例如图2中节点B上的第4个事件 (A:2，B:4，C:1) 与节点C上的第2个事件 (B:3，C:2) 没有因果关系、属于同时发生事件。</-></p><p>因为B4 &gt; B3并且 C1&lt;C2，说明两者之间没有顺序关系，否则不会出现一大一小，因此他们是同时发生的。</p><h3 id="Version-vector"><a href="#Version-vector" class="headerlink" title="Version vector"></a>Version vector</h3><p>基于Vector clock我们可以获得任意两个事件的顺序关系，结果或为先后顺序或为同时发生，识别事件顺序在工程实践中有很重要的引申应用，最常见的应用是发现数据冲突(detect conflict)。</p><p>分布式系统中数据一般存在多个副本(replication)，多个副本可能被同时更新，这会引起副本间数据不一致[7]，Version vector的实现与Vector clock非常类似[8]，目的用于发现数据冲突[9]。</p><p>当两个写入数据事件同时发生则发生了冲突，于是通过某些方法解决数据冲突。</p><p>Vector clock只用于发现数据冲突，不能解决数据冲突。如何解决数据冲突因场景而异，具体方法有以最后更新为准(last write win)，或将冲突的数据交给client由client端决定如何处理，或通过quorum决议事先避免数据冲突的情况发生[11]。</p><h3 id="选主，租约，多数派"><a href="#选主，租约，多数派" class="headerlink" title="选主，租约，多数派"></a>选主，租约，多数派</h3><blockquote><p>选举(election)是分布式系统实践中常见的问题，通过打破节点间的对等关系，选得的leader(或叫master、coordinator)有助于实现事务原子性、提升决议效率。</p><p>多数派(quorum)的思路帮助我们在网络分化的情况下达成决议一致性，在leader选举的场景下帮助我们选出唯一leader。</p><p>租约(lease)在一定期限内给予节点特定权利，也可以用于实现leader选举。</p></blockquote><p>选举(electioin)</p><blockquote><p>一致性问题(consistency)是独立的节点间如何达成决议的问题，选出大家都认可的leader本质上也是一致性问题，因而如何应对宕机恢复、网络分化等在leader选举中也需要考量。</p><p> 在一致性算法Paxos、ZAB[2]、Raft[3]中，为提升决议效率均有节点充当leader的角色。</p><p> ZAB、Raft中描述了具体的leader选举实现，与Bully算法类似ZAB中使用zxid标识节点，具有最大zxid的节点表示其所具备的事务(transaction)最新、被选为leader。</p></blockquote><p>多数派(quorum)</p><blockquote><p>在网络分化的场景下以上Bully算法会遇到一个问题，被分隔的节点都认为自己具有最大的序号、将产生多个leader，这时候就需要引入多数派(quorum)[4]。多数派的思路在分布式系统中很常见，其确保网络分化情况下决议唯一。</p></blockquote><p> 租约(lease)</p><p>选举中很重要的一个问题，以上尚未提到：怎么判断leader不可用、什么时候应该发起重新选举？</p><blockquote><p>最先可能想到会通过心跳(heart beat)判别leader状态是否正常，但在网络拥塞或瞬断的情况下，这容易导致出现双主。</p></blockquote><p>租约(lease)是解决该问题的常用方法，其最初提出时用于解决分布式缓存一致性问题[6]，后面在分布式锁[7]等很多方面都有应用。</p><pre><code>(a). 节点0、1、2在Z上注册自己，Z根据一定的规则(例如先到先得)颁发租约给节点，该租约同时对应一个有效时长；这里假设节点0获得租约、成为leader(b). leader宕机时，只有租约到期(timeout)后才重新发起选举，这里节点1获得租约、成为leader</code></pre><p>租约机制确保了一个时刻最多只有一个leader，避免只使用心跳机制产生双主的问题。在实践应用中，zookeeper、ectd可用于租约颁发。</p><h2 id="一致性，2pc和3pc"><a href="#一致性，2pc和3pc" class="headerlink" title="一致性，2pc和3pc"></a>一致性，2pc和3pc</h2><p>一致性(consensus)</p><p>何为一致性问题？简单而言，一致性问题就是相互独立的节点之间如何达成一项决议的问题。分布式系统中，进行数据库事务提交(commit transaction)、Leader选举、序列号生成等都会遇到一致性问题。</p><p>为了保证执行的一致性，可以使用2pc两段式提交和3pc三段式提交。</p><p>2PC</p><blockquote><p>2PC(tow phase commit)两阶段提交[5]顾名思义它分成两个阶段，先由一方进行提议(propose)并收集其他节点的反馈(vote)，再根据反馈决定提交(commit)或中止(abort)事务。我们将提议的节点称为协调者(coordinator)，其他参与决议节点称为参与者(participants, 或cohorts)：</p></blockquote><p>举个例子，首先用户想要执行一个事务，于是提交给leader，leader先让各个节点执行该事务。</p><p>我们要知道，事务是通过日志来实现的。各个节点使用redo日志进行重做，使用undo日志进行回滚。</p><p>于是各个节点执行事务，并把执行结果是否成功返回给leader，当leader收到全部确认消息后，发送消息让所有节点commit。如果有节点执行失败，则leader要求所有节点回滚。</p><p>2pc可能出现的一些问题是：</p><p>1 leader必须等待所有节点结果，如果有节点宕机或超时，则拒绝该事务，并向节点发送回滚的信息。</p><p>2 如果leader宕机，则一般配置watcherdog自动切换成备用leader，然后进行下一次的请求提交。</p><p>3这两种情况单独发生时都没有关系，有对应的措施可以进行回滚，但是如果当一个节点宕机时leader正在等待所有节点消息，其他节点也在等待leader最后的消息。</p><p>此时leader也不幸宕机，切换之后leader并不知道一个节点宕机了，这样的话其他的节点也会被阻塞住导致无法回滚。</p><blockquote></blockquote><p>3PC<br><img src="https://images2015.cnblogs.com/blog/116770/201603/116770-20160314002734304-489496391.png" alt="image"><br>coordinator接收完participant的反馈(vote)之后，进入阶段2，给各个participant发送准备提交(prepare to commit)指令</p><p>。participant接到准备提交指令后可以锁资源，但要求相关操作必须可回滚。coordinator接收完确认(ACK)后进入阶段3、进行commit/abort，3PC的阶段3与2PC的阶段2无异。协调者备份(coordinator watchdog)、状态记录(logging)同样应用在3PC。</p><p>participant如果在不同阶段宕机，我们来看看3PC如何应对：</p><blockquote><p>阶段1: coordinator或watchdog未收到宕机participant的vote，直接中止事务；宕机的participant恢复后，读取logging发现未发出赞成vote，自行中止该次事务</p><p>阶段2: coordinator未收到宕机participant的precommit ACK，但因为之前已经收到了宕机participant的赞成反馈(不然也不会进入到阶段2)，coordinator进行commit；watchdog可以通过问询其他participant获得这些信息，过程同理；宕机的participant恢复后发现收到precommit或已经发出赞成vote，则自行commit该次事务</p><p>阶段3: 即便coordinator或watchdog未收到宕机participant的commit ACK，也结束该次事务；宕机的participant恢复后发现收到commit或者precommit，也将自行commit该次事务<br>因为有了准备提交(prepare to<br>commit)阶段，3PC的事务处理延时也增加了1个RTT，变为3个RTT(propose+precommit+commit)，但是它防止participant宕机后整个系统进入阻塞态，增强了系统的可用性，对一些现实业务场景是非常值得的。</p></blockquote><p>总结一下就是：阶段一leader要求节点准备，节点返回ack或者fail。</p><p>如果节点都是ack，leader返回ack进入阶段二。<br>（如果fail则回滚，因为节点没有接收到ack，所以最终都会回滚）</p><p>阶段二时节点执行事务并且发送结果给leader，leader返回ack或者fail。由于阶段二的节点已经有了一个确定的状态ack，如果leader超时或宕机不返回，成功执行节点也会进行commit操作，这样即使有节点宕机也不会影响到其他节点。</p><h2 id="一致性算法paxos"><a href="#一致性算法paxos" class="headerlink" title="一致性算法paxos"></a>一致性算法paxos</h2><p>Basic Paxos</p><p>何为一致性问题？简单而言，一致性问题是在节点宕机、消息无序等场景可能出现的情况下，相互独立的节点之间如何达成决议的问题，作为解决一致性问题的协议，Paxos的核心是节点间如何确定并只确定一个值(value)。</p><p>和2PC类似，Paxos先把节点分成两类，发起提议(proposal)的一方为proposer，参与决议的一方为acceptor。假如只有一个proposer发起提议，并且节点不宕机、消息不丢包，那么acceptor做到以下这点就可以确定一个值。</p><blockquote><p>proposer发出提议，acceptor根据提议的id和值来决定是否接收提议，接受提议则替换为自己的提议，并且返回之前id最大的提议，当超过一半节点提议该值时，则该值被确定，这样既保证了时序，也保证了多数派。</p></blockquote><p> Multi Paxos</p><p>通过以上步骤分布式系统已经能确定一个值，“只确定一个值有什么用？这可解决不了我面临的问题。” 你心中可能有这样的疑问。</p><p>其实不断地进行“确定一个值”的过程、再为每个过程编上序号，就能得到具有全序关系(total order)的系列值，进而能应用在数据库副本存储等很多场景。我们把单次“确定一个值”的过程称为实例(instance)，它由proposer/acceptor/learner组成。    </p><p>Fast Paxos</p><p>在Multi Paxos中，proposer -&gt; leader -&gt; acceptor -&gt; learner，从提议到完成决议共经过3次通信，能不能减少通信步骤？</p><p>对Multi Paxos phase2a，如果可以自由提议value，则可以让proposer直接发起提议、leader退出通信过程，变为proposer -&gt; acceptor -&gt; learner，这就是Fast Paxos[2]的由来。</p><blockquote><p>多次paxos的确定值使用可以让多个proposer，acceptor一起运作。多个proposer提出提议，acceptor保留最大提议比返回之前提议，proposer当提议数量满足多数派则取出最大值向acceptor提议，于是过半数的acceptor比较提议后可以接受该提议，于是最终leader将提议写入acceptor，而acceptor再写入对应的learner。</p></blockquote><h2 id="raft和zab"><a href="#raft和zab" class="headerlink" title="raft和zab"></a>raft和zab</h2><p>Zab</p><p>Zab[5][6]的全称是Zookeeper atomic broadcast protocol，是Zookeeper内部用到的一致性协议。相比Paxos，Zab最大的特点是保证强一致性(strong consistency，或叫线性一致性linearizable consistency)。</p><p>和Raft一样，Zab要求唯一Leader参与决议，Zab可以分解成discovery、sync、broadcast三个阶段：</p><p><img src="https://images2015.cnblogs.com/blog/116770/201610/116770-20161025133734734-658183229.jpg" alt="image"></p><blockquote><p>discovery: 选举产生PL(prospective leader)，PL收集Follower epoch(cepoch)，根据Follower的反馈PL产生newepoch(每次选举产生新Leader的同时产生新epoch，类似Raft的term)</p></blockquote><blockquote><p>sync: PL补齐相比Follower多数派缺失的状态、之后各Follower再补齐相比PL缺失的状态，PL和Follower完成状态同步后PL变为正式Leader(established leader)</p></blockquote><blockquote><p>broadcast: Leader处理Client的写操作，并将状态变更广播至Follower，Follower多数派通过之后Leader发起将状态变更落地(deliver/commit)</p></blockquote><p>Raft：</p><h2 id="单个-Candidate-的竞选"><a href="#单个-Candidate-的竞选" class="headerlink" title="单个 Candidate 的竞选"></a>单个 Candidate 的竞选</h2><p>有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。</p><ul><li>下图表示一个分布式系统的最初阶段，此时只有 Follower，没有 Leader。Follower A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。</li></ul><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/111521118015898.gif" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/111521118015898.gif" alt=""></a></p><ul><li>此时 A 发送投票请求给其它所有节点。</li></ul><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/111521118445538.gif" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/111521118445538.gif" alt=""></a></p><ul><li>其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。</li></ul><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/111521118483039.gif" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/111521118483039.gif" alt=""></a></p><ul><li>之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。</li></ul><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/111521118640738.gif" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/111521118640738.gif" alt=""></a></p><h2 id="多个-Candidate-竞选"><a href="#多个-Candidate-竞选" class="headerlink" title="多个 Candidate 竞选"></a><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E4%B8%80%E8%87%B4%E6%80%A7.md#%E5%A4%9A%E4%B8%AA-candidate-%E7%AB%9E%E9%80%89" target="_blank" rel="noopener"></a>多个 Candidate 竞选</h2><ul><li>如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票，例如下图中 Candidate B 和 Candidate D 都获得两票，因此需要重新开始投票。</li></ul><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/111521119203347.gif" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/111521119203347.gif" alt=""></a></p><ul><li>当重新开始投票时，由于每个节点设置的随机竞选超时时间不同，因此能下一次再次出现多个 Candidate 并获得同样票数的概率很低。</li></ul><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/111521119368714.gif" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/111521119368714.gif" alt=""></a></p><h2 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E4%B8%80%E8%87%B4%E6%80%A7.md#%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6" target="_blank" rel="noopener"></a>日志复制</h2><ul><li>来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。</li></ul><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/7.gif" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/7.gif" alt=""></a></p><ul><li>Leader 会把修改复制到所有 Follower。</li></ul><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/9.gif" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/9.gif" alt=""></a></p><ul><li>Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。</li></ul><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/10.gif" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/10.gif" alt=""></a></p><ul><li>此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致。</li></ul><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/11.gif" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/11.gif" alt=""></a></p><h2 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h2><p>zookeeper在分布式系统中作为协调员的角色，可应用于Leader选举、分布式锁、配置管理等服务的实现。以下我们从zookeeper供的API、应用场景和监控三方面学习和了解zookeeper（以下简称ZK）。</p><p>ZK API</p><p>ZK以Unix文件系统树结构的形式管理存储的数据，图示如下：</p><p>其中每个树节点被称为znode，每个znode类似一个文件，包含文件元信息(meta data)和数据。</p><p>以下我们用server表示ZK服务的提供方，client表示ZK服务的使用方，当client连接ZK时，相应创建session会话信息。</p><p>有两种类型的znode：</p><p>Regular: 该类型znode只能由client端显式创建或删除</p><p>Ephemeral: client端可创建或删除该类型znode；当session终止时，ZK亦会删除该类型znode</p><p>znode创建时还可以被打上sequential标志，被打上该标志的znode，将自行加上自增的数字后缀</p><pre><code>ZK提供了以下API，供client操作znode和znode中存储的数据：create(path, data, flags)：创建路径为path的znode，在其中存储data[]数据，flags可设置为Regular或Ephemeral，并可选打上sequential标志。delete(path, version)：删除相应path/version的znodeexists(path,watch)：如果存在path对应znode，则返回true；否则返回false，watch标志可设置监听事件getData(path, watch)：返回对应znode的数据和元信息（如version等）setData(path, data, version)：将data[]数据写入对应path/version的znodegetChildren(path, watch)：返回指定znode的子节点集合</code></pre><p>K应用场景</p><p>基于以上ZK提供的znode和znode数据的操作，可轻松实现Leader选举、分布式锁、配置管理等服务。</p><p>Leader选举</p><blockquote><p>利用打上sequential标志的Ephemeral，我们可以实现Leader选举。假设需要从三个client中选取Leader，实现过程如下：</p><p>1、各自创建Ephemeral类型的znode，并打上sequential标志：</p><p>[zk: localhost:2181(CONNECTED) 4] ls /master<br>[lock-0000000241, lock-0000000243, lock-0000000242]</p><p>2、检查 /master 路径下的所有znode，如果自己创建的znode序号最小，则认为自己是Leader；否则记录序号比自己次小的znode</p><p>3、非Leader在次小序号znode上设置监听事件，并重复执行以上步骤2</p></blockquote><p>配置管理</p><p>znode可以存储数据，基于这一点，我们可以用ZK实现分布式系统的配置管理，假设有服务A，A扩容设备时需要将相应新增的ip/port同步到全网服务器的A.conf配置，实现过程如下：</p><blockquote><p>1、A扩容时，相应在ZK上新增znode，该znode数据形式如下：</p><p>[zk: localhost:2181(CONNECTED) 30] get /A/blk-0000340369<br>{“svr_info”: [{“ip”: “1.1.1.1.”, “port”: “11000”}]}<br>cZxid = 0x2ffdeda3be<br>……</p><p>2、全网机器监听 /A，当该znode下有新节点加入时，调用相应处理函数，将服务A的新增ip/port加入A.conf</p><p>3、完成步骤2后，继续设置对 /A监听</p></blockquote><p>ZK监控</p><p>ZK自身提供了一些“四字命令”，通过这些四字命令，我们可以获得ZK集群中，某台ZK的角色、znode数、健康状态等信息：</p><p>小结</p><p>zookeeper以目录树的形式管理数据，提供znode监听、数据设置等接口，基于这些接口，我们可以实现Leader选举、配置管理、命名服务等功能。结合四字命令，加上模拟zookeeper client 创建/删除znode，我们可以实现对zookeeper的有效监控。在各种分布式系统中，我们经常可以看到zookeeper的身影。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文基于之前的分布式系统理论系列文章总结而成,主要是理论部分，详细内容可见我的专栏：分布式系统理论与实践&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/24090.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/24090.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文主要是按照我自己的理解以及参考之前文章综合而成的，其中可能会有一些错误，还请见谅，也请指出。&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="技术总结" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="分布式系统" scheme="http://h2pl.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理与实践总结</title>
    <link href="http://h2pl.github.io/2018/07/08/Redis%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
    <id>http://h2pl.github.io/2018/07/08/Redis原理与实践总结/</id>
    <published>2018-07-08T14:15:12.000Z</published>
    <updated>2018-07-09T00:27:50.240Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要对Redis的设计和实现原理做了一个介绍很总结，有些东西我也介绍的不是很详细准确，尽量在自己的理解范围内把一些知识点和关键性技术做一个描述。如有错误，还望见谅，欢迎指出。<br>这篇文章主要还是参考我之前的技术专栏总结而来的。欢迎查看：</p><p>重新学习Redis</p><p><a href="https://blog.csdn.net/column/details/21877.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21877.html</a><br><a id="more"></a></p><h2 id="使用和基础数据结构（外观）"><a href="#使用和基础数据结构（外观）" class="headerlink" title="使用和基础数据结构（外观）"></a>使用和基础数据结构（外观）</h2><p>redis的基本使用方式是建立在redis提供的数据结构上的。</p><p>字符串<br>REDIS_STRING (字符串)是 Redis 使用得最为广泛的数据类型,它除了是 SET 、GET 等命令 的操作对象之外,数据库中的所有键,以及执行命令时提供给 Redis 的参数,都是用这种类型 保存的。</p><p>字符串类型分别使用 REDIS_ENCODING_INT 和 REDIS_ENCODING_RAW 两种编码</p><p>只有能表示为 long 类型的值,才会以整数的形式保存,其他类型 的整数、小数和字符串,都是用 sdshdr 结构来保存</p><p>哈希表<br>REDIS_HASH (哈希表)是HSET 、HLEN 等命令的操作对象</p><p>它使用 REDIS_ENCODING_ZIPLIST和REDIS_ENCODING_HT 两种编码方式</p><p>Redis 中每个hash可以存储232-1键值对（40多亿）</p><p>列表<br>REDIS_LIST(列表)是LPUSH 、LRANGE等命令的操作对象</p><p>它使用 REDIS_ENCODING_ZIPLIST和REDIS_ENCODING_LINKEDLIST 这两种方式编码</p><p>一个列表最多可以包含232-1 个元素(4294967295, 每个列表超过40亿个元素)。</p><p>集合<br>REDIS_SET (集合) 是 SADD 、 SRANDMEMBER 等命令的操作对象</p><p>它使用 REDIS_ENCODING_INTSET 和 REDIS_ENCODING_HT 两种方式编码</p><p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p><p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)</p><p>有序集<br>REDIS_ZSET (有序集)是ZADD 、ZCOUNT 等命令的操作对象</p><p>它使用 REDIS_ENCODING_ZIPLIST和REDIS_ENCODING_SKIPLIST 两种方式编码</p><p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>有序集合的成员是唯一的,但分数(score)却可以重复。</p><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)</p><p>下图说明了，外部数据结构和底层实际数据结构是通过realobject来连接的。一个外观类型里面必然存着一个realobject，通过它来访问底层数据结构。</p><p><img src="https://user-gold-cdn.xitu.io/2017/9/17/2c71cff03efc96d2280d12602cc2aa92?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><p>下面讨论redis底层数据结构</p><p>1 SDS动态字符串</p><p>sds字符串是字符串的实现</p><p>动态字符串是一个结构体，内部有一个buf数组，以及字符串长度，剩余长度等字段，优点是通过长度限制写入，避免缓冲区溢出，另外剩余长度不足时会自动扩容，扩展性较好，不需要频繁分配内存。</p><p>并且sds支持写入二进制数据，而不一定是字符。</p><p>2 dict字典</p><p>dict字典是哈希表的实现。</p><p>dict字典与Java中的哈希表实现简直如出一辙，首先都是数组+链表组成的结构，通过dictentry保存节点。</p><p>其中dict同时保存两个entry数组，当需要扩容时，把节点转移到第二个数组即可，平时只使用一个数组。</p><p><img src="http://zhangtielei.com/assets/photos_redis/redis_dict_structure.png" alt="image"></p><p>3 压缩链表ziplist</p><p>3.1 ziplist是一个经过特殊编码的双向链表，它的设计目标就是为了提高存储效率。ziplist可以用于存储字符串或整数，其中整数是按真正的二进制表示进行编码的，而不是编码成字符串序列。它能以O(1)的时间复杂度在表的两端提供push和pop操作。</p><p>3.2 实际上，ziplist充分体现了Redis对于存储效率的追求。一个普通的双向链表，链表中每一项都占用独立的一块内存，各项之间用地址指针（或引用）连接起来。这种方式会带来大量的内存碎片，而且地址指针也会占用额外的内存。</p><p>3.3 而ziplist却是将表中每一项存放在前后连续的地址空间内，一个ziplist整体占用一大块内存。它是一个表（list），但其实不是一个链表（linked list）。</p><p>3.4 另外，ziplist为了在细节上节省内存，对于值的存储采用了变长的编码方式，大概意思是说，对于大的整数，就多用一些字节来存储，而对于小的整数，就少用一些字节来存储。</p><p>实际上。redis的字典一开始的数据比较少时，会使用ziplist的方式来存储，也就是key1，value1，key2，value2这样的顺序存储，对于小数据量来说，这样存储既省空间，查询的效率也不低。</p><p>当数据量超过阈值时，哈希表自动膨胀为之前我们讨论的dict。</p><p>4 quicklist</p><p>quicklist是结合ziplist存储优势和链表灵活性与一身的双端链表。</p><p>quicklist的结构为什么这样设计呢？总结起来，大概又是一个空间和时间的折中：</p><p>4.1 双向链表便于在表的两端进行push和pop操作，但是它的内存开销比较大。</p><p>首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。</p><p>4.2 ziplist由于是一整块连续内存，所以存储效率很高。</p><p>但是，它不利于修改操作，每次数据变动都会引发一次内存的realloc。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能。</p><p><img src="http://zhangtielei.com/assets/photos_redis/redis_quicklist_structure.png" alt="image"></p><p>5 zset<br>zset其实是两种结构的合并。也就是dict和skiplist结合而成的。dict负责保存数据对分数的映射，而skiplist用于根据分数进行数据的查询（相辅相成）</p><p>6 skiplist</p><p>sortset数据结构使用了ziplist+zset两种数据结构。</p><p>Redis里面使用skiplist是为了实现sorted set这种对外的数据结构。sorted set提供的操作非常丰富，可以满足非常多的应用场景。这也意味着，sorted set相对来说实现比较复杂。</p><p>sortedset是由skiplist，dict和ziplist组成的。</p><p>当数据较少时，sorted set是由一个ziplist来实现的。<br>当数据多的时候，sorted</p><p>set是由一个叫zset的数据结构来实现的，这个zset包含一个dict + 一个skiplist。dict用来查询数据到分数(score)的对应关系，而skiplist用来根据分数查询数据（可能是范围查找）。</p><p> 在本系列前面关于ziplist的文章里，我们介绍过，ziplist就是由很多数据项组成的一大块连续内存。由于sorted set的每一项元素都由数据和score组成，因此，当使用zadd命令插入一个(数据, score)对的时候，底层在相应的ziplist上就插入两个数据项：数据在前，score在后。</p><p><img src="http://zhangtielei.com/assets/photos_redis/skiplist/redis_skiplist_example.png" alt="image"></p><p>skiplist的节点中存着节点值和分数。并且跳表是根据节点的分数进行排序的，所以可以根据节点分数进行范围查找。</p><p>7inset</p><p>inset是一个数字结合，他使用灵活的数据类型来保持数字。</p><p><img src="http://zhangtielei.com/assets/photos_redis/intset/redis_intset_add_example.png" alt="image"></p><p>新创建的intset只有一个header，总共8个字节。其中encoding = 2, length = 0。<br>添加13, 5两个元素之后，因为它们是比较小的整数，都能使用2个字节表示，所以encoding不变，值还是2。<br>当添加32768的时候，它不再能用2个字节来表示了（2个字节能表达的数据范围是-215~215-1，而32768等于215，超出范围了），因此encoding必须升级到INTSET_ENC_INT32（值为4），即用4个字节表示一个元素。</p><p>8总结</p><p>sds是一个灵活的字符串数组，并且支持直接存储二进制数据，同时提供长度和剩余空间的字段来保证伸缩性和防止溢出。</p><p>dict是一个字典结构，实现方式就是Java中的hashmap实现，同时持有两个节点数组，但只使用其中一个，扩容时换成另外一个。</p><p>ziplist是一个压缩链表，他放弃内存不连续的连接方式，而是直接分配连续内存进行存储，减少内存碎片。提高利用率，并且也支持存储二进制数据。</p><p>quicklist是ziplist和传统链表的中和形成的链表结果，每个链表节点都是一个ziplist。</p><p>skiplist一般有ziplist和zset两种实现方法，根据数据量来决定。zset本身是由skiplist和dict实现的。</p><p>inset是一个数字集合，他根据插入元素的数据类型来决定数组元素的长度。并自动进行扩容。</p><p>9 他们实现了哪些结构</p><p>字符串由sds实现</p><p>list由ziplist和quicklist实现</p><p>sortset由ziplist和zset实现</p><p>hash表由dict实现</p><p>集合由inset实现。</p><p><img src="https://user-gold-cdn.xitu.io/2017/9/17/2c71cff03efc96d2280d12602cc2aa92?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><h2 id="redis-server结构和数据库redisDb"><a href="#redis-server结构和数据库redisDb" class="headerlink" title="redis server结构和数据库redisDb"></a>redis server结构和数据库redisDb</h2><p>1 redis服务器中维护着一个数据库名为redisdb，实际上他是一个dict结构。</p><p>Redis的数据库使用字典作为底层实现，数据库的增、删、查、改都是构建在字典的操作之上的。 </p><p>2 redis服务器将所有数据库都保存在服务器状态结构redisServer(redis.h/redisServer)的db数组（应该是一个链表）里：</p><p>同理也有一个redis client结构，通过指针可以选择redis client访问的server是哪一个。</p><p>3 redisdb的键空间</p><pre><code>typedef struct redisDb {    // 数据库键空间，保存着数据库中的所有键值对    dict *dict;                 /* The keyspace for this DB */    // 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳    dict *expires;              /* Timeout of keys with a timeout set */    // 数据库号码    int id;                     /* Database ID */    // 数据库的键的平均 TTL ，统计信息    long long avg_ttl;          /* Average TTL, just for stats */    //..} redisDb</code></pre><p>这部分的代码说明了，redisdb除了维护一个dict组以外，还需要对应地维护一个expire的字典数组。</p><p>大的dict数组中有多个小的dict字典，他们共同负责存储redisdb的所有键值对。</p><p>同时，对应的expire字典则负责存储这些键的过期时间<br><img src="https://img-blog.csdn.net/20180701224321524?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3MjQ4ODg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p><p>4 过期键的删除策略</p><p>2、过期键删除策略<br>通过前面的介绍，大家应该都知道数据库键的过期时间都保存在过期字典里，那假如一个键过期了，那么这个过期键是什么时候被删除的呢？现在来看看redis的过期键的删除策略： </p><p>a、定时删除：在设置键的过期时间的同时，创建一个定时器，在定时结束的时候，将该键删除； </p><p>b、惰性删除：放任键过期不管，在访问该键的时候，判断该键的过期时间是否已经到了，如果过期时间已经到了，就执行删除操作； </p><p>c、定期删除：每隔一段时间，对数据库中的键进行一次遍历，删除过期的键。 </p><h2 id="redis的事件模型"><a href="#redis的事件模型" class="headerlink" title="redis的事件模型"></a>redis的事件模型</h2><p>redis处理请求的方式基于reactor线程模型，即一个线程处理连接，并且注册事件到IO多路复用器，复用器触发事件以后根据不同的处理器去执行不同的操作。总结以下客户端到服务端的请求过程</p><p>总结</p><pre><code>远程客户端连接到 redis 后，redis服务端会为远程客户端创建一个 redisClient 作为代理。redis 会读取嵌套字中的数据，写入 querybuf 中。解析 querybuf 中的命令，记录到 argc 和 argv 中。根据 argv[0] 查找对应的 recommand。执行 recommend 对应的执行函数。执行以后将结果存入 buf &amp; bufpos &amp; reply 中。返回给调用方。返回数据的时候，会控制写入数据量的大小，如果过大会分成若干次。保证 redis 的相应时间。Redis 作为单线程应用，一直贯彻的思想就是，每个步骤的执行都有一个上限（包括执行时间的上限或者文件尺寸的上限）一旦达到上限，就会记录下当前的执行进度，下次再执行。保证了 Redis 能够及时响应不发生阻塞。</code></pre><h2 id="备份方式"><a href="#备份方式" class="headerlink" title="备份方式"></a>备份方式</h2><p>快照（RDB）：就是我们俗称的备份，他可以在定期内对数据进行备份，将Redis服务器中的数据持久化到硬盘中；</p><p>只追加文件（AOF）：他会在执行写命令的时候，将执行的写命令复制到硬盘里面，后期恢复的时候，只需要重新执行一下这个写命令就可以了。类似于我们的MySQL数据库在进行主从复制的时候，使用的是binlog二进制文件，同样的是执行一遍写命令；</p><p>appendfsync同步频率的区别如下图：</p><p><img src="https://img-blog.csdn.net/20170313210401173?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="redis主从复制"><a href="#redis主从复制" class="headerlink" title="redis主从复制"></a>redis主从复制</h2><p>Redis复制工作过程：</p><p>slave向master发送sync命令。</p><p>master开启子进程来讲dataset写入rdb文件，同时将子进程完成之前接收到的写命令缓存起来。</p><p>子进程写完，父进程得知，开始将RDB文件发送给slave。</p><p>master发送完RDB文件，将缓存的命令也发给slave。</p><p>master增量的把写命令发给slave。</p><pre><code>注意有两步操作，一个是写入rdb的时候要缓存写命令，防止数据不一致。发完rdb后还要发写命令给salve，以后增量发命令就可以了</code></pre><h2 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h2><h3 id="使用setnx加expire实现加锁和时限"><a href="#使用setnx加expire实现加锁和时限" class="headerlink" title="使用setnx加expire实现加锁和时限"></a>使用setnx加expire实现加锁和时限</h3><p>  加锁时使用setnx设置key为1并设置超时时间，解锁时删除键</p><pre><code>tryLock(){      SETNX Key 1    EXPIRE Key Seconds}release(){    DELETE Key}</code></pre><p>这个方案的一个问题在于每次提交一个Redis请求，如果执行完第一条命令后应用异常或者重启，锁将无法过期，一种改善方案就是使用Lua脚本（包含SETNX和EXPIRE两条命令），但是如果Redis仅执行了一条命令后crash或者发生主从切换，依然会出现锁没有过期时间，最终导致无法释放。</p><h3 id="使用getset加锁和获取过期时间"><a href="#使用getset加锁和获取过期时间" class="headerlink" title="使用getset加锁和获取过期时间"></a>使用getset加锁和获取过期时间</h3><p>针对锁无法释放问题的一个解决方案基于GETSET命令来实现</p><pre><code>思路：SETNX(Key,ExpireTime)获取锁如果获取锁失败，通过GET(Key)返回的时间戳检查锁是否已经过期GETSET(Key,ExpireTime)修改Value为NewExpireTime检查GETSET返回的旧值，如果等于GET返回的值，则认为获取锁成功注意：这个版本去掉了EXPIRE命令，改为通过Value时间戳值来判断过期</code></pre><h3 id="2-0的setnx可以配置过期时间。"><a href="#2-0的setnx可以配置过期时间。" class="headerlink" title="2.0的setnx可以配置过期时间。"></a>2.0的setnx可以配置过期时间。</h3><pre><code>V2.0 基于SETNXtryLock(){      SETNX Key 1 Seconds}release(){    DELETE Key}</code></pre><p>Redis 2.6.12版本后SETNX增加过期时间参数，这样就解决了两条命令无法保证原子性的问题。但是设想下面一个场景： </p><ol><li>C1成功获取到了锁，之后C1因为GC进入等待或者未知原因导致任务执行过长，最后在锁失效前C1没有主动释放锁 2. C2在C1的锁超时后获取到锁，并且开始执行，这个时候C1和C2都同时在执行，会因重复执行造成数据不一致等未知情况 3. C1如果先执行完毕，则会释放C2的锁，此时可能导致另外一个C3进程获取到了锁</li></ol><p>流程图如下<br><img src="http://tech.dianwoda.com/content/images/2018/04/unsafe-lock.png" alt="2."></p><h3 id="使用sentx将值设为时间戳，通过lua脚本进行cas比较和删除操作"><a href="#使用sentx将值设为时间戳，通过lua脚本进行cas比较和删除操作" class="headerlink" title="使用sentx将值设为时间戳，通过lua脚本进行cas比较和删除操作"></a>使用sentx将值设为时间戳，通过lua脚本进行cas比较和删除操作</h3><pre><code>V3.0tryLock(){      SETNX Key UnixTimestamp Seconds}release(){      EVAL(      //LuaScript      if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then          return redis.call(&quot;del&quot;,KEYS[1])      else          return 0      end    )}</code></pre><p>这个方案通过指定Value为时间戳，并在释放锁的时候检查锁的Value是否为获取锁的Value，避免了V2.0版本中提到的C1释放了C2持有的锁的问题；另外在释放锁的时候因为涉及到多个Redis操作，并且考虑到Check And Set 模型的并发问题，所以使用Lua脚本来避免并发问题。</p><p>  如果在并发极高的场景下，比如抢红包场景，可能存在UnixTimestamp重复问题，另外由于不能保证分布式环境下的物理时钟一致性，也可能存在UnixTimestamp重复问题，只不过极少情况下会遇到。</p><h3 id="分布式Redis锁：Redlock"><a href="#分布式Redis锁：Redlock" class="headerlink" title="分布式Redis锁：Redlock"></a>分布式Redis锁：Redlock</h3><p>redlock的思想就是要求一个节点获取集群中N/2 + 1个节点<br>上的锁才算加锁成功。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>不论是基于SETNX版本的Redis单实例分布式锁，还是Redlock分布式锁，都是为了保证下特性</p><ol><li>安全性：在同一时间不允许多个Client同时持有锁</li><li>活性<br>死锁：锁最终应该能够被释放，即使Client端crash或者出现网络分区（通常基于超时机制）<br>容错性：只要超过半数Redis节点可用，锁都能被正确获取和释放<h2 id="分布式方案"><a href="#分布式方案" class="headerlink" title="分布式方案"></a>分布式方案</h2></li></ol><p>1 主从复制，优点是备份简易使用。缺点是不能故障切换，并且不易扩展。</p><p>2 使用sentinel哨兵工具监控和实现自动切换。</p><p>3 codis集群方案</p><p>首先codis使用代理的方式隐藏底层redis，这样可以完美融合以前的代码，不需要更改redis访问操作。</p><p>然后codis使用了zookeeper进行监控和自动切换。同时使用了redis-group的概念，保证一个group里是一主多从的主从模型，基于此来进行切换。</p><p>4 redis cluster集群</p><p>该集群是一个p2p方式部署的集群</p><p>Redis cluster是一个去中心化、多实例Redis间进行数据共享的集群。</p><p>每个节点上都保存着其他节点的信息，通过任一节点可以访问正常工作的节点数据，因为每台机器上的保留着完整的分片信息，某些机器不正常工作不影响整体集群的工作。并且每一台redis主机都会配备slave，通过sentinel自动切换。</p><p><img src="http://7xivgs.com1.z0.glb.clouddn.com/codis02.png" alt="image"></p><h2 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h2><p>事务<br>MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p><p>redis事务有一个特点，那就是在2.6以前，事务的一系列操作，如果有的成功有的失败，仍然会提交成功的那部分，后来改为全部不提交了。</p><p>但是Redis事务不支持回滚，提交以后不能执行回滚操作。</p><pre><code>为什么 Redis 不支持回滚（roll back）如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。以下是这种做法的优点：Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</code></pre><h3 id="redis脚本事务"><a href="#redis脚本事务" class="headerlink" title="redis脚本事务"></a>redis脚本事务</h3><p>Redis 脚本和事务<br>从定义上来说， Redis 中的脚本本身就是一种事务， 所以任何在事务里可以完成的事， 在脚本里面也能完成。 并且一般来说， 使用脚本要来得更简单，并且速度更快。</p><p>因为脚本功能是 Redis 2.6 才引入的， 而事务功能则更早之前就存在了， 所以 Redis 才会同时存在两种处理事务的方法。</p><p>redis事务的ACID特性<br>在传统的关系型数据库中,尝尝用ACID特质来检测事务功能的可靠性和安全性。<br>在redis中事务总是具有原子性(Atomicity),一致性(Consistency)和隔离性(Isolation),并且当redis运行在某种特定的持久化<br>模式下,事务也具有耐久性(Durability).</p><p>①原子性</p><p>事务具有原子性指的是,数据库将事务中的多个操作当作一个整体来执行,服务器要么就执行事务中的所有操作,要么就一个操作也不执行。<br>但是对于redis的事务功能来说,事务队列中的命令要么就全部执行,要么就一个都不执行,因此redis的事务是具有原子性的。</p><p>②一致性</p><pre><code>事务具有一致性指的是,如果数据库在执行事务之前是一致的,那么在事务执行之后,无论事务是否执行成功,数据库也应该仍然一致的。”一致“指的是数据符合数据库本身的定义和要求,没有包含非法或者无效的错误数据。redis通过谨慎的错误检测和简单的设计来保证事务一致性。</code></pre><p>③隔离性</p><pre><code>事务的隔离性指的是,即使数据库中有多个事务并发在执行,各个事务之间也不会互相影响,并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。因为redis使用单线程的方式来执行事务(以及事务队列中的命令),并且服务器保证,在执行事务期间不会对事物进行中断,因此,redis的事务总是以串行的方式运行的,并且事务也总是具有隔离性的</code></pre><p>④持久性</p><pre><code>事务的耐久性指的是,当一个事务执行完毕时,执行这个事务所得的结果已经被保持到永久存储介质里面。因为redis事务不过是简单的用队列包裹起来一组redis命令,redis并没有为事务提供任何额外的持久化功能,所以redis事务的耐久性由redis使用的模式决定</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要对Redis的设计和实现原理做了一个介绍很总结，有些东西我也介绍的不是很详细准确，尽量在自己的理解范围内把一些知识点和关键性技术做一个描述。如有错误，还望见谅，欢迎指出。&lt;br&gt;这篇文章主要还是参考我之前的技术专栏总结而来的。欢迎查看：&lt;/p&gt;
&lt;p&gt;重新学习Redis&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/21877.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21877.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="技术总结" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Redis" scheme="http://h2pl.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Mysql原理与实践总结</title>
    <link href="http://h2pl.github.io/2018/07/08/Mysql%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
    <id>http://h2pl.github.io/2018/07/08/Mysql原理与实践总结/</id>
    <published>2018-07-08T14:15:04.000Z</published>
    <updated>2018-07-09T00:26:38.365Z</updated>
    
    <content type="html"><![CDATA[<p>本文根据自己对MySQL的学习和实践以及各类文章与书籍总结而来。<br>囊括了MySQL数据库的基本原理和技术。本文主要是我的一个学习总结，基于之前的系列文章做了一个概括，如有错误，还望指出，谢谢。</p><p>详细内容请参考我的系列文章：</p><p>重新学习MySQL与Redis</p><p><a href="https://blog.csdn.net/column/details/21877.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21877.html</a><br><a id="more"></a></p><h1 id="数据库原理"><a href="#数据库原理" class="headerlink" title="数据库原理"></a>数据库原理</h1><p>Mysql是关系数据库。</p><h2 id="范式-反范式"><a href="#范式-反范式" class="headerlink" title="范式 反范式"></a>范式 反范式</h2><p>范式设计主要是避免冗余，以及数据不一致。反范式设计主要是避免多表连接，增加了冗余。</p><h2 id="主键-外键"><a href="#主键-外键" class="headerlink" title="主键 外键"></a>主键 外键</h2><p>主键是一个表中一行数据的唯一标识。<br>外键则是值某一列的键值是其他表的主键，外键的作用一般用来作为两表连接的键，并且保证数据的一致性。</p><h2 id="锁-共享锁和排它锁"><a href="#锁-共享锁和排它锁" class="headerlink" title="锁 共享锁和排它锁"></a>锁 共享锁和排它锁</h2><p>数据库的锁用来进行并发控制，排它锁也叫写锁，共享锁也叫行锁，根据不同粒度可以分为行锁和表锁。</p><h2 id="存储过程与视图"><a href="#存储过程与视图" class="headerlink" title="存储过程与视图"></a>存储过程与视图</h2><p>存储过程是对sql语句进行预编译并且以文件形式包装为一个可以快速执行的程序。但是缺点是不易修改，稍微改动语句就需要重新开发储存过程，优点是执行效率快。视图就是对其他一个或多个表进行重新包装，是一个外观模式，对视图数据的改动也会影响到数据报本身。</p><h2 id="事务与隔离级别"><a href="#事务与隔离级别" class="headerlink" title="事务与隔离级别"></a>事务与隔离级别</h2><p>事务的四个性质：原子性，一致性，持久性，隔离性。</p><p>原子性：一个事务中的操作要么全部成功要么全部失败。</p><p>一致性：事务执行成功的状态都是一致的，即使失败回滚了，也应该和事务执行前的状态是一致的。</p><p>隔离性：两个事务之间互不相干，不能互相影响。</p><p>事务的隔离级别<br>读未提交：事务A和事务B，A事务中执行的操作，B也可以看得到，因为级别是未提交读，别人事务中还没提交的数据你也看得到。这是没有任何并发措施的级别，也是默认级别。这个问题叫做脏读，为了解决这个问题，提出了读已提交。</p><p>读已提交：事务A和B，A中的操作B看不到，只有A提交后，在B中才看得到。虽然A的操作B看不到，但是B可以修改A用到的数据，导致A读两次的数据结果不同。这就是不可重读问题。</p><p>可重复读：事务A和B，事务A和B，A在数据行上加读锁，B虽然看得到但是改不了。所以是可重复读的，但是A的其他行仍然会被B访问并修改，所以导致了幻读问题。</p><p>序列化：数据库强制事务A和B串行化操作，避免了并发问题，但是效率比较低。</p><p>后面可以看一下mysql对隔离级别的实现。</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引的作用就和书的目录类似，比如根据书名做索引，然后我们通过书名就可以直接翻到某一页。数据表中我们要找一条数据，也可以根据它的主键来找到对应的那一页。当然数据库的搜索不是翻书，如果一页一页翻书，就相当于是全表扫描了，效率很低，所以人翻书肯定也是跳着翻。数据库也会基于类似的原理”跳着”翻书，快速地找到索引行。</p><h1 id="mysql原理"><a href="#mysql原理" class="headerlink" title="mysql原理"></a>mysql原理</h1><p>MySQL是oracle公司的免费数据库，作为关系数据库火了很久了。所以我们要学他。</p><h2 id="mysql客户端，服务端，存储引擎，文件系统"><a href="#mysql客户端，服务端，存储引擎，文件系统" class="headerlink" title="mysql客户端，服务端，存储引擎，文件系统"></a>mysql客户端，服务端，存储引擎，文件系统</h2><p>MySQL数据库的架构可以分为客户端，服务端，存储引擎和文件系统。</p><p>详细可以看下架构图，我稍微总结下</p><pre><code>最高层的客户端，通过tcp连接mysql的服务器，然后执行sql语句，其中涉及了查询缓存，执行计划处理和优化，接下来再到存储引擎层执行查询，底层实际上访问的是主机的文件系统。</code></pre><p><img src="http://image20.it168.com/201611_670x502/2701/39b96aa41090f9bb.png" alt="image"></p><h2 id="mysql常用语法"><a href="#mysql常用语法" class="headerlink" title="mysql常用语法"></a>mysql常用语法</h2><p>1 登录mysql</p><p>mysql -h 127.0.0.1 -u 用户名 -p</p><p>2 创建表<br>语法还是比较复杂的，之前有腾讯面试官问这个，然后答不上来。</p><pre><code>CREATE TABLE `user_accounts` (  `id`             int(100) unsigned NOT NULL AUTO_INCREMENT primary key,  `password`       varchar(32)       NOT NULL DEFAULT &apos;&apos; COMMENT &apos;用户密码&apos;,  `reset_password` tinyint(32)       NOT NULL DEFAULT 0 COMMENT &apos;用户类型：0－不需要重置密码；1-需要重置密码&apos;,  `mobile`         varchar(20)       NOT NULL DEFAULT &apos;&apos; COMMENT &apos;手机&apos;,  `create_at`      timestamp(6)      NOT NULL DEFAULT CURRENT_TIMESTAMP(6),  `update_at`      timestamp(6)      NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6),  -- 创建唯一索引，不允许重复  UNIQUE INDEX idx_user_mobile(`mobile`))ENGINE=InnoDB DEFAULT CHARSET=utf8</code></pre><p>3 crud比较简单，不谈</p><p>4 join用于多表连接，查询的通常是两个表的字段。</p><p>union用于组合同一种格式的多个select查询。</p><p>6 聚合函数，一般和group by一起使用，比如查找某部门员工的工资平均值。<br>就是select AVE(money) from departmentA group by department</p><p>7 建立索引</p><p>唯一索引(UNIQUE)<br>语法：ALTER TABLE 表名字 ADD UNIQUE (字段名字)</p><p>添加多列索引<br>语法：</p><p>ALTER TABLE table_name ADD INDEX index_name ( column1, column2, column3)</p><p>8 修改添加列</p><p>添加列<br>语法：alter table 表名 add 列名 列数据类型 [after 插入位置];</p><p>删除列<br>语法：alter table 表名 drop 列名称;</p><p>9 清空表数据<br>方法一：delete from 表名;<br>方法二：truncate from “表名”;</p><p>DELETE:1. DML语言;2. 可以回退;3. 可以有条件的删除;</p><p>TRUNCATE:1. DDL语言;2. 无法回退;3. 默认所有的表内容都删除;4. 删除速度比delete快。</p><h2 id="MySQL的存储原理"><a href="#MySQL的存储原理" class="headerlink" title="MySQL的存储原理"></a>MySQL的存储原理</h2><p>下面我们讨论的是innodb的存储原理</p><p>innodb的存储引擎将数据存储单元分为多层。按此不表</p><p>MySQL中的逻辑数据库只是一个shchme。事实上物理数据库只有一个。</p><p>mysql使用两个文件分别存储数据库的元数据和数据库的真正数据。</p><h3 id="数据页page"><a href="#数据页page" class="headerlink" title="数据页page"></a>数据页page</h3><p>数据页结构<br>页是 InnoDB 存储引擎管理数据的最小磁盘单位，而 B-Tree 节点就是实际存放表中数据的页面，我们在这里将要介绍页是如何组织和存储记录的；首先，一个 InnoDB 页有以下七个部分：</p><p><img src="https://raw.githubusercontent.com/Draveness/Analyze/master/contents/Database/images/mysql/InnoDB-B-Tree-Node.jpg" alt="InnoDB-B-Tree-Node"></p><p>每一个页中包含了两对 header/trailer：内部的 Page Header/Page Directory 关心的是页的状态信息，而 Fil Header/Fil Trailer 关心的是记录页的头信息。</p><pre><code>也就是说，外部的h-t对用来和其他页形成联系，而内部的h-t用来是保存内部记录的状态。</code></pre><p><img src="https://raw.githubusercontent.com/Draveness/Analyze/master/contents/Database/images/mysql/Infimum-Rows-Supremum.jpg" alt="https://raw.githubusercontent.com/Draveness/Analyze/master/contents/Database/images/mysql/Infimum-Rows-Supremum.jpg"></p><p>User Records 就是整个页面中真正用于存放行记录的部分，而 Free Space 就是空余空间了，它是一个链表的数据结构，为了保证插入和删除的效率，整个页面并不会按照主键顺序对所有记录进行排序，它会自动从左侧向右寻找空白节点进行插入，行记录在物理存储上并不是按照顺序的，它们之间的顺序是由 next_record 这一指针控制的。</p><pre><code>也就是说，一个页中存了非常多行的数据，而每一行数据和相邻行使用指针进行链表连接。</code></pre><h2 id="mysql的索引，b树，聚集索引"><a href="#mysql的索引，b树，聚集索引" class="headerlink" title="mysql的索引，b树，聚集索引"></a>mysql的索引，b树，聚集索引</h2><p>1 MySQL的innodb支持聚簇索引，myisam不支持聚簇索引。</p><p>innodb在建表时自动按照第一个非空字段或者主键建立聚簇索引。mysql使用B+树建立索引。</p><p>每一个非叶子结点只存储主键值，而叶子节点则是一个数据页，这个数据页就是上面所说的存储数据的page页。</p><p>一个节点页对应着多行数据，每个节点按照顺序使用指针连成一个链表。mysql使用索引访问一行数据时，先通过log2n的时间访问到叶子节点，然后在数据页中按照行数链表执行顺序查找，直到找到那一行数据。</p><p>2 b+树索引可以很好地支持范围搜索，因为叶子节点通过指针相连。</p><h2 id="mysql的explain-慢查询日志"><a href="#mysql的explain-慢查询日志" class="headerlink" title="mysql的explain 慢查询日志"></a>mysql的explain 慢查询日志</h2><p>explain主要用于检查sql语句的执行计划，然后分析sql是否使用到索引，是否进行了全局扫描等等。</p><p>mysql慢查询日志可以在mysql的,my.cnf文件中配置开启，然后执行操作超过设置时间就会记录慢日志。</p><p>比如分析一个sql：</p><pre><code>explain查看执行计划id    select_type    table    partitions    type    possible_keys    key    key_len    ref    rows    filtered    Extra1    SIMPLE    vote_record    \N    ALL    votenum,vote    \N    \N    \N    996507    50.00    Using where还是没用到索引，因为不符合最左前缀匹配。查询需要3.5秒左右最后修改一下sql语句EXPLAIN SELECT * FROM vote_record WHERE id &gt; 0 AND vote_num &gt; 1000;id    select_type    table    partitions    type    possible_keys    key    key_len    ref    rows    filtered    Extra1    SIMPLE    vote_record    \N    range    PRIMARY,votenum,vote    PRIMARY    4    \N    498253    50.00    Using where用到了索引，但是只用到了主键索引。再修改一次EXPLAIN SELECT * FROM vote_record WHERE id &gt; 0 AND vote_num = 1000;id    select_type    table    partitions    type    possible_keys    key    key_len    ref    rows    filtered    Extra1    SIMPLE    vote_record    \N    index_merge    PRIMARY,votenum,vote    votenum,PRIMARY    8,4    \N    51    100.00    Using intersect(votenum,PRIMARY); Using where用到了两个索引，votenum,PRIMARY。</code></pre><h2 id="mysql的binlog-redo-log和undo-log。"><a href="#mysql的binlog-redo-log和undo-log。" class="headerlink" title="mysql的binlog,redo log和undo log。"></a>mysql的binlog,redo log和undo log。</h2><p>binlog就是二进制日志，用于记录用户数据操作的日志。用于主从复制。</p><p>redolog负责事务的重做，记录事务中的每一步操作，记录完再执行操作，并且在数据刷入磁盘前刷入磁盘，保证可以重做成功。</p><p>undo日志负责事务的回滚，记录事务操作中的原值，记录完再执行操作，在事务提交前刷入磁盘，保证可以回滚成功。</p><p>这两个日志也是实现分布式事务的基础。</p><h2 id="mysql的数据类型"><a href="#mysql的数据类型" class="headerlink" title="mysql的数据类型"></a>mysql的数据类型</h2><p>mysql一般提供多种数据类型，int，double，varchar，tinyint，datatime等等。文本的话有fulltext，mediumtext等。没啥好说的。</p><h2 id="mysql的sql优化。"><a href="#mysql的sql优化。" class="headerlink" title="mysql的sql优化。"></a>mysql的sql优化。</h2><p>sql能优化的点是在有点多。</p><p>比如基本的，不使用null判断，不使用&gt;&lt;<br>分页的时候利用到索引，查询的时候注意顺序。</p><p>如果是基于索引的优化，则要注意索引列是否能够使用到</p><pre><code>1 索引列不要使用&gt;&lt; != 以及 null，还有exists等。2 索引列不要使用聚集函数。3 如果是联合索引，排在第一位的索引一定要用到，否则后面的也会失效，为什么呢，因为第一列索引不同时才会找第二列，如果没有第一列索引，后续的索引页没有意义。举个例子。联合索引A,B,C。查询时必须要用到A，但是A的位置无所谓，只要用到就行，A,B,C或者C,B,A都可以。4 分页时直接limit n 5可能用不到索引，假设索引列是ID，那么我们使用where id &gt; n limit 5就可以实现上述操作了。</code></pre><h2 id="MySQL的事务实现和锁"><a href="#MySQL的事务实现和锁" class="headerlink" title="MySQL的事务实现和锁"></a>MySQL的事务实现和锁</h2><p>innodb支持行级锁和事务，而myisam只支持表锁，它的所有操作都需要加锁。</p><p>1 锁</p><pre><code>锁可以分为共享锁和排它锁，也叫读锁和写锁。select操作默认不加锁，需要加锁时会用for update加排它锁，或者用in share mode表示加共享锁。这里的锁都是行锁。innodb会使用行锁配合mvcc一同完成事务的实现。并且使用next-key lock来实现可重复读，而不必加表锁或者串行化执行。</code></pre><p>2   MVCC</p><pre><code>MVCC是多版本控制协议。通过时间戳来判断先后顺序，并且是无锁的。但是需要额外存一个字段。读操作比较自己的版本号，自动读取比自己版本号新的版本。不读。写操作自动覆盖写版本号比自己的版本号早的版本。否则不写。这样保证一定程度上的一致性。MVCC比较好地支持读多写少的情景。但是偶尔需要加锁时才会进行加锁。</code></pre><p>3 事务</p><p>所以看看innodb如何实现事务的。</p><p>首先，innodb的行锁是加在索引上的，因为innodb默认有聚簇索引，但实际上的行锁是对整个索引节点进行加锁，锁了该节点所有的行。</p><p>看看innodb如何实现隔离级别以及解决一致问题</p><pre><code>未提交读，会导致脏读，没有并发措施已提交读，写入时需要加锁，使用行级写锁锁加锁指定行，其他事务就看不到未提交事务的数据了。但是会导致不可重读，可重复读：在原来基础上，在读取行时也需要加行级读锁，这样其他事务不能修改这些数据。就避免了不可重读。但是这样会导致幻读。序列化：序列化会串行化读写操作来避免幻读，事实上就是事务在读取数据时加了表级读锁。</code></pre><p>但是实际上。mysql的新版innodb引擎已经解决了幻读的问题，并且使用的是可重复读级别就能解决幻读了。</p><p>实现的原理是next-key lock。是gap lock的加强版。不会锁住全表，只会锁住被读取行前后的间隙行。</p><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>分库分表的方案比较多，首先看下分表。</p><p>当一个大表没办法继续优化的时候，可以使用分表，横向拆分的方案就是把一个表的数据放到多个表中。一般可以按照某个键来分表。比如最常用的id，1-100w放在表一。100w-200w在表二，以此类推。</p><p>如果是纵向分表，则可以按列拆分，比如用户信息的字段放在一个表，用户使用数据放在另一个表，这其实就是一次性拆表了。</p><p>分库的话就是把数据表存到多个库中了，和横向分表的效果差不多。</p><p>如果只是单机的分表分库，其性能瓶颈在于主机。</p><p>我们需要考虑扩展性，所以需要使用分布式的数据库。</p><p>==分布式数据库解决方案mycat==</p><pre><code>mycat是一款支持分库分表的数据库中间件，支持单机也支持分布式。首先部署mycat，mycat的访问方式和一个mysqlserver是类似的。里面可以配置数据库和数据表。然后在mycat的配置文件中，我们可以指定分片，比如按照id分片，然后在每个分片下配置mysql节点，可以是本地的数据库实例也可以是其他主机上的数据库。这样的话，每个分片都能找到对应机器上的数据库和表了。用户连接mycat执行数据库操作，实际上会根据id映射到对应的数据库和表中，</code></pre><h2 id="主从复制，读写分离"><a href="#主从复制，读写分离" class="headerlink" title="主从复制，读写分离"></a>主从复制，读写分离</h2><p>主从复制大法好，为了避免单点mysql宕机和丢失数据，我们一般使用主从部署，主节点将操作日志写入binlog，然后日志文件通过一个连接传给从节点的relaylog。从节点定时去relaylog读取日志，并且执行操作。这样保证了主从的同步。</p><p>读写分离大法好，为了避免主库的读写压力太大，由于业务以读操作为主，所以主节点一般作为主库，读节点作为从库，从库负责读，主库负责写，写入主库的数据通过日志同步给从库。这样的部署就是读写分离。</p><p>使用mycat中间件也可以配置读写分离，只需在分片时指定某个主机是读节点还是写节点即可。</p><h2 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h2><p>分布式关系数据库无非就是关系数据库的分布式部署方案。</p><p>真正的分布式数据库应该是nosql数据库，比如基于hdfs的hbase数据库。底层就是分布式的。</p><p>redis的分布式部署方案也比较成熟。</p><p>##</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文根据自己对MySQL的学习和实践以及各类文章与书籍总结而来。&lt;br&gt;囊括了MySQL数据库的基本原理和技术。本文主要是我的一个学习总结，基于之前的系列文章做了一个概括，如有错误，还望指出，谢谢。&lt;/p&gt;
&lt;p&gt;详细内容请参考我的系列文章：&lt;/p&gt;
&lt;p&gt;重新学习MySQL与Redis&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/21877.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21877.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="技术总结" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Mysql" scheme="http://h2pl.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Spring与SpringMVC源码解析总结</title>
    <link href="http://h2pl.github.io/2018/07/08/Spring%E4%B8%8ESpringMVC%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E6%80%BB%E7%BB%93/"/>
    <id>http://h2pl.github.io/2018/07/08/Spring与SpringMVC源码解析总结/</id>
    <published>2018-07-08T14:13:58.000Z</published>
    <updated>2018-07-09T00:28:31.703Z</updated>
    
    <content type="html"><![CDATA[<p>这篇总结主要是基于我之前Spring和SpringMVC源码系列文章而形成的的。主要是把重要的知识点用自己的话说了一遍，可能会有一些错误，还望见谅和指点。谢谢</p><p>更多详细内容可以查看我的专栏文章：#Spring和SpringMVC源码解析<br><a href="https://blog.csdn.net/column/details/21851.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21851.html</a></p><a id="more"></a><h1 id="Spring和SpringMVC"><a href="#Spring和SpringMVC" class="headerlink" title="Spring和SpringMVC"></a>Spring和SpringMVC</h1><p>Spring是一个框架，除了提供IOC和AOP以外，还加入了web等众多内容。</p><p>1 IOC：控制反转，改变类实例化的方式，通过xml等配置文件指定接口的实现类，让实现类和代码解耦，通过配置文件灵活调整实现类。</p><p>2 AOP: 面向切面编程，将切面代码封装，比如权限验证，日志模块等，这些逻辑重复率大，通过一个增强器封装功能，然后定义需要加入这些功能的切面，切面一般用表达式或者注解去匹配方法，可以完成前置和后置的处理逻辑。</p><p>3 SpringMVC是一个web框架，基于Spring之上，实现了web相关的功能，使用dispatcherservlet作为一切请求的处理入口。通过配置viewresolver解析页面，通过配置管理静态文件，还可以注入其他的配置信息，除此之外，springmvc可以访问spring容器的所有bean。</p><h2 id="Spring源码总结"><a href="#Spring源码总结" class="headerlink" title="Spring源码总结"></a>Spring源码总结</h2><p>IOC:</p><p>1 Spring的bean容器也叫beanfactory，我们常用的applicationcontext实际上内部有一个listablebeanfactory实际存储bean的map。</p><p>2 bean加载过程：spring容器加载时先读取配置文件，一般是xml，然后解析xml，找到其中所有bean，依次解析，然后生成每个bean的beandefinition，存在一个map中，根据beanid映射实际bean的map。</p><p>3 bean初始化：加载完以后，如果不启用懒加载模式，则默认使用单例加载，在注册完bean以后，可以获取到beandefinition信息，然后根据该信息首先先检查依赖关系，如果依赖其他bean则先加载其他bean，然后通过反射的方式即newinstance创建一个单例bean。</p><p>为什么要用反射呢，因为实现类可以通过配置改变，但接口是一致的，使用反射可以避免实现类改变时无法自动进行实例化。</p><p>当然，bean也可以使用原型方式加载，使用原型的话，每次创建bean都会是全新的。</p><p>AOP:</p><p>AOP的切面，切点，增强器一般也是配置在xml文件中的，所以bean容器在解析xml时会找到这些内容，并且首先创建增强器bean的实例。</p><p>基于上面创建bean的过程，AOP起到了什么作用呢，或者是是否有参与到其中呢，答案是有的。</p><p>在获得beandefinition的时候，spring容器会检查该bean是否有aop切面所修饰，是否有能够匹配切点表达式的方法，如果有的话，在创建bean之前，会将bean重新封装成一个动态代理的对象。</p><p>代理类会为bean增加切面中配置的advisor增强器，然后返回bean的时候实际上返回的是一个动态代理对象。</p><p>所以我们在调用bean的方法时，会自动织入切面的增强器，当然，动态代理既可以选择jdk增强器，也可以选择cglib增强器。</p><p>Spring事务：</p><p>spring事务其实是一种特殊的aop方式。在spring配置文件中配置好事务管理器和声明式事务注解后，就可以使用@transactional进行事务方法的处理了。</p><p>事务管理器的bean中会配置基本的信息，然后需要配置事务的增强器，不同方法使用不同的增强器。当然如果使用注解的话就不用这么麻烦了。</p><p>然后和aop的动态代理方式类似，当Spring容器为bean生成代理时，会注入事务的增强器，其中实际上实现了事务中的begin和commit，所以执行方法的过程实际上就是在事务中进行的。</p><h1 id="SpringMVC源码总结"><a href="#SpringMVC源码总结" class="headerlink" title="SpringMVC源码总结"></a>SpringMVC源码总结</h1><p>1 dispatcherservlet概述<br>SpringMVC使用dispatcherservlet作为唯一如果，在web.xml中进行配置，他继承自frameworkservlet，向上继承自httpservletbean。</p><p>httpservletbean为dispatcherservlet加载了来自web.xml配置信息中的信息，保存在servletcontext上下文中，而frameworkservletbean则初始化了spring web的bean容器。</p><p>这个容器一般是配置在spring-mvc.xml中的，他独立于spring容器，但是把spring容器作为父容器，所以SpringMVC可以访问spring容器中的各种类。</p><p>而dispatcherservlet自己做了什么呢，因为springmvc中配置了很多例如静态文件目录，自动扫描bean注解，以及viewresovler和httpconverter等信息，所以它需要初始化这些策略，如果没有配置则会使用默认值。</p><p>2 dispatcherservlet的执行流程</p><p>首先web容器会加载指定扫描bean并进行初始化。</p><p>当请求进来后，首先执行service方法，然后到dodispatch方法执行请求转发，事实上，spring web容器已经维护了一个map，通过注解@requestmapping映射到对应的bean以及方法上。通过这个map可以获取一个handlerchain，真正要执行的方法被封装成一个handler，并且调用方法前要执行前置的一些过滤器。</p><p>最终执行handler方法时实际上就是去执行真正的方法了。</p><p>3 viewresolver</p><p>解析完请求和执行完方法，会把modelandview对象解析成一个view对象，让后使用view.render方法执行渲染，至于使用什么样的视图解析器，就是由你配置的viewresolver来决定的，一般默认是jspviewresolver。</p><p>4 httpmessageconverter</p><p>一般配合responsebody使用，可以将数据自动转换为json和xml，根据http请求中适配的数据类型来决定使用哪个转换器。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇总结主要是基于我之前Spring和SpringMVC源码系列文章而形成的的。主要是把重要的知识点用自己的话说了一遍，可能会有一些错误，还望见谅和指点。谢谢&lt;/p&gt;
&lt;p&gt;更多详细内容可以查看我的专栏文章：#Spring和SpringMVC源码解析&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/21851.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21851.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="技术总结" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Spring" scheme="http://h2pl.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb技术总结</title>
    <link href="http://h2pl.github.io/2018/07/08/JavaWeb%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    <id>http://h2pl.github.io/2018/07/08/JavaWeb技术总结/</id>
    <published>2018-07-08T14:13:33.000Z</published>
    <updated>2018-07-09T00:26:09.727Z</updated>
    
    <content type="html"><![CDATA[<p>这篇总结主要是基于我之前两个系列的文章而来。主要是把重要的知识点用自己的话说了一遍，可能会有一些错误，还望见谅和指点。谢谢</p><p>更多详细内容可以查看我的专栏文章：</p><p>JavaWeb技术世界</p><p><a href="https://blog.csdn.net/column/details/21850.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21850.html</a></p><a id="more"></a><h2 id="Servlet及相关类"><a href="#Servlet及相关类" class="headerlink" title="Servlet及相关类"></a>Servlet及相关类</h2><p>servlet是一个接口，它的实现类有GenericServlet，而httpservlet是GenericServlet的一个子类，一般我们都会使用这个类。</p><p>servletconfig是用于保存servlet配置信息的数据结构，而servletcontext则负责保持servlet的上下文，web应用启动时加载web.xml信息于servletconfig中。</p><h2 id="Jsp和ViewResolver"><a href="#Jsp和ViewResolver" class="headerlink" title="Jsp和ViewResolver"></a>Jsp和ViewResolver</h2><p>jsp页面需要编译成class文件并通过tomcat的类加载器进行加载，形成servlet实例，请求到来时实际上执行的是servlet代码，然后最终再通过viewresolver渲染成页面。</p><h2 id="filter，listener"><a href="#filter，listener" class="headerlink" title="filter，listener"></a>filter，listener</h2><p>filter是过滤器，也需要在web.xml中配置，是责任链式的调用，在servlet执行service方法前执行。<br>listener则是监听器，由于容器组件都实现了lifecycle接口，所以可以在组件上添加监听器来控制生命周期。</p><h2 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h2><p>web.xml用来配置servlet和servlet的配置信息，listener和filter。也可以配置静态文件的目录等。</p><h2 id="war包"><a href="#war包" class="headerlink" title="war包"></a>war包</h2><p>waWAR包<br>WAR(Web Archive file)网络应用程序文件，是与平台无关的文件格式，它允许将许多文件组合成一个压缩文件。war专用在web方面 。</p><p>JAVA WEB工程，都是打成WAR包进行发布。</p><p>典型的war包内部结构如下：</p><p>webapp.war</p><p>  |    index.jsp</p><p>  |</p><p>  |— images</p><p>  |— META-INF</p><p>  |— WEB-INF</p><pre><code>|   web.xml                   // WAR包的描述文件||— classes|          action.class       // java类文件||— lib          other.jar             // 依赖的jar包          share.jar</code></pre><h2 id="tomcat基础"><a href="#tomcat基础" class="headerlink" title="tomcat基础"></a>tomcat基础</h2><p>上一篇文章关于网络编程和NIO已经讲过了，这里按住不表。</p><h2 id="log4j"><a href="#log4j" class="headerlink" title="log4j"></a>log4j</h2><p>log4j是非常常用的日志组件，不过现在为了使用更通用的日志组件，一般使用slf4j来配置日志管理器，然后再介入日志源，比如log4j这样的日志组件。</p><h2 id="数据库驱动和连接池"><a href="#数据库驱动和连接池" class="headerlink" title="数据库驱动和连接池"></a>数据库驱动和连接池</h2><p>一般我们会使用class.forname加载数据库驱动，但是随着Spring的发展，现在一般会进行数据源DataSource这个bean的配置，bean里面填写你的数据来源信息即可，并且在实现类中可以选择支持连接池的数据源实现类，比如c3poDataSource，非常方便。</p><p>数据库连接池本身和线程池类似，就是为了避免频繁建立数据库连接，保存了一部分连接并存放在集合里，一般可以用队列来存放。</p><p>除此之外，还可以使用tomcat的配置文件来管理数据库连接池，只需要简单的一些配置，就可以让tomcat自动管理数据库的连接池了。<br>应用需要使用的时候，通过jndi的方式访问即可，具体方法就是调用jndi命名服务的look方法。</p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>单元测试是工程中必不可少的组件，maven项目在打包期间会自动运行所有单元测试。一般我们使用junit做单元测试，统一地在test包中分别测试service和dao层，并且使用mock方法来构造假的数据，以便跳过数据库或者其他外部资源来完成测试。</p><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>maven是一个项目构建工具，基于约定大于配置的方式，规定了一个工程各个目录的用途，并且根据这些规则进行编译，测试和打包。<br>同时他提供了方便的包管理方式，以及快速部署的优势。</p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>git是分布式的代码管理工具，比起svn有着分布式的优势。太过常见了，略了。</p><h2 id="Json和xml"><a href="#Json和xml" class="headerlink" title="Json和xml"></a>Json和xml</h2><p>数据描述形式不同，json更简洁。</p><h2 id="hibernate和mybatis"><a href="#hibernate和mybatis" class="headerlink" title="hibernate和mybatis"></a>hibernate和mybatis</h2><p>由于jdbc方式的数据库连接和语句执行太过繁琐，重复代码太多，后来提出了jdbctemplate对数据进行bean转换。</p><p>但是还是差强人意，于是转而出现了hibernate这类的持久化框架。可以做到数据表和bean一一映射，程序只需要操作bean就可以完成数据库的curd。</p><p>mybatis比hibernate更轻量级，mybatis支持原生sql查询，并且也可以使用bean映射，同时还可以自定义地配置映射对象，更加灵活，并且在多表查询上更有优势。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇总结主要是基于我之前两个系列的文章而来。主要是把重要的知识点用自己的话说了一遍，可能会有一些错误，还望见谅和指点。谢谢&lt;/p&gt;
&lt;p&gt;更多详细内容可以查看我的专栏文章：&lt;/p&gt;
&lt;p&gt;JavaWeb技术世界&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/21850.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21850.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="技术总结" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaWeb" scheme="http://h2pl.github.io/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JVM原理学习总结</title>
    <link href="http://h2pl.github.io/2018/07/08/JVM%E6%80%BB%E7%BB%93/"/>
    <id>http://h2pl.github.io/2018/07/08/JVM总结/</id>
    <published>2018-07-08T14:09:47.000Z</published>
    <updated>2018-07-09T00:26:36.365Z</updated>
    
    <content type="html"><![CDATA[<p>这篇总结主要是基于我之前JVM系列文章而形成的的。主要是把重要的知识点用自己的话说了一遍，可能会有一些错误，还望见谅和指点。谢谢</p><p>更多详细内容可以查看我的专栏文章：深入理解JVM虚拟机</p><p><a href="https://blog.csdn.net/column/details/21960.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21960.html</a><br><a id="more"></a></p><h2 id="JVM介绍和源码"><a href="#JVM介绍和源码" class="headerlink" title="JVM介绍和源码"></a>JVM介绍和源码</h2><p>首先JVM是一个虚拟机，当你安装了jre，它就包含了jvm环境。JVM有自己的内存结构，字节码执行引擎，因此class字节码才能在jvm上运行，除了Java以外，Scala，groovy等语言也可以编译成字节码而后在jvm中运行。JVM是用c开发的。</p><h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p>内存模型老生常谈了，主要就是线程共享的堆区，方法区，本地方法栈。还有线程私有的虚拟机栈和程序计数器。</p><p>堆区存放所有对象，每个对象有一个地址，Java类jvm初始化时加载到方法区，而后会在堆区中生成一个Class对象，来负责这个类所有实例的实例化。</p><p>栈区存放的是栈帧结构，栈帧是一段内存空间，包括参数列表，返回地址，局部变量表等，局部变量表由一堆slot组成，slot的大小固定，根据变量的数据类型决定需要用到几个slot。</p><p>方法区存放类的元数据，将原来的字面量转换成引用，当然，方法区也提供常量池，常量池存放-128到127的数字类型的包装类。<br>字符串常量池则会存放使用intern的字符串变量。</p><h2 id="JVM-OOM和内存泄漏"><a href="#JVM-OOM和内存泄漏" class="headerlink" title="JVM OOM和内存泄漏"></a>JVM OOM和内存泄漏</h2><p>这里指的是oom和内存泄漏这类错误。</p><p>oom一般分为三种，堆区内存溢出，栈区内存溢出以及方法区内存溢出。</p><p>堆内存溢出主要原因是创建了太多对象，比如一个集合类死循环添加一个数，此时设置jvm参数使堆内存最大值为10m，一会就会报oom异常。</p><p>栈内存溢出主要与栈空间和线程有关，因为栈是线程私有的，如果创建太多线程，内存值超过栈空间上限，也会报oom。</p><p>方法区内存溢出主要是由于动态加载类的数量太多，或者是不断创建一个动态代理，用不了多久方法区内存也会溢出，会报oom，这里在1.7之前会报permgem oom，1.8则会报meta space oom，这是因为1.8中删除了堆中的永久代，转而使用元数据区。</p><p>内存泄漏一般是因为对象被引用无法回收，比如一个集合中存着很多对象，可能你在外部代码把对象的引用置空了，但是由于对象还被集合给引用着，所以无法被回收，导致内存泄漏。测试也很简单，就在集合里添加对象，添加完以后把引用置空，循环操作，一会就会出现oom异常，原因是内存泄漏太多了，导致没有空间分配新的对象。</p><h2 id="常见调试工具"><a href="#常见调试工具" class="headerlink" title="常见调试工具"></a>常见调试工具</h2><p>命令行工具有jstack jstat jmap 等，jstack可以跟踪线程的调用堆栈，以便追踪错误原因。</p><p>jstat可以检查jvm的内存使用情况，gc情况以及线程状态等。</p><p>jmap用于把堆栈快照转储到文件系统，然后可以用其他工具去排查。</p><p>visualvm是一款很不错的gui调试工具，可以远程登录主机以便访问其jvm的状态并进行监控。</p><h2 id="class文件结构"><a href="#class文件结构" class="headerlink" title="class文件结构"></a>class文件结构</h2><p>class文件结构比较复杂，首先jvm定义了一个class文件的规则，并且让jvm按照这个规则去验证与读取。</p><p>开头是一串魔数，然后接下来会有各种不同长度的数据，通过class的规则去读取这些数据，jvm就可以识别其内容，最后将其加载到方法区。</p><h2 id="JVM的类加载机制"><a href="#JVM的类加载机制" class="headerlink" title="JVM的类加载机制"></a>JVM的类加载机制</h2><p>jvm的类加载顺序是bootstrap类加载器，extclassloader加载器，最后是appclassloader用户加载器，分别加载的是jdk/bin ，jdk/ext以及用户定义的类目录下的类（一般通过ide指定），一般核心类都由bootstrap和ext加载器来加载，appclassloader用于加载自己写的类。</p><p>双亲委派模型，加载一个类时，首先获取当前类加载器，先找到最高层的类加载器bootstrap让他尝试加载，他如果加载不了再让ext加载器去加载，如果他也加载不了再让appclassloader去加载。这样的话，确保一个类型只会被加载一次，并且以高层类加载器为准，防止某些类与核心类重复，产生错误。</p><h2 id="defineclass-findclass和loadclass"><a href="#defineclass-findclass和loadclass" class="headerlink" title="defineclass findclass和loadclass"></a>defineclass findclass和loadclass</h2><p>类加载classloader中有两个方法loadclass和findclass，loadclass遵从双亲委派模型，先调用父类加载的loadclass，如果父类和自己都无法加载该类，则会去调用findclass方法，而findclass默认实现为空，如果要自定义类加载方式，则可以重写findclass方法。</p><p>常见使用defineclass的情况是从网络或者文件读取字节码，然后通过defineclass将其定义成一个类，并且返回一个Class对象，说明此时类已经加载到方法区了。当然1.8以前实现方法区的是永久代，1.8以后则是元空间了。</p><h2 id="JVM虚拟机字节码执行引擎"><a href="#JVM虚拟机字节码执行引擎" class="headerlink" title="JVM虚拟机字节码执行引擎"></a>JVM虚拟机字节码执行引擎</h2><p>jvm通过字节码执行引擎来执行class代码，他是一个栈式执行引擎。这部分内容比较高深，在这里就不献丑了。</p><h2 id="编译期优化和运行期优化"><a href="#编译期优化和运行期优化" class="headerlink" title="编译期优化和运行期优化"></a>编译期优化和运行期优化</h2><p>编译期优化主要有几种</p><p>1 泛型的擦除，使得泛型在编译时变成了实际类型，也叫伪泛型。</p><p>2 自动拆箱装箱，foreach循环自动变成迭代器实现的for循环。</p><p>3 条件编译，比如if(true)直接可得。</p><p>运行期优化主要有几种</p><p>1 JIT即时编译</p><p>Java既是编译语言也是解释语言，因为需要编译代码生成字节码，而后通过解释器解释执行。</p><p>但是，有些代码由于经常被使用而成为热点代码，每次都编译太过费时费力，干脆直接把他编译成本地代码，这种方式叫做JIT即时编译处理，所以这部分代码可以直接在本地运行而不需要通过jvm的执行引擎。</p><p>2 公共表达式擦除，就是一个式子在后面如果没有被修改，在后面调用时就会被直接替换成数值。</p><p>3 数组边界擦除，方法内联，比较偏，意义不大。</p><p>4 逃逸分析，用于分析一个对象的作用范围，如果只局限在方法中被访问，则说明不会逃逸出方法，这样的话他就是线程安全的，不需要进行并发加锁。</p><p>1</p><h2 id="JVM的垃圾回收"><a href="#JVM的垃圾回收" class="headerlink" title="JVM的垃圾回收"></a>JVM的垃圾回收</h2><p>1 GC算法：停止复制，存活对象少时适用，缺点是需要两倍空间。标记清除，存活对象多时适用，但是容易产生随便。标记整理，存活对象少时适用，需要移动对象较多。</p><p>2 GC分区，一般GC发生在堆区，堆区可分为年轻代，老年代，以前有永久代，现在没有了。</p><p>年轻代分为eden和survior，新对象分配在eden，当年轻代满时触发minor gc，存活对象移至survivor区，然后两个区互换，等待下一场gc，<br>当对象存活的阈值达到设定值时进入老年代，大对象也会直接进入老年代。</p><p>老年代空间较大，当老年代空间不足以存放年轻代过来的对象时，开始进行full gc。同时整理年轻代和老年代。<br>一般年轻代使用停止复制，老年代使用标记清除。</p><p>3 垃圾收集器</p><p>serial串行</p><p>parallel并行</p><p>它们都有年轻代与老年代的不同实现。</p><p>然后是scanvage收集器，注重吞吐量，可以自己设置，不过不注重延迟。</p><p>cms垃圾收集器，注重延迟的缩短和控制，并且收集线程和系统线程可以并发。</p><p>cms收集步骤主要是，初次标记gc root，然后停顿进行并发标记，而后处理改变后的标记，最后停顿进行并发清除。</p><p>g1收集器和cms的收集方式类似，但是g1将堆内存划分成了大小相同的小块区域，并且将垃圾集中到一个区域，存活对象集中到另一个区域，然后进行收集，防止产生碎片，同时使分配方式更灵活，它还支持根据对象变化预测停顿时间，从而更好地帮用户解决延迟等问题。</p><h2 id="JVM的锁优化"><a href="#JVM的锁优化" class="headerlink" title="JVM的锁优化"></a>JVM的锁优化</h2><p>在Java并发中讲述了synchronized重量级锁以及锁优化的方法，包括轻量级锁，偏向锁，自旋锁等。详细内容可以参考我的专栏：Java并发技术指南</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇总结主要是基于我之前JVM系列文章而形成的的。主要是把重要的知识点用自己的话说了一遍，可能会有一些错误，还望见谅和指点。谢谢&lt;/p&gt;
&lt;p&gt;更多详细内容可以查看我的专栏文章：深入理解JVM虚拟机&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/21960.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21960.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="技术总结" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JVM" scheme="http://h2pl.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程与NIO学习总结</title>
    <link href="http://h2pl.github.io/2018/07/08/Java%E7%BD%91%E7%BB%9C%E4%B8%8ENIO%E6%80%BB%E7%BB%93/"/>
    <id>http://h2pl.github.io/2018/07/08/Java网络与NIO总结/</id>
    <published>2018-07-08T14:08:22.000Z</published>
    <updated>2018-07-09T00:26:53.093Z</updated>
    
    <content type="html"><![CDATA[<p>这篇总结主要是基于我之前Java网络编程与NIO系列文章而形成的的。主要是把重要的知识点用自己的话说了一遍，可能会有一些错误，还望见谅和指点。谢谢</p><p>更多详细内容可以查看我的专栏文章：Java网络编程与NIO</p><p><a href="https://blog.csdn.net/column/details/21963.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21963.html</a><br><a id="more"></a></p><h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><p>Java IO的基础知识已在前面讲过</p><h2 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h2><p>socket是操作系统提供的网络编程接口，他封装了对于TCP/IP协议栈的支持，用于进程间的通信，当有连接接入主机以后，操作系统自动为其分配一个socket套接字，套接字绑定着一个IP与端口号。通过socket接口，可以获取tcp连接的输入流和输出流，并且通过他们进行读取和写入此操作。</p><p>Java提供了net包用于socket编程，同时支持像Inetaddress，URL等工具类，使用socket绑定一个endpoint（ip+端口号），可以用于客户端的请求处理和发送，使用serversocket绑定本地ip和端口号，可以用于服务端接收TCP请求。</p><h2 id="客户端，服务端的线程模型"><a href="#客户端，服务端的线程模型" class="headerlink" title="客户端，服务端的线程模型"></a>客户端，服务端的线程模型</h2><p>一般客户端使用单线程模型即可，当有数据到来时启动线程读取，需要写入数据时开启线程进行数据写入。</p><p>服务端一般使用多线程模型，一个线程负责接收tcp连接请求，每当接收到请求后开启一个线程处理它的读写请求。</p><p>udp的客户端和服务端就比较简单了，由于udp数据报长度是确定的，只需要写入一个固定的缓存和读取一个固定的缓存空间即可。</p><p>一般通过DatagramPacket包装一个udp数据报，然后通过DatagramSocket发送</p><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>上述的socket在处理IO请求时使用的是阻塞模型。</p><p>于是我们还是得来探讨一下IO模型。</p><p>一般认为，应用程序处理IO请求需要将内核缓存区中的数据拷贝到用户缓冲区。这个步骤可以通过系统调用来完成，而用户程序处理IO请求的时候，需要先检查用户缓冲区是否准备好了数据，这个操作是系统调用recevfrom，如果数据没有准备好，默认会阻塞调用该方法的线程。</p><p>这样就导致了线程处理IO请求需要频繁进行阻塞，特别是并发量大的时候，线程切换的开销巨大。</p><p>一般认为有几种IO模型</p><p>1 阻塞IO ：就是线程会阻塞在系统调用recevfrom上，并且等待数据准备就绪以后才会返回。</p><p>2 非阻塞IO : 不阻塞在系统调用recevfrom，而是通过自旋忙等的方式不断询问缓冲区数据是否准备就绪，避免线程阻塞的开销。</p><p>3 IO多路复用 ：使用IO多路复用器管理socket，由于每个socket是一个文件描述符，操作系统可以维护socket和它的连接状态，一般分为可连接，可读和可写等状态。</p><p>每当用户程序接受到socket请求，将请求托管给多路复用器进行监控，当程序对请求感兴趣的事件发生时，多路复用器以某种方式通知或是用户程序自己轮询请求，以便获取就绪的socket，然后只需使用一个线程进行轮询，多个线程处理就绪请求即可。</p><p>IO多路复用避免了每个socket请求都需要一个线程去处理，而是使用事件驱动的方式，让少数的线程去处理多数socket的IO请求。</p><p>Linux操作系统对IO多路复用提供了较好的支持，select，poll，epoll是Linux提供的支持IO多路复用的API。一般用户程序基于这个API去开发自己的IO复用模型。比如NIO的非阻塞模型，就是采用了IO多路复用的方式，是基于epoll实现的。</p><p>3.1 select方式主要是使用数组来存储socket描述符，系统将发生事件的描述符做标记，然后IO复用器在轮询描述符数组的时候，就可以知道哪些请求是就绪了的。缺点是数组的长度只能到1024，并且需要不断地在内核空间和用户空间之间拷贝数组。</p><p>3.2 poll方式不采用数组存储描述符，而是使用独立的数据结构来描述，并且使用id来表示描述符，能支持更多的请求数量，缺点和select方式有点类似，就是轮询的效率很低，并且需要拷贝数据。</p><p>当然，上述两种方法适合在请求总数较少，并且活跃请求数较多的情况，这种场景下他们的性能还是不错的。</p><p>3.3 epoll</p><p>epoll函数会在内核空间开辟一个特殊的数据结构，红黑树，树节点中存放的是一个socket描述符以及用户程序感兴趣的事件类型。同时epoll还会维护一个链表。用于存储已经就绪的socket描述符节点。</p><p>由Linux内核完成对红黑树的维护，当事件到达时，内核将就绪的socket节点加入链表中，用户程序可以直接访问这个链表以便获取就绪的socket。</p><p>当然了，这些操作都linux包装在epoll的api中了。</p><p>epoll_create函数会执行红黑树的创建操作。</p><p>epoll_ctl函数会将socket和感兴趣的事件注册到红黑树中。</p><p>epoll_wait函数会等待内核空间发来的链表，从而执行IO请求。</p><p>epoll的水平触发和边缘触发有所区别，水平触发的意思是，如果用户程序没有执行就绪链表里的任务，epoll仍会不断通知程序。</p><p>而边缘触发只会通知程序一次，之后socket的状态不发生改变epoll就不会再通知程序了。</p><p>4 信号驱动<br>略</p><p>5 异步非阻塞</p><p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p><p>事实上就是，用户提交IO请求，然后直接返回，并且内核自动完成将数据从内核缓冲区复制到用户缓冲区，完成后再通知用户。</p><p>当然，内核通知我们以后我们还需要执行剩余的操作，但是我们的代码已经继续往下运行了，所以AIO采用了回调的机制，为每个socket注册一个回调事件或者是回调处理器，在处理器中完成数据的操作，也就是内核通知到用户的时候，会自动触发回调函数，完成剩余操作。<br>这样的方式就是异步的网络编程。</p><p>但是，想要让操作系统支持这样的功能并非易事，windows的IOCP可以支持AIO方式，但是Linux的AIO支持并不是很好</p><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>由于Java原生的socket只支持阻塞方式处理IO</p><p>所以Java后来推出了新版IO 也叫New IO = NIO</p><p>NIO提出了socketChannel，serversocketchannel，bytebuffer，selector和selectedkey等概念。</p><p>1 socketchannel其实就是socket的替代品，他的好处是多个socket可以复用同一个bytebuffer，因为socket是从channel里打开的，所以多个socket都可以访问channel绑定着的buffer。</p><p>2 serversocketchannel顾名思义，是用在服务端的channel。</p><p>3 bytebuffer以前对用户是透明的，用户直接操作io流即可，所以之前的socket io操作都是阻塞的，引入bytebuffer以后，用户可以更灵活地进行io操作。</p><p>buffer可以分为不同数据类型的buffer，但是常用的还是bytebuffer。写入数据时按顺序写入，写入完使用flip方法反转缓冲区，让接收端反向读取。这个操作比较麻烦，后来的netty对缓冲区进行了重新封装，封装了这个经常容易出错的方法。</p><p>4 selector其实就是对io多路复用器的封装，一般基于linux的epoll来实现。<br>socket把感兴趣的事件和描述符注册到selector上，然后通过遍历selectedKey来获取感兴趣的请求，进行IO操作。<br>selectedkey应该就是epoll中就绪链表的实现了。</p><p>5 所以一般的流程是：<br>新建一个serversocket，启动一个线程进行while循环，当有请求接入时，使用accept方法阻塞获取socket，然后将socket和感兴趣的事件注册到selector上。再开启一个线程轮询selectoredKey，当请求就绪时开启一个线程去处理即可。</p><h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><p>后来NIO发展到2.0，Java又推出了AIO 的API，与上面描述的异步非阻塞模型类似。</p><p>AIO使用回调的方式处理IO请求，在socket上注册一个回调函数，然后提交请求后直接返回。由操作系统完成数据拷贝操作，需要操作系统对AIO的支持。</p><p>AIO的具体使用方式还是比较复杂的，感兴趣的可以自己查阅资料。</p><h2 id="Tomcat中的NIO模型"><a href="#Tomcat中的NIO模型" class="headerlink" title="Tomcat中的NIO模型"></a>Tomcat中的NIO模型</h2><p>Tomcat作为一个应用服务器，分为connector和container两个部分，connector负责接收请求，而container负责解析请求。</p><p>一般connector负责接收http请求，当然首先要建立tcp连接，所以涉及到了如何处理连接和IO请求。</p><p>Tomcat使用endpoint的概念来绑定一个ip+port，首先，使用acceptor循环等待连接请求。然后开启一个线程池，也叫poller池，每个请求绑定一个poller进行后续处理，poller将socket请求封装成一个事件，并且将这个事件注册到selector中。</p><p>poller还需要维护一个事件列表，以便获取selector上就绪的事件。然后poller再去列表中获取就绪的请求，将其封装成processor，交给后续的worker线程池，会有worker将其提交给container流程中进行处理。</p><p>当然，到达container之后还有非常复杂的处理过程，稍微提几个点。</p><h2 id="Tomcat的container"><a href="#Tomcat的container" class="headerlink" title="Tomcat的container"></a>Tomcat的container</h2><p>container是一个多级容器，最外层到最内层依次是engine，host，context和wrapper</p><p>下面是个server.xml文件实例，Tomcat根据该文件进行部署</p><server>                                                //顶层类元素，可以包括多个Service<br>    <service>                                           //顶层类元素，可包含一个Engine，多个Connecter<br>        <connector>                                     //连接器类元素，代表通信接口<br>                <engine>                                //容器类元素，为特定的Service组件处理客户请求，要包含多个Host<br>                        <host>                          //容器类元素，为特定的虚拟主机组件处理客户请求，可包含多个Context<br>                                <context>               //容器类元素，为特定的Web应用处理所有的客户请求<br>                                </context><br>                        </host><br>                </engine><br>        </connector><br>    </service><br></server><p>根据配置文件初始化容器信息，当请求到达时进行容器间的请求传递，事实上整个链条被称作pipeline，pipeline连接了各个容器的入口，由于每个容器和组件都实现了lifecycle接口。</p><p>tomcat可以在任意流程中通过加监听器的方式监听组件的生命周期，也就能够控制整个运行的流程，通过在pipeline上增加valve可以增加一些自定义的操作。</p><p>一般到wrapper层才开始真正的请求解析，因为wrapper其实就是对servlet的简单封装，此时进来的请求和响应已经是httprequest和httpresponse，很多信息已经解析完毕，只需要按照service方法执行业务逻辑即可，当然在执行service方法之前，会调用filter链先执行过滤操作。</p><h2 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h2><p>netty我也不是很在行，这里简单总结一下</p><p>netty是一个基于事件驱动的网络编程框架。</p><p>因为直接基于Java NIO编程复杂度太高，而且容易出错，于是netty对NIO进行了改造和封装。形成了一个比较完整的网络框架，可以通过他实现rpc，http服务。</p><p>先了解一下两种线程模型。reactor和proactor。</p><p>1 reactor就是netty采用的模型，首先也是使用一个acceptor线程接收连接请求，然后开启一个线程组reactor thread pool。</p><p>server会事先在endpoint上注册一系列的回调方法，然后接收socket请求后交给底层的selector进行管理，当selector对应的事件响应以后，会通知用户进程，然后reactor工作线程会执行接下来的IO请求，执行操作是写在回调处理器中的。</p><p>其实netty 支持三种reactor模型<br>1.1.Reactor单线程模型：Reactor单线程模型，指的是所有的I/O操作都在同一个NIO线程上面完成。对于一些小容量应用场景，可以使用单线程模型。</p><p>1.2.Reactor多线程模型：Rector多线程模型与单线程模型最大的区别就是有一组NIO线程处理I/O操作。主要用于高并发、大业务量场景。</p><p>1.3.主从Reactor多线程模型：主从Reactor线程模型的特点是服务端用于接收客户端连接的不再是个1个单独的NIO线程，而是一个独立的NIO线程池。利用主从NIO线程模型，可以解决1个服务端监听线程无法有效处理所有客户端连接的性能不足问题</p><p>2 proactor模型其实是基于异步非阻塞IO模型的，当accpetor接收到请求以后，直接提交异步的io请求给linux内核，内核完成io请求后会回写消息到proactor提供的事件队列中，此时工作线程查看到IO请求已完成，则会继续剩余的工作，也是通过回调处理器来进行的。</p><p>所以两者最大的差别是，前者基于epoll的IO多路复用，后者基于AIO实现。</p><p>3 netty的核心组件：</p><p>bytebuf</p><p>bytebuf是对NIO中Bytebuffer的优化和扩展，并且支持堆外内存分配，堆外内存避免gc，可以更好地与内核空间进行交换数据。</p><p>channel和NIO的channel类似，但是NIO的socket代码改成nio实现非常麻烦，所以netty优化了这个过程，只需替换几个类就可以实现不更新太多代码就完成旧IO和新IO的切换。</p><p>channelhandler就是任务的处理器了，使用回调函数的方式注册到channel中，更准确来说是注册到channelpipeline里。</p><p>channelpipeline是用来管理和连接多个channelhandler的容器，执行任务时，会根据channelpipeline的调用链完成处理器的顺序调用，启动服务器时只需要将需要的channelhandler注册在上面就可以了。</p><p>eventloop<br>在Netty的线程模型中，一个EventLoop将由一个永远不会改变的Thread驱动，而一个Channel一生只会使用一个EventLoop（但是一个EventLoop可能会被指派用于服务多个Channel），在Channel中的所有I/O操作和事件都由EventLoop中的线程处理，也就是说一个Channel的一生之中都只会使用到一个线程。</p><p>bootstrap</p><p>在深入了解地Netty的核心组件之后，发现它们的设计都很模块化，如果想要实现你自己的应用程序，就需要将这些组件组装到一起。Netty通过Bootstrap类，以对一个Netty应用程序进行配置（组装各个组件），并最终使它运行起来。</p><p>对于客户端程序和服务器程序所使用到的Bootstrap类是不同的，后者需要使用ServerBootstrap，这样设计是因为，在如TCP这样有连接的协议中，服务器程序往往需要一个以上的Channel，通过父Channel来接受来自客户端的连接，然后创建子Channel用于它们之间的通信，而像UDP这样无连接的协议，它不需要每个连接都创建子Channel，只需要一个Channel即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇总结主要是基于我之前Java网络编程与NIO系列文章而形成的的。主要是把重要的知识点用自己的话说了一遍，可能会有一些错误，还望见谅和指点。谢谢&lt;/p&gt;
&lt;p&gt;更多详细内容可以查看我的专栏文章：Java网络编程与NIO&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/21963.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21963.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="技术总结" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Java网络编程" scheme="http://h2pl.github.io/tags/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="NIO" scheme="http://h2pl.github.io/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Java并发总结</title>
    <link href="http://h2pl.github.io/2018/07/08/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <id>http://h2pl.github.io/2018/07/08/Java并发总结/</id>
    <published>2018-07-08T14:06:18.000Z</published>
    <updated>2018-07-09T00:27:41.291Z</updated>
    
    <content type="html"><![CDATA[<p>这篇总结主要是基于我Java并发技术系列的文章而形成的的。主要是把重要的知识点用自己的话说了一遍，可能会有一些错误，还望见谅和指点。谢谢</p><p>更多详细内容可以查看我的专栏文章：Java并发技术指南</p><p><a href="https://blog.csdn.net/column/details/21961.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21961.html</a><br><a id="more"></a></p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>线程安全一般指多线程之间的操作结果不会因为线程调度的顺序不同而发生改变。</p><h2 id="互斥和同步"><a href="#互斥和同步" class="headerlink" title="互斥和同步"></a>互斥和同步</h2><pre><code>互斥一般指资源的独占访问，同步则要求同步代码中的代码顺序执行，并且也是单线程独占的。</code></pre><h2 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h2><pre><code>JVM中的内存分区包括堆，栈，方法区等区域，这些内存都是抽象出来的，实际上，系统中只有一个主内存，但是为了方便Java多线程语义的实现，以及降低程序员编写并发程序的难度，Java提出了JMM内存模型，将内存分为主内存和工作内存，工作内存是线程独占的，实际上它是一系列寄存器，编译器优化后的结果。</code></pre><h2 id="as-if-Serial，happens-before"><a href="#as-if-Serial，happens-before" class="headerlink" title="as-if-Serial，happens-before"></a>as-if-Serial，happens-before</h2><pre><code>as if serial语义提供单线程代码的顺序执行保证，虽然他允许指令重排序，但是前提是指令重排序不会改变执行结果。</code></pre><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><pre><code>volatile语义实际上是在代码中插入一个内存屏障，内存屏障分为读写，写读，读读，写写四种，可以用来避免volatile变量的读写操作发生重排序，从而保证了volatile的语义，实际上，volatile修饰的变量强制要求线程写时将数据从缓存刷入主内存，读时强制要求线程从主内存中读取，因此保证了它的可见性。而对于volatile修饰的64位类型数据，可以保证其原子性，不会因为指令重排序导致一个64位数据被分割成两个32位数据来读取。</code></pre><h2 id="synchronized和锁优化"><a href="#synchronized和锁优化" class="headerlink" title="synchronized和锁优化"></a>synchronized和锁优化</h2><pre><code>synchronized是Java提供的同步标识，底层是操作系统的mutex lock调用，需要进行用户态到内核态的切换，开销比较大。synchronized经过编译后的汇编代码会有monitor in和monitor out的字样，用于标识进入监视器模块和退出监视器模块，监视器模块watcher会监控同步代码块中的线程号，只允线程号正确的线程进入。Java在synchronized关键字中进行了多次优化。比如轻量级锁优化，使用锁对象的对象头做文章，当一个线程需要获得该对象锁时，线程有一段空间叫做lock record，用于存储对象头的mask word，然后通过cas操作将对象头的mask word改成指向线程中的lockrecord。如果成功了就是获取到了锁，否则就是发生了互斥。需要锁粗化，膨胀为互斥锁。偏向锁，去掉了更多的同步措施，检查mask word是否是可偏向状态，然后检查mask word中的线程id是否是自己的id，如果是则执行同步代码，如果不是则cas修改其id，如果修改失败，则出现锁争用，偏向锁失效，膨胀为轻量级锁。自旋锁，每个线程会被分配一段时间片，并且听候cpu调度，如果发生线程阻塞需要切换的开销，于是使用自旋锁不需要阻塞，而是忙等循环，一获取时间片就开始忙等，这样的锁就是自旋锁，一般用于并发量比较小，又担心切换开销的场景。</code></pre><h2 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h2><pre><code>CAS操作是通过硬件实现的原子操作，通过一条指令完成比较和赋值的操作，防止发生因指令重排导致的非原子操作，在Java中通过unsafe包可以直接使用，在Java原子类中使用cas操作来完成一系列原子数据类型的构建，保证自加自减等依赖原值的操作不会出现并发问题。cas操作也广泛用在其他并发类中，通过循环cas操作可以完成线程安全的并发赋值，也可以通过一次cas操作来避免使用互斥锁。</code></pre><h2 id="Lock类"><a href="#Lock类" class="headerlink" title="Lock类"></a>Lock类</h2><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS是Lock类的基石，他是一个抽象类，通过操作一个变量state来判断线程锁争用的情况，通过一系列方法实现对该变量的修改。一般可以分为独占锁和互斥锁。</p><p>AQS维护着一个CLH阻塞队列，这个队列主要用来存放阻塞等待锁的线程节点。可以看做一个链表。</p><p>一：独占锁<br>独占锁的state只有0和1两种情况（如果是可重入锁也可以把state一直往上加，这里不讨论），state = 1时说明已经有线程争用到锁。线程获取锁时一般是通过aqs的lock方法，如果state为0，首先尝试cas修改state=1，成功返回，失败时则加入阻塞队列。非公共锁使用时，线程节点加入阻塞队列时依然会尝试cas获取锁，最后如果还是失败再老老实实阻塞在队列中。</p><p>独占锁还可以分为公平锁和非公平锁，公平锁要求锁节点依据顺序加入阻塞队列，通过判断前置节点的状态来改变后置节点的状态，比如前置节点获取锁后，释放锁时会通知后置节点。</p><p>非公平锁则不一定会按照队列的节点顺序来获取锁，如上面所说，会先尝试cas操作，失败再进入阻塞队列。</p><p>二：共享锁<br>共享锁的state状态可以是0到n。共享锁维护的阻塞队列和互斥锁不太一样，互斥锁的节点释放锁后只会通知后置节点，而共享锁获取锁后会通知所有的共享类型节点，让他们都来获取锁。共享锁用于countdownlatch工具类与cyliderbarrier等，可以很好地完成多线程的协调工作</p><h3 id="锁Lock和Conditon"><a href="#锁Lock和Conditon" class="headerlink" title="锁Lock和Conditon"></a>锁Lock和Conditon</h3><p>Lock 锁维护这两个内部类fairsync和unfairsync，都继承自aqs，重写了部分方法，实际上大部分方法还是aqs中的，Lock只是重新把AQS做了封装，让程序员更方便地使用Lock锁。</p><p>和Lock锁搭配使用的还有condition，由于Lock锁只维护着一个阻塞队列，有时候想分不同情况进行锁阻塞和锁通知怎么办，原来我们一般会使用多个锁对象，现在可以使用condition来完成这件事，比如线程A和线程B分别等待事件A和事件B，可以使用两个condition分别维护两个队列，A放在A队列，B放在B队列，由于Lock和condition是绑定使用的，当事件A触发，线程A被唤醒，此时他会加入Lock自己的CLH队列中进行锁争用，当然也分为公平锁和非公平锁两种，和上面的描述一样。</p><p>Lock和condtion的组合广泛用于JUC包中，比如生产者和消费者模型，再比如cyliderbarrier。</p><p>###读写锁</p><p>读写锁也是Lock的一个子类，它在一个阻塞队列中同时存储读线程节点和写线程节点，读写锁采用state的高16位和低16位分别代表独占锁和共享锁的状态，如果共享锁的state &gt; 0可以继续获取读锁，并且state-1，如果=0,则加入到阻塞队列中，写锁节点和独占锁的处理一样，因此一个队列中会有两种类型的节点，唤醒读锁节点时不会唤醒写锁节点，唤醒写锁节点时，则会唤醒后续的节点。</p><p>因此读写锁一般用于读多写少的场景，写锁可以降级为读锁，就是在获取到写锁的情况下可以再获取读锁。</p><h2 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h2><p>countdownlatch主要通过AQS的共享模式实现，初始时设置state为N，N是countdownlatch初始化使用的size，每当有一个线程执行countdown，则state-1，state = 0之前所有线程阻塞在队列中，当state=0时唤醒队头节点，队头节点依次通知所有共享类型的节点，唤醒这些线程并执行后面的代码。</p><p>cycliderbarrier主要通过lock和condition结合实现，首先设置state为屏障等待的线程数，在某个节点设置一个屏障，所有线程运行到此处会阻塞等待，其实就是等待在一个condition的队列中，并且每当有一个线程到达，state -=1 则当所有线程到达时,state = 0，则唤醒condition队列的所有结点，去执行后面的代码。</p><p>samphere也是使用AQS的共享模式实现的，与countlatch大同小异，不再赘述。</p><p>exchanger就比较复杂了。使用exchanger时会开辟一段空间用来让两个线程进行交互操作，这个空间一般是一个栈或队列，一个线程进来时先把数据放到这个格子里，然后阻塞等待其他线程跟他交换，如果另一个线程也进来了，就会读取这个数据，并把自己的数据放到对方线程的格子里，然后双双离开。当然使用栈和队列的交互是不同的，使用栈的话匹配的是最晚进来的一个线程，队列则相反。</p><h2 id="原子数据类型"><a href="#原子数据类型" class="headerlink" title="原子数据类型"></a>原子数据类型</h2><p>原子数据类型基本都是通过cas操作实现的，避免并发操作时出现的安全问题。</p><h2 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h2><p>同步容器主要就是concurrenthashmap了，在集合类中我已经讲了chm了，所以在这里简单带过，chm1.7通过分段锁来实现锁粗化，使用的死LLock锁，而1.8则改用synchronized和cas的结合，性能更好一些。</p><p>还有就是concurrentlinkedlist，ConcurrentSkipListMap与CopyOnWriteArrayList。</p><p>第一个链表也是通过cas和synchronized实现。</p><p>而concurrentskiplistmap则是一个跳表，跳表分为很多层，每层都是一个链表，每个节点可以有向下和向右两个指针，先通过向右指针进行索引，再通过向下指针细化搜索，这个的搜索效率是很高的，可以达到logn，并且它的实现难度也比较低。通过跳表存map就是把entry节点放在链表中了。查询时按照跳表的查询规则即可。</p><p>CopyOnWriteArrayList是一个写时复制链表，查询时不加锁，而修改时则会复制一个新list进行操作，然后再赋值给原list即可。<br>适合读多写少的场景。</p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><pre><code>    BlockingQueue 实现之 ArrayBlockingQueueArrayBlockingQueue其实就是数组实现的阻塞队列，该阻塞队列通过一个lock和两个condition实现，一个condition负责从队头插入节点，一个condition负责队尾读取节点，通过这样的方式可以实现生产者消费者模型。       BlockingQueue 实现之 LinkedBlockingQueueLinkedBlockingQueue是用链表实现的阻塞队列，和arrayblockqueue有所区别，它支持实现为无界队列，并且它使用两个lock和对应的condition搭配使用，这是因为链表可以同时对头部和尾部进行操作，而数组进行操作后可能还要执行移位和扩容等操作。所以链表实现更灵活，读写分别用两把锁，效率更高。    BlockingQueue 实现之 SynchronousQueue SynchronousQueue实现是一个不存储数据的队列，只会保留一个队列用于保存线程节点。详细请参加上面的exchanger实现类，它就是基于SynchronousQueue设计出来的工具类。    BlockingQueue 实现之 PriorityBlockingQueue    PriorityBlockingQueue    PriorityBlockingQueue是一个支持优先级的无界队列。默认情况下元素采取自然顺序排列，也可以通过比较器comparator来指定元素的排序规则。元素按照升序排列。    DelayQueue    DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将DelayQueue运用在以下应用场景：    缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。    定时任务调度。使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，从比如TimerQueue就是使用DelayQueue实现的。</code></pre><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p>首先看看executor接口，只提供一个run方法，而他的一个子接口executorservice则提供了更多方法，比如提交任务，结束线程池等。</p><p>然后抽象类abstractexecutorservice提供了更多的实现了，最后我们最常使用的类ThreadPoolExecutor就是继承它来的。</p><p>ThreadPoolExecutor可以传入多种参数来自定义实现线程池。</p><p>而我们也可以使用Executors中的工厂方法来实例化常用的线程池。</p><h3 id="常用线程池"><a href="#常用线程池" class="headerlink" title="常用线程池"></a>常用线程池</h3><p>比如newFixedThreadPool</p><p>newSingleThreadExecutor newCachedThreadPool</p><p>newScheduledThreadPool等等，这些线程池即可以使用submit提交有返回结果的callable和futuretask任务，通过一个future来接收结果，或者通过callable中的回调函数call来回写执行结果。也可以用execute执行无返回值的runable任务。</p><p>在探讨这些线程池的区别之前，先看看线程池的几个核心概念。</p><p>任务队列：线程池中维护了一个任务队列，每当向线程池提交任务时，任务加入队列。</p><p>工作线程：也叫worker，从线程池中获取任务并执行，执行后被回收或者保留，因情况而定。</p><p>核心线程数和最大线程数，核心线程数是线程池需要保持存活的线程数量，以便接收任务，最大线程数是能创建的线程数上限。</p><p>newFixedThreadPool可以设置固定的核心线程数和最大线程数，一个任务进来以后，就会开启一个线程去执行，并且这部分线程不会被回收，当开启的线程达到核心线程数时，则把任务先放进任务队列。当任务队列已满时，才会继续开启线程去处理，如果线程总数打到最大线程数限制，任务队列又是满的时候，会执行对应的拒绝策略。</p><p>拒绝策略一般有几种常用的，比如丢弃任务，丢弃队尾任务，回退给调用者执行，或者抛出异常，也可以使用自定义的拒绝策略。</p><p>newSingleThreadExecutor是一个单线程执行的线程池，只会维护一个线程，他也有任务队列，当任务队列已满并且线程数已经是1个的时候，再提交任务就会执行拒绝策略。</p><p>newCachedThreadPool比较特别，第一个任务进来时会开启一个线程，而后如果线程还没执行完前面的任务又有新任务进来，就会再创建一个线程，这个线程池使用的是无容量的SynchronousQueue队列，要求请求线程和接受线程匹配时才会完成任务执行。<br>所以如果一直提交任务，而接受线程来不及处理的话，就会导致线程池不断创建线程，导致cpu消耗很大。</p><p>ScheduledThreadPoolExecutor内部使用的是delayqueue队列，内部是一个优先级队列priorityqueue，也就是一个堆。通过这个delayqueue可以知道线程调度的先后顺序和执行时间点。</p><h2 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h2><p>又称工作窃取线程池。</p><p>我们在大学算法课本上，学过的一种基本算法就是：分治。其基本思路就是：把一个大的任务分成若干个子任务，这些子任务分别计算，最后再Merge出最终结果。这个过程通常都会用到递归。</p><p>而Fork/Join其实就是一种利用多线程来实现“分治算法”的并行框架。</p><p>另外一方面，可以把Fori/Join看作一个单机版的Map/Reduce，只不过这里的并行不是多台机器并行计算，而是多个线程并行计算。</p><p>与ThreadPool的区别<br>通过上面例子，我们可以看出，它在使用上，和ThreadPool有共同的地方，也有区别点：<br>（1） ThreadPool只有“外部任务”，也就是调用者放到队列里的任务。 ForkJoinPool有“外部任务”，还有“内部任务”，也就是任务自身在执行过程中，分裂出”子任务“，递归，再次放入队列。<br>（2）ForkJoinPool里面的任务通常有2类，RecusiveAction/RecusiveTask，这2个都是继承自FutureTask。在使用的时候，重写其compute算法。</p><p>工作窃取算法<br>上面提到，ForkJoinPool里有”外部任务“，也有“内部任务”。其中外部任务，是放在ForkJoinPool的全局队列里面，而每个Worker线程，也有一个自己的队列，用于存放内部任务。</p><p>窃取的基本思路就是：当worker自己的任务队列里面没有任务时，就去scan别的线程的队列，把别人的任务拿过来执行</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇总结主要是基于我Java并发技术系列的文章而形成的的。主要是把重要的知识点用自己的话说了一遍，可能会有一些错误，还望见谅和指点。谢谢&lt;/p&gt;
&lt;p&gt;更多详细内容可以查看我的专栏文章：Java并发技术指南&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/21961.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21961.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="技术总结" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Java并发" scheme="http://h2pl.github.io/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java集合框架学习总结</title>
    <link href="http://h2pl.github.io/2018/07/08/Java%E9%9B%86%E5%90%88%E7%B1%BB%E6%80%BB%E7%BB%93/"/>
    <id>http://h2pl.github.io/2018/07/08/Java集合类总结/</id>
    <published>2018-07-08T14:03:44.000Z</published>
    <updated>2018-07-09T00:27:23.126Z</updated>
    
    <content type="html"><![CDATA[<p>这篇总结是基于之前博客内容的一个整理和回顾。</p><p>这里先简单地总结一下，更多详细内容请参考我的专栏：深入浅出Java核心技术</p><p><a href="https://blog.csdn.net/column/details/21930.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21930.html</a></p><p>里面有包括Java集合类在内的众多Java核心技术系列文章。</p><p>以下总结不保证全对，如有错误，还望能够指出。谢谢<br><a id="more"></a></p><h2 id="Colletion，iterator，comparable"><a href="#Colletion，iterator，comparable" class="headerlink" title="Colletion，iterator，comparable"></a>Colletion，iterator，comparable</h2><p>一般认为Collection是最上层接口，但是hashmap实际上实现的是Map接口。iterator是迭代器，是实现iterable接口的类必须要提供的一个东西，能够使用for(i : A) 这种方式实现的类型能提供迭代器，以前有一个enumeration，现在早弃用了。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List接口下的实现类有ArrayList，linkedlist，vector等等，一般就是用这两个，用法不多说，老生常谈。<br>ArrayList的扩容方式是1.5倍扩容，这样扩容避免2倍扩容可能浪费空间，是一种折中的方案。<br>另外他不是线程安全，vector则是线程安全的，它是两倍扩容的。</p><p>linkedlist没啥好说的，多用于实现链表。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>map永远都是重头戏。</p><p>hashmap是数组和链表的组合结构，数组是一个Entry数组，entry是k-V键值对类型，所以一个entry数组存着很entry节点，一个entry的位置通过key的hashcode方法，再进行hash（移位等操作），最后与表长-1进行相与操作，其实就是取hash值到的后n - 1位，n代表表长是2的n次方。</p><p>hashmap的默认负载因子是0.75，阈值是16 * 0.75 = 12；初始长度为16；</p><p>hashmap的增删改查方式比较简单，都是遍历，替换。有一点要注意的是key相等时，替换元素，不相等时连成链表。</p><p>除此之外，1.8jdk改进了hashmap，当链表上的元素个数超过8个时自动转化成红黑树，节点变成树节点，以提高搜索效率和插入效率到logn。</p><p>还有一点值得一提的是，hashmap的扩容操作，由于hashmap非线程安全，扩容时如果多线程并发进行操作，则可能有两个线程分别操作新表和旧表，导致节点成环，查询时会形成死锁。chm避免了这个问题。</p><p>另外，扩容时会将旧表元素移到新表，原来的版本移动时会有rehash操作，每个节点都要rehash，非常不方便，而1.8改成另一种方式，对于同一个index下的链表元素，由于一个元素的hash值在扩容后只有两种情况，要么是hash值不变，要么是hash值变为原来值+2^n次方，这是因为表长翻倍，所以hash值取后n位，第一位要么是0要么是1，所以hash值也只有两种情况。这两种情况的元素分别加到两个不同的链表。这两个链表也只需要分别放到新表的两个位置即可，是不是很酷。</p><p>最后有一个比较冷门的知识点，hashmap1.7版本链表使用的是节点的头插法，扩容时转移链表仍然使用头插法，这样的结果就是扩容后链表会倒置，而hashmap.1.8在插入时使用尾插法，扩容时使用头插法，这样可以保证顺序不变。</p><h2 id="CHM"><a href="#CHM" class="headerlink" title="CHM"></a>CHM</h2><p>concurrenthashmap也稍微提一下把，chm1.7使用分段锁来控制并发，每个segment对应一个segmentmask，通过key的hash值相与这个segmentmask得到segment位置，然后在找到具体的entry数组下标。所以chm需要维护多个segment，每个segment对应一个数组。分段锁使用的是reetreetlock可重入锁实现。查询时不加锁。</p><p>1.8则放弃使用分段锁，改用cas+synchronized方式实现并发控制，查询时不加锁，插入时如果没有冲突直接cas到成功为止，有冲突则使用synchronized插入。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>set就是hashmap将value固定为一个object，只存key元素包装成一个entry即可，其他不变。</p><h2 id="Linkedhashmap"><a href="#Linkedhashmap" class="headerlink" title="Linkedhashmap"></a>Linkedhashmap</h2><p>在原来hashmap基础上将所有的节点依据插入的次序另外连成一个链表。用来保持顺序，可以使用它实现lru缓存，当访问命中时将节点移到队头，当插入元素超过长度时，删除队尾元素即可。</p><h2 id="collections和Arrays工具类"><a href="#collections和Arrays工具类" class="headerlink" title="collections和Arrays工具类"></a>collections和Arrays工具类</h2><p>两个工具类分别操作集合和数组，可以进行常用的排序，合并等操作。</p><h2 id="comparable和comparator"><a href="#comparable和comparator" class="headerlink" title="comparable和comparator"></a>comparable和comparator</h2><p>实现comparable接口可以让一个类的实例互相使用compareTo方法进行比较大小，可以自定义比较规则，comparator则是一个通用的比较器，比较指定类型的两个元素之间的大小关系。</p><h2 id="treemap和treeset"><a href="#treemap和treeset" class="headerlink" title="treemap和treeset"></a>treemap和treeset</h2><p>主要是基于红黑树实现的两个数据结构，可以保证key序列是有序的，获取sortedset就可以顺序打印key值了。其中涉及到红黑树的插入和删除，调整等操作，比较复杂，这里就不细说了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇总结是基于之前博客内容的一个整理和回顾。&lt;/p&gt;
&lt;p&gt;这里先简单地总结一下，更多详细内容请参考我的专栏：深入浅出Java核心技术&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/21930.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21930.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;里面有包括Java集合类在内的众多Java核心技术系列文章。&lt;/p&gt;
&lt;p&gt;以下总结不保证全对，如有错误，还望能够指出。谢谢&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="技术总结" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Java集合" scheme="http://h2pl.github.io/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC源码分析6：SpringMVC的视图解析原理</title>
    <link href="http://h2pl.github.io/2018/06/07/springmvc6/"/>
    <id>http://h2pl.github.io/2018/06/07/springmvc6/</id>
    <published>2018-06-07T03:03:19.000Z</published>
    <updated>2018-06-12T03:53:38.210Z</updated>
    
    <content type="html"><![CDATA[<p>转自 <a href="https://www.cnblogs.com/fangjian0423/p/springMVC-view-viewResolver.html" target="_blank" rel="noopener">SpringMVC视图机制详解[附带源码分析]</a></p><p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Spring源码解析 <a href="https://blog.csdn.net/column/details/21851.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21851.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a><br><a id="more"></a></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="http://www.cnblogs.com/fangjian0423/p/springMVC-view-viewResolver.html#preface" target="_blank" rel="noopener">前言</a></li><li><a href="http://www.cnblogs.com/fangjian0423/p/springMVC-view-viewResolver.html#introduction" target="_blank" rel="noopener">重要接口和类介绍</a></li><li><a href="http://www.cnblogs.com/fangjian0423/p/springMVC-view-viewResolver.html#analysis" target="_blank" rel="noopener">源码分析</a></li><li><a href="http://www.cnblogs.com/fangjian0423/p/springMVC-view-viewResolver.html#demo" target="_blank" rel="noopener">编码自定义的ViewResolver</a></li><li><a href="http://www.cnblogs.com/fangjian0423/p/springMVC-view-viewResolver.html#summary" target="_blank" rel="noopener">总结</a></li><li><a href="http://www.cnblogs.com/fangjian0423/p/springMVC-view-viewResolver.html#reference" target="_blank" rel="noopener">参考资料</a></li></ul><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SpringMVC是目前主流的Web MVC框架之一。 </p><p>如果有同学对它不熟悉，那么请参考它的入门blog：<a href="http://www.cnblogs.com/fangjian0423/p/springMVC-introduction.html" target="_blank" rel="noopener">http://www.cnblogs.com/fangjian0423/p/springMVC-introduction.html</a></p><p>本文将分析SpringMVC的视图这部分内容，让读者了解SpringMVC视图的设计原理。</p><h1 id="重要接口和类介绍"><a href="#重要接口和类介绍" class="headerlink" title="重要接口和类介绍"></a>重要接口和类介绍</h1><p><strong>1. View接口</strong></p><p>　　视图基础接口，它的各种实现类是无状态的，因此是线程安全的。 该接口定义了两个方法：　</p><p><img src="https://images0.cnblogs.com/i/411512/201406/092359485145662.png" alt=""></p><p><strong>2. AbstractView抽象类</strong></p><p>View接口的基础实现类。我们稍微介绍一下这个抽象类。</p><p>　　首先看下这个类的属性：</p><p><img src="https://images0.cnblogs.com/i/411512/201406/100014083899865.png" alt=""></p><p>　　再看下抽象类中接口方法的实现：</p><p>　　getContentType方法直接返回contentType属性即可。</p><p><img src="https://images0.cnblogs.com/i/411512/201406/100110310773735.png" alt=""></p><p> 　　render方法：</p><p><img src="https://images0.cnblogs.com/i/411512/201406/102247323892787.png" alt=""></p><p><strong>3. AbstractUrlBasedView抽象类</strong></p><p>　　继承自AbstractView抽象类，增加了1个类型为String的url参数。</p><p><strong>4. InternalResourceView类</strong></p><p>　　继承自AbstractUrlBasedView抽象类的类，表示JSP视图。</p><p>　　我们看下这个类的renderMergedOutputModel方法(AbstractView抽象类定义的抽象方法，为View接口提供的render方法服务)。</p><p><img src="https://images0.cnblogs.com/i/411512/201406/102252020309641.png" alt=""></p><p><strong>5. JstlView类</strong></p><p>　　JSTL视图，继承自InternalResourceView，该类大致上与InternalResourceView类一致。</p><p><strong>6. AbstractTemplateView抽象类</strong></p><p>　　继承自AbstractUrlBasedView抽象类，重写了renderMergedOutputModel方法，在该方法中会调用renderMergedTemplateModel方法，renderMergedTemplateModel方法为新定义的抽象方法。</p><p>　　该抽象类有几个boolean属性exposeSessionAttributes，exposeRequestAttributes。 设置为true的话会将request和session中的键值和值丢入到renderMergedTemplateModel方法中的model这个Map参数中。</p><p>　　这个类是某些模板引擎视图类的父类。 比如FreemarkerView，VelocityView。</p><p><strong>7. FreeMarkerView类</strong></p><p>　　继承自AbstractTemplateView抽象类。</p><p>　　直接看renderMergedTemplateModel方法，renderMergedTemplateModel内部会调用doRender方法：</p><p><img src="https://images0.cnblogs.com/i/411512/201406/102258387178319.png" alt=""></p><p><strong>8. RedirectView类</strong></p><p>　　继承自AbstractUrlBasedView，并实现SmartView接口。SmartView接口定义了1个boolean isRedirectView();方法。</p><p>　　该视图的renderMergedOutputModel方法主要就是通过response.sendRedirect进行重定向。</p><p>　　有关RedirectView方面的知识楼主另外写了1篇博客。<a href="http://www.cnblogs.com/fangjian0423/p/springMVC-redirectView-analysis.html" target="_blank" rel="noopener">http://www.cnblogs.com/fangjian0423/p/springMVC-redirectView-analysis.html</a></p><p><strong>9. ViewResolver接口</strong></p><p>　　视图解释器，用来解析视图View，与View接口配合使用。</p><p>　　该接口只有1个方法，通过视图名称viewName和Locale对象得到View接口实现类：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">View resolveViewName(<span class="built_in">String</span> viewName, <span class="built_in">Locale</span> <span class="built_in">locale</span>) throws Exception;</span><br></pre></td></tr></table></figure><p><strong>10. AbstractCachingViewResolver抽象类</strong></p><p>　　带有缓存功能的ViewResolver接口基础实现抽象类，该类有个属性名为viewAccessCache的以 “viewName_locale” 为key， View接口为value的Map。</p><p>　　该抽象类实现的resolveViewName方法内部会调用createView方法，方法内部会调用loadView抽象方法。</p><p><strong>11. UrlBasedViewResolver类</strong></p><p>　　继承自AbstractCachingViewResolver抽象类、并实现Ordered接口的类，是ViewResolver接口简单的实现类。</p><p><img src="https://images0.cnblogs.com/i/411512/201406/102341126705605.png" alt=""></p><p>　　该类复写了createView方法：</p><p><img src="https://images0.cnblogs.com/i/411512/201406/102349273585708.png" alt=""></p><p>　　父类(AbstractCachingViewResolver)的createView方法内部会调用loadView抽象方法，UrlBasedViewResolver实现了这个抽象方法：</p><p><img src="https://images0.cnblogs.com/i/411512/201406/110037187498815.png" alt=""></p><p><img src="https://images0.cnblogs.com/i/411512/201406/110043510779523.png" alt=""></p><p>　　下面对UrlBasedViewResolver做1个test，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.UrlBasedViewResolver"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/view/"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"viewClass"</span> <span class="attr">value</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceView"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"viewNames"</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span>*<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line">        </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"contentType"</span> <span class="attr">value</span>=<span class="string">"text/html;charset=utf-8"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"attributesMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"mytest"</span> <span class="attr">value</span>=<span class="string">"mytestvalue"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"attributes"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"test"</span>&gt;</span>testvalue<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>　　我们看到：以InternalResourceView这个JSP视图作为视图；viewNames我们设置了<em>，这里的</em>代表全部视图名(这个viewNames属性不设置也可以，代表全部视图名都处理)；http响应头部contentType信息：text/html;charset=utf-8；attributesMap和attributes传入的Map和Properties参数都会被丢入到staticAttributes属性中，这个staticAttributes会被设置成AbstractView的staticAttributes属性，也就是request域中的参数。</p><p><img src="https://images0.cnblogs.com/i/411512/201406/122254034056621.png" alt=""></p><p><img src="https://images0.cnblogs.com/i/411512/201406/122255053584961.png" alt=""></p><p><img src="https://images0.cnblogs.com/i/411512/201406/122253337649444.png" alt=""></p><p>　　我们看到request域中没有设置mytest和testvalue值。但是页面中会显示，因为我们配置了attributesMap和attributes参数。</p><p>　　如果我们把viewNames中的”*”改成”index1”。那么就报错了，因为处理视图名的时候index匹配不上index1。</p><p><img src="https://images0.cnblogs.com/i/411512/201406/122258119528822.png" alt=""></p><p><strong>12. InternalResourceViewResolver类</strong></p><p>　　继承自UrlBasedViewResolver，以InternalResourceView作为视图，若项目中存在“javax.servlet.jsp.jstl.core.Config”该类，那么会以JstlView作为视图。重写了buildView方法，主要就是为了给InternalResourceView视图设置属性。</p><p><strong>13. AbstractTemplateViewResolver类</strong></p><p>　　继承自UrlBasedViewResolver，重写了buildView方法，主要就是构造AbstractTemplateView以及为它设置相应的属性。</p><p><strong>14. FreeMarkerViewResolver类</strong></p><p>　　继承自AbstractTemplateViewResolver，将视图设置为FreeMarkerView。</p><p><strong>15. ModelAndView对象</strong></p><p>　　顾名思义，带有视图和Model属性的一个模型和视图类。</p><p><img src="https://images0.cnblogs.com/i/411512/201406/122342141709643.png" alt=""></p><p>　　值得注意的是，这个视图属性是一个Object类型的数据，可以直接是View接口的实现类或者视图名(字符串)。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>下面我们来分析SpringMVC处理视图的源码。</p><p>SpringMVC在处理请求的时候，通过RequestMappingHandlerMapping得到HandlerExecutionChain，然后通过RequestMappingHandlerAdapter得到1个ModelAndView对象，之后通过processDispatchResult方法处理。</p><p>processDispatchResult方法如下：</p><p><img src="https://images0.cnblogs.com/i/411512/201406/122331490924509.png" alt=""></p><p><img src="https://images0.cnblogs.com/i/411512/201406/122339489831665.png" alt=""></p><p>如果配置的ViewResolver如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="built_in">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"prefix"</span> value=<span class="string">"/WEB-INF/view/"</span>/&gt;</span><br><span class="line">  &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"suffix"</span> value=<span class="string">".jsp"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>那么就是使用InternalResourceViewResolver来解析视图。</p><p>之前分析过，InternalResourceViewResolver重写了UrlBasedViewResolver的buildView方法。但是还是会调用UrlBasedViewResolver的buildView方法。</p><p><img src="https://images0.cnblogs.com/i/411512/201406/130106345772394.png" alt=""></p><p>最终得到InternalResourceView或JstlView视图。这两个视图的render方法本文介绍重要接口及类的时候已分析。</p><p>PS：DispathcerServlet中的viewResolvers属性是个集合，如果存在多个ViewResolver对象，必定会有优先级的问题，这部分的内容请参考楼主的另一篇博客：</p><p><a href="http://www.cnblogs.com/fangjian0423/p/spring-Ordered-interface.html" target="_blank" rel="noopener">http://www.cnblogs.com/fangjian0423/p/spring-Ordered-interface.html</a></p><h1 id="编码自定义的ViewResolver"><a href="#编码自定义的ViewResolver" class="headerlink" title="编码自定义的ViewResolver"></a>编码自定义的ViewResolver</h1><p>下面，我们就来编写自定义的ViewResolver。</p><p>自定义的ViewResolver处理视图名的时候，遇到 “jsp:” 开头的会找jsp页面，遇到 “freemarker:” 开头的找freemarker页面。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> CustomViewResolver <span class="keyword">extends</span> UrlBasedViewResolver &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String JSP_URL_PREFIX = <span class="string">"jsp:"</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FTL_URL_PREFIX = <span class="string">"freemarker:"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> jstlPresent = ClassUtils.isPresent(</span><br><span class="line">            <span class="string">"javax.servlet.jsp.jstl.core.Config"</span>, CustomViewResolver.<span class="keyword">class</span>.getClassLoader());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">Boolean</span> exposePathVariables = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> exposeRequestAttributes = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> allowRequestOverride = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> exposeSessionAttributes = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> allowSessionOverride = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> exposeSpringMacroHelpers = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> CustomViewResolver() &#123;</span><br><span class="line">      <span class="keyword">this</span>.setViewClass(FreeMarkerView.<span class="keyword">class</span>);</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  <span class="keyword">protected</span> AbstractUrlBasedView buildView(String viewName) <span class="keyword">throws</span> Exception &#123; </span><br><span class="line">    <span class="keyword">if</span>(viewName.startsWith(FTL_URL_PREFIX)) &#123;</span><br><span class="line">        <span class="keyword">return</span> buildFreemarkerView(viewName.substring(FTL_URL_PREFIX.length()));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(viewName.startsWith(JSP_URL_PREFIX)) &#123;</span><br><span class="line">        <span class="keyword">Class</span> viewCls = jstlPresent ? JstlView.<span class="keyword">class</span> : InternalResourceView.<span class="keyword">class</span>;</span><br><span class="line">        <span class="keyword">return</span> buildView(viewCls, viewName.substring(JSP_URL_PREFIX.length()), getPrefix(), <span class="string">".jsp"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//默认以freemarker处理</span></span><br><span class="line">        <span class="keyword">return</span> buildFreemarkerView(viewName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> AbstractUrlBasedView build(<span class="keyword">Class</span> viewClass, String viewName, String prefix, String suffix) &#123; </span><br><span class="line">    AbstractUrlBasedView view = (AbstractUrlBasedView) BeanUtils.instantiateClass(viewClass);</span><br><span class="line">    view.setUrl(prefix + viewName + suffix);</span><br><span class="line">    String contentType = getContentType();</span><br><span class="line">    <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        view.setContentType(contentType);</span><br><span class="line">    &#125;</span><br><span class="line">    view.setRequestContextAttribute(getRequestContextAttribute());</span><br><span class="line">    view.setAttributesMap(getAttributesMap());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.exposePathVariables != <span class="keyword">null</span>) &#123;</span><br><span class="line">        view.setExposePathVariables(exposePathVariables);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> view;    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> AbstractUrlBasedView buildFreemarkerView(String viewName) <span class="keyword">throws</span> Exception &#123; </span><br><span class="line">    AbstractTemplateView view = (AbstractTemplateView) build(FreeMarkerView.<span class="keyword">class</span>, viewName, <span class="string">""</span>, getSuffix());</span><br><span class="line">    view.setExposeRequestAttributes(<span class="keyword">this</span>.exposeRequestAttributes);</span><br><span class="line">    view.setAllowRequestOverride(<span class="keyword">this</span>.allowRequestOverride);</span><br><span class="line">    view.setExposeSessionAttributes(<span class="keyword">this</span>.exposeSessionAttributes);</span><br><span class="line">    view.setAllowSessionOverride(<span class="keyword">this</span>.allowSessionOverride);</span><br><span class="line">    view.setExposeSpringMacroHelpers(<span class="keyword">this</span>.exposeSpringMacroHelpers);</span><br><span class="line">    <span class="keyword">return</span> view;      </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//get set方法省略</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml配置：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="built_in">class</span>=<span class="string">"org.format.demo.support.viewResolver.CustomViewResolver"</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"prefix"</span> value=<span class="string">"/WEB-INF/view/"</span>/&gt;</span><br><span class="line">  &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"suffix"</span> value=<span class="string">".ftl"</span>/&gt;</span><br><span class="line">  &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"contentType"</span> value=<span class="string">"text/html;charset=utf-8"</span>/&gt;</span><br><span class="line">  &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"exposeRequestAttributes"</span> value=<span class="string">"true"</span>/&gt;</span><br><span class="line">  &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"exposeSessionAttributes"</span> value=<span class="string">"true"</span>/&gt;</span><br><span class="line">  &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"exposeSpringMacroHelpers"</span> value=<span class="string">"true"</span>/&gt;</span><br><span class="line">  &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"requestContextAttribute"</span> value=<span class="string">"request"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">"freemarkerConfig"</span> <span class="built_in">class</span>=<span class="string">"org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"templateLoaderPath"</span> value=<span class="string">"/WEB-INF/view/"</span>/&gt;</span><br><span class="line">  &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"defaultEncoding"</span> value=<span class="string">"utf-8"</span>/&gt;</span><br><span class="line">  &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"freemarkerSettings"</span>&gt;</span><br><span class="line">    &lt;props&gt;</span><br><span class="line">      &lt;<span class="keyword">prop</span> key=<span class="string">"template_update_delay"</span>&gt;<span class="number">10</span>&lt;/<span class="keyword">prop</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">prop</span> key=<span class="string">"locale"</span>&gt;zh_CN&lt;/<span class="keyword">prop</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">prop</span> key=<span class="string">"datetime_format"</span>&gt;yyyy-MM-dd&lt;/<span class="keyword">prop</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">prop</span> key=<span class="string">"date_format"</span>&gt;yyyy-MM-dd&lt;/<span class="keyword">prop</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">prop</span> key=<span class="string">"number_format"</span>&gt;<span class="comment">#.##&lt;/prop&gt;</span></span><br><span class="line">    &lt;/props&gt;</span><br><span class="line">  &lt;/<span class="keyword">property</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>简单解释一下：CustomViewResolver解析视图名的时候，判断 “jsp:” 和 “freemarker:” 开头的名字，如果是 “jsp:” 开头的，如果有JSTL依赖，构造JSTLView视图，否则构造InternalResourceView视图。如果是 “freemarker:” 构造FreemarkerView。在构造视图之前分别会设置一些属性。</p><p>xml配置：配置prefix是为了给jsp视图用的，freemarker视图不需要prefix，因为FreemarkerView内部会使用配置的FreeMarkerConfigurer，并用FreeMarkerConfigurer内部的templateLoaderPath属性作为前缀，配置的suffix是为了让FreemarkerView使用，当后缀。</p><p>最后附上Controller代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(value = <span class="meta-string">"/tvrc"</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestViewResolverController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"jsp"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView jsp(ModelAndView view) &#123;</span><br><span class="line">        view.setViewName(<span class="string">"jsp:trvc/index"</span>);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/ftl"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView freemarker(ModelAndView view) &#123;</span><br><span class="line">        view.setViewName(<span class="string">"freemarker:trvc/index"</span>);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>视图 /WEB-INF/view/trvc/index.jsp 中的的内容是输出</p><h2>This is jsp page</h2><p></p><p>视图 /WEB-INF/view/trvc/index.ftl 中的的内容是输出</p><h2>This is freemarker page</h2><p></p><p><img src="https://images0.cnblogs.com/i/411512/201406/140202040149946.png" alt=""></p><p><img src="https://images0.cnblogs.com/i/411512/201406/140202212495247.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文分析了SpringMVC中的视图机制，View和ViewResolver这两个接口是视图机制的核心，并分析了几个重要的View和ViewResolver接口实现类，最终写了一个区别jsp和freemarker视图的ViewResolver实现类，让读者更加理解视图机制。</p><p>希望这篇文章能帮助读者了解SpringMVC视图机制。</p><p>文中难免有错误，希望读者能够指明出来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自 &lt;a href=&quot;https://www.cnblogs.com/fangjian0423/p/springMVC-view-viewResolver.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SpringMVC视图机制详解[附带源码分析]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Spring源码解析 &lt;a href=&quot;https://blog.csdn.net/column/details/21851.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21851.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="SpringMVC" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/SpringMVC/"/>
    
    
      <category term="SpringMVC" scheme="http://h2pl.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC源码剖析5：消息转换器HttpMessageConverter与@ResponseBody注解</title>
    <link href="http://h2pl.github.io/2018/06/07/springmvc5/"/>
    <id>http://h2pl.github.io/2018/06/07/springmvc5/</id>
    <published>2018-06-07T03:03:13.000Z</published>
    <updated>2018-06-12T03:53:56.959Z</updated>
    
    <content type="html"><![CDATA[<p>转自 <a href="https://www.cnblogs.com/fangjian0423/p/springMVC-xml-json-convert.html" target="_blank" rel="noopener">SpringMVC关于json、xml自动转换的原理研究[附带源码分析]</a></p><p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Spring源码解析 <a href="https://blog.csdn.net/column/details/21851.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21851.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a><br><a id="more"></a></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="http://www.cnblogs.com/fangjian0423/p/springMVC-xml-json-convert.html#preface" target="_blank" rel="noopener">前言</a></li><li><a href="http://www.cnblogs.com/fangjian0423/p/springMVC-xml-json-convert.html#phenomenon" target="_blank" rel="noopener">现象</a></li><li><a href="http://www.cnblogs.com/fangjian0423/p/springMVC-xml-json-convert.html#analysis" target="_blank" rel="noopener">源码分析</a></li><li><a href="http://www.cnblogs.com/fangjian0423/p/springMVC-xml-json-convert.html#demo" target="_blank" rel="noopener">实例讲解</a></li><li><a href="http://www.cnblogs.com/fangjian0423/p/springMVC-xml-json-convert.html#config" target="_blank" rel="noopener">关于配置</a></li><li><a href="http://www.cnblogs.com/fangjian0423/p/springMVC-xml-json-convert.html#summary" target="_blank" rel="noopener">总结</a></li><li><a href="http://www.cnblogs.com/fangjian0423/p/springMVC-xml-json-convert.html#reference" target="_blank" rel="noopener">参考资料</a></li></ul><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SpringMVC是目前主流的Web MVC框架之一。 </p><p>如果有同学对它不熟悉，那么请参考它的入门blog：<a href="http://www.cnblogs.com/fangjian0423/p/springMVC-introduction.html" target="_blank" rel="noopener">http://www.cnblogs.com/fangjian0423/p/springMVC-introduction.html</a></p><h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>本文使用的demo基于maven，是根据入门blog的例子继续写下去的。</p><p>我们先来看一看对应的现象。 我们这里的配置文件 *-dispatcher.xml中的关键配置如下(其他常规的配置文件不在讲解，可参考本文一开始提到的入门blog)：</p><p>(视图配置省略)</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:resources <span class="attribute">location</span>=<span class="string">"/static/"</span> <span class="attribute">mapping</span>=<span class="string">"/static/**"</span>/&gt;</span><br><span class="line">&lt;mvc:annotation-driven/&gt;</span><br><span class="line">&lt;context:component-scan <span class="attribute">base-package</span>=<span class="string">"org.format.demo.controller"</span>/&gt;</span><br></pre></td></tr></table></figure><p>pom中需要有以下依赖(Spring依赖及其他依赖不显示)：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.jackson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  jackson-core-asl</span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.jackson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  jackson-mapper-asl</span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个依赖是json序列化的依赖。</p><p>ok。我们在Controller中添加一个method：</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p><pre>@RequestMapping(“/xmlOrJson”)<br>@ResponseBody public Map&lt;String, Object&gt; xmlOrJson() {<br>    Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();<br>    map.put(“list”, employeeService.list()); return map;<br>}</pre></p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>直接访问地址：</p><p><img src="https://images0.cnblogs.com/i/411512/201405/101449596675807.png" alt=""></p><p>我们看到，短短几行配置。使用@ResponseBody注解之后，Controller返回的对象 自动被转换成对应的json数据，在这里不得不感叹SpringMVC的强大。</p><p>我们好像也没看到具体的配置，唯一看到的就是*-dispatcher.xml中的一句配置：<a href="mvc:annotation-driven/" target="_blank" rel="noopener">mvc:annotation-driven/</a>。其实就是这个配置，导致了java对象自动转换成json对象的现象。</p><p>那么spring到底是如何实现java对象到json对象的自动转换的呢？ 为什么转换成了json数据，如果想转换成xml数据，那该怎么办？</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p><strong>本文使用的spring版本是4.0.2。  </strong></p><p>在讲解<a href="mvc:annotation-driven/" target="_blank" rel="noopener">mvc:annotation-driven/</a>这个配置之前，我们先了解下Spring的消息转换机制。@ResponseBody这个注解就是使用消息转换机制，最终通过json的转换器转换成json数据的。</p><p>HttpMessageConverter接口就是Spring提供的http消息转换接口。有关这方面的知识大家可以参考”参考资料”中的<a href="http://my.oschina.net/lichhao/blog/172562" target="_blank" rel="noopener">第二条链接</a>，里面讲的很清楚。</p><p><img src="https://images0.cnblogs.com/i/411512/201405/101510002604230.png" alt=""></p><p>下面开始分析<a href="mvc:annotation-driven/" target="_blank" rel="noopener">mvc:annotation-driven/</a>这句配置:</p><p>这句代码在spring中的解析类是：</p><p><img src="https://images0.cnblogs.com/i/411512/201405/101606162131470.png" alt=""></p><p>在AnnotationDrivenBeanDefinitionParser源码的152行parse方法中：</p><p>分别实例化了RequestMappingHandlerMapping，ConfigurableWebBindingInitializer，RequestMappingHandlerAdapter等诸多类。</p><p>其中<strong>RequestMappingHandlerMapping和RequestMappingHandlerAdapter</strong>这两个类比较重要。</p><p>RequestMappingHandlerMapping处理请求映射的，处理@RequestMapping跟请求地址之间的关系。</p><p>RequestMappingHandlerAdapter是请求处理的适配器，也就是请求之后处理具体逻辑的执行，关系到哪个类的哪个方法以及转换器等工作，这个类是我们讲的重点，其中它的属性messageConverters是本文要讲的重点。</p><p><img src="https://images0.cnblogs.com/i/411512/201405/101611179016436.png" alt=""></p><p>私有方法:getMessageConverters</p><p><img src="https://images0.cnblogs.com/i/411512/201405/101630232136603.png" alt=""></p><p>从代码中我们可以，RequestMappingHandlerAdapter设置messageConverters的逻辑：</p><p>1.如果<a href="mvc:annotation-driven" target="_blank" rel="noopener">mvc:annotation-driven</a>节点有子节点message-converters，那么它的转换器属性messageConverters也由这些子节点组成。</p><p>message-converters的子节点配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.example.MyHttpMessageConverter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.example.MyOtherHttpMessageConverter"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.message-converters子节点不存在或它的属性register-defaults为true的话，加入其他的转换器：ByteArrayHttpMessageConverter、StringHttpMessageConverter、ResourceHttpMessageConverter等。</p><p>我们看到这么一段：</p><p><img src="https://images0.cnblogs.com/i/411512/201405/101640298384297.png" alt=""></p><p>这些boolean属性是哪里来的呢，它们是AnnotationDrivenBeanDefinitionParser的静态变量。</p><p><img src="https://images0.cnblogs.com/i/411512/201405/101641297132356.png" alt=""></p><p> 其中ClassUtils中的isPresent方法如下：</p><p><img src="https://images0.cnblogs.com/i/411512/201405/101643277139672.png" alt=""></p><p>看到这里，读者应该明白了为什么本文一开始在pom文件中需要加入对应的jackson依赖，为了让json转换器jackson成为默认转换器之一。</p><p><a href="mvc:annotation-driven" target="_blank" rel="noopener">mvc:annotation-driven</a>的作用读者也明白了。</p><p>下面我们看如何通过消息转换器将java对象进行转换的。</p><p>RequestMappingHandlerAdapter在进行handle的时候，会委托给HandlerMethod（具体由子类ServletInvocableHandlerMethod处理）的invokeAndHandle方法进行处理，这个方法又转接给HandlerMethodReturnValueHandlerComposite处理。</p><p>HandlerMethodReturnValueHandlerComposite维护了一个HandlerMethodReturnValueHandler列表。<strong>HandlerMethodReturnValueHandler是一个对返回值进行处理的策略接口，这个接口非常重要。关于这个接口的细节，请参考楼主的另外一篇博客：</strong><a href="http://www.cnblogs.com/fangjian0423/p/springMVC-request-param-analysis.html" target="_blank" rel="noopener">http://www.cnblogs.com/fangjian0423/p/springMVC-request-param-analysis.html</a>。然后找到对应的HandlerMethodReturnValueHandler对结果值进行处理。</p><p>最终找到RequestResponseBodyMethodProcessor这个Handler（由于使用了@ResponseBody注解）。</p><p>RequestResponseBodyMethodProcessor的supportsReturnType方法：</p><p><img src="https://images0.cnblogs.com/i/411512/201405/101803027605809.png" alt=""></p><p>然后使用handleReturnValue方法进行处理：</p><p><img src="https://images0.cnblogs.com/i/411512/201405/101803105889900.png" alt=""></p><p>我们看到，这里使用了转换器。　　</p><p>具体的转换方法：</p><p><img src="https://images0.cnblogs.com/i/411512/201405/101809037135949.png" alt=""></p><p><img src="https://images0.cnblogs.com/i/411512/201405/102031439173571.png" alt=""></p><p>至于为何是请求头部的<strong>Accept</strong>数据，读者可以进去debug这个<strong>getAcceptableMediaTypes</strong>方法看看。 我就不罗嗦了～～～</p><p> ok。至此，我们走遍了所有的流程。</p><p>现在，回过头来看。为什么一开始的demo输出了json数据？</p><p>我们来分析吧。</p><p>由于我们只配置了<a href="mvc:annotation-driven" target="_blank" rel="noopener">mvc:annotation-driven</a>，因此使用spring默认的那些转换器。</p><p><img src="https://images0.cnblogs.com/i/411512/201405/101816581047144.png" alt=""></p><p>很明显，我们看到了2个xml和1个json转换器。 <strong>要看能不能转换，得看HttpMessageConverter接口的public boolean canWrite(Class&lt;?&gt; clazz, MediaType mediaType)方法是否返回true来决定的。</strong></p><p>我们先分析SourceHttpMessageConverter：</p><p>它的canWrite方法被父类AbstractHttpMessageConverter重写了。</p><p><img src="https://images0.cnblogs.com/i/411512/201405/101830573234896.png" alt=""></p><p><img src="https://images0.cnblogs.com/i/411512/201405/101832284176592.png" alt=""></p><p><img src="https://images0.cnblogs.com/i/411512/201405/101832352929525.png" alt=""></p><p>发现SUPPORTED_CLASSES中没有Map类(本文demo返回的是Map类)，因此不支持。</p><p>下面看Jaxb2RootElementHttpMessageConverter：</p><p>这个类直接重写了canWrite方法。</p><p><img src="https://images0.cnblogs.com/i/411512/201405/101838053851073.png" alt=""></p><p>需要有XmlRootElement注解。 很明显，Map类当然没有。</p><p>最终MappingJackson2HttpMessageConverter匹配，进行json转换。（为何匹配，请读者自行查看源码）</p><h1 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h1><p> 我们分析了转换器的转换过程之后，下面就通过实例来验证我们的结论吧。</p><p>首先，我们先把xml转换器实现。</p><p>之前已经分析，默认的转换器中是支持xml的。下面我们加上注解试试吧。</p><p>由于Map是jdk源码中的部分，因此我们用Employee来做demo。</p><p>因此，Controller加上一个方法：</p><p><pre>@RequestMapping(“/xmlOrJsonSimple”)<br>@ResponseBody public Employee xmlOrJsonSimple() { return employeeService.getById(1);<br>}</pre></p><p>实体中加上@XmlRootElement注解</p><p><img src="https://images0.cnblogs.com/i/411512/201405/101903141989122.png" alt=""></p><p>结果如下：</p><p><img src="https://images0.cnblogs.com/i/411512/201405/101904598389030.png" alt=""></p><p>我们发现，解析成了xml。</p><p>这里为什么解析成xml，而不解析成json呢？</p><p>之前分析过，消息转换器是根据class和mediaType决定的。</p><p>我们使用firebug看到：</p><p><img src="https://images0.cnblogs.com/i/411512/201405/102222464019898.png" alt=""></p><p>我们发现Accept有xml，没有json。因此解析成xml了。</p><p>我们再来验证，同一地址，HTTP头部不同Accept。看是否正确。</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre>$.ajax({    url: "${request.contextPath}/employee/xmlOrJsonSimple",    success: function(res) {        console.log(res);    },    headers: { "Accept": "application/xml" }});</pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p><img src="https://images0.cnblogs.com/i/411512/201405/102231412601968.png" alt=""></p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre>$.ajax({    url: "${request.contextPath}/employee/xmlOrJsonSimple",    success: function(res) {        console.log(res);    },    headers: { "Accept": "application/json" }});</pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p><img src="https://images0.cnblogs.com/i/411512/201405/102231514794990.png" alt=""></p><p>验证成功。</p><h1 id="关于配置"><a href="#关于配置" class="headerlink" title="关于配置"></a>关于配置</h1><p>如果不想使用<a href="mvc:annotation-driven/" target="_blank" rel="noopener">mvc:annotation-driven/</a>中默认的RequestMappingHandlerAdapter的话，我们可以在重新定义这个bean，spring会覆盖掉默认的RequestMappingHandlerAdapter。</p><p>为何会覆盖，请参考楼主的另外一篇博客：<a href="http://www.cnblogs.com/fangjian0423/p/spring-Ordered-interface.html" target="_blank" rel="noopener">http://www.cnblogs.com/fangjian0423/p/spring-Ordered-interface.html</a></p><pre>    `<bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter">  <property name="messageConverters">    <list>      <bean class="org.springframework.http.converter.ByteArrayHttpMessageConverter">      <bean class="org.springframework.http.converter.StringHttpMessageConverter">      <bean class="org.springframework.http.converter.ResourceHttpMessageConverter">    </bean></bean></bean></list>  </property></bean>` </pre><p>或者如果只想换messageConverters的话。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.example.MyHttpMessageConverter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.example.MyOtherHttpMessageConverter"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果还想用其他converters的话。</p><p><img src="https://images0.cnblogs.com/i/411512/201405/102311480731629.png" alt=""></p><p>以上是spring-mvc jar包中的converters。</p><p>这里我们使用转换xml的MarshallingHttpMessageConverter。</p><p>这个converter里面使用了marshaller进行转换</p><p><img src="https://images0.cnblogs.com/i/411512/201405/102313161827280.png" alt=""></p><p>我们这里使用XStreamMarshaller。　　</p><p><img src="https://images0.cnblogs.com/i/411512/201405/102319292603758.png" alt=""></p><p><img src="https://images0.cnblogs.com/i/411512/201405/102319412294581.png" alt=""></p><p>json没有转换器，返回406.</p><p>至于xml格式的问题，大家自行解决吧。 这里用的是XStream～。</p><p>使用这种方式，pom别忘记了加入xstream的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.thoughtworks.xstream<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  xstream</span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> 写了这么多，可能读者觉得有点罗嗦。 毕竟这也是自己的一些心得，希望都能说出来与读者共享。</p><p>刚接触SpringMVC的时候，发现这种自动转换机制很牛逼，但是一直没有研究它的原理，目前，算是了了一个小小心愿吧，SpringMVC还有很多内容，以后自己研究其他内容的时候还会与大家一起共享的。</p><p>文章难免会出现一些错误，希望读者们能指明出来。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://my.oschina.net/HeliosFly/blog/205343" target="_blank" rel="noopener">http://my.oschina.net/HeliosFly/blog/205343</a></p><p><a href="http://my.oschina.net/lichhao/blog/172562" target="_blank" rel="noopener">http://my.oschina.net/lichhao/blog/172562</a></p><p><a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html" target="_blank" rel="noopener">http://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html</a></p><h1 id="详解RequestBody和-ResponseBody注解"><a href="#详解RequestBody和-ResponseBody注解" class="headerlink" title="详解RequestBody和@ResponseBody注解"></a>详解RequestBody和@ResponseBody注解</h1><p>概述 在SpringMVC中，可以使用@<a href="mailto:RequestBody%E5%92%8C@ResponseBody%E4%B8%A4%E4%B8%AA%E6%B3%A8%E8%A7%A3%EF%BC%8C%E5%88%86%E5%88%AB%E5%AE%8C%E6%88%90%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%88%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%88%B0%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%8C%E5%BA%95%E5%B1%82%E8%BF%99%E7%A7%8D%E7%81%B5%E6%B4%BB%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%B0%B1%E6%98%AFSpring3.x%E4%B8%AD%E6%96%B0%E5%BC%95%E5%85%A5%E7%9A%84HttpMessageConverter%E5%8D%B3%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8%E6%9C%BA%E5%88%B6%E3%80%82" target="_blank" rel="noopener">RequestBody和@ResponseBody两个注解，分别完成请求报文到对象和对象到响应报文的转换，底层这种灵活的消息转换机制，就是Spring3.x中新引入的HttpMessageConverter即消息转换器机制。</a></p><p>#Http请求的抽象 还是回到请求-响应，也就是解析请求体，然后返回响应报文这个最基本的Http请求过程中来。我们知道，在servlet标准中，可以用javax.servlet.ServletRequest接口中的以下方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">ServletInputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>来得到一个ServletInputStream。这个ServletInputStream中，可以读取到一个原始请求报文的所有内容。同样的，在javax.servlet.ServletResponse接口中，可以用以下方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">ServletOutputStream <span class="title">getOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>来得到一个ServletOutputStream，这个ServletOutputSteam，继承自java中的OutputStream，可以让你输出Http的响应报文内容。</p><p>让我们尝试着像SpringMVC的设计者一样来思考一下。我们知道，Http请求和响应报文本质上都是一串字符串，当请求报文来到java世界，它会被封装成为一个ServletInputStream的输入流，供我们读取报文。响应报文则是通过一个ServletOutputStream的输出流，来输出响应报文。</p><p>我们从流中，只能读取到原始的字符串报文，同样，我们往输出流中，也只能写原始的字符。而在java世界中，处理业务逻辑，都是以一个个有业务意义的<strong>对象</strong>为处理维度的，那么在报文到达SpringMVC和从SpringMVC出去，都存在一个字符串到java对象的阻抗问题。这一过程，不可能由开发者手工转换。我们知道，在Struts2中，采用了OGNL来应对这个问题，而在SpringMVC中，它是HttpMessageConverter机制。我们先来看两个接口。</p><p>#HttpInputMessage 这个类是SpringMVC内部对一次Http请求报文的抽象，在HttpMessageConverter的read()方法中，有一个HttpInputMessage的形参，它正是SpringMVC的消息转换器所作用的受体“请求消息”的内部抽象，消息转换器从“请求消息”中按照规则提取消息，转换为方法形参中声明的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpInputMessage</span> <span class="keyword">extends</span> <span class="title">HttpMessage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">InputStream <span class="title">getBody</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#HttpOutputMessage 这个类是SpringMVC内部对一次Http响应报文的抽象，在HttpMessageConverter的write()方法中，有一个HttpOutputMessage的形参，它正是SpringMVC的消息转换器所作用的受体“响应消息”的内部抽象，消息转换器将“响应消息”按照一定的规则写到响应报文中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpOutputMessage</span> <span class="keyword">extends</span> <span class="title">HttpMessage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">OutputStream <span class="title">getBody</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#HttpMessageConverter 对消息转换器最高层次的接口抽象，描述了一个消息转换器的一般特征，我们可以从这个接口中定义的方法，来领悟Spring3.x的设计者对这一机制的思考过程。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.http.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpInputMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpOutputMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> HttpMessageConverter&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> canRead(<span class="keyword">Class</span>&lt;?&gt; clazz, MediaType mediaType);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> canWrite(<span class="keyword">Class</span>&lt;?&gt; clazz, MediaType mediaType);</span><br><span class="line"></span><br><span class="line">List&lt;MediaType&gt; getSupportedMediaTypes();</span><br><span class="line"></span><br><span class="line">T <span class="keyword">read</span>(<span class="keyword">Class</span>&lt;? <span class="keyword">extends</span> T&gt; clazz, HttpInputMessage inputMessage)</span><br><span class="line"><span class="keyword">throws</span> IOException, HttpMessageNotReadableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">write</span>(T t, MediaType contentType, HttpOutputMessage outputMessage)</span><br><span class="line"><span class="keyword">throws</span> IOException, HttpMessageNotWritableException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HttpMessageConverter接口的定义出现了成对的canRead()，read()和canWrite()，write()方法，MediaType是对请求的Media Type属性的封装。举个例子，当我们声明了下面这个处理方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/string"</span>, method=RequestMethod.POST)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="built_in">String</span> readString(<span class="meta">@RequestBody</span> <span class="built_in">String</span> <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Read string '"</span> + <span class="built_in">string</span> + <span class="string">"'"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SpringMVC进入readString方法前，会根据@RequestBody注解选择适当的HttpMessageConverter实现类来将请求参数解析到string变量中，具体来说是使用了StringHttpMessageConverter类，它的canRead()方法返回true，然后它的read()方法会从请求中读出请求参数，绑定到readString()方法的string变量中。</p><p>当SpringMVC执行readString方法后，由于返回值标识了@ResponseBody，SpringMVC将使用StringHttpMessageConverter的write()方法，将结果作为String值写入响应报文，当然，此时canWrite()方法返回true。</p><p>我们可以用下面的图，简单描述一下这个过程。</p><p><img src="http://static.oschina.net/uploads/space/2013/1026/091627_zgNV_118997.png" alt="消息转换图"></p><p>#RequestResponseBodyMethodProcessor 将上述过程集中描述的一个类是org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor，这个类同时实现了HandlerMethodArgumentResolver和HandlerMethodReturnValueHandler两个接口。前者是将请求报文绑定到处理方法形参的策略接口，后者则是对处理方法返回值进行处理的策略接口。两个接口的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.method.support;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.MethodParameter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.WebDataBinder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.support.WebDataBinderFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.NativeWebRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter,</span></span></span><br><span class="line"><span class="function"><span class="params">   ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">   NativeWebRequest webRequest,</span></span></span><br><span class="line"><span class="function"><span class="params">   WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.web.method.support;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.MethodParameter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.NativeWebRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMethodReturnValueHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue,</span></span></span><br><span class="line"><span class="function"><span class="params">   MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">   ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">   NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RequestResponseBodyMethodProcessor这个类，同时充当了方法参数解析和返回值处理两种角色。我们从它的源码中，可以找到上面两个接口的方法实现。</p><p>对HandlerMethodArgumentResolver接口的实现：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> boolean supportsParameter(MethodParameter <span class="keyword">parameter</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">parameter</span>.hasParameterAnnotation(RequestBody.<span class="keyword">class</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object resolveArgument(MethodParameter <span class="keyword">parameter</span>, ModelAndViewContainer mavContainer,</span><br><span class="line">NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">Object argument = readWithMessageConverters(webRequest, <span class="keyword">parameter</span>, <span class="keyword">parameter</span>.getGenericParameterType());</span><br><span class="line"></span><br><span class="line">String <span class="keyword">name</span> = Conventions.getVariableNameForParameter(<span class="keyword">parameter</span>);</span><br><span class="line">WebDataBinder binder = binderFactory.createBinder(webRequest, argument, <span class="keyword">name</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argument <span class="comment">!= null) &#123;</span></span><br><span class="line">validate(binder, <span class="keyword">parameter</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + <span class="keyword">name</span>, binder.getBindingResult());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> argument;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对HandlerMethodReturnValueHandler接口的实现</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> returnType.getMethodAnnotation(ResponseBody.class) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> handleReturnValue(Object returnValue, MethodParameter returnType,</span><br><span class="line">ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span><br><span class="line"><span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException &#123;</span><br><span class="line"></span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">if</span> (returnValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">writeWithMessageConverters(returnValue, returnType, webRequest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完上面的代码，整个HttpMessageConverter消息转换的脉络已经非常清晰。因为两个接口的实现，分别是以是否有@RequestBody和@ResponseBody为条件，然后分别调用HttpMessageConverter来进行消息的读写。</p><p>如果你想问，怎么样跟踪到RequestResponseBodyMethodProcessor中，请你按照前面几篇博文的思路，然后到这里<a href="https://github.com/spring-projects/spring-mvc-showcase" target="_blank" rel="noopener">spring-mvc-showcase</a>下载源码回来，对其中HttpMessageConverter相关的例子进行debug，只要你肯下功夫，相信你一定会有属于自己的收获的。</p><p>#思考 张小龙在谈微信的本质时候说：“微信只是个平台，消息在其中流转”。在我们对SpringMVC源码分析的过程中，我们可以从HttpMessageConverter机制中领悟到类似的道理。在SpringMVC的设计者眼中，一次请求报文和一次响应报文，分别被抽象为一个请求消息HttpInputMessage和一个响应消息HttpOutputMessage。</p><p>处理请求时，由合适的消息转换器将请求报文绑定为方法中的形参对象，在这里，同一个对象就有可能出现多种不同的消息形式，比如json和xml。同样，当响应请求时，方法的返回值也同样可能被返回为不同的消息形式，比如json和xml。</p><p>在SpringMVC中，针对不同的消息形式，我们有不同的HttpMessageConverter实现类来处理各种消息形式。但是，只要这些消息所蕴含的“有效信息”是一致的，那么各种不同的消息转换器，都会生成同样的转换结果。至于各种消息间解析细节的不同，就被屏蔽在不同的HttpMessageConverter实现类中了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自 &lt;a href=&quot;https://www.cnblogs.com/fangjian0423/p/springMVC-xml-json-convert.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SpringMVC关于json、xml自动转换的原理研究[附带源码分析]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Spring源码解析 &lt;a href=&quot;https://blog.csdn.net/column/details/21851.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21851.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="SpringMVC" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/SpringMVC/"/>
    
    
      <category term="SpringMVC" scheme="http://h2pl.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC源码分析4：DispatcherServlet如何找到正确的Controller</title>
    <link href="http://h2pl.github.io/2018/06/06/springmvc4/"/>
    <id>http://h2pl.github.io/2018/06/06/springmvc4/</id>
    <published>2018-06-06T02:47:19.000Z</published>
    <updated>2018-06-12T03:53:51.065Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Spring源码解析 <a href="https://blog.csdn.net/column/details/21851.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21851.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a><br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SpringMVC是目前主流的Web MVC框架之一。 </p><p>我们使用浏览器通过地址 <a href="http://ip:port/contextPath/path进行访问，SpringMVC是如何得知用户到底是访问哪个Controller中的方法，这期间到底发生了什么。" target="_blank" rel="noopener">http://ip:port/contextPath/path进行访问，SpringMVC是如何得知用户到底是访问哪个Controller中的方法，这期间到底发生了什么。</a></p><p>本文将分析SpringMVC是如何处理请求与Controller之间的映射关系的，让读者知道这个过程中到底发生了什么事情。</p><p>本文实际上是在上文基础上，深入分析</p><pre>HandlerMapping里的</pre><pre>HandlerExecutionChain getHandler(HttpServletRequest var1) throws Exception;</pre><pre>该方法的具体实现，包括它如何找到对应的方法，以及如何把结果保存在map里，以便让请求转发到对应的handler上，同时也分析了handleradaptor具体做了什么事情。</pre><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>在分析源码之前，我们先了解一下几个东西。</p><p>1.这个过程中重要的接口和类。</p><p><strong>HandlerMethod类：</strong></p><p>　　Spring3.1版本之后引入的。 是一个封装了方法参数、方法注解，方法返回值等众多元素的类。</p><p>　　<img src="https://images0.cnblogs.com/i/411512/201405/232033308878895.jpg" alt=""></p><p>　　它的子类InvocableHandlerMethod有两个重要的属性WebDataBinderFactory和HandlerMethodArgumentResolverComposite， 很明显是对请求进行处理的。</p><p>　　InvocableHandlerMethod的子类ServletInvocableHandlerMethod有个重要的属性HandlerMethodReturnValueHandlerComposite，很明显是对响应进行处理的。</p><p>　　ServletInvocableHandlerMethod这个类在HandlerAdapter对每个请求处理过程中，都会实例化一个出来(上面提到的属性由HandlerAdapter进行设置)，分别对请求和返回进行处理。　　(RequestMappingHandlerAdapter源码，实例化ServletInvocableHandlerMethod的时候分别set了上面提到的重要属性)</p><p>　　<img src="https://images0.cnblogs.com/i/411512/201405/240149411377243.png" alt=""></p><p><strong>MethodParameter类：</strong></p><p>　　HandlerMethod类中的parameters属性类型，是一个MethodParameter数组。MethodParameter是一个封装了方法参数具体信息的工具类，包括参数的的索引位置，类型，注解，参数名等信息。</p><p>　　HandlerMethod在实例化的时候，构造函数中会初始化这个数组，这时只初始化了部分数据，在HandlerAdapter对请求处理过程中会完善其他属性，之后交予合适的HandlerMethodArgumentResolver接口处理。</p><p>　　以类DeptController为例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(value = <span class="meta-string">"/dept"</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> IDeptService deptService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping(<span class="meta-string">"/update"</span>)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="keyword">public</span> String update(Dept dept) &#123;</span><br><span class="line">    deptService.saveOrUpdate(dept);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　(刚初始化时的数据)　　</p><p><img src="https://images0.cnblogs.com/i/411512/201405/241246397157212.png" alt=""></p><p>　　(HandlerAdapter处理后的数据)</p><p><img src="https://images0.cnblogs.com/i/411512/201405/241246574657656.png" alt=""></p><p><strong>RequestCondition接口：</strong></p><p>　　<strong>Spring3.1版本之后引入的。 是SpringMVC的映射基础中的请求条件，可以进行combine, compareTo，getMatchingCondition操作。这个接口是映射匹配的关键接口，其中getMatchingCondition方法关乎是否能找到合适的映射。</strong></p><p>　　<img src="https://images0.cnblogs.com/i/411512/201405/241429158878034.png" alt=""></p><p><strong>RequestMappingInfo类：</strong></p><p>　　Spring3.1版本之后引入的。 是一个封装了各种请求映射条件并实现了RequestCondition接口的类。</p><p>　　有各种RequestCondition实现类属性，patternsCondition，methodsCondition，paramsCondition，headersCondition，consumesCondition以及producesCondition，这个请求条件看属性名也了解，分别代表http请求的路径模式、方法、参数、头部等信息。</p><p>　　<img src="https://images0.cnblogs.com/i/411512/201405/241556162777007.png" alt=""></p><p><strong>RequestMappingHandlerMapping类：</strong></p><p> 　　处理请求与HandlerMethod映射关系的一个类。</p><p>2.Web服务器启动的时候，SpringMVC到底做了什么。</p><p>先看AbstractHandlerMethodMapping的initHandlerMethods方法中。</p><p><img src="https://images0.cnblogs.com/i/411512/201405/241831201065104.png" alt=""></p><p><img src="https://images0.cnblogs.com/i/411512/201405/241922304028276.png" alt=""></p><p><img src="https://images0.cnblogs.com/i/411512/201405/241932113242502.png" alt=""></p><p>我们进入createRequestMappingInfo方法看下是如何构造RequestMappingInfo对象的。</p><p><img src="https://images0.cnblogs.com/i/411512/201405/251242523404424.png" alt=""></p><p>PatternsRequestCondition构造函数：</p><p><img src="https://images0.cnblogs.com/i/411512/201405/252348515124305.png" alt=""></p><p>类对应的RequestMappingInfo存在的话，跟方法对应的RequestMappingInfo进行combine操作。</p><p><img src="https://images0.cnblogs.com/i/411512/201405/250107154024892.png" alt=""></p><p>然后使用符合条件的method来注册各种HandlerMethod。</p><p><img src="https://images0.cnblogs.com/i/411512/201405/260023477461660.png" alt=""></p><p>下面我们来看下各种RequestCondition接口的实现类的combine操作。</p><p>PatternsRequestCondition：</p><p><img src="https://images0.cnblogs.com/i/411512/201405/251617000436911.png" alt=""></p><p><img src="https://images0.cnblogs.com/i/411512/201405/251917084021029.png" alt=""></p><p>RequestMethodsRequestCondition：</p><p>方法的请求条件，用个set直接add即可。</p><p><img src="https://images0.cnblogs.com/i/411512/201405/251919265597456.png" alt=""></p><p>其他相关的RequestConditon实现类读者可自行查看源码。</p><p>最终，RequestMappingHandlerMapping中两个比较重要的属性</p><p>private final Map&lt;T, HandlerMethod&gt; handlerMethods = new LinkedHashMap&lt;T, HandlerMethod&gt;();</p><p>private final MultiValueMap&lt;String, T&gt; urlMap = new LinkedMultiValueMap&lt;String, T&gt;();</p><p>T为RequestMappingInfo。</p><p>构造完成。</p><p>我们知道，SpringMVC的分发器DispatcherServlet会根据浏览器的请求地址获得HandlerExecutionChain。</p><p>这个过程我们看是如何实现的。</p><p>首先看HandlerMethod的获得(直接看关键代码了)：</p><p><img src="https://images0.cnblogs.com/i/411512/201405/252206079491274.png" alt=""></p><p>这里的比较器是使用RequestMappingInfo的compareTo方法(RequestCondition接口定义的)。</p><p><img src="https://images0.cnblogs.com/i/411512/201405/252219494658063.png" alt=""></p><p>然后构造HandlerExecutionChain加上拦截器</p><p><img src="https://images0.cnblogs.com/i/411512/201405/252208290431970.png" alt=""></p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>写了这么多，来点例子让我们验证一下吧。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Controller</span></span><br><span class="line"><span class="variable">@RequestMapping</span>(value = <span class="string">"/wildcard"</span>)</span><br><span class="line">public class TestWildcardController &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable">@RequestMapping</span>(<span class="string">"/test/**"</span>)</span><br><span class="line">  <span class="variable">@ResponseBody</span></span><br><span class="line">  public String test1(ModelAndView view) &#123;</span><br><span class="line">    <span class="selector-tag">view</span><span class="selector-class">.setViewName</span>(<span class="string">"/test/test"</span>);</span><br><span class="line">    <span class="selector-tag">view</span><span class="selector-class">.addObject</span>(<span class="string">"attr"</span>, <span class="string">"TestWildcardController -&gt; /test/**"</span>);</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">view</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @<span class="selector-tag">RequestMapping</span>(<span class="string">"/test/*"</span>)</span><br><span class="line">  @<span class="selector-tag">ResponseBody</span></span><br><span class="line">  <span class="selector-tag">public</span> <span class="selector-tag">String</span> <span class="selector-tag">test2</span>(ModelAndView view) &#123;</span><br><span class="line">    <span class="selector-tag">view</span><span class="selector-class">.setViewName</span>(<span class="string">"/test/test"</span>);</span><br><span class="line">    <span class="selector-tag">view</span><span class="selector-class">.addObject</span>(<span class="string">"attr"</span>, <span class="string">"TestWildcardController -&gt; /test*"</span>);</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">view</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @<span class="selector-tag">RequestMapping</span>(<span class="string">"test?"</span>)</span><br><span class="line">  @<span class="selector-tag">ResponseBody</span></span><br><span class="line">  <span class="selector-tag">public</span> <span class="selector-tag">String</span> <span class="selector-tag">test3</span>(ModelAndView view) &#123;</span><br><span class="line">    <span class="selector-tag">view</span><span class="selector-class">.setViewName</span>(<span class="string">"/test/test"</span>);</span><br><span class="line">    <span class="selector-tag">view</span><span class="selector-class">.addObject</span>(<span class="string">"attr"</span>, <span class="string">"TestWildcardController -&gt; test?"</span>);</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">view</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @<span class="selector-tag">RequestMapping</span>(<span class="string">"test/*"</span>)</span><br><span class="line">  @<span class="selector-tag">ResponseBody</span></span><br><span class="line">  <span class="selector-tag">public</span> <span class="selector-tag">String</span> <span class="selector-tag">test4</span>(ModelAndView view) &#123;</span><br><span class="line">    <span class="selector-tag">view</span><span class="selector-class">.setViewName</span>(<span class="string">"/test/test"</span>);</span><br><span class="line">    <span class="selector-tag">view</span><span class="selector-class">.addObject</span>(<span class="string">"attr"</span>, <span class="string">"TestWildcardController -&gt; test/*"</span>);</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">view</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这里的每个pattern都带了*因此，都不会加入到urlMap中，但是handlerMethods还是有的。</p><p><img src="https://images0.cnblogs.com/i/411512/201405/260032509654870.png" alt=""></p><p>当我们访问：<a href="http://localhost:8888/SpringMVCDemo/wildcard/test1的时候。" target="_blank" rel="noopener">http://localhost:8888/SpringMVCDemo/wildcard/test1的时候。</a></p><p>会先根据 “/wildcard/test1” 找urlMap对应的RequestMappingInfo集合，找不到的话取handlerMethods集合中所有的key集合(也就是RequestMappingInfo集合)。</p><p>然后进行匹配，匹配根据RequestCondition的getMatchingCondition方法。</p><p><img src="https://images0.cnblogs.com/i/411512/201405/260046407936253.png" alt=""></p><p>最终匹配到2个RequestMappingInfo：</p><p><img src="https://images0.cnblogs.com/i/411512/201405/260049401063106.png" alt=""></p><p>然后会使用比较器进行排序。</p><p>之前也分析过，比较器是有优先级的。</p><p>我们看到，RequestMappingInfo除了pattern，其他属性都是一样的。</p><p>我们看下PatternsRequestCondition比较的逻辑：</p><p><img src="https://images0.cnblogs.com/i/411512/201405/260125371817100.png" alt=""></p><p><img src="https://images0.cnblogs.com/i/411512/201405/260125488223078.png" alt=""></p><p>因此，/test*的通配符比/test?的多，因此，最终选择了/test?</p><p><img src="https://images0.cnblogs.com/i/411512/201405/260129091195087.png" alt=""></p><p>直接比较优先于通配符。</p><p><img src="https://images0.cnblogs.com/i/411512/201405/260129342756267.png" alt=""></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Controller</span></span><br><span class="line"><span class="variable">@RequestMapping</span>(value = <span class="string">"/priority"</span>)</span><br><span class="line">public class TestPriorityController &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable">@RequestMapping</span>(method = RequestMethod.GET)</span><br><span class="line">  <span class="variable">@ResponseBody</span></span><br><span class="line">  public String test1(ModelAndView view) &#123;</span><br><span class="line">    <span class="selector-tag">view</span><span class="selector-class">.setViewName</span>(<span class="string">"/test/test"</span>);</span><br><span class="line">    <span class="selector-tag">view</span><span class="selector-class">.addObject</span>(<span class="string">"attr"</span>, <span class="string">"其他condition相同，带有method属性的优先级高"</span>);</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">view</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @<span class="selector-tag">RequestMapping</span>()</span><br><span class="line">  @<span class="selector-tag">ResponseBody</span></span><br><span class="line">  <span class="selector-tag">public</span> <span class="selector-tag">String</span> <span class="selector-tag">test2</span>(ModelAndView view) &#123;</span><br><span class="line">    <span class="selector-tag">view</span><span class="selector-class">.setViewName</span>(<span class="string">"/test/test"</span>);</span><br><span class="line">    <span class="selector-tag">view</span><span class="selector-class">.addObject</span>(<span class="string">"attr"</span>, <span class="string">"其他condition相同，不带method属性的优先级高"</span>);</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">view</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里例子，其他requestCondition都一样，只有RequestMethodCondition不一样。</p><p><img src="https://images0.cnblogs.com/i/411512/201405/260151358222728.png" alt=""></p><p>看出，方法多的优先级越多。</p><p><img src="https://images0.cnblogs.com/i/411512/201405/260152065252948.png" alt=""></p><p>至于其他的RequestCondition，大家自行查看源码吧。</p><h1 id="资源文件映射"><a href="#资源文件映射" class="headerlink" title="资源文件映射"></a>资源文件映射</h1><p>以上分析均是基于Controller方法的映射(RequestMappingHandlerMapping)。</p><p>SpringMVC中还有静态文件的映射，SimpleUrlHandlerMapping。</p><p>DispatcherServlet找对应的HandlerExecutionChain的时候会遍历属性handlerMappings，这个一个实现了HandlerMapping接口的集合。</p><p>由于我们在*-dispatcher.xml中加入了以下配置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:resources <span class="attribute">location</span>=<span class="string">"/static/"</span> <span class="attribute">mapping</span>=<span class="string">"/static/**"</span>/&gt;</span><br></pre></td></tr></table></figure><p> Spring解析配置文件会使用ResourcesBeanDefinitionParser进行解析的时候，会实例化出SimpleUrlHandlerMapping。</p><p><img src="https://images0.cnblogs.com/i/411512/201405/261025451501584.jpg" alt=""></p><p><img src="https://images0.cnblogs.com/i/411512/201405/261026409781228.jpg" alt=""></p><p>其中注册的HandlerMethod为ResourceHttpRequestHandler。</p><p>访问地址：<a href="http://localhost:8888/SpringMVCDemo/static/js/jquery-1.11.0.js" target="_blank" rel="noopener">http://localhost:8888/SpringMVCDemo/static/js/jquery-1.11.0.js</a></p><p><img src="https://images0.cnblogs.com/i/411512/201405/261013551199069.jpg" alt=""></p><p><img src="https://images0.cnblogs.com/i/411512/201405/261028504315946.jpg" alt=""></p><p>地址匹配到/static/**。</p><p>最终SimpleUrlHandlerMapping找到对应的Handler -&gt; ResourceHttpRequestHandler。</p><p>ResourceHttpRequestHandler进行handleRequest的时候，直接输出资源文件的文本内容。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>大致上整理了一下SpringMVC对请求的处理，包括其中比较关键的类和接口，希望对读者有帮助。</p><p>让自己对SpringMVC有了更深入的认识，也为之后分析数据绑定，拦截器、HandlerAdapter等打下基础。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Spring源码解析 &lt;a href=&quot;https://blog.csdn.net/column/details/21851.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21851.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="SpringMVC" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/SpringMVC/"/>
    
    
      <category term="SpringMVC" scheme="http://h2pl.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC源码分析3：DispatcherServlet的初始化与请求转发</title>
    <link href="http://h2pl.github.io/2018/06/06/springmvc3/"/>
    <id>http://h2pl.github.io/2018/06/06/springmvc3/</id>
    <published>2018-06-06T02:47:15.000Z</published>
    <updated>2018-06-12T03:52:19.800Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Spring源码解析 <a href="https://blog.csdn.net/column/details/21851.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21851.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a><br><a id="more"></a></p><p>在我们第一次学Servlet编程，学java web的时候，还没有那么多框架。我们开发一个简单的功能要做的事情很简单，就是继承HttpServlet，根据需要重写一下doGet，doPost方法，跳转到我们定义好的jsp页面。Servlet类编写完之后在web.xml里注册这个Servlet类。</p><p>除此之外，没有其他了。我们启动web服务器，在浏览器中输入地址，就可以看到浏览器上输出我们写好的页面。为了更好的理解上面这个过程，你需要学习关于Servlet生命周期的三个阶段，就是所谓的“init-service-destroy”。</p><p>以上的知识，我觉得对于你理解SpringMVC的设计思想，已经足够了。SpringMVC当然可以称得上是一个复杂的框架，但是同时它又遵循Servlet世界里最简单的法则，那就是“init-service-destroy”。我们要分析SpringMVC的初始化流程，其实就是分析DispatcherServlet类的init()方法，让我们带着这种单纯的观点，打开DispatcherServlet的源码一窥究竟吧。</p><h2 id="配置元素读取"><a href="#配置元素读取" class="headerlink" title="配置元素读取"></a><init-param>配置元素读取</init-param></h2><p>用Eclipse IDE打开DispatcherServlet类的源码，ctrl+T看一下。</p><p><img src="http://static.oschina.net/uploads/space/2013/0114/170921_edHO_118997.jpg" alt=""></p><p>DispatcherServlet类的初始化入口方法init()定义在HttpServletBean这个父类中，HttpServletBean类作为一个直接继承于HttpServlet类的类，覆写了HttpServlet类的init()方法，实现了自己的初始化行为。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Initializing servlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line">BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, <span class="keyword">this</span>.environment));</span><br><span class="line">initBeanWrapper(bw);</span><br><span class="line">bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">logger.<span class="keyword">error</span>(<span class="string">"Failed to set bean properties on servlet '"</span> + getServletName() + <span class="string">"'"</span>, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">initServletBean();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Servlet '"</span> + getServletName() + <span class="string">"' configured successfully"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的initServletBean()方法在HttpServletBean类中是一个没有任何实现的空方法，它的目的就是留待子类实现自己的初始化逻辑，也就是我们常说的模板方法设计模式。SpringMVC在此生动的运用了这个模式，init()方法就是模版方法模式中的模板方法，SpringMVC真正的初始化过程，由子类FrameworkServlet中覆写的initServletBean()方法触发。</p><p>再看一下init()方法内被try,catch块包裹的代码，里面涉及到BeanWrapper，PropertyValues，ResourceEditor这些Spring内部非常底层的类。要深究具体代码实现上面的细节，需要对Spring框架源码具有相当深入的了解。我们这里先避繁就简，从代码效果和设计思想上面来分析这段try,catch块内的代码所做的事情：</p><ul><li>注册一个字符串到资源文件的编辑器，让Servlet下面的<init-param>配置元素可以使用形如“classpath:”这种方式指定SpringMVC框架bean配置文件的来源。</init-param></li><li>将web.xml中在DispatcherServlet这个Servlet下面的<init-param>配置元素利用JavaBean的方式（即通过setter方法）读取到DispatcherServlet中来。</init-param></li></ul><p>这两点，我想通过下面一个例子来说明一下。</p><p>我在web.xml中注册的DispatcherServlet配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- springMVC配置开始 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>appServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/spring-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>appServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- springMVC配置结束 --&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，我注册了一个名为contextConfigLocation的<init-param>元素，其值为“classpath:spring/spring-servlet.xml”，这也是大家常常用来指定SpringMVC配置文件路径的方法。上面那段try,catch块包裹的代码发挥的作用，一个是将“classpath:spring/spring-servlet.xml”这段字符串转换成classpath路径下的一个资源文件，供框架初始化读取配置元素。在我的工程中是在spring文件夹下面的配置文件spring-servlet.xml。</init-param></p><p><img src="http://static.oschina.net/uploads/space/2013/0114/185832_7twm_118997.jpg" alt=""></p><p>另外一个作用，就是将contextConfigLocation的值读取出来，然后通过setContextConfigLocation()方法设置到DispatcherServlet中，这个setContextConfigLocation()方法是在FrameworkServlet类中定义的，也就是上面继承类图中DispatcherServlet的直接父类。</p><p>我们在setContextConfigLocation()方法上面打上一个断点，启动web工程，可以看到下面的调试结果。</p><p><img src="http://static.oschina.net/uploads/space/2013/0114/190308_tfyy_118997.jpg" alt=""></p><p>HttpServletBean类的作者是大名鼎鼎的Spring之父Rod Johnson。作为POJO编程哲学的大师，他在HttpServletBean这个类的设计中，运用了依赖注入思想完成了<init-param>配置元素的读取。他抽离出HttpServletBean这个类的目的也在于此，就是“以依赖注入的方式来读取Servlet类的<init-param>配置信息”，而且这里很明显是一种setter注入。</init-param></init-param></p><p>明白了HttpServletBean类的设计思想，我们也就知道可以如何从中获益。具体来说，我们继承HttpServletBean类（就像DispatcherServlet做的那样），在类中定义一个属性，为这个属性加上setter方法后，我们就可以在<init-param>元素中为其定义值。在类被初始化后，值就会被注入进来，我们可以直接使用它，避免了样板式的getInitParameter()方法的使用，而且还免费享有Spring中资源编辑器的功能，可以在web.xml中，通过“classpath:”直接指定类路径下的资源文件。</init-param></p><p>注意，虽然SpringMVC本身为了后面初始化上下文的方便，使用了字符串来声明和设置contextConfigLocation参数，但是将其声明为Resource类型，同样能够成功获取。鼓励读者们自己继承HttpServletBean写一个测试用的Servlet类，并设置一个参数来调试一下，这样能够帮助你更好的理解获取配置参数的过程。</p><h2 id="容器上下文的建立"><a href="#容器上下文的建立" class="headerlink" title="容器上下文的建立"></a>容器上下文的建立</h2><p>上一篇文章中提到过，SpringMVC使用了Spring容器来容纳自己的配置元素，拥有自己的bean容器上下文。在SpringMVC初始化的过程中，非常关键的一步就是要建立起这个容器上下文，而这个建立上下文的过程，发生在FrameworkServlet类中，由上面init()方法中的initServletBean()方法触发。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">getServletContext().log(<span class="string">"Initializing Spring FrameworkServlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.info(<span class="string">"FrameworkServlet '"</span> + getServletName() + <span class="string">"': initialization started"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">initFrameworkServlet();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ServletException ex) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.<span class="keyword">error</span>(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.<span class="keyword">error</span>(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line"><span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line"><span class="keyword">this</span>.logger.info(<span class="string">"FrameworkServlet '"</span> + getServletName() + <span class="string">"': initialization completed in "</span> +</span><br><span class="line">elapsedTime + <span class="string">" ms"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initFrameworkServlet()方法是一个没有任何实现的空方法，除去一些样板式的代码，那么这个initServletBean()方法所做的事情已经非常明白：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br></pre></td></tr></table></figure><p>这一句简单直白的代码，道破了FrameworkServlet这个类，在SpringMVC类体系中的设计目的，它是 用来抽离出建立 WebApplicationContext 上下文这个过程的。</p><p>initWebApplicationContext()方法，封装了建立Spring容器上下文的整个过程，方法内的逻辑如下：</p><ol><li>获取由ContextLoaderListener初始化并注册在ServletContext中的根上下文，记为rootContext</li><li>如果webApplicationContext已经不为空，表示这个Servlet类是通过编程式注册到容器中的（Servlet 3.0+中的ServletContext.addServlet() ），上下文也由编程式传入。若这个传入的上下文还没被初始化，将rootContext上下文设置为它的父上下文，然后将其初始化，否则直接使用。</li><li>通过wac变量的引用是否为null，判断第2步中是否已经完成上下文的设置（即上下文是否已经用编程式方式传入），如果wac==null成立，说明该Servlet不是由编程式注册到容器中的。此时以contextAttribute属性的值为键，在ServletContext中查找上下文，查找得到，说明上下文已经以别的方式初始化并注册在contextAttribute下，直接使用。</li><li>检查wac变量的引用是否为null，如果wac==null成立，说明2、3两步中的上下文初始化策略都没成功，此时调用createWebApplicationContext(rootContext)，建立一个全新的以rootContext为父上下文的上下文，作为SpringMVC配置元素的容器上下文。大多数情况下我们所使用的上下文，就是这个新建的上下文。</li><li>以上三种初始化上下文的策略，都会回调onRefresh(ApplicationContext context)方法（回调的方式根据不同策略有不同），onRefresh方法在DispatcherServlet类中被覆写，以上面得到的上下文为依托，完成SpringMVC中默认实现类的初始化。</li><li>最后，将这个上下文发布到ServletContext中，也就是将上下文以一个和Servlet类在web.xml中注册名字有关的值为键，设置为ServletContext的一个属性。你可以通过改变publishContext的值来决定是否发布到ServletContext中，默认为true。</li></ol><p>以上面6点跟踪FrameworkServlet类中的代码，可以比较清晰的了解到整个容器上下文的建立过程，也就能够领会到FrameworkServlet类的设计目的，它是用来建立一个和Servlet关联的Spring容器上下文，并将其注册到ServletContext中的。跳脱开SpringMVC体系，我们也能通过继承FrameworkServlet类，得到与Spring容器整合的好处，FrameworkServlet和HttpServletBean一样，是一个可以独立使用的类。整个SpringMVC设计中，处处体现开闭原则，这里显然也是其中一点。</p><h2 id="初始化SpringMVC默认实现类"><a href="#初始化SpringMVC默认实现类" class="headerlink" title="初始化SpringMVC默认实现类"></a>初始化SpringMVC默认实现类</h2><p>初始化流程在FrameworkServlet类中流转，建立了上下文后，通过onRefresh(ApplicationContext context)方法的回调，进入到DispatcherServlet类中。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">initStrategies(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DispatcherServlet类覆写了父类FrameworkServlet中的onRefresh(ApplicationContext context)方法，提供了SpringMVC各种编程元素的初始化。当然这些编程元素，都是作为容器上下文中一个个bean而存在的。具体的初始化策略，在initStrategies()方法中封装。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void initStrategies(ApplicationContext <span class="built_in">context</span>) &#123;</span><br><span class="line">initMultipartResolver(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">initLocaleResolver(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">initThemeResolver(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">initHandlerMappings(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">initHandlerAdapters(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">initHandlerExceptionResolvers(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">initRequestToViewNameTranslator(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">initViewResolvers(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">initFlashMapManager(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们以其中initHandlerMappings(context)方法为例，分析一下这些SpringMVC编程元素的初始化策略，其他的方法，都是以类似的策略初始化的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> void initHandlerMappings(ApplicationContext context) &#123;</span><br><span class="line"><span class="keyword">this</span>.handlerMappings = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerMappings) &#123;</span><br><span class="line"><span class="comment">// Find all HandlerMappings in the ApplicationContext, including ancestor contexts.</span></span><br><span class="line">Map&lt;String, HandlerMapping&gt; matchingBeans =</span><br><span class="line">BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.<span class="keyword">class</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">this</span>.handlerMappings = new ArrayList&lt;HandlerMapping&gt;(matchingBeans.values());</span><br><span class="line"><span class="comment">// We keep HandlerMappings in sorted order.</span></span><br><span class="line">OrderComparator.sort(<span class="keyword">this</span>.handlerMappings);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.<span class="keyword">class</span>);</span><br><span class="line"><span class="keyword">this</span>.handlerMappings = Collections.singletonList(hm);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="comment">// Ignore, we'll add a default HandlerMapping later.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ensure we have at least one HandlerMapping, by registering</span></span><br><span class="line"><span class="comment">// a default HandlerMapping if no other mappings are found.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping.<span class="keyword">class</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"No HandlerMappings found in servlet '"</span> + getServletName() + <span class="string">"': using default"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>detectAllHandlerMappings变量默认为true，所以在初始化HandlerMapping接口默认实现类的时候，会把上下文中所有HandlerMapping类型的Bean都注册在handlerMappings这个List变量中。如果你手工将其设置为false，那么将尝试获取名为handlerMapping的Bean，新建一个只有一个元素的List，将其赋给handlerMappings。如果经过上面的过程，handlerMappings变量仍为空，那么说明你没有在上下文中提供自己HandlerMapping类型的Bean定义。此时，SpringMVC将采用默认初始化策略来初始化handlerMappings。</p><p>点进去getDefaultStrategies看一下。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; List&lt;T&gt; getDefaultStrategies(ApplicationContext context, Class&lt;T&gt; strategyInterface) &#123;</span><br><span class="line"><span class="keyword">String</span> <span class="built_in">key</span> = strategyInterface.getName();</span><br><span class="line"><span class="keyword">String</span> value = defaultStrategies.getProperty(<span class="built_in">key</span>);</span><br><span class="line"><span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">String</span>[] classNames = StringUtils.commaDelimitedListToStringArray(value);</span><br><span class="line">List&lt;T&gt; strategies = <span class="keyword">new</span> ArrayList&lt;T&gt;(classNames.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">String</span> className : classNames) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader());</span><br><span class="line"><span class="keyword">Object</span> strategy = createDefaultStrategy(context, clazz);</span><br><span class="line">strategies.<span class="built_in">add</span>((T) strategy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(</span><br><span class="line"><span class="string">"Could not find DispatcherServlet's default strategy class ["</span> + className +</span><br><span class="line"><span class="string">"] for interface ["</span> + <span class="built_in">key</span> + <span class="string">"]"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (LinkageError err) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(</span><br><span class="line"><span class="string">"Error loading DispatcherServlet's default strategy class ["</span> + className +</span><br><span class="line"><span class="string">"] for interface ["</span> + <span class="built_in">key</span> + <span class="string">"]: problem with class file or dependent class"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> strategies;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;T&gt;();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它是一个范型的方法，承担所有SpringMVC编程元素的默认初始化策略。方法的内容比较直白，就是以传递类的名称为键，从defaultStrategies这个Properties变量中获取实现类，然后反射初始化。</p><p>需要说明一下的是defaultStrategies变量的初始化，它是在DispatcherServlet的静态初始化代码块中加载的。</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Properties defaultStrategies;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="comment">// Load default strategy implementations from properties file.</span></span><br><span class="line"><span class="comment">// This is currently strictly internal and not meant to be customized</span></span><br><span class="line"><span class="comment">// by application developers.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.<span class="keyword">class</span>);</span><br><span class="line">defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not load 'DispatcherServlet.properties': "</span> + ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> DEFAULT_STRATEGIES_PATH = <span class="string">"DispatcherServlet.properties"</span>;</span><br></pre></td></tr></table></figure><p>这个DispatcherServlet.properties里面，以键值对的方式，记录了SpringMVC默认实现类，它在spring-webmvc-3.1.3.RELEASE.jar这个jar包内，在org.springframework.web.servlet包里面。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Default implementation classes for DispatcherServlet's strategy interfaces.</span></span><br><span class="line"><span class="comment"># Used as fallback when no matching beans are found in the DispatcherServlet context.</span></span><br><span class="line"><span class="comment"># Not meant to be customized by application developers.</span></span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.<span class="attribute">LocaleResolver</span>=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.<span class="attribute">ThemeResolver</span>=org.springframework.web.servlet.theme.FixedThemeResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.<span class="attribute">HandlerMapping</span>=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</span><br><span class="line">org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.<span class="attribute">HandlerAdapter</span>=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</span><br><span class="line">org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</span><br><span class="line">org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.<span class="attribute">HandlerExceptionResolver</span>=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\</span><br><span class="line">org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\</span><br><span class="line">org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.<span class="attribute">RequestToViewNameTranslator</span>=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.<span class="attribute">ViewResolver</span>=org.springframework.web.servlet.view.InternalResourceViewResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.<span class="attribute">FlashMapManager</span>=org.springframework.web.servlet.support.SessionFlashMapManager</span><br></pre></td></tr></table></figure><p>至此，我们分析完了initHandlerMappings(context)方法的执行过程，其他的初始化过程与这个方法非常类似。所有初始化方法执行完后，SpringMVC正式完成初始化，静静等待Web请求的到来。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回顾整个SpringMVC的初始化流程，我们看到，通过HttpServletBean、FrameworkServlet、DispatcherServlet三个不同的类层次，SpringMVC的设计者将三种不同的职责分别抽象，运用模版方法设计模式分别固定在三个类层次中。其中HttpServletBean完成的是<init-param>配置元素的依赖注入，FrameworkServlet完成的是容器上下文的建立，DispatcherServlet完成的是SpringMVC具体编程元素的初始化策略。</init-param></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Spring源码解析 &lt;a href=&quot;https://blog.csdn.net/column/details/21851.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21851.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="SpringMVC" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/SpringMVC/"/>
    
    
      <category term="SpringMVC" scheme="http://h2pl.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC源码分析2：SpringMVC设计理念与DispatcherServlet</title>
    <link href="http://h2pl.github.io/2018/06/06/springmvc2/"/>
    <id>http://h2pl.github.io/2018/06/06/springmvc2/</id>
    <published>2018-06-06T02:44:34.000Z</published>
    <updated>2018-06-12T03:51:37.136Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://my.oschina.net/lichhao/blog" target="_blank" rel="noopener">https://my.oschina.net/lichhao/blog</a></p><p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Spring源码解析 <a href="https://blog.csdn.net/column/details/21851.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21851.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a><br><a id="more"></a></p><h2 id="SpringMVC简介"><a href="#SpringMVC简介" class="headerlink" title="SpringMVC简介"></a>SpringMVC简介</h2><p>SpringMVC作为Struts2之后异军突起的一个表现层框架，正越来越流行，相信javaee的开发者们就算没使用过SpringMVC，也应该对其略有耳闻。我试图通过对SpringMVC的设计思想和源码实现的剖析，从抽象意义上的设计层面和实现意义上的代码层面两个方面，逐一揭开SpringMVC神秘的面纱，本文的代码，都是基于Spring的 3.1.3RELEASE版本。</p><p>任何一个框架，都有自己特定的适用领域，框架的设计和实现，必定是为了应付该领域内许多通用的，烦琐的、基础的工作而生。SpringMVC作为一个表现层框架，也必须直面Web开发领域中表现层中的几大课题，并给出自己的回答：</p><ul><li>URL到框架的映射。</li><li>http请求参数绑定</li><li>http响应的生成和输出</li></ul><p>这三大课题，组成一个完整的web请求流程，每一个部分都具有非常广阔的外延。SpringMVC框架对这些课题的回答又是什么呢？</p><p>学习一个框架，首要的是要先领会它的设计思想。从抽象、从全局上来审视这个框架。其中最具有参考价值的，就是这个框架所定义的核心接口。核心接口定义了框架的骨架，也在最抽象的意义上表达了框架的设计思想。</p><p>下面我以一个web请求流程为载体，依次介绍SpringMVC的核心接口和类。</p><p>用户在浏览器中，输入了<a href="http://www.xxxx.com/aaa/bbb.ccc的地址，回车后，浏览器发起一个http请求。请求到达你的服务器后，首先会被SpringMVC注册在web.xml中的前端转发器DispatcherServlet接收，DispatcherServlet是一个标准的Servlet，它的作用是接受和转发web请求到内部框架处理单元。" target="_blank" rel="noopener">http://www.xxxx.com/aaa/bbb.ccc的地址，回车后，浏览器发起一个http请求。请求到达你的服务器后，首先会被SpringMVC注册在web.xml中的前端转发器DispatcherServlet接收，DispatcherServlet是一个标准的Servlet，它的作用是接受和转发web请求到内部框架处理单元。</a></p><h2 id="HandlerMapping接口"><a href="#HandlerMapping接口" class="headerlink" title="HandlerMapping接口"></a>HandlerMapping接口</h2><p>下面看一下第一个出现在你面前的核心接口，它是在org.springframework.web.servlet包中定义的HandlerMapping接口：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.web.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMapping</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE = HandlerMapping.<span class="keyword">class</span>.getName() + <span class="string">".pathWithinHandlerMapping"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.<span class="keyword">class</span>.getName() + <span class="string">".bestMatchingPattern"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> INTROSPECT_TYPE_LEVEL_MAPPING = HandlerMapping.<span class="keyword">class</span>.getName() + <span class="string">".introspectTypeLevelMapping"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> URI_TEMPLATE_VARIABLES_ATTRIBUTE = HandlerMapping.<span class="keyword">class</span>.getName() + <span class="string">".uriTemplateVariables"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE = HandlerMapping.<span class="keyword">class</span>.getName() + <span class="string">".producibleMediaTypes"</span>;</span><br><span class="line"></span><br><span class="line">HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了阅读方便，我去掉了源码中的注释，但是我强烈建议你一定要记得去阅读它，这样你才能从框架的设计者口中得到最准确的关于这个类或者接口的设计说明。类中定义的几个常量，我们先不去管它。关键在于这个接口中唯一的方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><p>这个方法就算对于一个java初学者来说，也很容易理解：它只有一个类型为HttpServletRequest的参数，throws Exception的声明表示它不处理任何类型的异常，HandlerExecutionChain是它的返回类型。</p><h2 id="DispatcherServlet接受请求并找到对应Handler"><a href="#DispatcherServlet接受请求并找到对应Handler" class="headerlink" title="DispatcherServlet接受请求并找到对应Handler"></a>DispatcherServlet接受请求并找到对应Handler</h2><p>回到DispatcherServlet的处理流程，当DispatcherServlet接收到web请求后，由标准Servlet类处理方法doGet或者doPost，经过几次转发后，最终注册在DispatcherServlet类中的HandlerMapping实现类组成的一个List（有点拗口）会在一个循环中被遍历。以该web请求的HttpServletRequest对象为参数，依次调用其getHandler方法，第一个不为null的调用结果，将被返回。DispatcherServlet类中的这个遍历方法不长，贴一下，让大家有更直观的了解。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the HandlerExecutionChain for this request.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Tries all handler mappings in order.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the HandlerExecutionChain, or &lt;code&gt;null&lt;/code&gt; if no handler could be found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function">HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (HandlerMapping hm : <span class="keyword">this</span>.handlerMappings) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(</span><br><span class="line"><span class="string">"Testing handler map ["</span> + hm + <span class="string">"] in DispatcherServlet with name '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">HandlerExecutionChain <span class="keyword">handler</span> = hm.getHandler(request);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">handler</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">handler</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是的，第一步处理就这么简单的完成了。一个web请求经过处理后，会得到一个HandlerExecutionChain对象，这就是SpringMVC对URl映射给出的回答。需要留意的是，HandlerMapping接口的getHandler方法参数是HttpServletRequest，这意味着，HandlerMapping的实现类可以利用HttpServletRequest中的 所有信息来做出这个HandlerExecutionChain对象的生成”决策“。这包括，请求头、url路径、cookie、session、参数等等一切你从一个web请求中可以得到的任何东西（最常用的是url路径）。</p><p>SpirngMVC的第一个扩展点，就出现在这里。我们可以编写任意的HandlerMapping实现类，依据任何策略来决定一个web请求到HandlerExecutionChain对象的生成。可以说，从第一个核心接口的声明开始，SpringMVC就把自己的灵活性和野心暴露无疑：哥玩的就是”Open-Closed“。</p><p>HandlerExecutionChain这个类，就是我们下一个要了解的核心类。从名字可以直观的看得出，这个对象是一个执行链的封装。熟悉Struts2的都知道，Action对象也是被层层拦截器包装，这里可以做个类比，说明SpringMVC确实是吸收了Struts2的部分设计思想。</p><p>HandlerExecutionChain类的代码不长，它定义在org.springframework.web.servlet包中，为了更直观的理解，先上代码。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.util.CollectionUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerExecutionChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> HandlerInterceptor[] interceptors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerInterceptor&gt; interceptorList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> HandlerExecutionChain(Object handler) &#123;</span><br><span class="line"><span class="keyword">this</span>(handler, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> HandlerExecutionChain(Object handler, HandlerInterceptor[] interceptors) &#123;</span><br><span class="line"><span class="keyword">if</span> (handler instanceof HandlerExecutionChain) &#123;</span><br><span class="line">HandlerExecutionChain originalChain = (HandlerExecutionChain) handler;</span><br><span class="line"><span class="keyword">this</span>.handler = originalChain.getHandler();</span><br><span class="line"><span class="keyword">this</span>.interceptorList = new ArrayList&lt;HandlerInterceptor&gt;();</span><br><span class="line">CollectionUtils.mergeArrayIntoCollection(originalChain.getInterceptors(), <span class="keyword">this</span>.interceptorList);</span><br><span class="line">CollectionUtils.mergeArrayIntoCollection(interceptors, <span class="keyword">this</span>.interceptorList);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.handler = handler;</span><br><span class="line"><span class="keyword">this</span>.interceptors = interceptors;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object getHandler() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> void addInterceptor(HandlerInterceptor interceptor) &#123;</span><br><span class="line">initInterceptorList();</span><br><span class="line"><span class="keyword">this</span>.interceptorList.add(interceptor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> void addInterceptors(HandlerInterceptor[] interceptors) &#123;</span><br><span class="line"><span class="keyword">if</span> (interceptors != <span class="literal">null</span>) &#123;</span><br><span class="line">initInterceptorList();</span><br><span class="line"><span class="keyword">this</span>.interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> void initInterceptorList() &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.interceptorList == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.interceptorList = new ArrayList&lt;HandlerInterceptor&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.interceptors != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.interceptorList.addAll(Arrays.asList(<span class="keyword">this</span>.interceptors));</span><br><span class="line"><span class="keyword">this</span>.interceptors = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> HandlerInterceptor[] getInterceptors() &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.interceptors == <span class="literal">null</span> &amp;&amp; <span class="keyword">this</span>.interceptorList != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.interceptors = <span class="keyword">this</span>.interceptorList.toArray(new HandlerInterceptor[<span class="keyword">this</span>.interceptorList.size()]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.interceptors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String toString() &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.handler == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"HandlerExecutionChain with no handler"</span>;</span><br><span class="line">&#125;</span><br><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">sb.append(<span class="string">"HandlerExecutionChain with handler ["</span>).append(<span class="keyword">this</span>.handler).append(<span class="string">"]"</span>);</span><br><span class="line"><span class="keyword">if</span> (!CollectionUtils.isEmpty(<span class="keyword">this</span>.interceptorList)) &#123;</span><br><span class="line">sb.append(<span class="string">" and "</span>).append(<span class="keyword">this</span>.interceptorList.size()).append(<span class="string">" interceptor"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.interceptorList.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">sb.append(<span class="string">"s"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乱七八糟一大堆，相信你也没全看完，也没必要全看。其实只需要看两行足矣。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object <span class="keyword">handler</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> HandlerInterceptor[] interceptors;</span><br></pre></td></tr></table></figure><p>不出我们所料，一个实质执行对象，还有一堆拦截器。这不就是Struts2中的实现么，SpringMVC没有避嫌，还是采用了这种封装。得到HandlerExecutionChain这个执行链（execution chain）之后，下一步的处理将围绕其展开。</p><h2 id="HandlerInterceptor接口"><a href="#HandlerInterceptor接口" class="headerlink" title="HandlerInterceptor接口"></a>HandlerInterceptor接口</h2><p>HandlerInterceptor也是SpringMVC的核心接口，定义如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> preHandle(HttpServletRequest request, HttpServletResponse response, Object <span class="keyword">handler</span>)</span><br><span class="line">    <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> postHandle(</span><br><span class="line">HttpServletRequest request, HttpServletResponse response, Object <span class="keyword">handler</span>, ModelAndView modelAndView)</span><br><span class="line"><span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> afterCompletion(</span><br><span class="line">HttpServletRequest request, HttpServletResponse response, Object <span class="keyword">handler</span>, Exception ex)</span><br><span class="line"><span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，HandlerExecutionChain整个执行脉络也就清楚了：在真正调用其handler对象前，HandlerInterceptor接口实现类组成的数组将会被遍历，其preHandle方法会被依次调用，然后真正的handler对象将被调用。</p><p>handler对象被调用后，就生成了需要的响应数据，在将处理结果写到HttpServletResponse对象之前（SpringMVC称为渲染视图），其postHandle方法会被依次调用。视图渲染完成后，最后afterCompletion方法会被依次调用，整个web请求的处理过程就结束了。</p><p>在一个处理对象执行之前，之后利用拦截器做文章，这已经成为一种经典的框架设计套路。Struts2中的拦截器会做诸如参数绑定这类复杂的工作，那么SpringMVC的拦截器具体做些什么呢？我们暂且不关心，虽然这是很重要的细节，但细节毕竟是细节，我们先来理解更重要的东西。</p><p>HandlerInterceptor，是SpringMVC的第二个扩展点的暴露，通过自定义拦截器，我们可以在一个请求被真正处理之前、请求被处理但还没输出到响应中、请求已经被输出到响应中之后这三个时间点去做任何我们想要做的事情。Struts2框架的成功，就是源于这种拦截器的设计，SpringMVC吸收了这种设计思想，并推陈出新，更合理的划分了三个不同的时间点，从而给web请求处理这个流程，提供了更大的扩展性。</p><p>这个HandlerExecutionChain类中以Object引用所声明的handler对象，到底是个什么东东？它是怎么被调用的？</p><h2 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h2><p>回答这些问题之前，先看SpringMVC中的又一个核心接口，HandlerAdapter：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object <span class="keyword">handler</span>)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object <span class="keyword">handler</span>)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object <span class="keyword">handler</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在DispatcherServlet中，除了HandlerMapping实现类的列表，同样也注册了一个HandlerAdapter实现类组成的列表，有代码为证。</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/** <span class="built_in">List</span> <span class="keyword">of</span> HandlerMappings used by this servlet */</span><br><span class="line">private <span class="built_in">List</span>&lt;HandlerMapping&gt; handlerMappings;</span><br><span class="line"></span><br><span class="line">/** <span class="built_in">List</span> <span class="keyword">of</span> HandlerAdapters used by this servlet */</span><br><span class="line">private <span class="built_in">List</span>&lt;HandlerAdapter&gt; handlerAdapters;</span><br></pre></td></tr></table></figure><p>接下来，我们再以DispatcherServlet类中另外一段代码来回答上述的问题：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the HandlerAdapter for this handler object.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler the handler object to find an adapter for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ServletException if no HandlerAdapter can be found for the handler. This is a fatal error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function">HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object <span class="keyword">handler</span>)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (HandlerAdapter ha : <span class="keyword">this</span>.handlerAdapters) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Testing handler adapter ["</span> + ha + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ha.supports(<span class="keyword">handler</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> ha;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"No adapter for handler ["</span> + <span class="keyword">handler</span> +</span><br><span class="line"><span class="string">"]: Does your handler implement a supported interface like Controller?"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="请求流程总结"><a href="#请求流程总结" class="headerlink" title="请求流程总结"></a>请求流程总结</h2><p>这段代码已经很明显了，HandlerExecutionChain中的handler对象会被作为参数传递进去，在DispatcherServlet类中注册的HandlerAdapter实现类列表会被遍历，然后返回第一个supports方法返回true的HandlerAdapter对象，用这个HandlerAdapter实现类中的handle方法处理handler对象，并返回ModelAndView这个包含了视图和数据的对象。HandlerAdapter就是SpringMVC提供的第三个扩展点，你可以提供自己的实现类来处理handler对象。</p><p>ModelAndView对象的代码就不贴了，它是SpringMVC中对视图和数据的一个聚合类。其中的视图，就是由SpringMVC的最后一个核心接口View所抽象：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.web.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.<span class="built_in">Map</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">interface</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> RESPONSE_STATUS_ATTRIBUTE = View.<span class="keyword">class</span>.getName() + <span class="string">".responseStatus"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> PATH_VARIABLES = View.<span class="keyword">class</span>.getName() + <span class="string">".pathVariables"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> getContentType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> render(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的数据，最后会作为一个Map对象传递到View实现类中的render方法，调用这个render方法，就完成了视图到响应的渲染。这个View实现类，就是来自HandlerAdapter中的handle方法的返回结果。当然从ModelAndView到真正的View实现类有一个解析的过程，ModelAndView中可以有真正的视图对象，也可以只是有一个视图的名字，SpringMVC会负责将视图名称解析为真正的视图对象。</p><p>至此，我们了解了一个典型的完整的web请求在SpringMVC中的处理过程和其中涉及到的核心类和接口。</p><p>在一个典型的SpringMVC调用中，HandlerExecutionChain中封装handler对象就是用@Controller注解标识的类的一个实例，根据类级别和方法级别的@RequestMapping注解，由默认注册的DefaultAnnotationHandlerMapping（3.1.3中更新为RequestMappingHandlerMapping类，但是为了向后兼容，DefaultAnnotationHandlerMapping也可以使用）生成HandlerExecutionChain对象，再由AnnotationMethodHandlerAdapter（3.1.3中更新为RequestMappingHandlerAdapter类，但是为了向后兼容，AnnotationMethodHandlerAdapter也可以使用）来执行这个HandlerExecutionChain对象，生成最终的ModelAndView对象后，再由具体的View对象的render方法渲染视图。</p><p>可以看到，作为一个表现层框架，SpringMVC没有像Struts2那样激进，并没有采用和Web容器完全解耦的设计思想，而是以原生的Servlet框架对象为依托，通过合理的抽象，制定了严谨的的处理流程。这样做的结果是，执行效率比Struts2要高，灵活性也上升了一个层次。    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://my.oschina.net/lichhao/blog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://my.oschina.net/lichhao/blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Spring源码解析 &lt;a href=&quot;https://blog.csdn.net/column/details/21851.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21851.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="SpringMVC" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/SpringMVC/"/>
    
    
      <category term="SpringMVC" scheme="http://h2pl.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC源码分析1：SpringMVC概述</title>
    <link href="http://h2pl.github.io/2018/06/06/springmvc1/"/>
    <id>http://h2pl.github.io/2018/06/06/springmvc1/</id>
    <published>2018-06-06T02:29:08.000Z</published>
    <updated>2018-06-12T07:52:14.111Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>转自：<a href="http://jinnianshilongnian.iteye.com/category/231099" target="_blank" rel="noopener">跟开涛学SpringMVC</a></p><p>欢迎阅览我的CSDN专栏：Spring源码解析 <a href="https://blog.csdn.net/column/details/21851.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21851.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><h2 id="Web-MVC简介"><a href="#Web-MVC简介" class="headerlink" title="Web MVC简介"></a>Web MVC简介</h2><h3 id="Web开发中的请求-响应模型："><a href="#Web开发中的请求-响应模型：" class="headerlink" title="Web开发中的请求-响应模型："></a>Web开发中的请求-响应模型：</h3><p> <img src="http://sishuok.com/forum/upload/2012/7/1/2fc5edc55fa262fddccecc1816f5ff7b__1.JPG" alt=""></p><p>在Web世界里，具体步骤如下：</p><p>1、  Web浏览器（如IE）发起请求，如访问<a href="http://sishuok.com/" target="_blank" rel="noopener">http://sishuok.com</a></p><p>2、  Web服务器（如Tomcat）接收请求，处理请求（比如用户新增，则将把用户保存一下），最后产生响应（一般为html）。</p><p>3、web服务器处理完成后，返回内容给web客户端（一般就是我们的浏览器），客户端对接收的内容进行处理（如web浏览器将会对接收到的html内容进行渲染以展示给客户）。</p><p><strong>因此，在Web世界里：</strong></p><p>都是Web客户端发起请求，Web服务器接收、处理并产生响应。</p><p>一般Web服务器是不能主动通知Web客户端更新内容。虽然现在有些技术如服务器推（如Comet）、还有现在的HTML5 websocket可以实现Web服务器主动通知Web客户端。</p><p>到此我们了解了在web开发时的请求/响应模型，接下来我们看一下标准的MVC模型是什么。</p><h3 id="标准MVC模型概述"><a href="#标准MVC模型概述" class="headerlink" title="标准MVC模型概述"></a>标准MVC模型概述</h3><p><strong>MVC模型：</strong>是一种架构型的模式，本身不引入新功能，只是帮助我们将开发的结构组织的更加合理，使展示与模型分离、流程控制逻辑、业务逻辑调用与展示逻辑分离。如图1-2</p><p> <img src="http://sishuok.com/forum/upload/2012/7/1/a633b31a42f0224c9bf66cd3cc886e04__2.JPG" alt=""></p><p>图1-2</p><p><strong>首先让我们了解下MVC（Model-View-Controller）三元组的概念：</strong></p><p><strong>Model（模型）：</strong>数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据） 和 服务层（行为）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。</p><p><strong>View（视图）：</strong>负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。</p><p><strong>Controller（控制器）：</strong>接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。 也就是说控制器做了个调度员的工作，。</p><p>从图1-1我们还看到，在标准的MVC中模型能主动推数据给视图进行更新（观察者设计模式，在模型上注册视图，当模型更新时自动更新视图），但在Web开发中模型是无法主动推给视图（无法主动更新用户界面），因为在Web开发是请求-响应模型。</p><p>那接下来我们看一下在Web里MVC是什么样子，我们称其为 Web MVC 来区别标准的MVC。</p><h3 id="Web-MVC概述"><a href="#Web-MVC概述" class="headerlink" title="Web MVC概述"></a>Web MVC概述</h3><p>模型-视图-控制器概念和标准MVC概念一样，请参考1.2，我们再看一下Web MVC标准架构，如图1-3：</p><p><img src="http://sishuok.com/forum/upload/2012/7/1/baa1df353ed98b79231b535bc1f73dea__3.JPG" alt=""> </p><p>如图1-3</p><p>在Web MVC模式下，模型无法主动推数据给视图，如果用户想要视图更新，需要再发送一次请求（即请求-响应模型）。</p><p>概念差不多了，我们接下来了解下Web端开发的发展历程，和使用代码来演示一下Web MVC是如何实现的，还有为什么要使用MVC这个模式呢？</p><h3 id="Web端开发发展历程"><a href="#Web端开发发展历程" class="headerlink" title="Web端开发发展历程"></a>Web端开发发展历程</h3><p>此处我们只是简单的叙述比较核心的历程，如图1-4</p><p> <img src="http://sishuok.com/forum/upload/2012/7/1/41f193e4f961be27d511789df2ee7680__4.JPG" alt=""></p><p>图1-4</p><p><strong>1.4.1、CGI</strong>：（Common Gateway Interface）公共网关接口，一种在web服务端使用的脚本技术，使用C或Perl语言编写，用于接收web用户请求并处理，最后动态产生响应给用户，但每次请求将产生一个进程，重量级。</p><p><strong>1.4.2、Servlet</strong>：一种JavaEE web组件技术，是一种在服务器端执行的web组件，用于接收web用户请求并处理，最后动态产生响应给用户。但每次请求只产生一个线程（而且有线程池），轻量级。而且能利用许多JavaEE技术（如JDBC等）。本质就是在java代码里面 输出 html流。但表现逻辑、控制逻辑、业务逻辑调用混杂。如图1-5    </p><p><img src="http://sishuok.com/forum/upload/2012/7/1/799db5c79c85cb59b68b915916f8dddc__5.JPG" alt="" title="点击查看原始大小图片"> </p><p>图1-5</p><p>如图1-5，这种做法是绝对不可取的，控制逻辑、表现代码、业务逻辑对象调用混杂在一起，最大的问题是直接在Java代码里面输出Html，这样前端开发人员无法进行页面风格等的设计与修改，即使修改也是很麻烦，因此实际项目这种做法不可取。</p><p><strong>1.4.3、JSP：</strong>（Java Server Page）：一种在服务器端执行的web组件，是一种运行在标准的HTML页面中嵌入脚本语言（现在只支持Java）的模板页面技术。本质就是在html代码中嵌入java代码。JSP最终还是会被编译为Servlet，只不过比纯Servlet开发页面更简单、方便。但表现逻辑、控制逻辑、业务逻辑调用还是混杂。如图1-6</p><p> <img src="http://sishuok.com/forum/upload/2012/7/1/7486df5510b6068a360d8f0c6bbb706c__6.JPG" alt="" title="点击查看原始大小图片"></p><p>图1-6</p><p>如图1-6，这种做法也是绝对不可取的，控制逻辑、表现代码、业务逻辑对象调用混杂在一起，但比直接在servlet里输出html要好一点，前端开发人员可以进行简单的页面风格等的设计与修改（但如果嵌入的java脚本太多也是很难修改的），因此实际项目这种做法不可取。</p><p> <img src="http://sishuok.com/forum/upload/2012/7/1/c59e61daa2ed98f75aab1ae3397fb235__7.JPG" alt=""></p><p>JSP本质还是Servlet，最终在运行时会生成一个Servlet（如tomcat，将在tomcat\work\Catalina\web应用名\org\apache\jsp下生成），但这种使得写html简单点，但仍是控制逻辑、表现代码、业务逻辑对象调用混杂在一起。</p><p><strong>1.4.4、Model1：</strong>可以认为是JSP的增强版，可以认为是jsp+javabean如图1-7</p><p>特点：使用<a href="jsp:useBean" target="_blank" rel="noopener">jsp:useBean</a>标准动作，自动将请求参数封装为JavaBean组件；还必须使用java脚本执行控制逻辑。</p><p> <img src="http://sishuok.com/forum/upload/2012/7/1/c25b9ce9064a37ab93ffe02711b3ecc7__8.JPG" alt="" title="点击查看原始大小图片"></p><p>图1-7</p><p>此处我们可以看出，使用<a href="jsp:useBean" target="_blank" rel="noopener">jsp:useBean</a>标准动作可以简化javabean的获取/创建，及将请求参数封装到javabean，再看一下Model1架构，如图1-8。</p><p> <img src="http://sishuok.com/forum/upload/2012/7/1/d3b5b2ec88706fff7ef4b98d110837d1__9.JPG" alt="" title="点击查看原始大小图片"></p><p>图1-8 Model1架构</p><p>Model1架构中，JSP负责控制逻辑、表现逻辑、业务对象（javabean）的调用，只是比纯JSP简化了获取请求参数和封装请求参数。同样是不好的，在项目中应该严禁使用（或最多再demo里使用）。</p><p><strong>1.4.5、Model2：</strong>在JavaEE世界里，它可以认为就是<strong>Web MVC</strong>模型</p><p>Model2架构其实可以认为就是我们所说的Web MVC模型，只是控制器采用Servlet、模型采用JavaBean、视图采用JSP，如图1-9</p><p> <img src="http://sishuok.com/forum/upload/2012/7/1/a6b7b2ca293e610a7a2b32e47a16d718__10.JPG" alt="" title="点击查看原始大小图片"></p><p>图1-9 Model2架构</p><p>具体代码事例如下：</p><p> <img src="http://sishuok.com/forum/upload/2012/7/1/254a61cd5c20f1e8f0e1012f02cdaa31__11.JPG" alt="" title="点击查看原始大小图片"></p><p> <img src="http://sishuok.com/forum/upload/2012/7/1/0ec4c098750790295eaad2f1b3a4dc82__12.JPG" alt="" title="点击查看原始大小图片"></p><p><img src="http://sishuok.com/forum/upload/2012/7/1/1f330763be94e5abe7ecdd7928930dbb__13.JPG" alt="" title="点击查看原始大小图片"></p><p>从Model2架构可以看出，视图和模型分离了，控制逻辑和展示逻辑分离了。</p><p>但我们也看到严重的缺点：</p><p>1．  1、控制器：</p><p>1．1．1、控制逻辑可能比较复杂，其实我们可以按照规约，如请求参数submitFlag=toAdd，我们其实可以直接调用toAdd方法，来简化控制逻辑；而且每个模块基本需要一个控制器，造成控制逻辑可能很复杂；</p><p>1．1．2、请求参数到模型的封装比较麻烦，如果能交给框架来做这件事情，我们可以从中得到解放；</p><p>1．1．3、选择下一个视图，严重依赖Servlet API，这样很难或基本不可能更换视图；</p><p>1．1．4、给视图传输要展示的模型数据，使用Servlet API，更换视图技术也要一起更换，很麻烦。</p><p>1.2、模型：</p><p>1．2．1、此处模型使用JavaBean，可能造成JavaBean组件类很庞大，一般现在项目都是采用三层架构，而不采用JavaBean。</p><p> <img src="http://sishuok.com/forum/upload/2012/7/1/1570f54f6a52301d8ea58fe8fa9efb29__14.JPG" alt=""></p><p>1.3、视图</p><p>1．3．1、现在被绑定在JSP，很难更换视图，比如Velocity、FreeMarker；比如我要支持Excel、PDF视图等等。</p><p><strong>1.4.5、服务到工作者：Front Controller + Application Controller + Page Controller + Context</strong></p><p>即，前端控制器+应用控制器+页面控制器（也有称其为动作）+上下文，也是Web MVC，只是责任更加明确，详情请参考《核心J2EE设计模式》和《企业应用架构模式》如图1-10：</p><p> <img src="http://sishuok.com/forum/upload/2012/7/1/e7fae17e52bb3664d0d3f4ea8db7ae55__15.JPG" alt="" title="点击查看原始大小图片"></p><p>图1-10</p><p>运行流程如下：</p><p> <img src="http://sishuok.com/forum/upload/2012/7/1/925c5ff2cc8613c898b05a4817db1f56__16.JPG" alt="" title="点击查看原始大小图片"></p><p>职责：</p><p><strong>Front Controller：</strong>前端控制器，负责为表现层提供统一访问点，从而避免Model2中出现的重复的控制逻辑（由前端控制器统一回调相应的功能方法，如前边的根据submitFlag=login转调login方法）；并且可以为多个请求提供共用的逻辑（如准备上下文等等），将选择具体视图和具体的功能处理（如login里边封装请求参数到模型，并调用业务逻辑对象）分离。</p><p><strong>Application Controller：</strong>应用控制器，前端控制器分离选择具体视图和具体的功能处理之后，需要有人来管理，应用控制器就是用来选择具体视图技术（视图的管理）和具体的功能处理（页面控制器/命令对象/动作管理），一种策略设计模式的应用，可以很容易的切换视图/页面控制器，相互不产生影响。</p><p><strong>Page Controller(Command)：</strong>页面控制器/动作/处理器：功能处理代码，收集参数、封装参数到模型，转调业务对象处理模型，返回逻辑视图名交给前端控制器（和具体的视图技术解耦），由前端控制器委托给应用控制器选择具体的视图来展示，可以是命令设计模式的实现。页面控制器也被称为处理器或动作。</p><p><strong>Context：</strong>上下文，还记得Model2中为视图准备要展示的模型数据吗，我们直接放在request中（Servlet API相关），有了上下文之后，我们就可以将相关数据放置在上下文，从而与协议无关（如Servlet API）的访问/设置模型数据，一般通过ThreadLocal模式实现。</p><p>到此，我们回顾了整个web开发架构的发展历程，可能不同的web层框架在细节处理方面不同，但的目的是一样的：</p><p>干净的web表现层：</p><pre><code>模型和视图的分离；</code></pre><p>控制器中的控制逻辑与功能处理分离（收集并封装参数到模型对象、业务对象调用）；</p><p>控制器中的视图选择与具体视图技术分离。</p><p>轻薄的web表现层：</p><pre><code>做的事情越少越好，薄薄的，不应该包含无关代码；   只负责收集并组织参数到模型对象，启动业务对象的调用；   控制器只返回逻辑视图名并由相应的应用控制器来选择具体使用的视图策略；   尽量少使用框架特定API，保证容易测试。</code></pre><p>到此我们了解Web MVC的发展历程，接下来让我们了解下Spring MVC到底是什么、架构及来个HelloWorld了解下具体怎么使用吧。</p><p>本章具体代码请参考 springmvc-chapter1工程。</p><h2 id="Spring-Web-MVC是什么"><a href="#Spring-Web-MVC是什么" class="headerlink" title="Spring Web MVC是什么"></a>Spring Web MVC是什么</h2><p>Spring Web MVC是一种基于Java的实现了Web MVC设计模式的请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将web层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，Spring Web MVC也是要简化我们日常Web开发的。</p><p>另外还有一种基于组件的、事件驱动的Web框架在此就不介绍了，如Tapestry、JSF等。</p><p>Spring Web MVC也是服务到工作者模式的实现，但进行可优化。前端控制器是<code>DispatcherServlet；</code>应用控制器其实拆为处理器映射器(Handler Mapping)进行处理器管理和视图解析器(View Resolver)进行视图管理；页面控制器/动作/处理器为Controller接口（仅包含<code>ModelAndView handleRequest(request, response)</code> 方法）的实现（也可以是任何的POJO类）；支持本地化（Locale）解析、主题（Theme）解析及文件上传等；提供了非常灵活的数据验证、格式化和数据绑定机制；提供了强大的约定大于配置（惯例优先原则）的契约式编程支持。</p><h2 id="Spring-Web-MVC能帮我们做什么"><a href="#Spring-Web-MVC能帮我们做什么" class="headerlink" title="Spring Web MVC能帮我们做什么"></a>Spring Web MVC能帮我们做什么</h2><p>√让我们能非常简单的设计出干净的Web层和薄薄的Web层；</p><p>√进行更简洁的Web层的开发；</p><p>√天生与Spring框架集成（如IoC容器、AOP等）；</p><p>√提供强大的约定大于配置的契约式编程支持；</p><p>√能简单的进行Web层的单元测试；</p><p>√支持灵活的URL到页面控制器的映射；</p><p>√非常容易与其他视图技术集成，如Velocity、FreeMarker等等，因为模型数据不放在特定的API里，而是放在一个Model里（<code>Map</code>数据结构实现，因此很容易被其他框架使用）；</p><p>√非常灵活的数据验证、格式化和数据绑定机制，能使用任何对象进行数据绑定，不必实现特定框架的API；</p><p>√提供一套强大的JSP标签库，简化JSP开发；</p><p>√支持灵活的本地化、主题等解析；</p><p>√更加简单的异常处理；</p><p>√对静态资源的支持；</p><p>√支持Restful风格。</p><h2 id="Spring-Web-MVC架构"><a href="#Spring-Web-MVC架构" class="headerlink" title="Spring Web MVC架构"></a>Spring Web MVC架构</h2><p>Spring Web MVC框架也是一个基于请求驱动的Web框架，并且也使用了前端控制器模式来进行设计，再根据请求映射规则分发给相应的页面控制器（动作/处理器）进行处理。首先让我们整体看一下Spring Web MVC处理请求的流程：</p><h3 id="Spring-Web-MVC处理请求的流程"><a href="#Spring-Web-MVC处理请求的流程" class="headerlink" title="Spring Web MVC处理请求的流程"></a>Spring Web MVC处理请求的流程</h3><p>如图2-1</p><p> <img src="http://sishuok.com/forum/upload/2012/7/14/529024df9d2b0d1e62d8054a86d866c9__1.JPG" alt="" title="点击查看原始大小图片"></p><p>图2-1</p><p>具体执行步骤如下：</p><p>1、  首先用户发送请求————&gt;前端控制器，前端控制器根据请求信息（如URL）来决定选择哪一个页面控制器进行处理并把请求委托给它，即以前的控制器的控制逻辑部分；图2-1中的1、2步骤；</p><p>2、  页面控制器接收到请求后，进行功能处理，首先需要收集和绑定请求参数到一个对象，这个对象在Spring Web MVC中叫命令对象，并进行验证，然后将命令对象委托给业务对象进行处理；处理完毕后返回一个ModelAndView（模型数据和逻辑视图名）；图2-1中的3、4、5步骤；</p><p>3、  前端控制器收回控制权，然后根据返回的逻辑视图名，选择相应的视图进行渲染，并把模型数据传入以便视图渲染；图2-1中的步骤6、7；</p><p>4、  前端控制器再次收回控制权，将响应返回给用户，图2-1中的步骤8；至此整个结束。</p><p>问题：</p><p>1、  请求如何给前端控制器？</p><p>2、  前端控制器如何根据请求信息选择页面控制器进行功能处理？</p><p>3、  如何支持多种页面控制器呢？</p><p>4、  如何页面控制器如何使用业务对象？</p><p>5、  页面控制器如何返回模型数据？</p><p>6、  前端控制器如何根据页面控制器返回的逻辑视图名选择具体的视图进行渲染？</p><p>7、  不同的视图技术如何使用相应的模型数据？</p><p>首先我们知道有如上问题，那这些问题如何解决呢？请让我们先继续，在后边依次回答。</p><h3 id="Spring-Web-MVC架构-1"><a href="#Spring-Web-MVC架构-1" class="headerlink" title="Spring Web MVC架构"></a>Spring Web MVC架构</h3><p>1、Spring Web MVC核心架构图，如图2-2</p><p> <img src="http://sishuok.com/forum/upload/2012/7/14/57ea9e7edeebd5ee2ec0cf27313c5fb6__2.JPG" alt="" title="点击查看原始大小图片"></p><p>图2-2</p><p>架构图对应的DispatcherServlet核心代码如下：</p><p>java代码：</p><pre><code>//前端控制器分派方法  protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {          HttpServletRequest processedRequest = request;          HandlerExecutionChain mappedHandler = null;          int interceptorIndex = -1;          try {              ModelAndView mv;              boolean errorView = false;              try {                     //检查是否是请求是否是multipart（如文件上传），如果是将通过MultipartResolver解析                  processedRequest = checkMultipart(request);                     //步骤2、请求到处理器（页面控制器）的映射，通过HandlerMapping进行映射                  mappedHandler = getHandler(processedRequest, false);                  if (mappedHandler == null || mappedHandler.getHandler() == null) {                      noHandlerFound(processedRequest, response);                      return;                  }                     //步骤3、处理器适配，即将我们的处理器包装成相应的适配器（从而支持多种类型的处理器）                  HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());                    // 304 Not Modified缓存支持                  //此处省略具体代码                  // 执行处理器相关的拦截器的预处理（HandlerInterceptor.preHandle）                  //此处省略具体代码                  // 步骤4、由适配器执行处理器（调用处理器相应功能处理方法）                  mv = ha.handle(processedRequest, response, mappedHandler.getHandler());                  // Do we need view name translation?                  if (mv != null &amp;&amp; !mv.hasView()) {                      mv.setViewName(getDefaultViewName(request));                  }                  // 执行处理器相关的拦截器的后处理（HandlerInterceptor.postHandle）                  //此处省略具体代码              }              catch (ModelAndViewDefiningException ex) {                  logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, ex);                  mv = ex.getModelAndView();              }              catch (Exception ex) {                  Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);                  mv = processHandlerException(processedRequest, response, handler, ex);                  errorView = (mv != null);              }              //步骤5 步骤6、解析视图并进行视图的渲染  //步骤5 由ViewResolver解析View（viewResolver.resolveViewName(viewName, locale)）  //步骤6 视图在渲染时会把Model传入（view.render(mv.getModelInternal(), request, response);）              if (mv != null &amp;&amp; !mv.wasCleared()) {                  render(mv, processedRequest, response);                  if (errorView) {                      WebUtils.clearErrorRequestAttributes(request);                  }              }              else {                  if (logger.isDebugEnabled()) {                      logger.debug(&quot;Null ModelAndView returned to DispatcherServlet with name &apos;&quot; + getServletName() +                              &quot;&apos;: assuming HandlerAdapter completed request handling&quot;);                  }              }              // 执行处理器相关的拦截器的完成后处理（HandlerInterceptor.afterCompletion）              //此处省略具体代码          catch (Exception ex) {              // Trigger after-completion for thrown exception.              triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, ex);              throw ex;          }          catch (Error err) {              ServletException ex = new NestedServletException(&quot;Handler processing failed&quot;, err);              // Trigger after-completion for thrown exception.              triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, ex);              throw ex;          }          finally {              // Clean up any resources used by a multipart request.              if (processedRequest != request) {                  cleanupMultipart(processedRequest);              }          }      }  </code></pre><p>核心架构的具体流程步骤如下：</p><p>1、  首先用户发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；</p><p>2、  DispatcherServlet——&gt;HandlerMapping， HandlerMapping将会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象、多个HandlerInterceptor拦截器）对象，通过这种策略模式，很容易添加新的映射策略；</p><p>3、  DispatcherServlet——&gt;HandlerAdapter，HandlerAdapter将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；</p><p>4、  HandlerAdapter——&gt;处理器功能处理方法的调用，HandlerAdapter将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView对象（包含模型数据、逻辑视图名）；</p><p>5、  ModelAndView的逻辑视图名——&gt; ViewResolver， ViewResolver将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；</p><p>6、  View——&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术；</p><p>7、返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。</p><p>此处我们只是讲了核心流程，没有考虑拦截器、本地解析、文件上传解析等，后边再细述。</p><p>到此，再来看我们前边提出的问题：</p><p>1、  请求如何给前端控制器？这个应该在web.xml中进行部署描述，在HelloWorld中详细讲解。</p><p>2、  前端控制器如何根据请求信息选择页面控制器进行功能处理？ 我们需要配置HandlerMapping进行映射</p><p>3、  如何支持多种页面控制器呢？配置HandlerAdapter从而支持多种类型的页面控制器</p><p>4、  如何页面控制器如何使用业务对象？可以预料到，肯定利用Spring IoC容器的依赖注入功能</p><p>5、  页面控制器如何返回模型数据？使用ModelAndView返回</p><p>6、  前端控制器如何根据页面控制器返回的逻辑视图名选择具体的视图进行渲染？ 使用ViewResolver进行解析</p><p>7、  不同的视图技术如何使用相应的模型数据？ 因为Model是一个Map数据结构，很容易支持其他视图技术</p><p>在此我们可以看出具体的核心开发步骤：</p><p>1、  DispatcherServlet在web.xml中的部署描述，从而拦截请求到Spring Web MVC</p><p>2、  HandlerMapping的配置，从而将请求映射到处理器</p><p>3、  HandlerAdapter的配置，从而支持多种类型的处理器</p><p>4、  ViewResolver的配置，从而将逻辑视图名解析为具体视图技术</p><p>5、处理器（页面控制器）的配置，从而进行功能处理</p><p>上边的开发步骤我们会在Hello World中详细验证。</p><h2 id="Spring-Web-MVC优势"><a href="#Spring-Web-MVC优势" class="headerlink" title="Spring Web MVC优势"></a>Spring Web MVC优势</h2><p>1、清晰的角色划分：前端控制器（<code>DispatcherServlet</code>）、请求到处理器映射（HandlerMapping）、处理器适配器（HandlerAdapter）、视图解析器（ViewResolver）、处理器或页面控制器（Controller）、验证器（   Validator）、命令对象（Command  请求参数绑定到的对象就叫命令对象）、表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）。</p><p>2、分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要；</p><p>3、由于命令对象就是一个POJO，无需继承框架特定API，可以使用命令对象直接作为业务对象；</p><p>4、和Spring 其他框架无缝集成，是其它Web框架所不具备的；</p><p>5、可适配，通过HandlerAdapter可以支持任意的类作为处理器；</p><p>6、可定制性，HandlerMapping、ViewResolver等能够非常简单的定制；</p><p>7、功能强大的数据验证、格式化、绑定机制；</p><p>8、利用Spring提供的Mock对象能够非常简单的进行Web层单元测试；</p><p>9、本地化、主题的解析的支持，使我们更容易进行国际化和主题的切换。</p><p>10、强大的JSP标签库，使JSP编写更容易。</p><p>………………还有比如RESTful风格的支持、简单的文件上传、约定大于配置的契约式编程支持、基于注解的零配置支持等等。</p><h2 id="DispatcherServlet作用"><a href="#DispatcherServlet作用" class="headerlink" title="DispatcherServlet作用"></a>DispatcherServlet作用</h2><p>DispatcherServlet是前端控制器设计模式的实现，提供Spring Web MVC的集中访问点，而且负责职责的分派，而且与Spring IoC容器无缝集成，从而可以获得Spring的所有好处。 具体请参考第二章的图2-1。</p><p>DispatcherServlet主要用作职责调度工作，本身主要用于控制流程，主要职责如下：</p><p>1、文件上传解析，如果请求类型是multipart将通过MultipartResolver进行文件上传解析；</p><p>2、通过HandlerMapping，将请求映射到处理器（返回一个HandlerExecutionChain，它包括一个处理器、多个HandlerInterceptor拦截器）；</p><p>3、通过HandlerAdapter支持多种类型的处理器(HandlerExecutionChain中的处理器)；</p><p>4、通过ViewResolver解析逻辑视图名到具体视图实现；</p><p>5、本地化解析；</p><p>6、渲染具体的视图等；</p><p>7、如果执行过程中遇到异常将交给HandlerExceptionResolver来解析。</p><p>从以上我们可以看出DispatcherServlet主要负责流程的控制（而且在流程中的每个关键点都是很容易扩展的）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转自：&lt;a href=&quot;http://jinnianshilongnian.iteye.com/category/231099&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;跟开涛学SpringMVC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Spring源码解析 &lt;a href=&quot;https://blog.csdn.net/column/details/21851.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21851.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="SpringMVC" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/SpringMVC/"/>
    
    
      <category term="SpringMVC" scheme="http://h2pl.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码剖析9：Spring事务源码剖析</title>
    <link href="http://h2pl.github.io/2018/06/05/spring9/"/>
    <id>http://h2pl.github.io/2018/06/05/spring9/</id>
    <published>2018-06-05T14:29:06.000Z</published>
    <updated>2018-06-11T15:33:34.131Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="http://www.linkedkeeper.com/detail/blog.action?bid=1045" target="_blank" rel="noopener">http://www.linkedkeeper.com/detail/blog.action?bid=1045</a></p><p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Spring源码解析 <a href="https://blog.csdn.net/column/details/21851.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21851.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><h2 id="声明式事务使用"><a href="#声明式事务使用" class="headerlink" title="声明式事务使用"></a>声明式事务使用</h2><p>Spring事务是我们日常工作中经常使用的一项技术，Spring提供了编程、注解、aop切面三种方式供我们使用Spring事务，其中编程式事务因为对代码入侵较大所以不被推荐使用，注解和aop切面的方式可以基于需求自行选择，我们以注解的方式为例来分析Spring事务的原理和源码实现。</p><p>首先我们简单看一下Spring事务的使用方式，配置：</p><pre><code>&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; &lt;bean id=&quot;transactionManager&quot;          class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;     &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt;</code></pre><p>在需要开启事务的方法上加上@Transactional注解即可，这里需要注意的是，当<a href="tx:annotation-driven/" target="_blank" rel="noopener">tx:annotation-driven/</a>标签在不指定transaction-manager属性的时候，会默认寻找id固定名为transactionManager的bean作为事务管理器，如果没有id为transactionManager的bean并且在使用@Transactional注解时也没有指定value（事务管理器），程序就会报错。当我们在配置两个以上的<a href="tx:annotation-driven/" target="_blank" rel="noopener">tx:annotation-driven/</a>标签时，如下：</p><pre><code>    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager1&quot;/&gt;&lt;bean id=&quot;transactionManager1&quot;         class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource1&quot;/&gt;&lt;/bean&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager2&quot;/&gt;&lt;bean id=&quot;transactionManager2&quot;         class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource2&quot;/&gt;&lt;/bean&gt;</code></pre><p>这时第一个<a href="tx:annotation-driven/" target="_blank" rel="noopener">tx:annotation-driven/</a>会生效，也就是当我们使用@Transactional注解时不指定事务管理器，默认使用的事务管理器是transactionManager1，后文分析源码时会具体提到这些注意点。</p><p>下面我们开始分析Spring的相关源码，首先看一下对<a href="tx:annotation-driven/" target="_blank" rel="noopener">tx:annotation-driven/</a>标签的解析，这里需要读者对Spring自定义标签解析的过程有一定的了解，笔者后续也会出相关的文章。锁定TxNamespaceHandler：</p><h2 id="TxNamespaceHandler"><a href="#TxNamespaceHandler" class="headerlink" title="TxNamespaceHandler"></a>TxNamespaceHandler</h2><p>(右键可查看大图)</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_f205abd7-5bc2-4b82-840c-87a96f8351ab.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_9a6ff79d-58b5-4ecd-bf41-ccafde97c44a.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_c1a525fa-56d4-4c85-8208-57558cb53aec.jpg" alt=""></p><h2 id="注册事务功能bean"><a href="#注册事务功能bean" class="headerlink" title="注册事务功能bean"></a>注册事务功能bean</h2><p>这个方法比较长，关键的部分做了标记，最外围的if判断限制了<a href="tx:annotation-driven/" target="_blank" rel="noopener">tx:annotation-driven/</a>标签只能被解析一次，所以只有第一次被解析的标签会生效。蓝色框的部分分别注册了三个BeanDefinition，分别为AnnotationTransactionAttributeSource、TransactionInterceptor和BeanFactoryTransactionAttributeSourceAdvisor，并将前两个BeanDefinition添加到第三个BeanDefinition的属性当中，这三个bean支撑了整个事务功能，后面会详细说明。我们先来看红色框的第个方法：</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_35702577-8042-4a66-a4eb-337307324810.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_384e595c-2b6d-44cc-bd0b-25fa1f47af5e.jpg" alt=""></p><p>还记得当<a href="tx:annotation-driven/" target="_blank" rel="noopener">tx:annotation-driven/</a>标签在不指定transaction-manager属性的时候，会默认寻找id固定名为transactionManager的bean作为事务管理器这个注意事项么，就是在这里实现的。下面我们来看红色框的第二个方法：</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_82a174da-6c9e-4b3c-9a4f-a99228ee6262.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_7288aabb-a34e-4386-a648-de9d9c361743.jpg" alt=""></p><p>这两个方法的主要目的是注册InfrastructureAdvisorAutoProxyCreator，注册这个类的目的是什么呢？我们看下这个类的层次：</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_f55221cc-7b52-4479-92eb-3ee52509eb8e.jpg" alt=""></p><h2 id="使用bean的后处理方法获取增强器"><a href="#使用bean的后处理方法获取增强器" class="headerlink" title="使用bean的后处理方法获取增强器"></a>使用bean的后处理方法获取增强器</h2><p>我们发现这个类间接实现了BeanPostProcessor接口，我们知道，Spring会保证所有bean在实例化的时候都会调用其postProcessAfterInitialization方法，我们可以使用这个方法包装和改变bean，而真正实现这个方法是在其父类AbstractAutoProxyCreator类中：</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_4483fff2-e26d-44eb-8726-64da54fd6e4b.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_a3285183-0bd9-4302-9db9-cd719ac90fdb.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_843d5be7-2cfc-4ca4-ab46-e535d9703705.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_548a4b88-1b9b-43ba-8aad-0a6f0ac1ee2f.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_c6ec857c-f145-49c0-8f50-7b3ac008b907.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_23fadeda-ae10-4108-a358-f1dafe8f1db4.jpg" alt=""></p><p>上面这个方法相信大家已经看出了它的目的，先找出所有对应Advisor的类的beanName，再通过beanFactory.getBean方法获取这些bean并返回。不知道大家还是否记得在文章开始的时候提到的三个类，其中BeanFactoryTransactionAttributeSourceAdvisor实现了Advisor接口，所以这个bean就会在此被提取出来，而另外两个bean被织入了BeanFactoryTransactionAttributeSourceAdvisor当中，所以也会一起被提取出来，下图为BeanFactoryTransactionAttributeSourceAdvisor类的层次：</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_f8266cd6-4916-4c93-8b59-6711d6d94ebb.jpg" alt=""></p><h2 id="Spring获取匹配的增强器"><a href="#Spring获取匹配的增强器" class="headerlink" title="Spring获取匹配的增强器"></a>Spring获取匹配的增强器</h2><p>下面让我们来看Spring如何在所有候选的增强器中获取匹配的增强器：</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_ba7d0e1c-474b-442c-893f-251ae510390e.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_0b89068d-863e-46ac-aa39-389a9f0a713e.jpg" alt=""></p><p>上面的方法中提到引介增强的概念，在此做简要说明，引介增强是一种比较特殊的增强类型，它不是在目标方法周围织入增强，而是为目标类创建新的方法和属性，所以引介增强的连接点是类级别的，而非方法级别的。通过引介增强，我们可以为目标类添加一个接口的实现，即原来目标类未实现某个接口，通过引介增强可以为目标类创建实现该接口的代理，使用方法可以参考文末的引用链接。另外这个方法用两个重载的canApply方法为目标类寻找匹配的增强器，其中第一个canApply方法会调用第二个canApply方法并将第三个参数传为false：</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_1961aea7-915a-4abb-bf3f-158a4bc0b79c.jpg" alt=""></p><p>在上面BeanFactoryTransactionAttributeSourceAdvisor类的层次中我们看到它实现了PointcutAdvisor接口，所以会调用红框中的canApply方法进行判断，第一个参数pca.getPointcut()也就是调用BeanFactoryTransactionAttributeSourceAdvisor的getPointcut方法：</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_dd7d4b92-419d-44c7-b3e5-f2e1897fa473.jpg" alt=""></p><p>这里的transactionAttributeSource也就是我们在文章开始看到的为BeanFactoryTransactionAttributeSourceAdvisor织入的两个bean中的AnnotationTransactionAttributeSource，我们以TransactionAttributeSourcePointcut作为第一个参数继续跟踪canApply方法：</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_f3e359a5-26e5-4a2c-866a-46bac7aad87b.jpg" alt=""></p><p>我们跟踪pc.getMethodMatcher()方法也就是TransactionAttributeSourcePointcut的getMethodMatcher方法是在它的父类中实现：</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_23ae85db-b941-4d08-8aa0-fd0c6980dc1a.jpg" alt=""></p><p>发现方法直接返回this，也就是下面methodMatcher.matches方法就是调用TransactionAttributeSourcePointcut的matches方法：</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_f390cb4e-ca76-49ee-ad9d-d491b5f86ad1.jpg" alt=""></p><p>在上面我们看到其实这个tas就是AnnotationTransactionAttributeSource，这里的目的其实也就是判断我们的业务方法或者类上是否有@Transactional注解，跟踪AnnotationTransactionAttributeSource的getTransactionAttribute方法：</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_a51a6423-2848-4a9b-bb71-9f7639ef33fa.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_8ec34ac9-3404-4cb9-af16-3bb33b2a02e5.jpg" alt=""></p><p>方法中的事务声明优先级最高，如果方法上没有声明则在类上寻找：</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_c073014d-ff9e-4a88-ab30-f39bf480776f.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_56e3cf18-453f-4845-a03b-de530f22b666.jpg" alt=""></p><p>this.annotationParsers是在AnnotationTransactionAttributeSource类初始化的时候初始化的：</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_a3971a3d-77b9-4689-a6db-afbb70d985a3.jpg" alt=""></p><p>所以annotationParser.parseTransactionAnnotation就是调用SpringTransactionAnnotationParser的parseTransactionAnnotation方法：</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_d1a502be-3aed-48d6-8321-89e94f942ca3.jpg" alt=""></p><p>至此，我们终于看到的Transactional注解，下面无疑就是解析注解当中声明的属性了：</p><h2 id="Transactional注解"><a href="#Transactional注解" class="headerlink" title="Transactional注解"></a>Transactional注解</h2><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_655918f9-40b3-493d-8eca-d5351e005655.jpg" alt=""></p><p>在这个方法中我们看到了在Transactional注解中声明的各种常用或者不常用的属性的解析，至此，事务的初始化工作算是完成了，下面开始真正的进入执行阶段。</p><p>在上文AbstractAutoProxyCreator类的wrapIfNecessary方法中，获取到目标bean匹配的增强器之后，会为bean创建代理，这部分内容我们会在Spring AOP的文章中进行详细说明，在此简要说明方便大家理解，在执行代理类的目标方法时，会调用Advisor的getAdvice获取MethodInterceptor并执行其invoke方法，而我们本文的主角BeanFactoryTransactionAttributeSourceAdvisor的getAdvice方法会返回我们在文章开始看到的为其织入的另外一个bean，也就是TransactionInterceptor，它实现了MethodInterceptor，所以我们分析其invoke方法：</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_2fc8d7dd-d830-4214-b8c6-c92c77171a1e.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_60d5b11e-b770-453a-a900-4a5d99619122.jpg" alt=""></p><p>这个方法很长，但是整体逻辑还是非常清晰的，首选获取事务属性，这里的getTransactionAttrubuteSource()方法的返回值同样是在文章开始我们看到的被织入到TransactionInterceptor中的AnnotationTransactionAttributeSource，在事务准备阶段已经解析过事务属性并保存到缓存中，所以这里会直接从缓存中获取，接下来获取配置的TransactionManager，也就是determineTransactionManager方法，这里如果配置没有指定transaction-manager并且也没有默认id名为transactionManager的bean，就会报错，然后是针对声明式事务和编程式事务的不同处理，创建事务信息，执行目标方法，最后根据执行结果进行回滚或提交操作，我们先分析创建事务的过程。在分析之前希望大家能先去了解一下Spring的事务传播行为，有助于理解下面的源码，这里做一个简要的介绍，更详细的信息请大家自行查阅Spring官方文档，里面有更新详细的介绍。</p><p>Spring的事务传播行为定义在Propagation这个枚举类中，一共有七种，分别为：</p><p>REQUIRED：业务方法需要在一个容器里运行。如果方法运行时，已经处在一个事务中，那么加入到这个事务，否则自己新建一个新的事务，是默认的事务传播行为。</p><p>NOT_SUPPORTED：声明方法不需要事务。如果方法没有关联到一个事务，容器不会为他开启事务，如果方法在一个事务中被调用，该事务会被挂起，调用结束后，原先的事务会恢复执行。</p><p>REQUIRESNEW：不管是否存在事务，该方法总汇为自己发起一个新的事务。如果方法已经运行在一个事务中，则原有事务挂起，新的事务被创建。</p><p>MANDATORY：该方法只能在一个已经存在的事务中执行，业务方法不能发起自己的事务。如果在没有事务的环境下被调用，容器抛出例外。</p><p>SUPPORTS：该方法在某个事务范围内被调用，则方法成为该事务的一部分。如果方法在该事务范围外被调用，该方法就在没有事务的环境下执行。</p><p>NEVER：该方法绝对不能在事务范围内执行。如果在就抛例外。只有该方法没有关联到任何事务，才正常执行。</p><p>NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效。</p><h2 id="开启事务过程"><a href="#开启事务过程" class="headerlink" title="开启事务过程"></a>开启事务过程</h2><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_708ab424-b604-43f9-bbd5-fb2624db99b9.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_43132c39-82d2-482a-896f-9817c4b95828.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_4d557bcf-70f8-485d-b464-99414abc12a2.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_504e5c5d-bd6b-4213-9f31-85d9373e98ee.jpg" alt=""></p><p>判断当前线程是否存在事务就是判断记录的数据库连接是否为空并且transactionActive状态为true。</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_a483d06f-ea22-4a76-989e-e5aeee2ec88c.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_4c5b05f6-bfc8-447c-8e3e-d37c56e4fab9.jpg" alt=""></p><p>REQUIRESNEW会开启一个新事务并挂起原事务，当然开启一个新事务就需要一个新的数据库连接：</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_3af47045-58ce-4657-a246-96644fe23ac1.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_850d67a1-6a9f-4eaf-b2b4-e95ec103be74.jpg" alt=""></p><p>suspend挂起操作主要目的是将当前connectionHolder置为null，保存原有事务信息，以便于后续恢复原有事务，并将当前正在进行的事务信息进行重置。下面我们看Spring如何开启一个新事务：</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_72d271ed-a776-4ea1-aef5-1b0257bcb287.jpg" alt=""></p><p>这里我们看到了数据库连接的获取，如果是新事务需要获取新一个新的数据库连接，并为其设置了隔离级别、是否只读等属性，下面就是将事务信息记录到当前线程中：</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_21873217-513b-4bf1-895f-8253406688d0.jpg" alt=""></p><p>接下来就是记录事务状态并返回事务信息：</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_1e39eb93-a9fc-4bdb-bc75-78875f365d45.jpg" alt=""></p><p>然后就是我们目标业务方法的执行了，根据执行结果的不同做提交或回滚操作，我们先看一下回滚操作：</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_bdee2ff7-6b22-4979-a4a6-68768cb07ec9.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_6efd682b-d826-42ec-a742-36664fa1ee55.jpg" alt=""></p><p>其中回滚条件默认为RuntimeException或Error，我们也可以自行配置。</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_49828188-3b75-4e8e-a27c-8d24efee1152.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_3ff0a0a4-7481-4769-a5f7-9b798376032a.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_f8e84baa-f411-432d-b624-06c03d6a0770.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_65273017-9cb7-4b02-b4f3-704f28705ca7.jpg" alt=""></p><p>保存点一般用于嵌入式事务，内嵌事务的回滚不会引起外部事务的回滚。下面我们来看新事务的回滚：</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_a539fba7-ac99-4be3-97d6-670191bf3795.jpg" alt=""></p><p>很简单，就是获取当前线程的数据库连接并调用其rollback方法进行回滚，使用的是底层数据库连接提供的API。最后还有一个清理和恢复挂起事务的操作：</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_f91a16c5-a49b-48ab-81d5-4fe4689d9848.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_d97f1fb2-3878-482e-9fe4-7fd5c21a4035.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_d6df1fef-4455-400b-9054-cf58c8e6c109.jpg" alt=""></p><p>如果事务执行前有事务挂起，那么当前事务执行结束后需要将挂起的事务恢复，挂起事务时保存了原事务信息，重置了当前事务信息，所以恢复操作就是将当前的事务信息设置为之前保存的原事务信息。到这里事务的回滚操作就结束了，下面让我们来看事务的提交操作：</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_15a2a67f-8aed-4e0c-a0e7-1ee9c52f6daa.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_370f9de0-e3a6-4839-ae98-611ee1fe01eb.jpg" alt=""></p><p>在上文分析回滚流程中我们提到了如果当前事务不是独立的事务，也没有保存点，在回滚的时候只是设置一个回滚标记，由外部事务提交时统一进行整体事务的回滚。</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_57b414a2-718d-48a8-ab6f-21d15421f7cc.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_e44c8ad4-55ec-4953-bfce-6a3ddd741ce5.jpg" alt=""></p><p>提交操作也是很简单的调用数据库连接底层API的commit方法。</p><p>参考链接：</p><p><a href="http://blog.163.com/asd_wll/blog/static/2103104020124801348674/" target="_blank" rel="noopener">http://blog.163.com/asd_wll/blog/static/2103104020124801348674/</a></p><p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#spring-data-tier" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#spring-data-tier</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;http://www.linkedkeeper.com/detail/blog.action?bid=1045&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.linkedkeeper.com/detail/blog.action?bid=1045&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Spring源码解析 &lt;a href=&quot;https://blog.csdn.net/column/details/21851.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21851.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Spring" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Spring/"/>
    
    
      <category term="Spring事务" scheme="http://h2pl.github.io/tags/Spring%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码剖析8：Spring事务概述</title>
    <link href="http://h2pl.github.io/2018/06/05/spring8/"/>
    <id>http://h2pl.github.io/2018/06/05/spring8/</id>
    <published>2018-06-05T14:29:02.000Z</published>
    <updated>2018-06-11T15:27:26.370Z</updated>
    
    <content type="html"><![CDATA[<p>原文出处： <a href="http://sishuok.com/forum/blogPost/list/0/2508.html" target="_blank" rel="noopener">张开涛</a></p><p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Spring源码解析 <a href="https://blog.csdn.net/column/details/21851.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21851.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><h2 id="数据库事务概述"><a href="#数据库事务概述" class="headerlink" title="数据库事务概述"></a>数据库事务概述</h2><p>事务首先是一系列操作组成的工作单元，该工作单元内的操作是不可分割的，即要么所有操作都做，要么所有操作都不做，这就是事务。</p><p>事务必需满足ACID（原子性、一致性、隔离性和持久性）特性，缺一不可：</p><ul><li>原子性（Atomicity）：即事务是不可分割的最小工作单元，事务内的操作要么全做，要么全不做；</li><li>一致性（Consistency）：在事务执行前数据库的数据处于正确的状态，而事务执行完成后数据库的数据还是处于正确的状态，即数据完整性约束没有被破坏；如银行转帐，A转帐给B，必须保证A的钱一定转给B，一定不会出现A的钱转了但B没收到，否则数据库的数据就处于不一致（不正确）的状态。</li><li>隔离性（Isolation）：并发事务执行之间无影响，在一个事务内部的操作对其他事务是不产生影响，这需要事务隔离级别来指定隔离性；</li><li>持久性（Durability）：事务一旦执行成功，它对数据库的数据的改变必须是永久的，不会因比如遇到系统故障或断电造成数据不一致或丢失。</li></ul><p>在实际项目开发中数据库操作一般都是并发执行的，即有多个事务并发执行，并发执行就可能遇到问题，目前常见的问题如下：</p><ul><li>丢失更新：两个事务同时更新一行数据，最后一个事务的更新会覆盖掉第一个事务的更新，从而导致第一个事务更新的数据丢失，这是由于没有加锁造成的；</li><li>脏读：一个事务看到了另一个事务未提交的更新数据；</li><li>不可重复读：在同一事务中，多次读取同一数据却返回不同的结果；也就是有其他事务更改了这些数据；</li><li>幻读：一个事务在执行过程中读取到了另一个事务已提交的插入数据；即在第一个事务开始时读取到一批数据，但此后另一个事务又插入了新数据并提交，此时第一个事务又读取这批数据但发现多了一条，即好像发生幻觉一样。</li></ul><p>为了解决这些并发问题，需要通过数据库隔离级别来解决，在标准SQL规范中定义了四种隔离级别：</p><ul><li>未提交读（Read Uncommitted）：最低隔离级别，一个事务能读取到别的事务未提交的更新数据，很不安全，可能出现丢失更新、脏读、不可重复读、幻读；</li><li>提交读（Read Committed）：一个事务能读取到别的事务提交的更新数据，不能看到未提交的更新数据，不可能可能出现丢失更新、脏读，但可能出现不可重复读、幻读；</li><li>可重复读（Repeatable Read）：保证同一事务中先后执行的多次查询将返回同一结果，不受其他事务影响，可能可能出现丢失更新、脏读、不可重复读，但可能出现幻读；</li><li>序列化（Serializable）：最高隔离级别，不允许事务并发执行，而必须串行化执行，最安全，不可能出现更新、脏读、不可重复读、幻读。</li></ul><p>隔离级别越高，数据库事务并发执行性能越差，能处理的操作越少。因此在实际项目开发中为了考虑并发性能一般使用提交读隔离级别，它能避免丢失更新和脏读，尽管不可重复读和幻读不能避免，但可以在可能出现的场合使用悲观锁或乐观锁来解决这些问题。</p><h3 id="事务类型"><a href="#事务类型" class="headerlink" title="事务类型"></a>事务类型</h3><p>数据库事务类型有本地事务和分布式事务：</p><ul><li>本地事务：就是普通事务，能保证单台数据库上的操作的ACID，被限定在一台数据库上；</li><li>分布式事务：涉及两个或多个数据库源的事务，即跨越多台同类或异类数据库的事务（由每台数据库的本地事务组成的），分布式事务旨在保证这些本地事务的所有操作的ACID，使事务可以跨越多台数据库；</li></ul><p>Java事务类型有JDBC事务和JTA事务：</p><ul><li>JDBC事务：就是数据库事务类型中的本地事务，通过Connection对象的控制来管理事务；</li><li>JTA事务：JTA指Java事务API(Java Transaction API)，是Java EE数据库事务规范， JTA只提供了事务管理接口，由应用程序服务器厂商（如WebSphere Application Server）提供实现，JTA事务比JDBC更强大，支持分布式事务。</li></ul><p>Java EE事务类型有本地事务和全局事务：</p><ul><li>本地事务：使用JDBC编程实现事务；</li><li>全局事务：由应用程序服务器提供，使用JTA事务；</li></ul><p>按是否通过编程实现事务有声明式事务和编程式事务；</p><ul><li>声明式事务： 通过注解或XML配置文件指定事务信息；</li><li>编程式事务：通过编写代码实现事务。</li></ul><h3 id="Spring提供的事务管理"><a href="#Spring提供的事务管理" class="headerlink" title="Spring提供的事务管理"></a>Spring提供的事务管理</h3><p>Spring框架最核心功能之一就是事务管理，而且提供一致的事务管理抽象，这能帮助我们：</p><ul><li>提供一致的编程式事务管理API，不管使用Spring JDBC框架还是集成第三方框架使用该API进行事务编程；</li><li>无侵入式的声明式事务支持。</li></ul><p>Spring支持声明式事务和编程式事务事务类型。</p><p>spring事务特性 </p><p>spring所有的事务管理策略类都继承自org.springframework.transaction.PlatformTransactionManager接口 </p><p>其中TransactionDefinition接口定义以下特性：</p><p>事务隔离级别</p><p>  隔离级别是指若干个并发的事务之间的隔离程度。TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p><ul><li>TransactionDefinition.ISOLATION_DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED。</li><li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如PostgreSQL实际上并没有此级别。</li><li>TransactionDefinition.ISOLATION_READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。</li><li>TransactionDefinition.ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。</li><li>TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><p>事务传播行为</p><pre><code>所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。在TransactionDefinition定义中包括了如下几个表示传播行为的常量：</code></pre><ul><li>TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。</li><li>TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li><li>TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li><li>TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li></ul><p>事务超时</p><pre><code>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。</code></pre><p>  默认设置为底层事务系统的超时值，如果底层数据库事务系统没有设置超时值，那么就是none，没有超时限制。</p><p>事务只读属性</p><pre><code>只读事务用于客户代码只读但不修改数据的情形，只读事务用于特定情景下的优化，比如使用Hibernate的时候。</code></pre><p>默认为读写事务。</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Spring框架支持事务管理的核心是事务管理器抽象，对于不同的数据访问框架（如Hibernate）通过实现策略接口PlatformTransactionManager，从而能支持各种数据访问框架的事务管理，PlatformTransactionManager接口定义如下：</p><p>java代码：</p><pre><code>public interface PlatformTransactionManager {       TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;       void commit(TransactionStatus status) throws TransactionException;       void rollback(TransactionStatus status) throws TransactionException;}</code></pre><ul><li>getTransaction()：返回一个已经激活的事务或创建一个新的事务（根据给定的TransactionDefinition类型参数定义的事务属性），返回的是TransactionStatus对象代表了当前事务的状态，其中该方法抛出TransactionException（未检查异常）表示事务由于某种原因失败。</li><li>commit()：用于提交TransactionStatus参数代表的事务，具体语义请参考Spring Javadoc；</li><li>rollback()：用于回滚TransactionStatus参数代表的事务，具体语义请参考Spring Javadoc。</li></ul><p>TransactionDefinition接口定义如下：</p><p>java代码：</p><pre><code>public interface TransactionDefinition {       int getPropagationBehavior();       int getIsolationLevel();       int getTimeout();       boolean isReadOnly();       String getName();}</code></pre><ul><li>getPropagationBehavior()：返回定义的事务传播行为；</li><li>getIsolationLevel()：返回定义的事务隔离级别；</li><li>getTimeout()：返回定义的事务超时时间；</li><li>isReadOnly()：返回定义的事务是否是只读的；</li><li>getName()：返回定义的事务名字。</li></ul><p>TransactionStatus接口定义如下：</p><p>java代码：</p><pre><code>public interface TransactionStatus extends SavepointManager {       boolean isNewTransaction();       boolean hasSavepoint();       void setRollbackOnly();       boolean isRollbackOnly();       void flush();       boolean isCompleted();}</code></pre><ul><li>isNewTransaction()：返回当前事务状态是否是新事务；</li><li>hasSavepoint()：返回当前事务是否有保存点；</li><li>setRollbackOnly()：设置当前事务应该回滚；</li><li>isRollbackOnly(()：返回当前事务是否应该回滚；</li><li>flush()：用于刷新底层会话中的修改到数据库，一般用于刷新如Hibernate/JPA的会话，可能对如JDBC类型的事务无任何影响；</li><li>isCompleted():当前事务否已经完成。</li></ul><h3 id="内置事务管理器实现"><a href="#内置事务管理器实现" class="headerlink" title="内置事务管理器实现"></a>内置事务管理器实现</h3><p>Spring提供了许多内置事务管理器实现：</p><ul><li>DataSourceTransactionManager：位于org.springframework.jdbc.datasource包中，数据源事务管理器，提供对单个javax.sql.DataSource事务管理，用于Spring JDBC抽象框架、iBATIS或MyBatis框架的事务管理；</li><li>JdoTransactionManager：位于org.springframework.orm.jdo包中，提供对单个javax.jdo.PersistenceManagerFactory事务管理，用于集成JDO框架时的事务管理；</li><li>JpaTransactionManager：位于org.springframework.orm.jpa包中，提供对单个javax.persistence.EntityManagerFactory事务支持，用于集成JPA实现框架时的事务管理；</li><li>HibernateTransactionManager：位于org.springframework.orm.hibernate3包中，提供对单个org.hibernate.SessionFactory事务支持，用于集成Hibernate框架时的事务管理；该事务管理器只支持Hibernate3+版本，且Spring3.0+版本只支持Hibernate 3.2+版本；</li><li>JtaTransactionManager：位于org.springframework.transaction.jta包中，提供对分布式事务管理的支持，并将事务管理委托给Java EE应用服务器事务管理器；</li><li>OC4JjtaTransactionManager：位于org.springframework.transaction.jta包中，Spring提供的对OC4J10.1.3+应用服务器事务管理器的适配器，此适配器用于对应用服务器提供的高级事务的支持；</li><li>WebSphereUowTransactionManager：位于org.springframework.transaction.jta包中，Spring提供的对WebSphere 6.0+应用服务器事务管理器的适配器，此适配器用于对应用服务器提供的高级事务的支持；</li><li>WebLogicJtaTransactionManager：位于org.springframework.transaction.jta包中，Spring提供的对WebLogic 8.1+应用服务器事务管理器的适配器，此适配器用于对应用服务器提供的高级事务的支持。</li></ul><p>Spring不仅提供这些事务管理器，还提供对如JMS事务管理的管理器等，Spring提供一致的事务抽象如图9-1所示。<br><img src="http://dl.iteye.com/upload/attachment/0066/0970/632fd877-8165-3a60-ae7e-6429da8ed136.jpg" alt="" title="点击查看原始大小图片"></p><p>图9-1 Spring事务管理器</p><p>接下来让我们学习一下如何在Spring配置文件中定义事务管理器：</p><p>一、声明对本地事务的支持：</p><p>a)JDBC及iBATIS、MyBatis框架事务管理器</p><p>java代码：</p><pre><code>&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;</code></pre><p>通过dataSource属性指定需要事务管理的单个javax.sql.DataSource对象。</p><p>b)Jdo事务管理器</p><p>java代码：</p><pre><code>&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.orm.jdo.JdoTransactionManager&quot;&gt;    &lt;property name=&quot;persistenceManagerFactory&quot; ref=&quot;persistenceManagerFactory&quot;/&gt;&lt;/bean&gt;</code></pre><p>通过persistenceManagerFactory属性指定需要事务管理的javax.jdo.PersistenceManagerFactory对象。</p><p>c)Jpa事务管理器</p><p>java代码：</p><pre><code>bean id=&quot;txManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt;    &lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot;/&gt;&lt;/bean&gt;</code></pre><p>通过entityManagerFactory属性指定需要事务管理的javax.persistence.EntityManagerFactory对象。</p><p>还需要为entityManagerFactory对象指定jpaDialect属性，该属性所对应的对象指定了如何获取连接对象、开启事务、关闭事务等事务管理相关的行为。</p><p>java代码：</p><pre><code>&lt;bean id=&quot;entityManagerFactory&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt;        ……        &lt;property name=&quot;jpaDialect&quot; ref=&quot;jpaDialect&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;jpaDialect&quot; class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaDialect&quot;/&gt;</code></pre><p>d)Hibernate事务管理器</p><p>java代码：</p><pre><code>&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;&lt;/bean&gt;</code></pre><p>通过entityManagerFactory属性指定需要事务管理的org.hibernate.SessionFactory对象。</p><h2 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h2><h3 id="声明式事务概述"><a href="#声明式事务概述" class="headerlink" title="声明式事务概述"></a>声明式事务概述</h3><p>从上节编程式实现事务管理可以深刻体会到编程式事务的痛苦，即使通过代理配置方式也是不小的工作量。</p><p>本节将介绍声明式事务支持，使用该方式后最大的获益是简单，事务管理不再是令人痛苦的，而且此方式属于无侵入式，对业务逻辑实现无影响。</p><p>接下来先来看看声明式事务如何实现吧。</p><h3 id="声明式实现事务管理"><a href="#声明式实现事务管理" class="headerlink" title="声明式实现事务管理"></a>声明式实现事务管理</h3><p>1、定义业务逻辑实现，此处使用ConfigUserServiceImpl和ConfigAddressServiceImpl：</p><p>2、定义配置文件（chapter9/service/ applicationContext-service-declare.xml）：</p><p>2.1、XML命名空间定义，定义用于事务支持的tx命名空间和AOP支持的aop命名空间：</p><pre><code>java代码：&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;      xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-3.0.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx-3.0.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-3.0.xsd&quot;&gt;</code></pre><p>2.2、业务实现配置，非常简单，使用以前定义的非侵入式业务实现：</p><pre><code>java代码：&lt;bean id=&quot;userService&quot; class=&quot;cn.javass.spring.chapter9.service.impl.ConfigUserServiceImpl&quot;&gt;    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;    &lt;property name=&quot;addressService&quot; ref=&quot;addressService&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;addressService&quot; class=&quot;cn.javass.spring.chapter9.service.impl.ConfigAddressServiceImpl&quot;&gt;    &lt;property name=&quot;addressDao&quot; ref=&quot;addressDao&quot;/&gt;&lt;/bean&gt;</code></pre><p>2.3、事务相关配置：</p><pre><code>java代码：&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;    &lt;tx:attributes&gt;        &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; isolation=&quot;READ_COMMITTED&quot;/&gt;        &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; isolation=&quot;READ_COMMITTED&quot; read-only=&quot;true&quot;/&gt;    &lt;/tx:attributes&gt;&lt;/tx:advice&gt;</code></pre><p>java代码：</p><pre><code>&lt;aop:config&gt;    &lt;aop:pointcut id=&quot;serviceMethod&quot; expression=&quot;execution(* cn..chapter9.service..*.*(..))&quot;/&gt;    &lt;aop:advisor pointcut-ref=&quot;serviceMethod&quot; advice-ref=&quot;txAdvice&quot;/&gt;&lt;/aop:config&gt;&lt;tx:advice&gt;：事务通知定义，用于指定事务属性，其中“transaction-manager”属性指定事务管理器，并通过&lt; tx:attributes &gt;指定具体需要拦截的方法； &lt;tx:method name=”save*”&gt;：表示将拦截以save开头的方法，被拦截的方法将应用配置的事务属性：propagation=”REQUIRED”表示传播行为是Required，isolation=”READ_COMMITTED”表示隔离级别是提交读；&lt;tx:method name=”*”&gt;：表示将拦截其他所有方法，被拦截的方法将应用配置的事务属性：propagation=”REQUIRED”表示传播行为是Required，isolation=”READ_COMMITTED”表示隔离级别是提交读，read-only=”true”表示事务只读；&lt;aop:config&gt;：AOP相关配置：&lt;aop:pointcut/&gt;：切入点定义，定义名为”serviceMethod”的aspectj切入点，切入点表达式为”execution(* cn..chapter9.service..*.*(..))”表示拦截cn包及子包下的chapter9. service包及子包下的任何类的任何方法；&lt;aop:advisor&gt;：Advisor定义，其中切入点为serviceMethod，通知为txAdvice。从配置中可以看出，将对cn包及子包下的chapter9. service包及子包下的任何类的任何方法应用“txAdvice”通知指定的事务属性。</code></pre><p>3、修改测试方法并测试该配置方式是否好用：</p><p>将TransactionTest 类的testServiceTransaction测试方法拷贝一份命名为testDeclareTransaction：</p><p>并在testDeclareTransaction测试方法内将：</p><p>4、执行测试，测试正常通过，说明该方式能正常工作，当调用save方法时将匹配到事务通知中定义的“&lt;tx:method name=”save<em>”&gt;”中指定的事务属性，而调用countAll方法时将匹配到事务通知中定义的“&lt;tx:method name=”</em>”&gt;”中指定的事务属性。</p><p>声明式事务是如何实现事务管理的呢？还记不记得TransactionProxyFactoryBean实现配置式事务管理，配置式事务管理是通过代理方式实现，而声明式事务管理同样是通过AOP代理方式实现。</p><p>声明式事务通过AOP代理方式实现事务管理，利用环绕通知TransactionInterceptor实现事务的开启及关闭，而TransactionProxyFactoryBean内部也是通过该环绕通知实现的，因此可以认为是<a href="tx:tags/" target="_blank" rel="noopener">tx:tags/</a>帮你定义了TransactionProxyFactoryBean，从而简化事务管理。</p><p>了解了实现方式后，接下来详细学习一下配置吧：</p><p>9.4.4  <a href="tx:advice/" target="_blank" rel="noopener">tx:advice/</a>配置详解<br>声明式事务管理通过配置<a href="tx:advice/" target="_blank" rel="noopener">tx:advice/</a>来定义事务属性，配置方式如下所示：</p><pre><code>java代码：&lt;tx:advice id=&quot;……&quot; transaction-manager=&quot;……&quot;&gt;&lt;tx:attributes&gt;        &lt;tx:method name=&quot;……&quot;                           propagation=&quot; REQUIRED&quot;                           isolation=&quot;READ_COMMITTED&quot;                           timeout=&quot;-1&quot;                           read-only=&quot;false&quot;                           no-rollback-for=&quot;&quot;                           rollback-for=&quot;&quot;/&gt;        ……    &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;tx:advice&gt;：id用于指定此通知的名字， transaction-manager用于指定事务管理器，默认的事务管理器名字为“transactionManager”；&lt;tx:method&gt;：用于定义事务属性即相关联的方法名；</code></pre><p>name：定义与事务属性相关联的方法名，将对匹配的方法应用定义的事务属性，可以使用“<em>”通配符来匹配一组或所有方法，如“save</em>”将匹配以save开头的方法，而“*”将匹配所有方法；</p><p>propagation：事务传播行为定义，默认为“REQUIRED”，表示Required，其值可以通过TransactionDefinition的静态传播行为变量的“PROPAGATION_”后边部分指定，如“TransactionDefinition.PROPAGATION_REQUIRED”可以使用“REQUIRED”指定；</p><p>isolation：事务隔离级别定义；默认为“DEFAULT”，其值可以通过TransactionDefinition的静态隔离级别变量的“ISOLATION_”后边部分指定，如“TransactionDefinition. ISOLATION_DEFAULT”可以使用“DEFAULT”指定：</p><p>timeout：事务超时时间设置，单位为秒，默认-1，表示事务超时将依赖于底层事务系统；</p><p>read-only：事务只读设置，默认为false，表示不是只读；</p><p>rollback-for：需要触发回滚的异常定义，以“，”分割，默认任何RuntimeException 将导致事务回滚，而任何Checked Exception 将不导致事务回滚；异常名字定义和TransactionProxyFactoryBean中含义一样</p><p>no-rollback-for：不被触发进行回滚的 Exception(s)；以“，”分割；异常名字定义和TransactionProxyFactoryBean中含义一样；</p><p>记不记得在配置方式中为了解决“自我调用”而导致的不能设置正确的事务属性问题，使用“((IUserService)AopContext.currentProxy()).otherTransactionMethod()”方式解决，在声明式事务要得到支持需要使用&lt;aop:config expose-proxy=”true”&gt;来开启。</p><p>9.4.5  多事务语义配置及最佳实践<br>什么是多事务语义？说白了就是为不同的Bean配置不同的事务属性，因为我们项目中不可能就几个Bean，而可能很多，这可能需要为Bean分组，为不同组的Bean配置不同的事务语义。在Spring中，可以通过配置多切入点和多事务通知并通过不同方式组合使用即可。</p><pre><code>   1、首先看下声明式事务配置的最佳实践吧：&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;&lt;tx:attributes&gt;           &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt;           &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot; /&gt;           &lt;tx:method name=&quot;create*&quot; propagation=&quot;REQUIRED&quot; /&gt;           &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot; /&gt;           &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt;           &lt;tx:method name=&quot;merge*&quot; propagation=&quot;REQUIRED&quot; /&gt;           &lt;tx:method name=&quot;del*&quot; propagation=&quot;REQUIRED&quot; /&gt;           &lt;tx:method name=&quot;remove*&quot; propagation=&quot;REQUIRED&quot; /&gt;           &lt;tx:method name=&quot;put*&quot; propagation=&quot;REQUIRED&quot; /&gt;           &lt;tx:method name=&quot;get*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;           &lt;tx:method name=&quot;count*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;          &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;          &lt;tx:method name=&quot;list*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;          &lt;tx:method name=&quot;*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;       &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;aop:config&gt;       &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* cn.javass..service.*.*(..))&quot; /&gt;       &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot; /&gt;&lt;/aop:config&gt;</code></pre><p>该声明式事务配置可以应付常见的CRUD接口定义，并实现事务管理，我们只需修改切入点表达式来拦截我们的业务实现从而对其应用事务属性就可以了，如果还有更复杂的事务属性直接添加即可，即</p><p>如果我们有一个batchSaveOrUpdate方法需要“REQUIRES_NEW”事务传播行为，则直接添加如下配置即可：</p><p>java代码：<br>1<br>&lt;tx:method name=”batchSaveOrUpdate” propagation=”REQUIRES_NEW” /&gt;<br>2、接下来看一下多事务语义配置吧，声明式事务最佳实践中已经配置了通用事务属性，因此可以针对需要其他事务属性的业务方法进行特例化配置：</p><pre><code>java代码：&lt;tx:advice id=&quot;noTxAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;    &lt;tx:attributes&gt;           &lt;tx:method name=&quot;*&quot; propagation=&quot;NEVER&quot; /&gt;    &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;aop:config&gt;       &lt;aop:pointcut id=&quot;noTxPointcut&quot; expression=&quot;execution(* cn.javass..util.*.*())&quot; /&gt;       &lt;aop:advisor advice-ref=&quot;noTxPointcut&quot; pointcut-ref=&quot;noTxAdvice&quot; /&gt;&lt;/aop:config&gt;</code></pre><p>该声明将对切入点匹配的方法所在事务应用“Never”传播行为。</p><p>多事务语义配置时，切入点一定不要叠加，否则将应用两次事务属性，造成不必要的错误及麻烦。</p><h3 id="Transactional实现事务管理"><a href="#Transactional实现事务管理" class="headerlink" title="@Transactional实现事务管理"></a>@Transactional实现事务管理</h3><p>对声明式事务管理，Spring提供基于@Transactional注解方式来实现，但需要Java 5+。</p><p>注解方式是最简单的事务配置方式，可以直接在Java源代码中声明事务属性，且对于每一个业务类或方法如果需要事务都必须使用此注解。</p><p>接下来学习一下注解事务的使用吧：</p><p>1、定义业务逻辑实现：</p><pre><code>package cn.javass.spring.chapter9.service.impl;//省略importpublic class AnnotationUserServiceImpl implements IUserService {    private IUserDao userDao;    private IAddressService addressService;    public void setUserDao(IUserDao userDao) {        this.userDao = userDao;    }    public void setAddressService(IAddressService addressService) {        this.addressService = addressService;    }    @Transactional(propagation=Propagation.REQUIRED, isolation=Isolation.READ_COMMITTED)    @Override    public void save(final UserModel user) {        userDao.save(user);        user.getAddress().setUserId(user.getId());        addressService.save(user.getAddress());    }    @Transactional(propagation=Propagation.REQUIRED, isolation=Isolation.READ_COMMITTED, readOnly=true)    @Override    public int countAll() {        return userDao.countAll();    }}</code></pre><p>2、定义配置文件（chapter9/service/ applicationContext-service-annotation.xml）：</p><p>2.1、XML命名空间定义，定义用于事务支持的tx命名空间和AOP支持的aop命名空间：</p><p>java代码：<br>        &lt;beans xmlns=”<a href="http://www.springframework.org/schema/beans&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/beans&quot;</a><br>              xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema-instance&quot;</a><br>            xmlns:tx=”<a href="http://www.springframework.org/schema/tx&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/tx&quot;</a><br>              xmlns:aop=”<a href="http://www.springframework.org/schema/aop&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/aop&quot;</a><br>              xsi:schemaLocation=”</p><pre><code>http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-3.0.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx-3.0.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-3.0.xsd&quot;&gt;</code></pre><p>2.2、业务实现配置，非常简单，使用以前定义的非侵入式业务实现：</p><pre><code>java代码：&lt;bean id=&quot;userService&quot; class=&quot;cn.javass.spring.chapter9.service.impl.ConfigUserServiceImpl&quot;&gt;    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;    &lt;property name=&quot;addressService&quot; ref=&quot;addressService&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;addressService&quot; class=&quot;cn.javass.spring.chapter9.service.impl.ConfigAddressServiceImpl&quot;&gt;    &lt;property name=&quot;addressDao&quot; ref=&quot;addressDao&quot;/&gt;&lt;/bean&gt;</code></pre><p>2.3、事务相关配置：</p><pre><code>java代码：1&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;使用如上配置已支持声明式事务。3、修改测试方法并测试该配置方式是否好用：将TransactionTest 类的testServiceTransaction测试方法拷贝一份命名为testAnntationTransactionTest：classpath:chapter9/service/applicationContext-service-annotation.xml&quot;userService.save(user);try {    userService.save(user);    Assert.fail();} catch (RuntimeException e) {}Assert.assertEquals(0, userService.countAll());Assert.assertEquals(0, addressService.countAll());</code></pre><p>4、执行测试，测试正常通过，说明该方式能正常工作，因为在AnnotationAddressServiceImpl类的save方法中抛出异常，因此事务需要回滚，所以两个countAll操作都返回0。</p><p>9.4.7  @Transactional配置详解<br>Spring提供的<a href="tx:annotation-driven/" target="_blank" rel="noopener">tx:annotation-driven/</a>用于开启对注解事务管理的支持，从而能识别Bean类上的@Transactional注解元数据，其具有以下属性：</p><p>transaction-manager：指定事务管理器名字，默认为transactionManager，当使用其他名字时需要明确指定；<br>proxy-target-class：表示将使用的代码机制，默认false表示使用JDK代理，如果为true将使用CGLIB代理<br>order：定义事务通知顺序，默认Ordered.LOWEST_PRECEDENCE，表示将顺序决定权交给AOP来处理。<br>Spring使用@Transactional 来指定事务属性，可以在接口、类或方法上指定，如果类和方法上都指定了@Transactional ，则方法上的事务属性被优先使用，具体属性如下：</p><p>value：指定事务管理器名字，默认使用<a href="tx:annotation-driven/" target="_blank" rel="noopener">tx:annotation-driven/</a>指定的事务管理器，用于支持多事务管理器环境；<br>propagation：指定事务传播行为，默认为Required，使用Propagation.REQUIRED指定；<br>isolation：指定事务隔离级别，默认为“DEFAULT”，使用Isolation.DEFAULT指定；<br>readOnly：指定事务是否只读，默认false表示事务非只读；<br>timeout：指定事务超时时间，以秒为单位，默认-1表示事务超时将依赖于底层事务系统；<br>rollbackFor：指定一组异常类，遇到该类异常将回滚事务；<br>rollbackForClassname：指定一组异常类名字，其含义与<a href="tx:method" target="_blank" rel="noopener">tx:method</a>中的rollback-for属性语义完全一样；<br>noRollbackFor：指定一组异常类，即使遇到该类异常也将提交事务，即不回滚事务；<br>noRollbackForClassname：指定一组异常类名字，其含义与<a href="tx:method" target="_blank" rel="noopener">tx:method</a>中的no-rollback-for属性语义完全一样；<br>Spring提供的@Transactional 注解事务管理内部同样利用环绕通知TransactionInterceptor实现事务的开启及关闭。</p><p>使用@Transactional注解事务管理需要特别注意以下几点：</p><p>如果在接口、实现类或方法上都指定了@Transactional 注解，则优先级顺序为方法&gt;实现类&gt;接口；<br>建议只在实现类或实现类的方法上使用@Transactional，而不要在接口上使用，这是因为如果使用JDK代理机制是没问题，因为其使用基于接口的代理；而使用使用CGLIB代理机制时就会遇到问题，因为其使用基于类的代理而不是接口，这是因为接口上的@Transactional注解是“不能继承的”；<br>                  具体请参考基于JDK动态代理和CGLIB动态代理的实现Spring注解管理事务（@Trasactional）到底有什么区别。<br>在Spring代理机制下(不管是JDK动态代理还是CGLIB代理)，“自我调用”同样不会应用相应的事务属性，其语义和<a href="tx:tags" target="_blank" rel="noopener">tx:tags</a>中一样；<br>默认只对RuntimeException异常回滚；<br>在使用Spring代理时，默认只有在public可见度的方法的@Transactional 注解才是有效的，其它可见度（protected、private、包可见）的方法上即使有@Transactional 注解也不会应用这些事务属性的，Spring也不会报错，如果你非要使用非公共方法注解事务管理的话，可考虑使用AspectJ。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文出处： &lt;a href=&quot;http://sishuok.com/forum/blogPost/list/0/2508.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;张开涛&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Spring源码解析 &lt;a href=&quot;https://blog.csdn.net/column/details/21851.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21851.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Spring" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Spring/"/>
    
    
      <category term="Spring事务" scheme="http://h2pl.github.io/tags/Spring%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码剖析7：AOP实现原理详解</title>
    <link href="http://h2pl.github.io/2018/06/04/spring7/"/>
    <id>http://h2pl.github.io/2018/06/04/spring7/</id>
    <published>2018-06-04T14:28:59.000Z</published>
    <updated>2018-06-11T15:23:25.219Z</updated>
    
    <content type="html"><![CDATA[<p>参考<a href="http://www.linkedkeeper.com/detail/blog.action?bid=1048" target="_blank" rel="noopener">http://www.linkedkeeper.com/detail/blog.action?bid=1048</a></p><p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Spring源码解析 <a href="https://blog.csdn.net/column/details/21851.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21851.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><p>前言</p><p>前面写了六篇文章详细地分析了Spring Bean加载流程，这部分完了之后就要进入一个比较困难的部分了，就是AOP的实现原理分析。为了探究AOP实现原理，首先定义几个类，一个Dao接口：</p><p>public interface Dao {<br>    public void select();<br>    public void insert();<br>}<br>Dao接口的实现类DaoImpl：</p><pre><code>public class DaoImpl implements Dao {    @Override    public void select() {        System.out.println(&quot;Enter DaoImpl.select()&quot;);    }    @Override    public void insert() {        System.out.println(&quot;Enter DaoImpl.insert()&quot;);    }}</code></pre><p>定义一个TimeHandler，用于方法调用前后打印时间，在AOP中，这扮演的是横切关注点的角色：</p><pre><code>public class TimeHandler {    public void printTime() {        System.out.println(&quot;CurrentTime:&quot; + System.currentTimeMillis());    }}</code></pre><p>定义一个XML文件aop.xml：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-3.0.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-3.0.xsd&quot;&gt;    &lt;bean id=&quot;daoImpl&quot; class=&quot;org.xrq.action.aop.DaoImpl&quot; /&gt;    &lt;bean id=&quot;timeHandler&quot; class=&quot;org.xrq.action.aop.TimeHandler&quot; /&gt;    &lt;aop:config proxy-target-class=&quot;true&quot;&gt;        &lt;aop:aspect id=&quot;time&quot; ref=&quot;timeHandler&quot;&gt;            &lt;aop:pointcut id=&quot;addAllMethod&quot; expression=&quot;execution(* org.xrq.action.aop.Dao.*(..))&quot; /&gt;            &lt;aop:before method=&quot;printTime&quot; pointcut-ref=&quot;addAllMethod&quot; /&gt;            &lt;aop:after method=&quot;printTime&quot; pointcut-ref=&quot;addAllMethod&quot; /&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;&lt;/beans&gt;</code></pre><p>写一段测试代码TestAop.java：</p><pre><code>public class TestAop {    @Test    public void testAop() {        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring/aop.xml&quot;);        Dao dao = (Dao)ac.getBean(&quot;daoImpl&quot;);        dao.select();    }}</code></pre><p>代码运行结果就不看了，有了以上的内容，我们就可以根据这些跟一下代码，看看Spring到底是如何实现AOP的。</p><h2 id="AOP实现原理——找到Spring处理AOP的源头"><a href="#AOP实现原理——找到Spring处理AOP的源头" class="headerlink" title="AOP实现原理——找到Spring处理AOP的源头"></a>AOP实现原理——找到Spring处理AOP的源头</h2><p>有很多朋友不愿意去看AOP源码的一个很大原因是因为找不到AOP源码实现的入口在哪里，这个确实是。不过我们可以看一下上面的测试代码，就普通Bean也好、AOP也好，最终都是通过getBean方法获取到Bean并调用方法的，getBean之后的对象已经前后都打印了TimeHandler类printTime()方法里面的内容，可以想见它们已经是被Spring容器处理过了。</p><p>既然如此，那无非就两个地方处理：</p><p>加载Bean定义的时候应该有过特殊的处理<br>getBean的时候应该有过特殊的处理<br>因此，本文围绕【1.加载Bean定义的时候应该有过特殊的处理】展开，先找一下到底是哪里Spring对AOP做了特殊的处理。代码直接定位到DefaultBeanDefinitionDocumentReader的parseBeanDefinitions方法：</p><pre><code>protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {    if (delegate.isDefaultNamespace(root)) {        NodeList nl = root.getChildNodes();        for (int i = 0; i &lt; nl.getLength(); i++) {            Node node = nl.item(i);            if (node instanceof Element) {                Element ele = (Element) node;                if (delegate.isDefaultNamespace(ele)) {                    parseDefaultElement(ele, delegate);                }                else {                    delegate.parseCustomElement(ele);                }            }        }    }    else {        delegate.parseCustomElement(root);    }}</code></pre><p>正常来说，遇到<bean id="”daoImpl”…">、<bean id="”timeHandler”…">这两个标签的时候，都会执行第9行的代码，因为<bean>标签是默认的Namespace。但是在遇到后面的<a href="aop:config" target="_blank" rel="noopener">aop:config</a>标签的时候就不一样了，<a href="aop:config" target="_blank" rel="noopener">aop:config</a>并不是默认的Namespace，因此会执行第12行的代码，看一下：</bean></bean></bean></p><pre><code>public BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) {    String namespaceUri = getNamespaceURI(ele);    NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);    if (handler == null) {        error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;, ele);        return null;    }    return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));}</code></pre><p>因为之前把整个XML解析为了org.w3c.dom.Document，org.w3c.dom.Document以树的形式表示整个XML，具体到每一个节点就是一个Node。</p><p>首先第2行从<a href="aop:config" target="_blank" rel="noopener">aop:config</a>这个Node（参数Element是Node接口的子接口）中拿到Namespace=”<a href="http://www.springframework.org/schema/aop“，第3行的代码根据这个Namespace获取对应的NamespaceHandler即Namespace处理器，具体到aop这个Namespace的NamespaceHandler是org.springframework.aop.config.AopNamespaceHandler类，也就是第3行代码获取到的结果。具体到AopNamespaceHandler里面，有几个Parser，是用于具体标签转换的，分别为：" target="_blank" rel="noopener">http://www.springframework.org/schema/aop“，第3行的代码根据这个Namespace获取对应的NamespaceHandler即Namespace处理器，具体到aop这个Namespace的NamespaceHandler是org.springframework.aop.config.AopNamespaceHandler类，也就是第3行代码获取到的结果。具体到AopNamespaceHandler里面，有几个Parser，是用于具体标签转换的，分别为：</a></p><p>config–&gt;ConfigBeanDefinitionParser<br>aspectj-autoproxy–&gt;AspectJAutoProxyBeanDefinitionParser<br>scoped-proxy–&gt;ScopedProxyBeanDefinitionDecorator<br>spring-configured–&gt;SpringConfiguredBeanDefinitionParser<br>接着，就是第8行的代码，利用AopNamespaceHandler的parse方法，解析<a href="aop:config" target="_blank" rel="noopener">aop:config</a>下的内容了。</p><h2 id="解析增强器advisor"><a href="#解析增强器advisor" class="headerlink" title="解析增强器advisor"></a>解析增强器advisor</h2><p>AOP Bean定义加载——根据织入方式将<a href="aop:before" target="_blank" rel="noopener">aop:before</a>、<a href="aop:after" target="_blank" rel="noopener">aop:after</a>转换成名为adviceDef的RootBeanDefinition<br>上面经过分析，已经找到了Spring是通过AopNamespaceHandler处理的AOP，那么接着进入AopNamespaceHandler的parse方法源代码：</p><pre><code>public BeanDefinition parse(Element element, ParserContext parserContext) {    return findParserForElement(element, parserContext).parse(element, parserContext);}   </code></pre><p>首先获取具体的Parser，因为当前节点是<a href="aop:config" target="_blank" rel="noopener">aop:config</a>，上一部分最后有列，config是通过ConfigBeanDefinitionParser来处理的，因此findParserForElement(element, parserContext)这一部分代码获取到的是ConfigBeanDefinitionParser，接着看ConfigBeanDefinitionParser的parse方法：</p><pre><code>public BeanDefinition parse(Element element, ParserContext parserContext) {    CompositeComponentDefinition compositeDef =            new CompositeComponentDefinition(element.getTagName(), parserContext.extractSource(element));    parserContext.pushContainingComponent(compositeDef);    configureAutoProxyCreator(parserContext, element);    List&lt;Element&gt; childElts = DomUtils.getChildElements(element);    for (Element elt: childElts) {        String localName = parserContext.getDelegate().getLocalName(elt);        if (POINTCUT.equals(localName)) {            parsePointcut(elt, parserContext);        }        else if (ADVISOR.equals(localName)) {            parseAdvisor(elt, parserContext);        }        else if (ASPECT.equals(localName)) {            parseAspect(elt, parserContext);        }    }    parserContext.popAndRegisterContainingComponent();    return null;}</code></pre><p>重点先提一下第6行的代码，该行代码的具体实现不跟了但它非常重要，configureAutoProxyCreator方法的作用我用几句话说一下：</p><p>向Spring容器注册了一个BeanName为org.springframework.aop.config.internalAutoProxyCreator的Bean定义，可以自定义也可以使用Spring提供的（根据优先级来）<br>Spring默认提供的是org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator，这个类是AOP的核心类，留在下篇讲解<br>在这个方法里面也会根据配置proxy-target-class和expose-proxy，设置是否使用CGLIB进行代理以及是否暴露最终的代理。<br><a href="aop:config" target="_blank" rel="noopener">aop:config</a>下的节点为<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>，想见必然是执行第18行的代码parseAspect，跟进去：</p><pre><code>private void parseAspect(Element aspectElement, ParserContext parserContext) {    String aspectId = aspectElement.getAttribute(ID);    String aspectName = aspectElement.getAttribute(REF);    try {        this.parseState.push(new AspectEntry(aspectId, aspectName));        List&lt;BeanDefinition&gt; beanDefinitions = new ArrayList&lt;BeanDefinition&gt;();        List&lt;BeanReference&gt; beanReferences = new ArrayList&lt;BeanReference&gt;();        List&lt;Element&gt; declareParents = DomUtils.getChildElementsByTagName(aspectElement, DECLARE_PARENTS);        for (int i = METHOD_INDEX; i &lt; declareParents.size(); i++) {            Element declareParentsElement = declareParents.get(i);            beanDefinitions.add(parseDeclareParents(declareParentsElement, parserContext));        }        // We have to parse &quot;advice&quot; and all the advice kinds in one loop, to get the        // ordering semantics right.        NodeList nodeList = aspectElement.getChildNodes();        boolean adviceFoundAlready = false;        for (int i = 0; i &lt; nodeList.getLength(); i++) {            Node node = nodeList.item(i);            if (isAdviceNode(node, parserContext)) {                if (!adviceFoundAlready) {                    adviceFoundAlready = true;                    if (!StringUtils.hasText(aspectName)) {                        parserContext.getReaderContext().error(                                &quot;&lt;aspect&gt; tag needs aspect bean reference via &apos;ref&apos; attribute when declaring advices.&quot;,                                aspectElement, this.parseState.snapshot());                        return;                    }                    beanReferences.add(new RuntimeBeanReference(aspectName));                }                AbstractBeanDefinition advisorDefinition = parseAdvice(                        aspectName, i, aspectElement, (Element) node, parserContext, beanDefinitions, beanReferences);                beanDefinitions.add(advisorDefinition);            }        }        AspectComponentDefinition aspectComponentDefinition = createAspectComponentDefinition(                aspectElement, aspectId, beanDefinitions, beanReferences, parserContext);        parserContext.pushContainingComponent(aspectComponentDefinition);        List&lt;Element&gt; pointcuts = DomUtils.getChildElementsByTagName(aspectElement, POINTCUT);        for (Element pointcutElement : pointcuts) {            parsePointcut(pointcutElement, parserContext);        }        parserContext.popAndRegisterContainingComponent();    }    finally {        this.parseState.pop();    }}</code></pre><p>从第20行~第37行的循环开始关注这个方法。这个for循环有一个关键的判断就是第22行的ifAdviceNode判断，看下ifAdviceNode方法做了什么：</p><pre><code>private boolean isAdviceNode(Node aNode, ParserContext parserContext) {    if (!(aNode instanceof Element)) {        return false;    }    else {        String name = parserContext.getDelegate().getLocalName(aNode);        return (BEFORE.equals(name) || AFTER.equals(name) || AFTER_RETURNING_ELEMENT.equals(name) ||                AFTER_THROWING_ELEMENT.equals(name) || AROUND.equals(name));    }}</code></pre><p>即这个for循环只用来处理<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的<a href="aop:before" target="_blank" rel="noopener">aop:before</a>、<a href="aop:after" target="_blank" rel="noopener">aop:after</a>、<a href="aop:after-returning" target="_blank" rel="noopener">aop:after-returning</a>、&lt;aop:after-throwing method=””&gt;、&lt;aop:around method=””&gt;这五个标签的。</p><p>接着，如果是上述五种标签之一，那么进入第33行~第34行的parseAdvice方法：</p><pre><code>private AbstractBeanDefinition parseAdvice(    String aspectName, int order, Element aspectElement, Element adviceElement, ParserContext parserContext,    List&lt;BeanDefinition&gt; beanDefinitions, List&lt;BeanReference&gt; beanReferences) {    try {        this.parseState.push(new AdviceEntry(parserContext.getDelegate().getLocalName(adviceElement)));        // create the method factory bean        RootBeanDefinition methodDefinition = new RootBeanDefinition(MethodLocatingFactoryBean.class);        methodDefinition.getPropertyValues().add(&quot;targetBeanName&quot;, aspectName);        methodDefinition.getPropertyValues().add(&quot;methodName&quot;, adviceElement.getAttribute(&quot;method&quot;));        methodDefinition.setSynthetic(true);        // create instance factory definition        RootBeanDefinition aspectFactoryDef =        new RootBeanDefinition(SimpleBeanFactoryAwareAspectInstanceFactory.class);        aspectFactoryDef.getPropertyValues().add(&quot;aspectBeanName&quot;, aspectName);        aspectFactoryDef.setSynthetic(true);        // register the pointcut        AbstractBeanDefinition adviceDef = createAdviceDefinition(            adviceElement, parserContext, aspectName, order, methodDefinition, aspectFactoryDef,            beanDefinitions, beanReferences);        // configure the advisor        RootBeanDefinition advisorDefinition = new RootBeanDefinition(AspectJPointcutAdvisor.class);        advisorDefinition.setSource(parserContext.extractSource(adviceElement));        advisorDefinition.getConstructorArgumentValues().addGenericArgumentValue(adviceDef);        if (aspectElement.hasAttribute(ORDER_PROPERTY)) {            advisorDefinition.getPropertyValues().add(                ORDER_PROPERTY, aspectElement.getAttribute(ORDER_PROPERTY));        }        // register the final advisor        parserContext.getReaderContext().registerWithGeneratedName(advisorDefinition);        return advisorDefinition;    }    finally {        this.parseState.pop();    }}</code></pre><p>方法主要做了三件事：</p><p>根据织入方式（before、after这些）创建RootBeanDefinition，名为adviceDef即advice定义<br>将上一步创建的RootBeanDefinition写入一个新的RootBeanDefinition，构造一个新的对象，名为advisorDefinition，即advisor定义<br>将advisorDefinition注册到DefaultListableBeanFactory中<br>下面来看做的第一件事createAdviceDefinition方法定义：</p><pre><code>private AbstractBeanDefinition createAdviceDefinition(        Element adviceElement, ParserContext parserContext, String aspectName, int order,        RootBeanDefinition methodDef, RootBeanDefinition aspectFactoryDef,        List&lt;BeanDefinition&gt; beanDefinitions, List&lt;BeanReference&gt; beanReferences) {    RootBeanDefinition adviceDefinition = new RootBeanDefinition(getAdviceClass(adviceElement, parserContext));    adviceDefinition.setSource(parserContext.extractSource(adviceElement));        adviceDefinition.getPropertyValues().add(ASPECT_NAME_PROPERTY, aspectName);    adviceDefinition.getPropertyValues().add(DECLARATION_ORDER_PROPERTY, order);    if (adviceElement.hasAttribute(RETURNING)) {        adviceDefinition.getPropertyValues().add(                RETURNING_PROPERTY, adviceElement.getAttribute(RETURNING));    }    if (adviceElement.hasAttribute(THROWING)) {        adviceDefinition.getPropertyValues().add(                THROWING_PROPERTY, adviceElement.getAttribute(THROWING));    }    if (adviceElement.hasAttribute(ARG_NAMES)) {        adviceDefinition.getPropertyValues().add(                ARG_NAMES_PROPERTY, adviceElement.getAttribute(ARG_NAMES));    }    ConstructorArgumentValues cav = adviceDefinition.getConstructorArgumentValues();    cav.addIndexedArgumentValue(METHOD_INDEX, methodDef);    Object pointcut = parsePointcutProperty(adviceElement, parserContext);    if (pointcut instanceof BeanDefinition) {        cav.addIndexedArgumentValue(POINTCUT_INDEX, pointcut);        beanDefinitions.add((BeanDefinition) pointcut);    }    else if (pointcut instanceof String) {        RuntimeBeanReference pointcutRef = new RuntimeBeanReference((String) pointcut);        cav.addIndexedArgumentValue(POINTCUT_INDEX, pointcutRef);        beanReferences.add(pointcutRef);    }    cav.addIndexedArgumentValue(ASPECT_INSTANCE_FACTORY_INDEX, aspectFactoryDef);    return adviceDefinition;}</code></pre><p>首先可以看到，创建的AbstractBeanDefinition实例是RootBeanDefinition，这和普通Bean创建的实例为GenericBeanDefinition不同。然后进入第6行的getAdviceClass方法看一下：</p><pre><code>private Class getAdviceClass(Element adviceElement, ParserContext parserContext) {    String elementName = parserContext.getDelegate().getLocalName(adviceElement);    if (BEFORE.equals(elementName)) {        return AspectJMethodBeforeAdvice.class;    }    else if (AFTER.equals(elementName)) {        return AspectJAfterAdvice.class;    }    else if (AFTER_RETURNING_ELEMENT.equals(elementName)) {        return AspectJAfterReturningAdvice.class;    }    else if (AFTER_THROWING_ELEMENT.equals(elementName)) {        return AspectJAfterThrowingAdvice.class;    }    else if (AROUND.equals(elementName)) {        return AspectJAroundAdvice.class;    }    else {        throw new IllegalArgumentException(&quot;Unknown advice kind [&quot; + elementName + &quot;].&quot;);    }}</code></pre><p>既然创建Bean定义，必然该Bean定义中要对应一个具体的Class，不同的切入方式对应不同的Class：</p><p>before对应AspectJMethodBeforeAdvice<br>After对应AspectJAfterAdvice<br>after-returning对应AspectJAfterReturningAdvice<br>after-throwing对应AspectJAfterThrowingAdvice<br>around对应AspectJAroundAdvice<br>createAdviceDefinition方法剩余逻辑没什么，就是判断一下标签里面的属性并设置一下相应的值而已，至此<a href="aop:before" target="_blank" rel="noopener">aop:before</a>、<a href="aop:after" target="_blank" rel="noopener">aop:after</a>两个标签对应的AbstractBeanDefinition就创建出来了。</p><p>AOP Bean定义加载——将名为adviceDef的RootBeanDefinition转换成名为advisorDefinition的RootBeanDefinition<br>下面我们看一下第二步的操作，将名为adviceDef的RootBeanD转换成名为advisorDefinition的RootBeanDefinition，跟一下上面一部分ConfigBeanDefinitionParser类parseAdvice方法的第26行~32行的代码：</p><pre><code>RootBeanDefinition advisorDefinition = new RootBeanDefinition(AspectJPointcutAdvisor.class);advisorDefinition.setSource(parserContext.extractSource(adviceElement));advisorDefinition.getConstructorArgumentValues().addGenericArgumentValue(adviceDef);if (aspectElement.hasAttribute(ORDER_PROPERTY)) {    advisorDefinition.getPropertyValues().add(            ORDER_PROPERTY, aspectElement.getAttribute(ORDER_PROPERTY));}</code></pre><p>这里相当于将上一步生成的RootBeanDefinition包装了一下，new一个新的RootBeanDefinition出来，Class类型是org.springframework.aop.aspectj.AspectJPointcutAdvisor。</p><p>第4行~第7行的代码是用于判断<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签中有没有”order”属性的，有就设置一下，”order”属性是用来控制切入方法优先级的。</p><p>AOP Bean定义加载——将BeanDefinition注册到DefaultListableBeanFactory中</p><p>最后一步就是将BeanDefinition注册到DefaultListableBeanFactory中了，代码就是前面ConfigBeanDefinitionParser的parseAdvice方法的最后一部分了：</p><p>…<br>// register the final advisor<br>parserContext.getReaderContext().registerWithGeneratedName(advisorDefinition);<br>…<br>跟一下registerWithGeneratedName方法的实现：</p><pre><code>public String registerWithGeneratedName(BeanDefinition beanDefinition) {    String generatedName = generateBeanName(beanDefinition);    getRegistry().registerBeanDefinition(generatedName, beanDefinition);    return generatedName;}</code></pre><p>第2行获取注册的名字BeanName，和<bean>的注册差不多，使用的是Class全路径+”#”+全局计数器的方式，其中的Class全路径为org.springframework.aop.aspectj.AspectJPointcutAdvisor，依次类推，每一个BeanName应当为org.springframework.aop.aspectj.AspectJPointcutAdvisor#0、org.springframework.aop.aspectj.AspectJPointcutAdvisor#1、org.springframework.aop.aspectj.AspectJPointcutAdvisor#2这样下去。</bean></p><p>第3行向DefaultListableBeanFactory中注册，BeanName已经有了，剩下的就是Bean定义，Bean定义的解析流程之前已经看过了，就不说了。</p><h2 id="解析切面的过程"><a href="#解析切面的过程" class="headerlink" title="解析切面的过程"></a>解析切面的过程</h2><p>AOP Bean定义加载——AopNamespaceHandler处理<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>流程<br>回到ConfigBeanDefinitionParser的parseAspect方法：</p><pre><code>private void parseAspect(Element aspectElement, ParserContext parserContext) {        ...          AspectComponentDefinition aspectComponentDefinition = createAspectComponentDefinition(                aspectElement, aspectId, beanDefinitions, beanReferences, parserContext);        parserContext.pushContainingComponent(aspectComponentDefinition);        List&lt;Element&gt; pointcuts = DomUtils.getChildElementsByTagName(aspectElement, POINTCUT);        for (Element pointcutElement : pointcuts) {            parsePointcut(pointcutElement, parserContext);        }        parserContext.popAndRegisterContainingComponent();    }    finally {        this.parseState.pop();    }}</code></pre><p>省略号部分表示是解析的是<a href="aop:before" target="_blank" rel="noopener">aop:before</a>、<a href="aop:after" target="_blank" rel="noopener">aop:after</a>这种标签，上部分已经说过了，就不说了，下面看一下解析<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>部分的源码。</p><p>第5行~第7行的代码构建了一个Aspect标签组件定义，并将Apsect标签组件定义推到ParseContext即解析工具上下文中，这部分代码不是关键。</p><p>第9行的代码拿到所有<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>下的pointcut标签，进行遍历，由parsePointcut方法进行处理：</p><pre><code>private AbstractBeanDefinition parsePointcut(Element pointcutElement, ParserContext parserContext) {    String id = pointcutElement.getAttribute(ID);    String expression = pointcutElement.getAttribute(EXPRESSION);    AbstractBeanDefinition pointcutDefinition = null;    try {        this.parseState.push(new PointcutEntry(id));        pointcutDefinition = createPointcutDefinition(expression);        pointcutDefinition.setSource(parserContext.extractSource(pointcutElement));        String pointcutBeanName = id;        if (StringUtils.hasText(pointcutBeanName)) {            parserContext.getRegistry().registerBeanDefinition(pointcutBeanName, pointcutDefinition);        }        else {            pointcutBeanName = parserContext.getReaderContext().registerWithGeneratedName(pointcutDefinition);        }        parserContext.registerComponent(                new PointcutComponentDefinition(pointcutBeanName, pointcutDefinition, expression));    }    finally {        this.parseState.pop();    }    return pointcutDefinition;}</code></pre><p>第2行~第3行的代码获取<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>标签下的”id”属性与”expression”属性。</p><p>第8行的代码推送一个PointcutEntry，表示当前Spring上下文正在解析Pointcut标签。</p><p>第9行的代码创建Pointcut的Bean定义，之后再看，先把其他方法都看一下。</p><p>第10行的代码不管它，最终从NullSourceExtractor的extractSource方法获取Source，就是个null。</p><p>第12行~第18行的代码用于注册获取到的Bean定义，默认pointcutBeanName为<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>标签中定义的id属性：</p><p>如果<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>标签中配置了id属性就执行的是第13行~第15行的代码，pointcutBeanName=id<br>如果<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>标签中没有配置id属性就执行的是第16行~第18行的代码，和Bean不配置id属性一样的规则，pointcutBeanName=org.springframework.aop.aspectj.AspectJExpressionPointcut#序号（从0开始累加）<br>第20行~第21行的代码向解析工具上下文中注册一个Pointcut组件定义</p><p>第23行~第25行的代码，finally块在<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>标签解析完毕后，让之前推送至栈顶的PointcutEntry出栈，表示此次<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>标签解析完毕。</p><p>最后回头来一下第9行代码createPointcutDefinition的实现，比较简单：</p><pre><code>protected AbstractBeanDefinition createPointcutDefinition(String expression) {    RootBeanDefinition beanDefinition = new RootBeanDefinition(AspectJExpressionPointcut.class);    beanDefinition.setScope(BeanDefinition.SCOPE_PROTOTYPE);    beanDefinition.setSynthetic(true);    beanDefinition.getPropertyValues().add(EXPRESSION, expression);    return beanDefinition;}</code></pre><p>关键就是注意一下两点：</p><p><a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>标签对应解析出来的BeanDefinition是RootBeanDefinition，且RootBenaDefinitoin中的Class是org.springframework.aop.aspectj.AspectJExpressionPointcut<br><a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>标签对应的Bean是prototype即原型的<br>这样一个流程下来，就解析了<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>标签中的内容并将之转换为RootBeanDefintion存储在Spring容器中。</p><h2 id="AOP为Bean生成代理的时机分析"><a href="#AOP为Bean生成代理的时机分析" class="headerlink" title="AOP为Bean生成代理的时机分析"></a>AOP为Bean生成代理的时机分析</h2><p>上篇文章说了，org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator这个类是Spring提供给开发者的AOP的核心类，就是AspectJAwareAdvisorAutoProxyCreator完成了【类/接口–&gt;代理】的转换过程，首先我们看一下AspectJAwareAdvisorAutoProxyCreator的层次结构：</p><p>这里最值得注意的一点是最左下角的那个方框，我用几句话总结一下：</p><p>AspectJAwareAdvisorAutoProxyCreator是BeanPostProcessor接口的实现类<br>postProcessBeforeInitialization方法与postProcessAfterInitialization方法实现在父类AbstractAutoProxyCreator中<br>postProcessBeforeInitialization方法是一个空实现<br>逻辑代码在postProcessAfterInitialization方法中<br>基于以上的分析，将Bean生成代理的时机已经一目了然了：在每个Bean初始化之后，如果需要，调用AspectJAwareAdvisorAutoProxyCreator中的postProcessBeforeInitialization为Bean生成代理。</p><p>代理对象实例化—-判断是否为<bean>生成代理<br>上文分析了Bean生成代理的时机是在每个Bean初始化之后，下面把代码定位到Bean初始化之后，先是AbstractAutowireCapableBeanFactory的initializeBean方法进行初始化：</bean></p><pre><code>protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {    if (System.getSecurityManager() != null) {        AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {            public Object run() {                invokeAwareMethods(beanName, bean);                return null;            }        }, getAccessControlContext());    }    else {        invokeAwareMethods(beanName, bean);    }    Object wrappedBean = bean;    if (mbd == null || !mbd.isSynthetic()) {        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);    }    try {    invokeInitMethods(beanName, wrappedBean, mbd);    }    catch (Throwable ex) {        throw new BeanCreationException(                (mbd != null ? mbd.getResourceDescription() : null),                beanName, &quot;Invocation of init method failed&quot;, ex);    }    if (mbd == null || !mbd.isSynthetic()) {        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);    }    return wrappedBean;}</code></pre><p>初始化之前是第16行的applyBeanPostProcessorsBeforeInitialization方法，初始化之后即29行的applyBeanPostProcessorsAfterInitialization方法：</p><pre><code>public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)        throws BeansException {    Object result = existingBean;    for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {        result = beanProcessor.postProcessAfterInitialization(result, beanName);        if (result == null) {            return result;        }    }    return result;}</code></pre><p>这里调用每个BeanPostProcessor的postProcessBeforeInitialization方法。按照之前的分析，看一下AbstractAutoProxyCreator的postProcessAfterInitialization方法实现：</p><pre><code>public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {    if (bean != null) {        Object cacheKey = getCacheKey(bean.getClass(), beanName);        if (!this.earlyProxyReferences.contains(cacheKey)) {            return wrapIfNecessary(bean, beanName, cacheKey);        }    }    return bean;}</code></pre><p>跟一下第5行的方法wrapIfNecessary：</p><pre><code>protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {    if (this.targetSourcedBeans.contains(beanName)) {        return bean;    }    if (this.nonAdvisedBeans.contains(cacheKey)) {        return bean;    }    if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {        this.nonAdvisedBeans.add(cacheKey);        return bean;    }    // Create proxy if we have advice.    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);    if (specificInterceptors != DO_NOT_PROXY) {        this.advisedBeans.add(cacheKey);        Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));        this.proxyTypes.put(cacheKey, proxy.getClass());        return proxy;    }    this.nonAdvisedBeans.add(cacheKey);    return bean;}</code></pre><p>第2行~第11行是一些不需要生成代理的场景判断，这里略过。首先我们要思考的第一个问题是：哪些目标对象需要生成代理？因为配置文件里面有很多Bean，肯定不能对每个Bean都生成代理，因此需要一套规则判断Bean是不是需要生成代理，这套规则就是第14行的代码getAdvicesAndAdvisorsForBean：</p><pre><code>protected List&lt;Advisor&gt; findEligibleAdvisors(Class beanClass, String beanName) {    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);    extendAdvisors(eligibleAdvisors);    if (!eligibleAdvisors.isEmpty()) {        eligibleAdvisors = sortAdvisors(eligibleAdvisors);    }    return eligibleAdvisors;}</code></pre><p>顾名思义，方法的意思是为指定class寻找合适的Advisor。</p><p>第2行代码，寻找候选Advisors，根据上文的配置文件，有两个候选Advisor，分别是<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>节点下的<a href="aop:before" target="_blank" rel="noopener">aop:before</a>和<a href="aop:after" target="_blank" rel="noopener">aop:after</a>这两个，这两个在XML解析的时候已经被转换生成了RootBeanDefinition。</p><p>跳过第3行的代码，先看下第4行的代码extendAdvisors方法，之后再重点看一下第3行的代码。第4行的代码extendAdvisors方法作用是向候选Advisor链的开头（也就是List.get(0)的位置）添加一个org.springframework.aop.support.DefaultPointcutAdvisor。</p><p>第3行代码，根据候选Advisors，寻找可以使用的Advisor，跟一下方法实现：</p><pre><code>public static List&lt;Advisor&gt; findAdvisorsThatCanApply(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz) {    if (candidateAdvisors.isEmpty()) {        return candidateAdvisors;    }    List&lt;Advisor&gt; eligibleAdvisors = new LinkedList&lt;Advisor&gt;();    for (Advisor candidate : candidateAdvisors) {        if (candidate instanceof IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) {            eligibleAdvisors.add(candidate);        }    }    boolean hasIntroductions = !eligibleAdvisors.isEmpty();    for (Advisor candidate : candidateAdvisors) {        if (candidate instanceof IntroductionAdvisor) {            // already processed            continue;        }        if (canApply(candidate, clazz, hasIntroductions)) {            eligibleAdvisors.add(candidate);        }    }    return eligibleAdvisors;}</code></pre><p>整个方法的主要判断都围绕canApply展开方法：</p><pre><code>public static boolean canApply(Advisor advisor, Class&lt;?&gt; targetClass, boolean hasIntroductions) {    if (advisor instanceof IntroductionAdvisor) {        return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);    }    else if (advisor instanceof PointcutAdvisor) {        PointcutAdvisor pca = (PointcutAdvisor) advisor;        return canApply(pca.getPointcut(), targetClass, hasIntroductions);    }    else {        // It doesn&apos;t have a pointcut so we assume it applies.        return true;    }}</code></pre><p>第一个参数advisor的实际类型是AspectJPointcutAdvisor，它是PointcutAdvisor的子类，因此执行第7行的方法：</p><pre><code>public static boolean canApply(Pointcut pc, Class&lt;?&gt; targetClass, boolean hasIntroductions) {    if (!pc.getClassFilter().matches(targetClass)) {        return false;    }    MethodMatcher methodMatcher = pc.getMethodMatcher();    IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;    if (methodMatcher instanceof IntroductionAwareMethodMatcher) {        introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;    }    Set&lt;Class&gt; classes = new HashSet&lt;Class&gt;(ClassUtils.getAllInterfacesForClassAsSet(targetClass));    classes.add(targetClass);    for (Class&lt;?&gt; clazz : classes) {        Method[] methods = clazz.getMethods();        for (Method method : methods) {            if ((introductionAwareMethodMatcher != null &amp;&amp;                introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||                    methodMatcher.matches(method, targetClass)) {                return true;            }        }    }    return false;}</code></pre><p>这个方法其实就是拿当前Advisor对应的expression做了两层判断：</p><p>目标类必须满足expression的匹配规则<br>目标类中的方法必须满足expression的匹配规则，当然这里方法不是全部需要满足expression的匹配规则，有一个方法满足即可<br>如果以上两条都满足，那么容器则会判断该<bean>满足条件，需要被生成代理对象，具体方式为返回一个数组对象，该数组对象中存储的是<bean>对应的Advisor。</bean></bean></p><h2 id="代理对象实例化过程"><a href="#代理对象实例化过程" class="headerlink" title="代理对象实例化过程"></a>代理对象实例化过程</h2><p>代理对象实例化—-为<bean>生成代理代码上下文梳理<br>上文分析了为<bean>生成代理的条件，现在就正式看一下Spring上下文是如何为<bean>生成代理的。回到AbstractAutoProxyCreator的wrapIfNecessary方法：</bean></bean></bean></p><pre><code>protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {    if (this.targetSourcedBeans.contains(beanName)) {        return bean;    }    if (this.nonAdvisedBeans.contains(cacheKey)) {        return bean;    }    if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {        this.nonAdvisedBeans.add(cacheKey);        return bean;    }    // Create proxy if we have advice.    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);    if (specificInterceptors != DO_NOT_PROXY) {        this.advisedBeans.add(cacheKey);        Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));        this.proxyTypes.put(cacheKey, proxy.getClass());        return proxy;    }    this.nonAdvisedBeans.add(cacheKey);    return bean;}</code></pre><p>第14行拿到<bean>对应的Advisor数组，第15行判断只要Advisor数组不为空，那么就会通过第17行的代码为<bean>创建代理：</bean></bean></p><pre><code>protected Object createProxy(        Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) {    ProxyFactory proxyFactory = new ProxyFactory();    // Copy our properties (proxyTargetClass etc) inherited from ProxyConfig.    proxyFactory.copyFrom(this);    if (!shouldProxyTargetClass(beanClass, beanName)) {        // Must allow for introductions; can&apos;t just set interfaces to        // the target&apos;s interfaces only.        Class&lt;?&gt;[] targetInterfaces = ClassUtils.getAllInterfacesForClass(beanClass, this.proxyClassLoader);        for (Class&lt;?&gt; targetInterface : targetInterfaces) {            proxyFactory.addInterface(targetInterface);        }    }    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);    for (Advisor advisor : advisors) {        proxyFactory.addAdvisor(advisor);    }    proxyFactory.setTargetSource(targetSource);    customizeProxyFactory(proxyFactory);    proxyFactory.setFrozen(this.freezeProxy);    if (advisorsPreFiltered()) {        proxyFactory.setPreFiltered(true);    }    return proxyFactory.getProxy(this.proxyClassLoader);}</code></pre><p>第4行~第6行new出了一个ProxyFactory，Proxy，顾名思义，代理工厂的意思，提供了简单的方式使用代码获取和配置AOP代理。</p><p>第8行的代码做了一个判断，判断的内容是<a href="aop:config" target="_blank" rel="noopener">aop:config</a>这个节点中proxy-target-class=”false”或者proxy-target-class不配置，即不使用CGLIB生成代理。如果满足条件，进判断，获取当前Bean实现的所有接口，讲这些接口Class对象都添加到ProxyFactory中。</p><p>第17行~第28行的代码没什么看的必要，向ProxyFactory中添加一些参数而已。重点看第30行proxyFactory.getProxy(this.proxyClassLoader)这句：</p><pre><code>public Object getProxy(ClassLoader classLoader) {return createAopProxy().getProxy(classLoader);}</code></pre><p>实现代码就一行，但是却明确告诉我们做了两件事情：</p><p>创建AopProxy接口实现类<br>通过AopProxy接口的实现类的getProxy方法获取<bean>对应的代理<br>就从这两个点出发，分两部分分析一下。</bean></p><p>代理对象实例化—-创建AopProxy接口实现类<br>看一下createAopProxy()方法的实现，它位于DefaultAopProxyFactory类中：</p><pre><code>protected final synchronized AopProxy createAopProxy() {if (!this.active) {activate();}return getAopProxyFactory().createAopProxy(this);}</code></pre><p>前面的部分没什么必要看，直接进入重点即createAopProxy方法：</p><pre><code>public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {    if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {        Class targetClass = config.getTargetClass();        if (targetClass == null) {            throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +                    &quot;Either an interface or a target is required for proxy creation.&quot;);        }        if (targetClass.isInterface()) {            return new JdkDynamicAopProxy(config);        }        if (!cglibAvailable) {            throw new AopConfigException(                    &quot;Cannot proxy target class because CGLIB2 is not available. &quot; +                    &quot;Add CGLIB to the class path or specify proxy interfaces.&quot;);        }        return CglibProxyFactory.createCglibProxy(config);    }    else {        return new JdkDynamicAopProxy(config);    }}</code></pre><p>平时我们说AOP原理三句话就能概括：</p><p>对类生成代理使用CGLIB<br>对接口生成代理使用JDK原生的Proxy<br>可以通过配置文件指定对接口使用CGLIB生成代理<br>这三句话的出处就是createAopProxy方法。看到默认是第19行的代码使用JDK自带的Proxy生成代理，碰到以下三种情况例外：</p><p>ProxyConfig的isOptimize方法为true，这表示让Spring自己去优化而不是用户指定<br>ProxyConfig的isProxyTargetClass方法为true，这表示配置了proxy-target-class=”true”<br>ProxyConfig满足hasNoUserSuppliedProxyInterfaces方法执行结果为true，这表示<bean>对象没有实现任何接口或者实现的接口是SpringProxy接口<br>在进入第2行的if判断之后再根据目标<bean>的类型决定返回哪种AopProxy。简单总结起来就是：</bean></bean></p><p>proxy-target-class没有配置或者proxy-target-class=”false”，返回JdkDynamicAopProxy<br>proxy-target-class=”true”或者<bean>对象没有实现任何接口或者只实现了SpringProxy接口，返回Cglib2AopProxy<br>当然，不管是JdkDynamicAopProxy还是Cglib2AopProxy，AdvisedSupport都是作为构造函数参数传入的，里面存储了具体的Advisor。 </bean></p><p>代理对象实例化—-通过getProxy方法获取<bean>对应的代理<br>其实代码已经分析到了JdkDynamicAopProxy和Cglib2AopProxy，剩下的就没什么好讲的了，无非就是看对这两种方式生成代理的熟悉程度而已。</bean></p><p>Cglib2AopProxy生成代理的代码就不看了，对Cglib不熟悉的朋友可以看Cglib及其基本使用一文。</p><p>JdkDynamicAopProxy生成代理的方式稍微看一下：</p><p>public Object getProxy(ClassLoader classLoader) {<br>    if (logger.isDebugEnabled()) {<br>        logger.debug(“Creating JDK dynamic proxy: target source is “ + this.advised.getTargetSource());<br>    }<br>    Class[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised);<br>    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);<br>    return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);<br>}<br>这边解释一下第5行和第6行的代码，第5行代码的作用是拿到所有要代理的接口，第6行代码的作用是尝试寻找这些接口方法里面有没有equals方法和hashCode方法，同时都有的话打个标记，寻找结束，equals方法和hashCode方法有特殊处理。</p><p>最终通过第7行的Proxy.newProxyInstance方法获取接口/类对应的代理对象，Proxy是JDK原生支持的生成代理的方式。</p><p>代理方法调用原理<br>前面已经详细分析了为接口/类生成代理的原理，生成代理之后就要调用方法了，这里看一下使用JdkDynamicAopProxy调用方法的原理。</p><p>由于JdkDynamicAopProxy本身实现了InvocationHandler接口，因此具体代理前后处理的逻辑在invoke方法中：</p><pre><code>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {    MethodInvocation invocation;    Object oldProxy = null;    boolean setProxyContext = false;    TargetSource targetSource = this.advised.targetSource;    Class targetClass = null;    Object target = null;    try {        if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) {            // The target does not implement the equals(Object) method itself.            return equals(args[0]);        }        if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) {            // The target does not implement the hashCode() method itself.            return hashCode();        }        if (!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;                method.getDeclaringClass().isAssignableFrom(Advised.class)) {            // Service invocations on ProxyConfig with the proxy config...            return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);        }        Object retVal;        if (this.advised.exposeProxy) {            // Make invocation available if necessary.            oldProxy = AopContext.setCurrentProxy(proxy);            setProxyContext = true;        }        // May be null. Get as late as possible to minimize the time we &quot;own&quot; the target,        // in case it comes from a pool.        target = targetSource.getTarget();        if (target != null) {            targetClass = target.getClass();        }        // Get the interception chain for this method.        List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);        // Check whether we have any advice. If we don&apos;t, we can fallback on direct        // reflective invocation of the target, and avoid creating a MethodInvocation.        if (chain.isEmpty()) {            // We can skip creating a MethodInvocation: just invoke the target directly            // Note that the final invoker must be an InvokerInterceptor so we know it does            // nothing but a reflective operation on the target, and no hot swapping or fancy proxying.            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, args);        }        else {            // We need to create a method invocation...            invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);            // Proceed to the joinpoint through the interceptor chain.            retVal = invocation.proceed();        }        // Massage return value if necessary.        if (retVal != null &amp;&amp; retVal == target &amp;&amp; method.getReturnType().isInstance(proxy) &amp;&amp;                !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {            // Special case: it returned &quot;this&quot; and the return type of the method            // is type-compatible. Note that we can&apos;t help if the target sets            // a reference to itself in another returned object.            retVal = proxy;        }        return retVal;    }    finally {        if (target != null &amp;&amp; !targetSource.isStatic()) {            // Must have come from TargetSource.            targetSource.releaseTarget(target);        }        if (setProxyContext) {            // Restore old proxy.            AopContext.setCurrentProxy(oldProxy);        }    }}</code></pre><p>第11行~第18行的代码，表示equals方法与hashCode方法即使满足expression规则，也不会为之产生代理内容，调用的是JdkDynamicAopProxy的equals方法与hashCode方法。至于这两个方法是什么作用，可以自己查看一下源代码。</p><p>第19行~第23行的代码，表示方法所属的Class是一个接口并且方法所属的Class是AdvisedSupport的父类或者父接口，直接通过反射调用该方法。</p><p>第27行~第30行的代码，是用于判断是否将代理暴露出去的，由<a href="aop:config" target="_blank" rel="noopener">aop:config</a>标签中的expose-proxy=”true/false”配置。</p><p>第41行的代码，获取AdvisedSupport中的所有拦截器和动态拦截器列表，用于拦截方法，具体到我们的实际代码，列表中有三个Object，分别是：</p><p>chain.get(0)：ExposeInvocationInterceptor，这是一个默认的拦截器，对应的原Advisor为DefaultPointcutAdvisor<br>chain.get(1)：MethodBeforeAdviceInterceptor，用于在实际方法调用之前的拦截，对应的原Advisor为AspectJMethodBeforeAdvice<br>chain.get(2)：AspectJAfterAdvice，用于在实际方法调用之后的处理<br>第45行~第50行的代码，如果拦截器列表为空，很正常，因为某个类/接口下的某个方法可能不满足expression的匹配规则，因此此时通过反射直接调用该方法。</p><p>第51行~第56行的代码，如果拦截器列表不为空，按照注释的意思，需要一个ReflectiveMethodInvocation，并通过proceed方法对原方法进行拦截，proceed方法感兴趣的朋友可以去看一下，里面使用到了递归的思想对chain中的Object进行了层层的调用。</p><h2 id="CGLIB代理实现"><a href="#CGLIB代理实现" class="headerlink" title="CGLIB代理实现"></a>CGLIB代理实现</h2><p>下面我们来看一下CGLIB代理的方式，这里需要读者去了解一下CGLIB以及其创建代理的方式：</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_22ccd185-6cf6-4696-a9f6-3f1001fad8bf.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_d6ae728d-91af-4dff-919c-c02707a6b1ca.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_38629750-f1c6-4621-a7fd-3f48b2c21327.jpg" alt=""></p><p>这里将拦截器链封装到了DynamicAdvisedInterceptor中，并加入了Callback，DynamicAdvisedInterceptor实现了CGLIB的MethodInterceptor，所以其核心逻辑在intercept方法中：</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_0ac132d8-ef67-4f71-9529-cba377030dc4.jpg" alt=""></p><p>这里我们看到了与JDK动态代理同样的获取拦截器链的过程，并且CglibMethodInvokcation继承了我们在JDK动态代理看到的ReflectiveMethodInvocation，但是并没有重写其proceed方法，只是重写了执行目标方法的逻辑，所以整体上是大同小异的。</p><p>到这里，整个Spring 动态AOP的源码就分析完了，Spring还支持静态AOP，这里就不过多赘述了，有兴趣的读者可以查阅相关资料来学习。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考&lt;a href=&quot;http://www.linkedkeeper.com/detail/blog.action?bid=1048&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.linkedkeeper.com/detail/blog.action?bid=1048&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Spring源码解析 &lt;a href=&quot;https://blog.csdn.net/column/details/21851.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21851.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Spring" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Spring/"/>
    
    
      <category term="Spring AOP" scheme="http://h2pl.github.io/tags/Spring-AOP/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码剖析6：Spring AOP概述</title>
    <link href="http://h2pl.github.io/2018/06/04/spring6/"/>
    <id>http://h2pl.github.io/2018/06/04/spring6/</id>
    <published>2018-06-04T14:28:55.000Z</published>
    <updated>2018-06-11T15:13:58.946Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Spring源码解析 <a href="https://blog.csdn.net/column/details/21851.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21851.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><p>原文出处： 五月的仓颉</p><h2 id="我们为什么要使用-AOP"><a href="#我们为什么要使用-AOP" class="headerlink" title="我们为什么要使用 AOP"></a>我们为什么要使用 AOP</h2><p>前言<br>一年半前写了一篇文章Spring3：AOP，是当时学习如何使用Spring AOP的时候写的，比较基础。这篇文章最后的推荐以及回复认为我写的对大家有帮助的评论有很多，但是现在从我个人的角度来看，这篇文章写得并不好，甚至可以说是没有太多实质性的内容，因此这些推荐和评论让我觉得受之有愧。</p><p>基于以上原因，更新一篇文章，从最基础的原始代码–&gt;使用设计模式（装饰器模式与代理）–&gt;使用AOP三个层次来讲解一下为什么我们要使用AOP，希望这篇文章可以对网友朋友们有益。</p><p>原始代码的写法<br>既然要通过代码来演示，那必须要有例子，这里我的例子为：</p><p>1<br>有一个接口Dao有insert、delete、update三个方法，在insert与update被调用的前后，打印调用前的毫秒数与调用后的毫秒数<br>首先定义一个Dao接口：</p><pre><code>/** * @author 五月的仓颉http://www.cnblogs.com/xrq730/p/7003082.html */public interface Dao {    public void insert();    public void delete();    public void update();}</code></pre><p>然后定义一个实现类DaoImpl：</p><pre><code>/** * @author 五月的仓颉http://www.cnblogs.com/xrq730/p/7003082.html */public class DaoImpl implements Dao {    @Override    public void insert() {        System.out.println(&quot;DaoImpl.insert()&quot;);    }    @Override    public void delete() {        System.out.println(&quot;DaoImpl.delete()&quot;);    }    @Override    public void update() {        System.out.println(&quot;DaoImpl.update()&quot;);    }}</code></pre><p>最原始的写法，我要在调用insert()与update()方法前后分别打印时间，就只能定义一个新的类包一层，在调用insert()方法与update()方法前后分别处理一下，新的类我命名为ServiceImpl，其实现为：</p><pre><code>/** * @author 五月的仓颉http://www.cnblogs.com/xrq730/p/7003082.html */public class ServiceImpl {    private Dao dao = new DaoImpl();    public void insert() {        System.out.println(&quot;insert()方法开始时间：&quot; + System.currentTimeMillis());        dao.insert();        System.out.println(&quot;insert()方法结束时间：&quot; + System.currentTimeMillis());    }    public void delete() {        dao.delete();    }    public void update() {        System.out.println(&quot;update()方法开始时间：&quot; + System.currentTimeMillis());        dao.update();        System.out.println(&quot;update()方法结束时间：&quot; + System.currentTimeMillis());    }}</code></pre><p>这是最原始的写法，这种写法的缺点也是一目了然：</p><p>方法调用前后输出时间的逻辑无法复用，如果有别的地方要增加这段逻辑就得再写一遍<br>如果Dao有其它实现类，那么必须新增一个类去包装该实现类，这将导致类数量不断膨胀<br>使用装饰器模式<br>接着我们使用上设计模式，先用装饰器模式，看看能解决多少问题。装饰器模式的核心就是实现Dao接口并持有Dao接口的引用，我将新增的类命名为LogDao，其实现为：</p><pre><code>/** * @author 五月的仓颉http://www.cnblogs.com/xrq730/p/7003082.html */public class LogDao implements Dao {    private Dao dao;    public LogDao(Dao dao) {        this.dao = dao;    }    @Override    public void insert() {        System.out.println(&quot;insert()方法开始时间：&quot; + System.currentTimeMillis());        dao.insert();        System.out.println(&quot;insert()方法结束时间：&quot; + System.currentTimeMillis());    }    @Override    public void delete() {        dao.delete();    }    @Override    public void update() {        System.out.println(&quot;update()方法开始时间：&quot; + System.currentTimeMillis());        dao.update();        System.out.println(&quot;update()方法结束时间：&quot; + System.currentTimeMillis());    }}</code></pre><p>在使用的时候，可以使用”Dao dao = new LogDao(new DaoImpl())”的方式，这种方式的优点为：</p><p>透明，对调用方来说，它只知道Dao，而不知道加上了日志功能<br>类不会无限膨胀，如果Dao的其它实现类需要输出日志，只需要向LogDao的构造函数中传入不同的Dao实现类即可<br>不过这种方式同样有明显的缺点，缺点为：</p><p>输出日志的逻辑还是无法复用<br>输出日志的逻辑与代码有耦合，如果我要对delete()方法前后同样输出时间，需要修改LogDao<br>但是，这种做法相比最原始的代码写法，已经有了很大的改进。</p><p>使用代理模式<br>接着我们使用代理模式尝试去实现最原始的功能，使用代理模式，那么我们就要定义一个InvocationHandler，我将它命名为LogInvocationHandler，其实现为：</p><pre><code>/** * @author 五月的仓颉http://www.cnblogs.com/xrq730/p/7003082.html */public class LogInvocationHandler implements InvocationHandler {    private Object obj;    public LogInvocationHandler(Object obj) {        this.obj = obj;    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        String methodName = method.getName();        if (&quot;insert&quot;.equals(methodName) || &quot;update&quot;.equals(methodName)) {            System.out.println(methodName + &quot;()方法开始时间：&quot; + System.currentTimeMillis());            Object result = method.invoke(obj, args);            System.out.println(methodName + &quot;()方法结束时间：&quot; + System.currentTimeMillis());            return result;        }        return method.invoke(obj, args);    }}</code></pre><p>其调用方式很简单，我写一个main函数：</p><pre><code>/** * @author 五月的仓颉http://www.cnblogs.com/xrq730/p/7003082.html */public static void main(String[] args) {    Dao dao = new DaoImpl();    Dao proxyDao = (Dao)Proxy.newProxyInstance(LogInvocationHandler.class.getClassLoader(), new Class&lt;?&gt;[]{Dao.class}, new LogInvocationHandler(dao));    proxyDao.insert();    System.out.println(&quot;----------分割线----------&quot;);    proxyDao.delete();    System.out.println(&quot;----------分割线----------&quot;);    proxyDao.update();}</code></pre><p>结果就不演示了，这种方式的优点为：</p><p>输出日志的逻辑被复用起来，如果要针对其他接口用上输出日志的逻辑，只要在newProxyInstance的时候的第二个参数增加Class&lt;?&gt;数组中的内容即可<br>这种方式的缺点为：</p><p>JDK提供的动态代理只能针对接口做代理，不能针对类做代理<br>代码依然有耦合，如果要对delete方法调用前后打印时间，得在LogInvocationHandler中增加delete方法的判断<br>使用CGLIB<br>接着看一下使用CGLIB的方式，使用CGLIB只需要实现MethodInterceptor接口即可：</p><pre><code>/** * @author 五月的仓颉http://www.cnblogs.com/xrq730/p/7003082.html */public class DaoProxy implements MethodInterceptor {    @Override    public Object intercept(Object object, Method method, Object[] objects, MethodProxy proxy) throws Throwable {        String methodName = method.getName();        if (&quot;insert&quot;.equals(methodName) || &quot;update&quot;.equals(methodName)) {            System.out.println(methodName + &quot;()方法开始时间：&quot; + System.currentTimeMillis());            proxy.invokeSuper(object, objects);            System.out.println(methodName + &quot;()方法结束时间：&quot; + System.currentTimeMillis());            return object;        }        proxy.invokeSuper(object, objects);        return object;    }}</code></pre><p>代码调用方式为：</p><pre><code>/** * @author 五月的仓颉http://www.cnblogs.com/xrq730/p/7003082.html */public static void main(String[] args) {    DaoProxy daoProxy = new DaoProxy();    Enhancer enhancer = new Enhancer();    enhancer.setSuperclass(DaoImpl.class);    enhancer.setCallback(daoProxy);    Dao dao = (DaoImpl)enhancer.create();    dao.insert();    System.out.println(&quot;----------分割线----------&quot;);    dao.delete();    System.out.println(&quot;----------分割线----------&quot;);    dao.update();}</code></pre><p>使用CGLIB解决了JDK的Proxy无法针对类做代理的问题，但是这里要专门说明一个问题：使用装饰器模式可以说是对使用原生代码的一种改进，使用Java代理可以说是对于使用装饰器模式的一种改进，但是使用CGLIB并不是对于使用Java代理的一种改进。</p><p>前面的可以说改进是因为使用装饰器模式比使用原生代码更好，使用Java代理又比使用装饰器模式更好，但是Java代理与CGLIb的对比并不能说改进，因为使用CGLIB并不一定比使用Java代理更好，这两种各有优缺点，像Spring框架就同时支持Java Proxy与CGLIB两种方式。</p><p>从目前看来代码又更好了一些，但是我认为还有两个缺点：</p><p>无论使用Java代理还是使用CGLIB，编写这部分代码都稍显麻烦<br>代码之间的耦合还是没有解决，像要针对delete()方法加上这部分逻辑就必须修改代码</p><h2 id="使用AOP"><a href="#使用AOP" class="headerlink" title="使用AOP"></a>使用AOP</h2><p>最后来看一下使用AOP的方式，首先定义一个时间处理类，我将它命名为TimeHandler：</p><pre><code>/** * @author 五月的仓颉http://www.cnblogs.com/xrq730/p/7003082.html */public class TimeHandler {    public void printTime(ProceedingJoinPoint pjp) {        Signature signature = pjp.getSignature();        if (signature instanceof MethodSignature) {            MethodSignature methodSignature = (MethodSignature)signature;            Method method = methodSignature.getMethod();            System.out.println(method.getName() + &quot;()方法开始时间：&quot; + System.currentTimeMillis());            try {                pjp.proceed();                System.out.println(method.getName() + &quot;()方法结束时间：&quot; + System.currentTimeMillis());            } catch (Throwable e) {            }        }    }}</code></pre><p>到第8行的代码与第12行的代码分别打印方法开始执行时间与方法结束执行时间。我这里写得稍微复杂点，使用了<a href="aop:around" target="_blank" rel="noopener">aop:around</a>的写法，其实也可以拆分为<a href="aop:before" target="_blank" rel="noopener">aop:before</a>与<a href="aop:after" target="_blank" rel="noopener">aop:after</a>两种，这个看个人喜好。</p><p>这里多说一句，切面方法printTime本身可以不用定义任何的参数，但是有些场景下需要获取调用方法的类、方法签名等信息，此时可以在printTime方法中定义JointPoint，Spring会自动将参数注入，可以通过JoinPoint获取调用方法的类、方法签名等信息。由于这里我用的<a href="aop:around" target="_blank" rel="noopener">aop:around</a>，要保证方法的调用，这样才能在方法调用前后输出时间，因此不能直接使用JoinPoint，因为JoinPoint没法保证方法调用。此时可以使用ProceedingJoinPoint，ProceedingPointPoint的proceed()方法可以保证方法调用，但是要注意一点，ProceedingJoinPoint只能和<a href="aop:around" target="_blank" rel="noopener">aop:around</a>搭配，换句话说，如果aop.xml中配置的是<a href="aop:before" target="_blank" rel="noopener">aop:before</a>，然后printTime的方法参数又是ProceedingJoinPoint的话，Spring容器启动将报错。</p><p>接着看一下aop.xml的配置：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-3.0.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-3.0.xsd&quot;&gt;    &lt;bean id=&quot;daoImpl&quot; class=&quot;org.xrq.spring.action.aop.DaoImpl&quot; /&gt;    &lt;bean id=&quot;timeHandler&quot; class=&quot;org.xrq.spring.action.aop.TimeHandler&quot; /&gt;    &lt;aop:config&gt;        &lt;aop:pointcut id=&quot;addAllMethod&quot; expression=&quot;execution(* org.xrq.spring.action.aop.Dao.*(..))&quot; /&gt;        &lt;aop:aspect id=&quot;time&quot; ref=&quot;timeHandler&quot;&gt;            &lt;aop:before method=&quot;printTime&quot; pointcut-ref=&quot;addAllMethod&quot; /&gt;            &lt;aop:after method=&quot;printTime&quot; pointcut-ref=&quot;addAllMethod&quot; /&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;&lt;/beans&gt;</code></pre><p>我不大会写expression，也懒得去百度了，因此这里就拦截Dao下的所有方法了。测试代码很简单：<br>    =<br>    /**</p><pre><code> * @author 五月的仓颉http://www.cnblogs.com/xrq730/p/7003082.html */public class AopTest {    @Test    @SuppressWarnings(&quot;resource&quot;)    public void testAop() {        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring/aop.xml&quot;);        Dao dao = (Dao)ac.getBean(&quot;daoImpl&quot;);        dao.insert();        System.out.println(&quot;----------分割线----------&quot;);        dao.delete();        System.out.println(&quot;----------分割线----------&quot;);        dao.update();    }}</code></pre><h2 id="AOP总结"><a href="#AOP总结" class="headerlink" title="AOP总结"></a>AOP总结</h2><p>结果就不演示了。到此我总结一下使用AOP的几个优点：</p><p>切面的内容可以复用，比如TimeHandler的printTime方法，任何地方需要打印方法执行前的时间与方法执行后的时间，都可以使用TimeHandler的printTime方法<br>避免使用Proxy、CGLIB生成代理，这方面的工作全部框架去实现，开发者可以专注于切面内容本身<br>代码与代码之间没有耦合，如果拦截的方法有变化修改配置文件即可<br>下面用一张图来表示一下AOP的作用：</p><p>我们传统的编程方式是垂直化的编程，即A–&gt;B–&gt;C–&gt;D这么下去，一个逻辑完毕之后执行另外一段逻辑。但是AOP提供了另外一种思路，它的作用是在业务逻辑不知情（即业务逻辑不需要做任何的改动）的情况下对业务代码的功能进行增强，这种编程思想的使用场景有很多，例如事务提交、方法执行之前的权限检测、日志打印、方法调用事件等等。</p><p>AOP使用场景举例<br>上面的例子纯粹为了演示使用，为了让大家更加理解AOP的作用，这里以实际场景作为例子。</p><p>第一个例子，我们知道MyBatis的事务默认是不会自动提交的，因此在编程的时候我们必须在增删改完毕之后调用SqlSession的commit()方法进行事务提交，这非常麻烦，下面利用AOP简单写一段代码帮助我们自动提交事务（这段代码我个人测试过可用）：</p><pre><code>/** * @author 五月的仓颉http://www.cnblogs.com/xrq730/p/7003082.html */public class TransactionHandler {    public void commit(JoinPoint jp) {        Object obj = jp.getTarget();        if (obj instanceof MailDao) {            Signature signature = jp.getSignature();            if (signature instanceof MethodSignature) {                SqlSession sqlSession = SqlSessionThrealLocalUtil.getSqlSession();                               MethodSignature methodSignature = (MethodSignature)signature;                Method method = methodSignature.getMethod();                String methodName = method.getName();                if (methodName.startsWith(&quot;insert&quot;) || methodName.startsWith(&quot;update&quot;) || methodName.startsWith(&quot;delete&quot;)) {                    sqlSession.commit();                }                sqlSession.close();            }        }    }}</code></pre><p>这种场景下我们要使用的aop标签为<a href="aop:after" target="_blank" rel="noopener">aop:after</a>，即切在方法调用之后。</p><p>这里我做了一个SqlSessionThreadLocalUtil，每次打开会话的时候，都通过SqlSessionThreadLocalUtil把当前会话SqlSession放到ThreadLocal中，看到通过TransactionHandler，可以实现两个功能：</p><p>insert、update、delete操作事务自动提交<br>对SqlSession进行close()，这样就不需要在业务代码里面关闭会话了，因为有些时候我们写业务代码的时候会忘记关闭SqlSession，这样可能会造成内存句柄的膨胀，因此这部分切面也一并做了<br>整个过程，业务代码是不知道的，而TransactionHandler的内容可以充分再多处场景下进行复用。</p><p>第二个例子是权限控制的例子，不管是从安全角度考虑还是从业务角度考虑，我们在开发一个Web系统的时候不可能所有请求都对所有用户开放，因此这里就需要做一层权限控制了，大家看AOP作用的时候想必也肯定会看到AOP可以做权限控制，这里我就演示一下如何使用AOP做权限控制。我们知道原生的Spring MVC，Java类是实现Controller接口的，基于此，利用AOP做权限控制的大致代码如下（这段代码纯粹就是一段示例，我构建的Maven工程是一个普通的Java工程，因此没有验证过）：</p><pre><code>/** * @author 五月的仓颉http://www.cnblogs.com/xrq730/p/7003082.html */public class PermissionHandler {    public void hasPermission(JoinPoint jp) throws Exception {        Object obj = jp.getTarget();        if (obj instanceof Controller) {            Signature signature = jp.getSignature();            MethodSignature methodSignature = (MethodSignature)signature;            // 获取方法签名            Method method = methodSignature.getMethod();            // 获取方法参数            Object[] args = jp.getArgs();            // Controller中唯一一个方法的方法签名ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception;            // 这里对这个方法做一层判断            if (&quot;handleRequest&quot;.equals(method.getName()) &amp;&amp; args.length == 2) {                Object firstArg = args[0];                if (obj instanceof HttpServletRequest) {                    HttpServletRequest request = (HttpServletRequest)firstArg;                    // 获取用户id                    long userId = Long.parseLong(request.getParameter(&quot;userId&quot;));                    // 获取当前请求路径                    String requestUri = request.getRequestURI();                    if(!PermissionUtil.hasPermission(userId, requestUri)) {                        throw new Exception(&quot;没有权限&quot;);                    }                }            }        }    }}</code></pre><p>毫无疑问这种场景下我们要使用的aop标签为<a href="aop:before" target="_blank" rel="noopener">aop:before</a>。这里我写得很简单，获取当前用户id与请求路径，根据这两者，判断该用户是否有权限访问该请求，大家明白意思即可。</p><p>后记<br>文章演示了从原生代码到使用AOP的过程，一点一点地介绍了每次演化的优缺点，最后以实际例子分析了AOP可以做什么事情。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Spring源码解析 &lt;a href=&quot;https://blog.csdn.net/column/details/21851.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21851.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Spring" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Spring/"/>
    
    
      <category term="Spring AOP" scheme="http://h2pl.github.io/tags/Spring-AOP/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码剖析5：JDK和cglib动态代理原理详解</title>
    <link href="http://h2pl.github.io/2018/06/03/spring5/"/>
    <id>http://h2pl.github.io/2018/06/03/spring5/</id>
    <published>2018-06-03T14:27:56.000Z</published>
    <updated>2018-06-11T15:11:15.091Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Spring源码解析 <a href="https://blog.csdn.net/column/details/21851.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21851.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><p> AOP的基础是Java动态代理，了解和使用两种动态代理能让我们更好地理解 AOP，在讲解AOP之前，让我们先来看看Java动态代理的使用方式以及底层实现原理。</p><p>转自<a href="https://www.jianshu.com/u/668d0795a95b" target="_blank" rel="noopener">https://www.jianshu.com/u/668d0795a95b</a></p><p>本文是基于jdk1.8来对动态代理的底层机制进行探究的</p><h2 id="Java代理介绍"><a href="#Java代理介绍" class="headerlink" title="Java代理介绍"></a>Java代理介绍</h2><p>Java中代理的实现一般分为三种：JDK静态代理、JDK动态代理以及CGLIB动态代理。在Spring的AOP实现中，主要应用了JDK动态代理以及CGLIB动态代理。但是本文着重介绍JDK动态代理机制，CGLIB动态代理后面会接着探究。</p><p>代理一般实现的模式为JDK静态代理：创建一个接口，然后创建被代理的类实现该接口并且实现该接口中的抽象方法。之后再创建一个代理类，同时使其也实现这个接口。在代理类中持有一个被代理对象的引用，而后在代理类方法中调用该对象的方法。</p><p>其实就是代理类为被代理类预处理消息、过滤消息并在此之后将消息转发给被代理类，之后还能进行消息的后置处理。代理类和被代理类通常会存在关联关系(即上面提到的持有的被带离对象的引用)，代理类本身不实现服务，而是通过调用被代理类中的方法来提供服务。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p><img src="https://upload-images.jianshu.io/upload_images/2993097-9826e2ca25024e2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/366" alt=""></p><p>接口</p><p><img src="https://upload-images.jianshu.io/upload_images/2993097-c8112c29db7622a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/487" alt=""></p><p>被代理类</p><p><img src="https://upload-images.jianshu.io/upload_images/2993097-d8f7025fa265aa77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/576" alt=""></p><p>代理类</p><p><img src="https://upload-images.jianshu.io/upload_images/2993097-8cc4c393a8d9186f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/490" alt=""></p><p>测试类以及输出结果</p><p>我们可以看出，使用JDK静态代理很容易就完成了对一个类的代理操作。但是JDK静态代理的缺点也暴露了出来：由于代理只能为一个类服务，如果需要代理的类很多，那么就需要编写大量的代理类，比较繁琐。</p><p>下面我们使用JDK动态代理来做同样的事情</p><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p><img src="https://upload-images.jianshu.io/upload_images/2993097-9826e2ca25024e2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/366" alt=""></p><p>接口</p><p><img src="https://upload-images.jianshu.io/upload_images/2993097-c8112c29db7622a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/487" alt=""></p><p>被代理类</p><p><img src="https://upload-images.jianshu.io/upload_images/2993097-23918ecb571b47d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p><p>代理类</p><p><img src="https://upload-images.jianshu.io/upload_images/2993097-0150b9b51f5b7765.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p><p>测试类以及输出结果</p><h3 id="JDK动态代理实现原理"><a href="#JDK动态代理实现原理" class="headerlink" title="JDK动态代理实现原理"></a>JDK动态代理实现原理</h3><p>JDK动态代理其实也是基本接口实现的。因为通过接口指向实现类实例的多态方式，可以有效地将具体实现与调用解耦，便于后期的修改和维护。</p><p>通过上面的介绍，我们可以发现JDK静态代理与JDK动态代理之间有些许相似，比如说都要创建代理类，以及代理类都要实现接口等。但是不同之处也非常明显—-在静态代理中我们需要对哪个接口和哪个被代理类创建代理类，所以我们在编译前就需要代理类实现与被代理类相同的接口，并且直接在实现的方法中调用被代理类相应的方法；但是动态代理则不同，我们不知道要针对哪个接口、哪个被代理类创建代理类，因为它是在运行时被创建的。</p><p>让我们用一句话来总结一下JDK静态代理和JDK动态代理的区别，然后开始探究JDK动态代理的底层实现机制：<br>JDK静态代理是通过直接编码创建的，而JDK动态代理是利用反射机制在运行时创建代理类的。<br>其实在动态代理中，核心是InvocationHandler。每一个代理的实例都会有一个关联的调用处理程序(InvocationHandler)。对待代理实例进行调用时，将对方法的调用进行编码并指派到它的调用处理器(InvocationHandler)的invoke方法。所以对代理对象实例方法的调用都是通过InvocationHandler中的invoke方法来完成的，而invoke方法会根据传入的代理对象、方法名称以及参数决定调用代理的哪个方法。</p><p>我们从JDK动态代理的测试类中可以发现代理类生成是通过Proxy类中的newProxyInstance来完成的，下面我们进入这个函数看一看：</p><h3 id="Proxy类中的newProxyInstance"><a href="#Proxy类中的newProxyInstance" class="headerlink" title="Proxy类中的newProxyInstance"></a>Proxy类中的newProxyInstance</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object newProxyInstance(ClassLoader loader,</span><br><span class="line">                                         <span class="keyword">Class</span>&lt;?&gt;[] interfaces,</span><br><span class="line">                                         InvocationHandler h)</span><br><span class="line">       <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//如果h为空将抛出异常</span></span><br><span class="line">       Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">Class</span>&lt;?&gt;[] intfs = interfaces.clone();<span class="comment">//拷贝被代理类实现的一些接口，用于后面权限方面的一些检查</span></span><br><span class="line">       <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">       <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//在这里对某些安全权限进行检查，确保我们有权限对预期的被代理类进行代理</span></span><br><span class="line">           checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 下面这个方法将产生代理类</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">Class</span>&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 使用指定的调用处理程序获取代理类的构造函数对象</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">               checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">           <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">           <span class="comment">//假如代理类的构造函数是private的，就使用反射来set accessible</span></span><br><span class="line">           <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">               AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;<span class="keyword">Void</span>&gt;() &#123;</span><br><span class="line">                   <span class="keyword">public</span> <span class="keyword">Void</span> run() &#123;</span><br><span class="line">                       cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//根据代理类的构造函数来生成代理类的对象并返回</span></span><br><span class="line">           <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">           Throwable t = e.getCause();</span><br><span class="line">           <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">               <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>所以代理类其实是通过getProxyClass方法来生成的：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 生成一个代理类，但是在调用本方法之前必须进行权限检查</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">Class</span>&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                          <span class="keyword">Class</span>&lt;?&gt;... interfaces) &#123;</span><br><span class="line">       <span class="comment">//如果接口数量大于65535，抛出非法参数错误</span></span><br><span class="line">       <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果在缓存中有对应的代理类，那么直接返回</span></span><br><span class="line">       <span class="comment">// 否则代理类将有 ProxyClassFactory 来创建</span></span><br><span class="line">       <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>那么ProxyClassFactory是什么呢？</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  里面有一个根据给定ClassLoader和Interface来创建代理类的工厂函数  </span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> ProxyClassFactory</span><br><span class="line">     <span class="keyword">implements</span> BiFunction&lt;ClassLoader, <span class="keyword">Class</span>&lt;?&gt;[], <span class="keyword">Class</span>&lt;?&gt;&gt;</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment">// 代理类的名字的前缀统一为“$Proxy”</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 每个代理类前缀后面都会跟着一个唯一的编号，如$Proxy0、$Proxy1、$Proxy2</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">Class</span>&lt;?&gt; apply(ClassLoader loader, <span class="keyword">Class</span>&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">         Map&lt;<span class="keyword">Class</span>&lt;?&gt;, <span class="keyword">Boolean</span>&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">Class</span>&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">              * 验证类加载器加载接口得到对象是否与由apply函数参数传入的对象相同</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">             <span class="keyword">Class</span>&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 interfaceClass = <span class="keyword">Class</span>.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                     intf + <span class="string">" is not visible from class loader"</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">              * 验证这个Class对象是不是接口</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">             <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                     interfaceClass.getName() + <span class="string">" is not an interface"</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">              * 验证这个接口是否重复</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">             <span class="keyword">if</span> (interfaceSet.put(interfaceClass, <span class="keyword">Boolean</span>.<span class="keyword">TRUE</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                     <span class="string">"repeated interface: "</span> + interfaceClass.getName());</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// 声明代理类所在的package</span></span><br><span class="line">         <span class="keyword">int</span> accessFlags = Modifier.<span class="keyword">PUBLIC</span> | Modifier.<span class="keyword">FINAL</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * 记录一个非公共代理接口的包，以便在同一个包中定义代理类。同时验证所有非公共</span></span><br><span class="line"><span class="comment">          * 代理接口都在同一个包中</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">Class</span>&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">             <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">             <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                 accessFlags = Modifier.<span class="keyword">FINAL</span>;</span><br><span class="line">                 String name = intf.getName();</span><br><span class="line">                 <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">                 String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">                 <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     proxyPkg = pkg;</span><br><span class="line">                 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                         <span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 如果全是公共代理接口，那么生成的代理类就在com.sun.proxy package下</span></span><br><span class="line">             proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">"."</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * 为代理类生成一个name  package name + 前缀+唯一编号</span></span><br><span class="line"><span class="comment">          * 如 com.sun.proxy.$Proxy0.class</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">         String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * 生成指定代理类的字节码文件</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">             proxyName, interfaces, accessFlags);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                                 proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">              * A ClassFormatError here means that (barring bugs in the</span></span><br><span class="line"><span class="comment">              * proxy class generation code) there was some other</span></span><br><span class="line"><span class="comment">              * invalid aspect of the arguments supplied to the proxy</span></span><br><span class="line"><span class="comment">              * class creation (such as virtual machine limitations</span></span><br><span class="line"><span class="comment">              * exceeded).</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h3><p>由上方代码byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);可以看到，其实生成代理类字节码文件的工作是通过 ProxyGenerate类中的generateProxyClass方法来完成的。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(final <span class="keyword">String</span> var0, Class&lt;?&gt;[] var1, <span class="keyword">int</span> var2) &#123;</span><br><span class="line">       ProxyGenerator var3 = <span class="keyword">new</span> ProxyGenerator(var0, var1, var2);</span><br><span class="line">      <span class="comment">// 真正用来生成代理类字节码文件的方法在这里</span></span><br><span class="line">       final <span class="keyword">byte</span>[] var4 = var3.generateClassFile();</span><br><span class="line">      <span class="comment">// 保存代理类的字节码文件</span></span><br><span class="line">       <span class="built_in">if</span>(saveGeneratedFiles) &#123;</span><br><span class="line">           AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction() &#123;</span><br><span class="line">               <span class="keyword">public</span> Void <span class="built_in">run</span>() &#123;</span><br><span class="line">                   <span class="built_in">try</span> &#123;</span><br><span class="line">                       <span class="keyword">int</span> var1 = var0.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">                       Path var2;</span><br><span class="line">                       <span class="built_in">if</span>(var1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                           Path var3 = Paths.<span class="built_in">get</span>(var0.substring(<span class="number">0</span>, var1).replace(<span class="string">'.'</span>, <span class="built_in">File</span>.separatorChar), </span><br><span class="line">                                                                                  <span class="keyword">new</span> <span class="keyword">String</span>[<span class="number">0</span>]);</span><br><span class="line">                           Files.createDirectories(var3, <span class="keyword">new</span> FileAttribute[<span class="number">0</span>]);</span><br><span class="line">                           var2 = var3.resolve(var0.substring(var1 + <span class="number">1</span>, var0.length()) + <span class="string">".class"</span>);</span><br><span class="line">                       &#125; <span class="built_in">else</span> &#123;</span><br><span class="line">                           var2 = Paths.<span class="built_in">get</span>(var0 + <span class="string">".class"</span>, <span class="keyword">new</span> <span class="keyword">String</span>[<span class="number">0</span>]);</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       Files.<span class="built_in">write</span>(var2, var4, <span class="keyword">new</span> OpenOption[<span class="number">0</span>]);</span><br><span class="line">                       <span class="built_in">return</span> null;</span><br><span class="line">                   &#125; <span class="built_in">catch</span> (IOException var4x) &#123;</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"I/O exception saving generated file: "</span> + var4x);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">return</span> var4;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>下面来看看真正用于生成代理类字节码文件的generateClassFile方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> byte[] generateClassFile() &#123;</span><br><span class="line">        <span class="comment">//下面一系列的addProxyMethod方法是将接口中的方法和Object中的方法添加到代理方法中(proxyMethod)</span></span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(hashCodeMethod, Object.<span class="keyword">class</span>);</span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(equalsMethod, Object.<span class="keyword">class</span>);</span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(toStringMethod, Object.<span class="keyword">class</span>);</span><br><span class="line">        Class[] var1 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">        int var2 = var1.length;</span><br><span class="line"></span><br><span class="line">        int var3;</span><br><span class="line">        Class var4;</span><br><span class="line">       <span class="comment">//获得接口中所有方法并添加到代理方法中</span></span><br><span class="line">        <span class="keyword">for</span>(var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">            var4 = var1[var3];</span><br><span class="line">            Method[] var5 = var4.getMethods();</span><br><span class="line">            int var6 = var5.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(int var7 = <span class="number">0</span>; var7 &lt; var6; ++var7) &#123;</span><br><span class="line">                Method var8 = var5[var7];</span><br><span class="line">                <span class="keyword">this</span>.addProxyMethod(var8, var4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator var11 = <span class="keyword">this</span>.proxyMethods.values().iterator();</span><br><span class="line">        <span class="comment">//验证具有相同方法签名的方法的返回类型是否一致</span></span><br><span class="line">        List var12;</span><br><span class="line">        <span class="keyword">while</span>(var11.hasNext()) &#123;</span><br><span class="line">            var12 = (List)var11.next();</span><br><span class="line">            checkReturnTypes(var12);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后面一系列的步骤用于写代理类Class文件</span></span><br><span class="line">        Iterator var15;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">//生成代理类的构造函数</span></span><br><span class="line">            <span class="keyword">this</span>.methods.add(<span class="keyword">this</span>.generateConstructor());</span><br><span class="line">            var11 = <span class="keyword">this</span>.proxyMethods.values().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var11.hasNext()) &#123;</span><br><span class="line">                var12 = (List)var11.next();</span><br><span class="line">                var15 = var12.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(var15.hasNext()) &#123;</span><br><span class="line">                    ProxyGenerator.ProxyMethod var16 = (ProxyGenerator.ProxyMethod)var15.next();</span><br><span class="line">                    <span class="comment">//将代理类字段声明为Method，并且字段修饰符为 private static.</span></span><br><span class="line">                   <span class="comment">//因为 10 是 ACC_PRIVATE和ACC_STATIC的与运算 故代理类的字段都是 private static Method ***</span></span><br><span class="line">                    <span class="keyword">this</span>.fields.add(new ProxyGenerator.FieldInfo(var16.methodFieldName, </span><br><span class="line">                                   <span class="string">"Ljava/lang/reflect/Method;"</span>, <span class="number">10</span>));</span><br><span class="line">                   <span class="comment">//生成代理类的方法</span></span><br><span class="line">                    <span class="keyword">this</span>.methods.add(var16.generateMethod());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">//为代理类生成静态代码块对某些字段进行初始化</span></span><br><span class="line">            <span class="keyword">this</span>.methods.add(<span class="keyword">this</span>.generateStaticInitializer());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new InternalError(<span class="string">"unexpected I/O Exception"</span>, var10);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.methods.size() &gt; <span class="string">'\uffff'</span>) &#123; <span class="comment">//代理类中的方法数量超过65535就抛异常</span></span><br><span class="line">            <span class="keyword">throw</span> new IllegalArgumentException(<span class="string">"method limit exceeded"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.fields.size() &gt; <span class="string">'\uffff'</span>) &#123;<span class="comment">// 代理类中字段数量超过65535也抛异常</span></span><br><span class="line">            <span class="keyword">throw</span> new IllegalArgumentException(<span class="string">"field limit exceeded"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 后面是对文件进行处理的过程</span></span><br><span class="line">            <span class="keyword">this</span>.cp.getClass(dotToSlash(<span class="keyword">this</span>.className));</span><br><span class="line">            <span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/reflect/Proxy"</span>);</span><br><span class="line">            var1 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">            var2 = var1.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">                var4 = var1[var3];</span><br><span class="line">                <span class="keyword">this</span>.cp.getClass(dotToSlash(var4.getName()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.cp.setReadOnly();</span><br><span class="line">            ByteArrayOutputStream var13 = new ByteArrayOutputStream();</span><br><span class="line">            DataOutputStream var14 = new DataOutputStream(var13);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                var14.writeInt(<span class="number">-889275714</span>);</span><br><span class="line">                var14.writeShort(<span class="number">0</span>);</span><br><span class="line">                var14.writeShort(<span class="number">49</span>);</span><br><span class="line">                <span class="keyword">this</span>.cp.write(var14);</span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.accessFlags);</span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.cp.getClass(dotToSlash(<span class="keyword">this</span>.className)));</span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/reflect/Proxy"</span>));</span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.interfaces.length);</span><br><span class="line">                Class[] var17 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">                int var18 = var17.length;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(int var19 = <span class="number">0</span>; var19 &lt; var18; ++var19) &#123;</span><br><span class="line">                    Class var22 = var17[var19];</span><br><span class="line">                    var14.writeShort(<span class="keyword">this</span>.cp.getClass(dotToSlash(var22.getName())));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.fields.size());</span><br><span class="line">                var15 = <span class="keyword">this</span>.fields.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(var15.hasNext()) &#123;</span><br><span class="line">                    ProxyGenerator.FieldInfo var20 = (ProxyGenerator.FieldInfo)var15.next();</span><br><span class="line">                    var20.write(var14);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.methods.size());</span><br><span class="line">                var15 = <span class="keyword">this</span>.methods.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(var15.hasNext()) &#123;</span><br><span class="line">                    ProxyGenerator.MethodInfo var21 = (ProxyGenerator.MethodInfo)var15.next();</span><br><span class="line">                    var21.write(var14);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var14.writeShort(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> var13.toByteArray();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">                <span class="keyword">throw</span> new InternalError(<span class="string">"unexpected I/O Exception"</span>, var9);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="代理类的方法调用"><a href="#代理类的方法调用" class="headerlink" title="代理类的方法调用"></a>代理类的方法调用</h2><p>下面是将接口与Object中一些方法添加到代理类中的addProxyMethod方法：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> addProxyMethod(Method var1, <span class="keyword">Class</span>&lt;?&gt; var2) &#123;</span><br><span class="line">        String var3 = var1.getName();<span class="comment">//获得方法名称</span></span><br><span class="line">        <span class="keyword">Class</span>[] var4 = var1.getParameterTypes();<span class="comment">//获得方法参数类型</span></span><br><span class="line">        <span class="keyword">Class</span> var5 = var1.getReturnType();<span class="comment">//获得方法返回类型</span></span><br><span class="line">        <span class="keyword">Class</span>[] var6 = var1.getExceptionTypes();<span class="comment">//异常类型</span></span><br><span class="line">        String var7 = var3 + getParameterDescriptors(var4);<span class="comment">//获得方法签名</span></span><br><span class="line">        Object var8 = (List)<span class="keyword">this</span>.proxyMethods.get(var7);<span class="comment">//根据方法前面获得proxyMethod的value</span></span><br><span class="line">        <span class="keyword">if</span>(var8 != <span class="keyword">null</span>) &#123;<span class="comment">//处理多个代理接口中方法重复的情况</span></span><br><span class="line">            Iterator var9 = ((List)var8).iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var9.hasNext()) &#123;</span><br><span class="line">                ProxyGenerator.ProxyMethod var10 = (ProxyGenerator.ProxyMethod)var9.<span class="keyword">next</span>();</span><br><span class="line">                <span class="keyword">if</span>(var5 == var10.returnType) &#123;</span><br><span class="line">                    ArrayList var11 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">                    collectCompatibleTypes(var6, var10.exceptionTypes, var11);</span><br><span class="line">                    collectCompatibleTypes(var10.exceptionTypes, var6, var11);</span><br><span class="line">                    var10.exceptionTypes = <span class="keyword">new</span> <span class="keyword">Class</span>[var11.<span class="keyword">size</span>()];</span><br><span class="line">                    var10.exceptionTypes = (<span class="keyword">Class</span>[])var11.toArray(var10.exceptionTypes);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            var8 = <span class="keyword">new</span> ArrayList(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">this</span>.proxyMethods.put(var7, var8);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ((List)var8).add(<span class="keyword">new</span> ProxyGenerator.ProxyMethod(var3, var4, var5, var6, var2, <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这就是最终真正的代理类，它继承自Proxy并实现了我们定义的Subject接口。我们通过</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">HelloInterface helloInterface</span> = (HelloInterface ) Proxy.newProxyInstance(loader, interfaces, handler);</span><br></pre></td></tr></table></figure><ul><li>1</li></ul><p>得到的最终代理类对象就是上面这个类的实例。那么我们执行如下语句：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helloInterface.hello(<span class="string">"Tom"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><ul><li>1</li></ul><p>实际上就是执行上面类的相应方法，也就是：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> hello(<span class="keyword">String</span> paramString)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">try</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> <span class="keyword">Object</span>[] &#123; paramString &#125;);</span><br><span class="line">     <span class="comment">//就是调用我们自定义的InvocationHandlerImpl的 invoke方法：</span></span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Error|RuntimeException localError)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">throw</span> localError;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable localThrowable)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(localThrowable);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注意这里的<code>this.h.invoke</code>中的h，它是类Proxy中的一个属性</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected InvocationHandler h<span class="comment">;</span></span><br></pre></td></tr></table></figure><ul><li></li></ul><p>因为这个代理类继承了Proxy，所以也就继承了这个属性，而这个属性值就是我们定义的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InvocationHandler <span class="keyword">handler</span> = <span class="keyword">new</span> InvocationHandlerImpl(hello);</span><br></pre></td></tr></table></figure><ul><li>1</li></ul><p>同时我们还发现，invoke方法的第一参数在底层调用的时候传入的是<code>this</code>，也就是最终生成的代理对象ProxySubject，这是JVM自己动态生成的，而不是我们自己定义的代理对象。</p><h2 id="深入理解CGLIB动态代理机制"><a href="#深入理解CGLIB动态代理机制" class="headerlink" title="深入理解CGLIB动态代理机制"></a>深入理解CGLIB动态代理机制</h2><p>Cglib是什么</p><p>Cglib是一个强大的、高性能的代码生成包，它广泛被许多AOP框架使用，为他们提供方法的拦截。下图是我网上找到的一张Cglib与一些框架和语言的关系：</p><p><img src="https://images2015.cnblogs.com/blog/801753/201704/801753-20170403122105941-1116862243.gif" alt=""></p><p>对此图总结一下：</p><ul><li>最底层的是字节码Bytecode，字节码是Java为了保证“一次编译、到处运行”而产生的一种虚拟指令格式，例如iload_0、iconst_1、if_icmpne、dup等</li><li>位于字节码之上的是ASM，这是一种直接操作字节码的框架，应用ASM需要对Java字节码、Class结构比较熟悉</li><li>位于ASM之上的是CGLIB、Groovy、BeanShell，后两种并不是Java体系中的内容而是脚本语言，它们通过ASM框架生成字节码变相执行Java代码，这说明在JVM中执行程序并不一定非要写Java代码—-只要你能生成Java字节码，JVM并不关心字节码的来源，当然通过Java代码生成的JVM字节码是通过编译器直接生成的，算是最“正统”的JVM字节码</li><li>位于CGLIB、Groovy、BeanShell之上的就是Hibernate、Spring AOP这些框架了，这一层大家都比较熟悉</li><li>最上层的是Applications，即具体应用，一般都是一个Web项目或者本地跑一个程序</li></ul><p>本文是基于CGLIB 3.1进行探究的</p><p>cglib is a powerful, high performance and quality Code Generation Library, It is used to extend JAVA classes and implements interfaces at runtime.</p><p>在Spring AOP中，通常会用它来生成AopProxy对象。不仅如此，在Hibernate中PO(Persistant Object 持久化对象)字节码的生成工作也要靠它来完成。</p><p>本文将深入探究CGLIB动态代理的实现机制，配合下面这篇文章一起食用口味更佳：<br><a href="https://www.jianshu.com/p/471c80a7e831" target="_blank" rel="noopener">深入理解JDK动态代理机制</a></p><h3 id="CGLIB动态代理示例"><a href="#CGLIB动态代理示例" class="headerlink" title="CGLIB动态代理示例"></a>CGLIB动态代理示例</h3><p>下面由一个简单的示例开始我们对CGLIB动态代理的介绍：</p><p><img src="https://upload-images.jianshu.io/upload_images/2993097-c6dbc3fc93c3fa92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/360" alt=""></p><p>为了后续编码的顺利进行，我们需要使用Maven引入CGLIB的包</p><p><img src="https://upload-images.jianshu.io/upload_images/2993097-69719960eabd4f12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/481" alt=""></p><p>图1.1 被代理类</p><p><img src="https://upload-images.jianshu.io/upload_images/2993097-37963fd134822383.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p><p>图1.2 实现MethodInterceptor接口生成方法拦截器</p><p><img src="https://upload-images.jianshu.io/upload_images/2993097-50f7fd91f5fad172.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p><p>图1.3 生成代理类对象并打印在代理类对象调用方法之后的执行结果</p><p>JDK代理要求被代理的类必须实现接口，有很强的局限性。而CGLIB动态代理则没有此类强制性要求。简单的说，CGLIB会让生成的代理类继承被代理类，并在代理类中对代理方法进行强化处理(前置处理、后置处理等)。在CGLIB底层，其实是借助了ASM这个非常强大的Java字节码生成框架。</p><h3 id="生成代理类对象"><a href="#生成代理类对象" class="headerlink" title="生成代理类对象"></a>生成代理类对象</h3><p>从图1.3中我们看到，代理类对象是由Enhancer类创建的。Enhancer是CGLIB的字节码增强器，可以很方便的对类进行拓展，如图1.3中的为类设置Superclass。</p><p>创建代理对象的几个步骤:</p><ul><li>生成代理类的二进制字节码文件；</li><li>加载二进制字节码，生成Class对象( 例如使用Class.forName()方法 )；</li><li>通过反射机制获得实例构造，并创建代理类对象</li></ul><p>我们来看看将代理类Class文件反编译之后的Java代码</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line">package proxy<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method<span class="comment">;</span></span><br><span class="line">import net.sf.cglib.core.ReflectUtils<span class="comment">;</span></span><br><span class="line">import net.sf.cglib.core.Signature<span class="comment">;</span></span><br><span class="line">import net.sf.cglib.proxy.Callback<span class="comment">;</span></span><br><span class="line">import net.sf.cglib.proxy.Factory<span class="comment">;</span></span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor<span class="comment">;</span></span><br><span class="line">import net.sf.cglib.proxy.MethodProxy<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">public class HelloServiceImpl$EnhancerByCGLIB$82ef2d06</span><br><span class="line">  extends HelloServiceImpl</span><br><span class="line">  implements Factory</span><br><span class="line">&#123;</span><br><span class="line">  private boolean CGLIB$BOUND<span class="comment">;</span></span><br><span class="line">  private <span class="keyword">static</span> final ThreadLocal CGLIB$THREAD_CALLBACKS<span class="comment">;</span></span><br><span class="line">  private <span class="keyword">static</span> final Callback[] CGLIB$STATIC_CALLBACKS<span class="comment">;</span></span><br><span class="line">  private MethodInterceptor CGLIB$CALLBACK_0<span class="comment">;</span></span><br><span class="line">  private <span class="keyword">static</span> final Method CGLIB$sayHello$0$Method<span class="comment">;</span></span><br><span class="line">  private <span class="keyword">static</span> final MethodProxy CGLIB$sayHello$0$Proxy<span class="comment">;</span></span><br><span class="line">  private <span class="keyword">static</span> final Object[] CGLIB$emptyArgs<span class="comment">;</span></span><br><span class="line">  private <span class="keyword">static</span> final Method CGLIB$finalize$1$Method<span class="comment">;</span></span><br><span class="line">  private <span class="keyword">static</span> final MethodProxy CGLIB$finalize$1$Proxy<span class="comment">;</span></span><br><span class="line">  private <span class="keyword">static</span> final Method CGLIB$equals$2$Method<span class="comment">;</span></span><br><span class="line">  private <span class="keyword">static</span> final MethodProxy CGLIB$equals$2$Proxy<span class="comment">;</span></span><br><span class="line">  private <span class="keyword">static</span> final Method CGLIB$toString$3$Method<span class="comment">;</span></span><br><span class="line">  private <span class="keyword">static</span> final MethodProxy CGLIB$toString$3$Proxy<span class="comment">;</span></span><br><span class="line">  private <span class="keyword">static</span> final Method CGLIB$hashCode$4$Method<span class="comment">;</span></span><br><span class="line">  private <span class="keyword">static</span> final MethodProxy CGLIB$hashCode$4$Proxy<span class="comment">;</span></span><br><span class="line">  private <span class="keyword">static</span> final Method CGLIB$clone$5$Method<span class="comment">;</span></span><br><span class="line">  private <span class="keyword">static</span> final MethodProxy CGLIB$clone$5$Proxy<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> void CGLIB$STATICHOOK1()</span><br><span class="line">  &#123;</span><br><span class="line">    CGLIB$THREAD_CALLBACKS = new ThreadLocal()<span class="comment">;</span></span><br><span class="line">    CGLIB$emptyArgs = new Object[<span class="number">0</span>]<span class="comment">;</span></span><br><span class="line">    Class localClass1 = Class.forName(<span class="string">"proxy.HelloServiceImpl$EnhancerByCGLIB$82ef2d06"</span>)<span class="comment">;</span></span><br><span class="line">    Class localClass2<span class="comment">;</span></span><br><span class="line">    Method[] tmp95_92 = ReflectUtils.findMethods(new <span class="built_in">String</span>[] &#123; <span class="string">"finalize"</span>, <span class="string">"()V"</span>, <span class="string">"equals"</span>, <span class="string">"(Ljava/lang/Object;)Z"</span>, <span class="string">"toString"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="string">"hashCode"</span>, <span class="string">"()I"</span>, <span class="string">"clone"</span>, <span class="string">"()Ljava/lang/Object;"</span> &#125;, (localClass2 = Class.forName(<span class="string">"java.lang.Object"</span>)).getDeclaredMethods())<span class="comment">;</span></span><br><span class="line">    CGLIB$finalize$1$Method = tmp95_92[<span class="number">0</span>]<span class="comment">;</span></span><br><span class="line">    CGLIB$finalize$1$Proxy = MethodProxy.create(localClass2, localClass1, <span class="string">"()V"</span>, <span class="string">"finalize"</span>, <span class="string">"CGLIB$finalize$1"</span>)<span class="comment">;</span></span><br><span class="line">    Method[] tmp115_95 = tmp95_92<span class="comment">;</span></span><br><span class="line">    CGLIB$equals$2$Method = tmp115_95[<span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">    CGLIB$equals$2$Proxy = MethodProxy.create(localClass2, localClass1, <span class="string">"(Ljava/lang/Object;)Z"</span>, <span class="string">"equals"</span>, <span class="string">"CGLIB$equals$2"</span>)<span class="comment">;</span></span><br><span class="line">    Method[] tmp135_115 = tmp115_95<span class="comment">;</span></span><br><span class="line">    CGLIB$toString$3$Method = tmp135_115[<span class="number">2</span>]<span class="comment">;</span></span><br><span class="line">    CGLIB$toString$3$Proxy = MethodProxy.create(localClass2, localClass1, <span class="string">"()Ljava/lang/String;"</span>, <span class="string">"toString"</span>, <span class="string">"CGLIB$toString$3"</span>)<span class="comment">;</span></span><br><span class="line">    Method[] tmp155_135 = tmp135_115<span class="comment">;</span></span><br><span class="line">    CGLIB$hashCode$4$Method = tmp155_135[<span class="number">3</span>]<span class="comment">;</span></span><br><span class="line">    CGLIB$hashCode$4$Proxy = MethodProxy.create(localClass2, localClass1, <span class="string">"()I"</span>, <span class="string">"hashCode"</span>, <span class="string">"CGLIB$hashCode$4"</span>)<span class="comment">;</span></span><br><span class="line">    Method[] tmp175_155 = tmp155_135<span class="comment">;</span></span><br><span class="line">    CGLIB$clone$5$Method = tmp175_155[<span class="number">4</span>]<span class="comment">;</span></span><br><span class="line">    CGLIB$clone$5$Proxy = MethodProxy.create(localClass2, localClass1, <span class="string">"()Ljava/lang/Object;"</span>, <span class="string">"clone"</span>, <span class="string">"CGLIB$clone$5"</span>)<span class="comment">;</span></span><br><span class="line">    tmp175_155<span class="comment">;</span></span><br><span class="line">    Method[] tmp223_220 = ReflectUtils.findMethods(new <span class="built_in">String</span>[] &#123; <span class="string">"sayHello"</span>, <span class="string">"()V"</span> &#125;, (localClass2 = Class.forName(<span class="string">"proxy.HelloServiceImpl"</span>)).getDeclaredMethods())<span class="comment">;</span></span><br><span class="line">    CGLIB$sayHello$0$Method = tmp223_220[<span class="number">0</span>]<span class="comment">;</span></span><br><span class="line">    CGLIB$sayHello$0$Proxy = MethodProxy.create(localClass2, localClass1, <span class="string">"()V"</span>, <span class="string">"sayHello"</span>, <span class="string">"CGLIB$sayHello$0"</span>)<span class="comment">;</span></span><br><span class="line">    tmp223_220<span class="comment">;</span></span><br><span class="line">    <span class="keyword">return</span><span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  final void CGLIB$sayHello$0()</span><br><span class="line">  &#123;</span><br><span class="line">    super.sayHello()<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final void sayHello()</span><br><span class="line">  &#123;</span><br><span class="line">    MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0<span class="comment">;</span></span><br><span class="line">    <span class="keyword">if</span> (tmp4_1 == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      tmp4_1<span class="comment">;</span></span><br><span class="line">      CGLIB$BIND_CALLBACKS(this)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (this.CGLIB$CALLBACK_0 != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    super.sayHello()<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  final void CGLIB$finalize$1()</span><br><span class="line">    throws Throwable</span><br><span class="line">  &#123;</span><br><span class="line">    super.finalize()<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected final void finalize()</span><br><span class="line">    throws Throwable</span><br><span class="line">  &#123;</span><br><span class="line">    MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0<span class="comment">;</span></span><br><span class="line">    <span class="keyword">if</span> (tmp4_1 == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      tmp4_1<span class="comment">;</span></span><br><span class="line">      CGLIB$BIND_CALLBACKS(this)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (this.CGLIB$CALLBACK_0 != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    super.finalize()<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  final boolean CGLIB$equals$2(Object paramObject)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> super.equals(paramObject)<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final boolean equals(Object paramObject)</span><br><span class="line">  &#123;</span><br><span class="line">    MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0<span class="comment">;</span></span><br><span class="line">    <span class="keyword">if</span> (tmp4_1 == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      tmp4_1<span class="comment">;</span></span><br><span class="line">      CGLIB$BIND_CALLBACKS(this)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    MethodInterceptor tmp17_14 = this.CGLIB$CALLBACK_0<span class="comment">;</span></span><br><span class="line">    <span class="keyword">if</span> (tmp17_14 != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      Object tmp41_36 = tmp17_14.intercept(this, CGLIB$equals$2$Method, new Object[] &#123; paramObject &#125;, CGLIB$equals$2$Proxy)<span class="comment">;</span></span><br><span class="line">      tmp41_36<span class="comment">;</span></span><br><span class="line">      <span class="keyword">return</span> tmp41_36 == <span class="literal">null</span> ? <span class="literal">false</span> : ((Boolean)tmp41_36).booleanValue()<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> super.equals(paramObject)<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  final <span class="built_in">String</span> CGLIB$toString$3()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> super.toString()<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final <span class="built_in">String</span> toString()</span><br><span class="line">  &#123;</span><br><span class="line">    MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0<span class="comment">;</span></span><br><span class="line">    <span class="keyword">if</span> (tmp4_1 == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      tmp4_1<span class="comment">;</span></span><br><span class="line">      CGLIB$BIND_CALLBACKS(this)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    MethodInterceptor tmp17_14 = this.CGLIB$CALLBACK_0<span class="comment">;</span></span><br><span class="line">    <span class="keyword">if</span> (tmp17_14 != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="built_in">String</span>)tmp17_14.intercept(this, CGLIB$toString$3$Method, CGLIB$emptyArgs, CGLIB$toString$3$Proxy)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> super.toString()<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  final <span class="built_in">int</span> CGLIB$hashCode$4()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> super.hashCode()<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final <span class="built_in">int</span> hashCode()</span><br><span class="line">  &#123;</span><br><span class="line">    MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0<span class="comment">;</span></span><br><span class="line">    <span class="keyword">if</span> (tmp4_1 == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      tmp4_1<span class="comment">;</span></span><br><span class="line">      CGLIB$BIND_CALLBACKS(this)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    MethodInterceptor tmp17_14 = this.CGLIB$CALLBACK_0<span class="comment">;</span></span><br><span class="line">    <span class="keyword">if</span> (tmp17_14 != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      Object tmp36_31 = tmp17_14.intercept(this, CGLIB$hashCode$4$Method, CGLIB$emptyArgs, CGLIB$hashCode$4$Proxy)<span class="comment">;</span></span><br><span class="line">      tmp36_31<span class="comment">;</span></span><br><span class="line">      <span class="keyword">return</span> tmp36_31 == <span class="literal">null</span> ? <span class="number">0</span> : ((<span class="built_in">Number</span>)tmp36_31).intValue()<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> super.hashCode()<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  final Object CGLIB$clone$5()</span><br><span class="line">    throws CloneNotSupportedException</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> super.clone()<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected final Object clone()</span><br><span class="line">    throws CloneNotSupportedException</span><br><span class="line">  &#123;</span><br><span class="line">    MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0<span class="comment">;</span></span><br><span class="line">    <span class="keyword">if</span> (tmp4_1 == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      tmp4_1<span class="comment">;</span></span><br><span class="line">      CGLIB$BIND_CALLBACKS(this)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    MethodInterceptor tmp17_14 = this.CGLIB$CALLBACK_0<span class="comment">;</span></span><br><span class="line">    <span class="keyword">if</span> (tmp17_14 != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> tmp17_14.intercept(this, CGLIB$clone$5$Method, CGLIB$emptyArgs, CGLIB$clone$5$Proxy)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> super.clone()<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">static</span> MethodProxy CGLIB$findMethodProxy(Signature paramSignature)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">String</span> tmp4_1 = paramSignature.toString()<span class="comment">;</span></span><br><span class="line">    <span class="keyword">switch</span> (tmp4_1.hashCode())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1574182249</span>: </span><br><span class="line">      <span class="keyword">if</span> (tmp4_1.equals(<span class="string">"finalize()V"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> CGLIB$finalize$1$Proxy<span class="comment">;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">break</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public HelloServiceImpl$EnhancerByCGLIB$82ef2d06()</span><br><span class="line">  &#123;</span><br><span class="line">    CGLIB$BIND_CALLBACKS(this)<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">static</span> void CGLIB$SET_THREAD_CALLBACKS(Callback[] paramArrayOfCallback)</span><br><span class="line">  &#123;</span><br><span class="line">    CGLIB$THREAD_CALLBACKS.set(paramArrayOfCallback)<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">static</span> void CGLIB$SET_STATIC_CALLBACKS(Callback[] paramArrayOfCallback)</span><br><span class="line">  &#123;</span><br><span class="line">    CGLIB$STATIC_CALLBACKS = paramArrayOfCallback<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private <span class="keyword">static</span> final void CGLIB$BIND_CALLBACKS(Object paramObject)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="number">82</span>ef2d06 local82ef2d06 = (<span class="number">82</span>ef2d06)paramObject<span class="comment">;</span></span><br><span class="line">    <span class="keyword">if</span> (!local82ef2d06.CGLIB$BOUND)</span><br><span class="line">    &#123;</span><br><span class="line">      local82ef2d06.CGLIB$BOUND = <span class="literal">true</span><span class="comment">;</span></span><br><span class="line">      Object tmp23_20 = CGLIB$THREAD_CALLBACKS.get()<span class="comment">;</span></span><br><span class="line">      <span class="keyword">if</span> (tmp23_20 == <span class="literal">null</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        tmp23_20<span class="comment">;</span></span><br><span class="line">        CGLIB$STATIC_CALLBACKS<span class="comment">;</span></span><br><span class="line">      &#125;</span><br><span class="line">      local82ef2d06.CGLIB$CALLBACK_0 = (// INTERNAL ERROR //</span><br></pre></td></tr></table></figure><h3 id="对委托类进行代理"><a href="#对委托类进行代理" class="headerlink" title="对委托类进行代理"></a>对委托类进行代理</h3><p>我们上面贴出了生成的代理类源码。以我们上面的例子为参考，下面我们总结一下CGLIB在进行代理的时候都进行了哪些工作呢</p><ul><li>生成的代理类HelloServiceImpl$EnhancerByCGLIB$82ef2d06继承被代理类HelloServiceImpl。在这里我们需要注意一点：如果委托类被final修饰，那么它不可被继承，即不可被代理；同样，如果委托类中存在final修饰的方法，那么该方法也不可被代理；</li><li>代理类会为委托方法生成两个方法，一个是重写的sayHello方法，另一个是CGLIB$sayHello$0方法，我们可以看到它是直接调用父类的sayHello方法；</li><li>当执行代理对象的sayHello方法时，会首先判断一下是否存在实现了MethodInterceptor接口的CGLIB$CALLBACK_0;，如果存在，则将调用MethodInterceptor中的intercept方法，如图2.1。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2993097-ddda6ee7551e9c36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p><p>图2.1 intercept方法</p><p><img src="https://upload-images.jianshu.io/upload_images/2993097-1a37bc027b32be3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/372" alt=""></p><p>图2.2 代理类为每个委托方法都会生成两个方法</p><p>在intercept方法中，我们除了会调用委托方法，还会进行一些增强操作。在Spring AOP中，典型的应用场景就是在某些敏感方法执行前后进行操作日志记录。</p><p>我们从图2.1中看到，调用委托方法是通过代理方法的MethodProxy对象调用invokeSuper方法来执行的，下面我们看看invokeSuper方法中的玄机：</p><p><img src="https://upload-images.jianshu.io/upload_images/2993097-5ba5ef2af44dc243.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p><p>图2.3 invokeSuper方法</p><p>在这里好像不能直接看出代理方法的调用。没关系，我会慢慢介绍。<br>我们知道，在JDK动态代理中方法的调用是通过反射来完成的。如果有对此不太了解的同学，可以看下我之前的博客—-<a href="https://www.jianshu.com/p/471c80a7e831" target="_blank" rel="noopener">深入理解JDK动态代理机制</a>。但是在CGLIB中，方法的调用并不是通过反射来完成的，而是直接对方法进行调用：FastClass对Class对象进行特别的处理，比如将会用数组保存method的引用，每次调用方法的时候都是通过一个index下标来保持对方法的引用。比如下面的getIndex方法就是通过方法签名来获得方法在存储了Class信息的数组中的下标。</p><p><img src="https://upload-images.jianshu.io/upload_images/2993097-b91561abbbc419d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p><p>图2.4 getIndex方法</p><p><img src="https://upload-images.jianshu.io/upload_images/2993097-0c390706e9ae20af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/377" alt=""></p><p>图2.5 FastClassInfo类中持有两个FastClass对象的引用.png</p><p>以我们上面的sayHello方法为例，f1指向委托类对象，f2指向代理类对象，i1和i2分别代表着sayHello方法以及CGLIB$sayHello$0方法在对象信息数组中的下标。</p><p>到此为止CGLIB动态代理机制就介绍完了，下面给出三种代理方式之间对比。</p><table><thead><tr><th>代理方式</th><th>实现</th><th>优点</th><th>缺点</th><th>特点</th></tr></thead><tbody><tr><td>JDK静态代理</td><td>代理类与委托类实现同一接口，并且在代理类中需要硬编码接口</td><td>实现简单，容易理解</td><td>代理类需要硬编码接口，在实际应用中可能会导致重复编码，浪费存储空间并且效率很低</td><td>好像没啥特点</td></tr><tr><td>JDK动态代理</td><td>代理类与委托类实现同一接口，主要是通过代理类实现InvocationHandler并重写invoke方法来进行动态代理的，在invoke方法中将对方法进行增强处理</td><td>不需要硬编码接口，代码复用率高</td><td>只能够代理实现了接口的委托类</td><td>底层使用反射机制进行方法的调用</td></tr><tr><td>CGLIB动态代理</td><td>代理类将委托类作为自己的父类并为其中的非final委托方法创建两个方法，一个是与委托方法签名相同的方法，它在方法中会通过super调用委托方法；另一个是代理类独有的方法。在代理方法中，它会判断是否存在实现了MethodInterceptor接口的对象，若存在则将调用intercept方法对委托方法进行代理</td><td>可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口</td><td>不能对final类以及final方法进行代理</td><td>底层将方法全部存入一个数组中，通过数组索引直接进行方法调用</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Spring源码解析 &lt;a href=&quot;https://blog.csdn.net/column/details/21851.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21851.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Spring" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Spring/"/>
    
    
      <category term="Spring" scheme="http://h2pl.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码剖析4：其余方式获取Bean的过程分析</title>
    <link href="http://h2pl.github.io/2018/06/03/spring4/"/>
    <id>http://h2pl.github.io/2018/06/03/spring4/</id>
    <published>2018-06-03T14:27:54.000Z</published>
    <updated>2018-06-11T15:05:30.826Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Spring源码解析 <a href="https://blog.csdn.net/column/details/21851.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21851.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><h2 id="原型Bean加载过程"><a href="#原型Bean加载过程" class="headerlink" title="原型Bean加载过程"></a>原型Bean加载过程</h2><p>之前的文章，分析了非懒加载的单例Bean整个加载过程，除了非懒加载的单例Bean之外，Spring中还有一种Bean就是原型（Prototype）的Bean，看一下定义方式：</p><pre>1 <?xml version="1.0" encoding="UTF-8"?>2 <beans 3="" 4="" xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://www.springframework.org/schema/beans 5     http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">6 7     <bean id="prototypeBean" class="org.xrq.action.PrototypeBean" scope="prototype">8     9 </bean></beans></pre><p>原型Bean加载流程总得来说和单例Bean差不多，看一下不同之处，在AbstractBeanFactory的doGetBean的方法的这一步：</p><pre> 1 else if (mbd.isPrototype()) { 2     // It's a prototype -> create a new instance. 3     Object prototypeInstance = null; 4     try { 5         beforePrototypeCreation(beanName); 6         prototypeInstance = createBean(beanName, mbd, args); 7     } 8     finally { 9 afterPrototypeCreation(beanName); 10 } 11     bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); 12 }</pre><p>第6行createBean是一样的，原型Bean实例化的主要区别就在于第6行，它是直接创建bean的，而单例bean我们再对比一下：</p><pre> 1 if (mbd.isSingleton()) { 2     sharedInstance = getSingleton(beanName, new ObjectFactory() { 3         public Object getObject() throws BeansException { 4             try { 5                 return createBean(beanName, mbd, args); 6             } 7             catch (BeansException ex) { 8                 // Explicitly remove instance from singleton cache: It might have been put there 9                 // eagerly by the creation process, to allow for circular reference resolution. 10                 // Also remove any beans that received a temporary reference to the bean.11 destroySingleton(beanName); 12                 throw ex; 13 } 14 } 15 }); 16     bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); 17 }</pre><p>它优先会尝试getSington，即先尝试从singletonObjects中获取一下bean是否存在，如果存在直接返回singletonObjects中的bean对象。</p><p>接着，我们看到原型bean创建和单例bean创建的区别还在于第5行和第9行，先看第5行的代码：</p><pre> 1 protected void beforePrototypeCreation(String beanName) { 2     Object curVal = this.prototypesCurrentlyInCreation.get(); 3     if (curVal == null) { 4         this.prototypesCurrentlyInCreation.set(beanName); 5     } 6     else if (curVal instanceof String) { 7         Set<string> beanNameSet = new HashSet<string>(2); 8         beanNameSet.add((String) curVal); 9 beanNameSet.add(beanName); 10         this.prototypesCurrentlyInCreation.set(beanNameSet); 11 } 12     else { 13         Set<string> beanNameSet = (Set<string>) curVal; 14 beanNameSet.add(beanName); 15 } 16 }</string></string></string></string></pre><p>这段主要是说bean在创建前要把当前beanName设置到ThreadLocal中去，其目的是保证多线程不会同时创建同一个bean。接着看第9行的代码实现，即bean创建之后做了什么：</p><pre> 1 protected void afterPrototypeCreation(String beanName) { 2     Object curVal = this.prototypesCurrentlyInCreation.get(); 3     if (curVal instanceof String) { 4         this.prototypesCurrentlyInCreation.remove(); 5     } 6     else if (curVal instanceof Set) { 7         Set<string> beanNameSet = (Set<string>) curVal; 8         beanNameSet.remove(beanName); 9         if (beanNameSet.isEmpty()) { 10             this.prototypesCurrentlyInCreation.remove(); 11 } 12 } 13 }</string></string></pre><p>很好理解，就是把当前bean移除一下，这样其它线程就可以创建bean了。第11行的代码不看了，意思是如果bean是FactoryBean的实现类的话，调用getObject()方法获取真正的对象。</p><h2 id="byName源码实现"><a href="#byName源码实现" class="headerlink" title="byName源码实现"></a>byName源码实现</h2><p>Spring有为开发者提供Autowire（自动装配）的功能，自动装配最常用的就是byName和byType这两种属性。由于自动装配是为了解决对象注入导致的<property>过多的问题，因此很容易找到byName与byType的Spring源码实现应该在属性注入这一块，定位到属性注入的代码AbstractAutowireCapableBeanFactory的populateBean方法，直接截取重点：</property></p><pre> 1 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME || 2         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) { 3     MutablePropertyValues newPvs = new MutablePropertyValues(pvs); 4  5     // Add property values based on autowire by name if applicable. 6     if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) { 7         autowireByName(beanName, mbd, bw, newPvs); 8     } 9 10     // Add property values based on autowire by type if applicable.11     if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) { 12 autowireByType(beanName, mbd, bw, newPvs); 13 } 14 15     pvs = newPvs; 16 }</pre><p>看到第6行~第8行判断是否byName形式，是就执行byName自动装配代码；第11行~第13行判断是否byType形式，是就执行byType自动装配代码。那么首先看一下第7行的byName代码实现：</p><pre> 1 protected void autowireByName( 2         String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) { 3  4     String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw); 5     for (String propertyName : propertyNames) { 6         if (containsBean(propertyName)) { 7             Object bean = getBean(propertyName); 8             pvs.add(propertyName, bean); 9 registerDependentBean(propertyName, beanName); 10             if (logger.isDebugEnabled()) { 11                 logger.debug("Added autowiring by name from bean name '" + beanName +12                         "' via property '" + propertyName + "' to bean named '" + propertyName + "'"); 13 } 14 } 15         else { 16             if (logger.isTraceEnabled()) { 17                 logger.trace("Not autowiring property '" + propertyName + "' of bean '" + beanName +18                         "' by name: no matching bean found"); 19 } 20 } 21 } 22 }</pre><p>篇幅问题，代码不一层层跟了，逻辑梳理一下：</p><ul><li>第4行，找到Bean中不是简单属性的属性，这句话有点绕，意思就是找到属性是对象类型的属性，但也不是所有的对象类型都会被找到，比如CharSequence类型、Number类型、Date类型、URL类型、URI类型、Locale类型、Class类型就会忽略，具体可见BeanUtils的isSimpleProperty方法</li><li>第5行~第7行，遍历所有被找到的属性，如果bean定义中包含了属性名，那么先实例化该属性名对应的bean</li><li>第9行registerDependentBean，注册一下当前bean的依赖bean，用于在某个bean被销毁前先将其依赖的bean销毁</li></ul><p>其余代码都是一些打日志的，没什么好说的。</p><h2 id="byType源码实现"><a href="#byType源码实现" class="headerlink" title="byType源码实现"></a>byType源码实现</h2><p>上面说了byName的源码实现，接下来看一下byType源码实现：</p><pre> 1 protected void autowireByType( 2         String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) { 3  4     TypeConverter converter = getCustomTypeConverter(); 5     if (converter == null) { 6         converter = bw; 7     } 8  9     Set<string> autowiredBeanNames = new LinkedHashSet<string>(4); 10     String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw); 11     for (String propertyName : propertyNames) { 12         try { 13             PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName); 14             // Don't try autowiring by type for type Object: never makes sense, 15             // even if it technically is a unsatisfied, non-simple property.16             if (!Object.class.equals(pd.getPropertyType())) { 17                 MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd); 18                 // Do not allow eager init for type matching in case of a prioritized post-processor.19                 boolean eager = !PriorityOrdered.class.isAssignableFrom(bw.getWrappedClass()); 20                 DependencyDescriptor desc = new AutowireByTypeDependencyDescriptor(methodParam, eager); 21                 Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter); 22                 if (autowiredArgument != null) { 23 pvs.add(propertyName, autowiredArgument); 24 } 25                 for (String autowiredBeanName : autowiredBeanNames) { 26 registerDependentBean(autowiredBeanName, beanName); 27                     if (logger.isDebugEnabled()) { 28                         logger.debug("Autowiring by type from bean name '" + beanName + "' via property '" +29                                 propertyName + "' to bean named '" + autowiredBeanName + "'"); 30 } 31 } 32 autowiredBeanNames.clear(); 33 } 34 } 35         catch (BeansException ex) { 36             throw new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex); 37 } 38 } 39 }</string></string></pre><p>前面一样，到第10行都是找到Bean中属性是对象类型的属性。</p><p>接着就是遍历一下PropertyName，获取PropertyName对应的属性描述，注意一下16行的判断及其对应的注释：不要尝试自动装配Object类型，这没有任何意义，即使从技术角度看它是一个非简单的对象属性。</p><p>第18行~第20行跳过（没有太明白是干什么的），byType实现的源码主要在第21行的方法resolveDependency中，这个方法是AbstractAutowireCapableBeanFactory类的实现类DefaultListableBeanFactory中的方法：</p><pre> 1 public Object resolveDependency(DependencyDescriptor descriptor, String beanName, 2     Set<string> autowiredBeanNames, TypeConverter typeConverter) throws BeansException  { 3  4     descriptor.initParameterNameDiscovery(getParameterNameDiscoverer()); 5     if (descriptor.getDependencyType().equals(ObjectFactory.class)) { 6         return new DependencyObjectFactory(descriptor, beanName); 7     } 8     else if (descriptor.getDependencyType().equals(javaxInjectProviderClass)) { 9         return new DependencyProviderFactory().createDependencyProvider(descriptor, beanName); 10 } 11     else { 12         return doResolveDependency(descriptor, descriptor.getDependencyType(), beanName, autowiredBeanNames, typeConverter); 13 } 14 }</string></pre><p>这里判断一下要自动装配的属性是ObjectFactory.class还是javaxInjectProviderClass还是其他的，我们装配的是其他的，看一下12行的代码实现：</p><pre> 1 protected Object doResolveDependency(DependencyDescriptor descriptor, Class<?> type, String beanName, 2     Set<string> autowiredBeanNames, TypeConverter typeConverter) throws BeansException  { 3  4     Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor); 5     if (value != null) { 6         if (value instanceof String) { 7             String strVal = resolveEmbeddedValue((String) value); 8             BeanDefinition bd = (beanName != null && containsBean(beanName) ? getMergedBeanDefinition(beanName) : null); 9             value = evaluateBeanDefinitionString(strVal, bd); 10 } 11         TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter()); 12         return converter.convertIfNecessary(value, type); 13 } 14 15     if (type.isArray()) { 16 ... 17 } 18     else if (Collection.class.isAssignableFrom(type) && type.isInterface()) { 19 ... 20 } 21     else if (Map.class.isAssignableFrom(type) && type.isInterface()) { 22 ... 23 } 24     else { 25         Map<string, object=""> matchingBeans = findAutowireCandidates(beanName, type, descriptor); 26         if (matchingBeans.isEmpty()) { 27             if (descriptor.isRequired()) { 28                 raiseNoSuchBeanDefinitionException(type, "", descriptor); 29 } 30             return null; 31 } 32         if (matchingBeans.size() > 1) { 33             String primaryBeanName = determinePrimaryCandidate(matchingBeans, descriptor); 34             if (primaryBeanName == null) { 35                 throw new NoSuchBeanDefinitionException(type, "expected single matching bean but found " +36                         matchingBeans.size() + ": " + matchingBeans.keySet()); 37 } 38             if (autowiredBeanNames != null) { 39 autowiredBeanNames.add(primaryBeanName); 40 } 41             return matchingBeans.get(primaryBeanName); 42 } 43         // We have exactly one match.44         Map.Entry<string, object=""> entry = matchingBeans.entrySet().iterator().next(); 45         if (autowiredBeanNames != null) { 46 autowiredBeanNames.add(entry.getKey()); 47 } 48         return entry.getValue(); 49 } 50 }</string,></string,></string></pre><p>第四行结果是null不看了，为了简化代码Array装配、Collection装配、Map装配的代码都略去了，重点看一下普通属性的装配。首先是第25行获取一下自动装配的候选者：</p><pre> 1 protected Map<string, object=""> findAutowireCandidates( 2     String beanName, Class requiredType, DependencyDescriptor descriptor) { 3  4     String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors( 5             this, requiredType, true, descriptor.isEager()); 6     Map<string, object=""> result = new LinkedHashMap<string, object="">(candidateNames.length); 7     for (Class autowiringType : this.resolvableDependencies.keySet()) { 8         if (autowiringType.isAssignableFrom(requiredType)) { 9             Object autowiringValue = this.resolvableDependencies.get(autowiringType); 10             autowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType); 11             if (requiredType.isInstance(autowiringValue)) { 12 result.put(ObjectUtils.identityToString(autowiringValue), autowiringValue); 13                 break; 14 } 15 } 16 } 17     for (String candidateName : candidateNames) { 18         if (!candidateName.equals(beanName) && isAutowireCandidate(candidateName, descriptor)) { 19 result.put(candidateName, getBean(candidateName)); 20 } 21 } 22     return result; 23 }</string,></string,></string,></pre><p>代码逻辑整理一下：</p><ul><li>首先获取候选者bean名称，通过DefaultListableBeanFactory的getBeanNamesForType方法，即找一下所有的Bean定义中指定Type的实现类或者子类</li><li>接着第7行~第16行的判断要自动装配的类型是不是要自动装配的纠正类型，这个在<a href="http://www.cnblogs.com/xrq730/p/6670457.html" target="_blank" rel="noopener">【Spring源码分析】非懒加载的单例Bean初始化前后的一些操作</a>一文讲PrepareBeanFactory方法的时候有讲过，如果要自动装配的类型是纠正类型，比如是一个ResourceLoader，那么就会为该类型生成一个代理实例，具体可以看一下第10行的AutowireUtils.resolveAutowiringValue方法的实现  </li><li>正常来说都是执行的第17行~第21行的代码，逐个判断查找一下beanName对应的BeanDefinition，判断一下是不是自动装配候选者，默认都是的，如果<bean>的autowire-candidate属性设置为false就不是</bean></li></ul><p>这样，拿到所有待装配对象的实现类或者子类的候选者，组成一个Map，Key为beanName，Value为具体的Bean。接着回看获取Bean之后的逻辑：</p><pre> 1 Map<string, object=""> matchingBeans = findAutowireCandidates(beanName, type, descriptor); 2     if (matchingBeans.isEmpty()) { 3         if (descriptor.isRequired()) { 4             raiseNoSuchBeanDefinitionException(type, "", descriptor); 5         } 6         return null; 7     } 8     if (matchingBeans.size() > 1) { 9         String primaryBeanName = determinePrimaryCandidate(matchingBeans, descriptor); 10         if (primaryBeanName == null) { 11             throw new NoSuchBeanDefinitionException(type, "expected single matching bean but found " +12                     matchingBeans.size() + ": " + matchingBeans.keySet()); 13 } 14         if (autowiredBeanNames != null) { 15 autowiredBeanNames.add(primaryBeanName); 16 } 17         return matchingBeans.get(primaryBeanName); 18 } 19     // We have exactly one match.20     Map.Entry<string, object=""> entry = matchingBeans.entrySet().iterator().next(); 21     if (autowiredBeanNames != null) { 22 autowiredBeanNames.add(entry.getKey()); 23 } 24     ... 25 }</string,></string,></pre><p>整理一下逻辑：</p><ul><li>如果拿到的Map是空的且属性必须注入，抛异常</li><li>如果拿到的Map中有多个候选对象，判断其中是否有<bean>中属性配置为”primary=true”的，有就拿执行第13行~第15行的代码，没有就第8行的方法返回null，抛异常，这个异常的描述相信Spring用的比较多的应该比较熟悉</bean></li><li>如果拿到的Map中只有一个候选对象，直接拿到那个 </li></ul><p>通过这样一整个流程，实现了byType自动装配，byType自动装配流程比较长，中间细节比较多，还需要多看看才能弄明白。</p><p>最后注意一点，即所有待注入的PropertyName–&gt;PropertyValue映射拿到之后都只是放在MutablePropertyValues中，最后由AbstractPropertyAccessor类的setPropertyValues方法遍历并进行逐一注入。</p><h2 id="通过FactoryBean获取Bean实例源码实现"><a href="#通过FactoryBean获取Bean实例源码实现" class="headerlink" title="通过FactoryBean获取Bean实例源码实现"></a>通过FactoryBean获取Bean实例源码实现</h2><p>我们知道可以通过实现FactoryBean接口，重写getObject()方法实现个性化定制Bean的过程，这部分我们就来看一下Spring源码是如何实现通过FactoryBean获取Bean实例的。代码直接定位到AbstractBeanFactory的doGetBean方法创建单例Bean这部分：</p><pre> 1 // Create bean instance. 2 if (mbd.isSingleton()) { 3     sharedInstance = getSingleton(beanName, new ObjectFactory() { 4         public Object getObject() throws BeansException { 5             try { 6                 return createBean(beanName, mbd, args); 7             } 8             catch (BeansException ex) { 9                 // Explicitly remove instance from singleton cache: It might have been put there 10                 // eagerly by the creation process, to allow for circular reference resolution. 11                 // Also remove any beans that received a temporary reference to the bean.12 destroySingleton(beanName); 13                 throw ex; 14 } 15 } 16 }); 17     bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); 18 }</pre><p>FactoryBean首先是个Bean且被实例化出来成为一个对象之后才能调用getObject()方法，因此还是会执行第3行~第16行的代码，这段代码之前分析过了就不说了。之后执行第17行的方法：</p><pre> 1 protected Object getObjectForBeanInstance( 2         Object beanInstance, String name, String beanName, RootBeanDefinition mbd) { 3  4     // Don't let calling code try to dereference the factory if the bean isn't a factory. 5     if (BeanFactoryUtils.isFactoryDereference(name) && !(beanInstance instanceof FactoryBean)) { 6         throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass()); 7     } 8  9     // Now we have the bean instance, which may be a normal bean or a FactoryBean. 10     // If it's a FactoryBean, we use it to create a bean instance, unless the 11     // caller actually wants a reference to the factory.12     if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) { 13         return beanInstance; 14 } 15 16     Object object = null; 17     if (mbd == null) { 18         object = getCachedObjectForFactoryBean(beanName); 19 } 20     if (object == null) { 21         // Return bean instance from factory.22         FactoryBean factory = (FactoryBean) beanInstance; 23         // Caches object obtained from FactoryBean if it is a singleton.24         if (mbd == null && containsBeanDefinition(beanName)) { 25             mbd = getMergedLocalBeanDefinition(beanName); 26 } 27         boolean synthetic = (mbd != null && mbd.isSynthetic()); 28         object = getObjectFromFactoryBean(factory, beanName, !synthetic); 29 } 30     return object; 31 }</pre><p>首先第5行~第7行判断一下是否beanName以”&amp;”开头并且不是FactoryBean的实现类，不满足则抛异常，因为beanName以”&amp;”开头是FactoryBean的实现类bean定义的一个特征。</p><p>接着判断第12行~第14行，如果：</p><ul><li>bean不是FactoryBean的实现类</li><li>beanName以”&amp;”开头</li></ul><p>这两种情况，都直接把生成的bean对象返回出去，不会执行余下的流程。</p><p>最后流程走到第16行~第30行，最终调用getObject()方法实现个性化定制bean，先执行第28行的方法：</p><pre> 1 protected Object getObjectFromFactoryBean(FactoryBean factory, String beanName, boolean shouldPostProcess) { 2     if (factory.isSingleton() && containsSingleton(beanName)) { 3         synchronized (getSingletonMutex()) { 4             Object object = this.factoryBeanObjectCache.get(beanName); 5             if (object == null) { 6                 object = doGetObjectFromFactoryBean(factory, beanName, shouldPostProcess); 7                 this.factoryBeanObjectCache.put(beanName, (object != null ? object : NULL_OBJECT)); 8             } 9             return (object != NULL_OBJECT ? object : null); 10 } 11 } 12     else { 13         return doGetObjectFromFactoryBean(factory, beanName, shouldPostProcess); 14 } 15 }</pre><p>第1行~第11行的代码与第12行~第13行的代码最终都是一样的，调用了如下一段：</p><pre> 1 private Object doGetObjectFromFactoryBean( 2         final FactoryBean factory, final String beanName, final boolean shouldPostProcess) 3         throws BeanCreationException { 4  5     Object object; 6     try { 7         if (System.getSecurityManager() != null) { 8             AccessControlContext acc = getAccessControlContext(); 9             try { 10                 object = AccessController.doPrivileged(new PrivilegedExceptionAction<object>() { 11                     public Object run() throws Exception { 12                             return factory.getObject(); 13 } 14 }, acc); 15 } 16             catch (PrivilegedActionException pae) { 17                 throw pae.getException(); 18 } 19 } 20         else { 21             object = factory.getObject(); 22 } 23 } 24     catch (FactoryBeanNotInitializedException ex) { 25         throw new BeanCurrentlyInCreationException(beanName, ex.toString()); 26 } 27     catch (Throwable ex) { 28         throw new BeanCreationException(beanName, "FactoryBean threw exception on object creation", ex); 29 } 30         31     // Do not accept a null value for a FactoryBean that's not fully 32     // initialized yet: Many FactoryBeans just return null then.33     if (object == null && isSingletonCurrentlyInCreation(beanName)) { 34         throw new BeanCurrentlyInCreationException( 35                 beanName, "FactoryBean which is currently in creation returned null from getObject"); 36 } 37 38     if (object != null && shouldPostProcess) { 39         try { 40             object = postProcessObjectFromFactoryBean(object, beanName); 41 } 42         catch (Throwable ex) { 43             throw new BeanCreationException(beanName, "Post-processing of the FactoryBean's object failed", ex); 44 } 45 } 46 47     return object; 48 }</object></pre><p>第12行和第21行的代码，都一样，最终调用getObject()方法获取对象。回过头去看之前的getObjectFromFactoryBean方法，虽然if…else…逻辑最终都是调用了以上的方法，但是区别在于：</p><ul><li>如果FactoryBean接口实现类的isSington方法返回的是true，那么每次调用getObject方法的时候会优先尝试从FactoryBean对象缓存中取目标对象，有就直接拿，没有就创建并放入FactoryBean对象缓存，这样保证了每次单例的FactoryBean调用getObject()方法后最终拿到的目标对象一定是单例的，即在内存中都是同一份</li><li>如果FactoryBean接口实现类的isSington方法返回的是false，那么每次调用getObject方法的时候都会新创建一个目标对象</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Spring源码解析 &lt;a href=&quot;https://blog.csdn.net/column/details/21851.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21851.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Spring" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Spring/"/>
    
    
      <category term="Spring" scheme="http://h2pl.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码剖析3：懒加载的单例Bean获取过程分析</title>
    <link href="http://h2pl.github.io/2018/06/03/spring3/"/>
    <id>http://h2pl.github.io/2018/06/03/spring3/</id>
    <published>2018-06-03T14:27:51.000Z</published>
    <updated>2018-06-11T15:01:28.818Z</updated>
    
    <content type="html"><![CDATA[<p>转自<a href="https://www.cnblogs.com/xrq730/p/6285358.html" target="_blank" rel="noopener">【Spring源码分析】Bean加载流程概览</a></p><p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Spring源码解析 <a href="https://blog.csdn.net/column/details/21851.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21851.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><p>转自：<a href="http://www.cnblogs.com/xrq730" target="_blank" rel="noopener">http://www.cnblogs.com/xrq730</a></p><h2 id="代码入口"><a href="#代码入口" class="headerlink" title="代码入口"></a>代码入口</h2><p>之前写文章都会啰啰嗦嗦一大堆再开始，进入【Spring源码分析】这个板块就直接切入正题了。</p><p>很多朋友可能想看Spring源码，但是不知道应当如何入手去看，这个可以理解：Java开发者通常从事的都是Java Web的工作，对于程序员来说，一个Web项目用到Spring，只是配置一下配置文件而已，Spring的加载过程相对是不太透明的，不太好去找加载的代码入口。</p><p>下面有很简单的一段代码可以作为Spring代码加载的入口：</p><pre> 1 ApplicationContext ac = new ClassPathXmlApplicationContext("spring.xml"); 2 ac.getBean(XXX.class);</pre><p>ClassPathXmlApplicationContext用于加载CLASSPATH下的Spring配置文件，可以看到，第二行就已经可以获取到Bean的实例了，那么必然第一行就已经完成了对所有Bean实例的加载，因此可以通过ClassPathXmlApplicationContext作为入口。为了后面便于代码阅读，先给出一下ClassPathXmlApplicationContext这个类的继承关系：<img src="https://images2015.cnblogs.com/blog/801753/201702/801753-20170201125310058-568989522.png" alt=""></p><p>大致的继承关系是如上图所示的，由于版面的关系，没有继续画下去了，左下角的ApplicationContext应当还有一层继承关系，比较关键的一点是它是BeanFactory的子接口。</p><p>最后声明一下，本文使用的Spring版本为3.0.7，比较老，使用这个版本纯粹是因为公司使用而已。</p><p>ClassPathXmlApplicationContext存储内容</p><p>为了更理解ApplicationContext，拿一个实例ClassPathXmlApplicationContext举例，看一下里面存储的内容，加深对ApplicationContext的认识，以表格形式展现：</p><table><thead><tr><th>对象名</th><th>类  型</th><th>作  用</th><th>归属类</th></tr></thead><tbody><tr><td>configResources</td><td>Resource[]</td><td>配置文件资源对象数组</td><td>ClassPathXmlApplicationContext</td></tr><tr><td>configLocations</td><td>String[]</td><td>配置文件字符串数组，存储配置文件路径</td><td>AbstractRefreshableConfigApplicationContext</td></tr><tr><td>beanFactory</td><td>DefaultListableBeanFactory</td><td>上下文使用的Bean工厂</td><td>AbstractRefreshableApplicationContext</td></tr><tr><td>beanFactoryMonitor</td><td>Object</td><td>Bean工厂使用的同步监视器</td><td>AbstractRefreshableApplicationContext</td></tr><tr><td>id</td><td>String</td><td>上下文使用的唯一Id，标识此ApplicationContext</td><td>AbstractApplicationContext</td></tr><tr><td>parent</td><td>ApplicationContext</td><td>父级ApplicationContext</td><td>AbstractApplicationContext</td></tr><tr><td>beanFactoryPostProcessors</td><td>List<beanfactorypostprocessor></beanfactorypostprocessor></td><td>存储BeanFactoryPostProcessor接口，Spring提供的一个扩展点</td><td>AbstractApplicationContext</td></tr><tr><td>startupShutdownMonitor</td><td>Object</td><td>refresh方法和destory方法公用的一个监视器，避免两个方法同时执行</td><td>AbstractApplicationContext</td></tr><tr><td>shutdownHook</td><td>Thread</td><td>Spring提供的一个钩子，JVM停止执行时会运行Thread里面的方法</td><td>AbstractApplicationContext</td></tr><tr><td>resourcePatternResolver</td><td>ResourcePatternResolver</td><td>上下文使用的资源格式解析器</td><td>AbstractApplicationContext</td></tr><tr><td>lifecycleProcessor</td><td>LifecycleProcessor</td><td>用于管理Bean生命周期的生命周期处理器接口</td><td>AbstractApplicationContext</td></tr><tr><td>messageSource</td><td>MessageSource</td><td>用于实现国际化的一个接口</td><td>AbstractApplicationContext</td></tr><tr><td>applicationEventMulticaster</td><td>ApplicationEventMulticaster</td><td>Spring提供的事件管理机制中的事件多播器接口</td><td>AbstractApplicationContext</td></tr><tr><td>applicationListeners</td><td>Set<applicationlistener></applicationlistener></td><td>Spring提供的事件管理机制中的应用监听器</td><td>AbstractApplicationContext</td></tr></tbody></table><p>ClassPathXmlApplicationContext构造函数</p><p>看下ClassPathXmlApplicationContext的构造函数：</p><pre> 1 public ClassPathXmlApplicationContext(String configLocation) throws BeansException { 2     this(new String[] {configLocation}, true, null); 3 }</pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre>1 public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) 2         throws BeansException { 3 4     super(parent); 5 setConfigLocations(configLocations); 6     if (refresh) { 7 refresh(); 8 } 9 }</pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>从第二段代码看，总共就做了三件事：</p><p>　　1、super(parent)</p><p>　　　　没什么太大的作用，设置一下父级ApplicationContext，这里是null</p><p>　　2、setConfigLocations(configLocations)</p><p>　　　　代码就不贴了，一看就知道，里面做了两件事情：</p><p>　　　　（1）将指定的Spring配置文件的路径存储到本地</p><p>　　　　（2）解析Spring配置文件路径中的${PlaceHolder}占位符，替换为系统变量中PlaceHolder对应的Value值，System本身就自带一些系统变量比如class.path、os.name、user.dir等，也可以通过System.setProperty()方法设置自己需要的系统变量</p><h2 id="refresh"><a href="#refresh" class="headerlink" title="refresh()"></a>refresh()</h2><p>　　　　这个就是整个Spring Bean加载的核心了，它是ClassPathXmlApplicationContext的父类AbstractApplicationContext的一个方法，顾名思义，用于刷新整个Spring上下文信息，定义了整个Spring上下文加载的流程。</p><p>refresh方法</p><p>上面已经说了，refresh()方法是整个Spring Bean加载的核心，因此看一下整个refresh()方法的定义：</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre> 1 public void refresh() throws BeansException, IllegalStateException { 2         synchronized (this.startupShutdownMonitor) { 3             // Prepare this context for refreshing. 4             prepareRefresh(); 5  6             // Tell the subclass to refresh the internal bean factory. 7             ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); 8  9             // Prepare the bean factory for use in this context.10 prepareBeanFactory(beanFactory); 11 12             try { 13                 // Allows post-processing of the bean factory in context subclasses.14 postProcessBeanFactory(beanFactory); 15 16                 // Invoke factory processors registered as beans in the context.17 invokeBeanFactoryPostProcessors(beanFactory); 18 19                 // Register bean processors that intercept bean creation.20 registerBeanPostProcessors(beanFactory); 21 22                 // Initialize message source for this context.23 initMessageSource(); 24 25                 // Initialize event multicaster for this context.26 initApplicationEventMulticaster(); 27 28                 // Initialize other special beans in specific context subclasses.29 onRefresh(); 30 31                 // Check for listener beans and register them.32 registerListeners(); 33 34                 // Instantiate all remaining (non-lazy-init) singletons.35 finishBeanFactoryInitialization(beanFactory); 36 37                 // Last step: publish corresponding event.38 finishRefresh(); 39 } 40 41             catch (BeansException ex) { 42                 // Destroy already created singletons to avoid dangling resources.43 destroyBeans(); 44 45                 // Reset 'active' flag.46 cancelRefresh(ex); 47 48                 // Propagate exception to caller.49                 throw ex; 50 } 51 } 52     }</pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>每个子方法的功能之后一点一点再分析，首先refresh()方法有几点是值得我们学习的：</p><p>　　1、方法是加锁的，这么做的原因是避免多线程同时刷新Spring上下文</p><p>　　2、尽管加锁可以看到是针对整个方法体的，但是没有在方法前加synchronized关键字，而使用了对象锁startUpShutdownMonitor，这样做有两个好处：</p><p>　　　　（1）refresh()方法和close()方法都使用了startUpShutdownMonitor对象锁加锁，这就保证了在调用refresh()方法的时候无法调用close()方法，反之亦然，避免了冲突</p><p>　　　　（2）另外一个好处不在这个方法中体现，但是提一下，使用对象锁可以减小了同步的范围，只对不能并发的代码块进行加锁，提高了整体代码运行的效率</p><p>　　3、方法里面使用了每个子方法定义了整个refresh()方法的流程，使得整个方法流程清晰易懂。这点是非常值得学习的，一个方法里面几十行甚至上百行代码写在一起，在我看来会有三个显著的问题：</p><p>　　　　（1）扩展性降低。反过来讲，假使把流程定义为方法，子类可以继承父类，可以根据需要重写方法</p><p>　　　　（2）代码可读性差。很简单的道理，看代码的人是愿意看一段500行的代码，还是愿意看10段50行的代码？</p><p>　　　　（3）代码可维护性差。这点和上面的类似但又有不同，可维护性差的意思是，一段几百行的代码，功能点不明确，不易后人修改，可能会导致“牵一发而动全身”</p><p>prepareRefresh方法</p><p>下面挨个看refresh方法中的子方法，首先是prepareRefresh方法，看一下源码：</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre> 1 /** 2  * Prepare this context for refreshing, setting its startup date and 3  * active flag. 4  */ 5 protected void prepareRefresh() { 6     this.startupDate = System.currentTimeMillis(); 7         synchronized (this.activeMonitor) { 8         this.active = true; 9 } 10 11     if (logger.isInfoEnabled()) { 12         logger.info("Refreshing " + this); 13 } 14 }</pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>这个方法功能比较简单，顾名思义，准备刷新Spring上下文，其功能注释上写了：</p><p>1、设置一下刷新Spring上下文的开始时间</p><p>2、将active标识位设置为true</p><p>另外可以注意一下12行这句日志，这句日志打印了真正加载Spring上下文的Java类。</p><p>obtainFreshBeanFactory方法</p><p>obtainFreshBeanFactory方法的作用是获取刷新Spring上下文的Bean工厂，其代码实现为：</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre>1 protected ConfigurableListableBeanFactory obtainFreshBeanFactory() { 2 refreshBeanFactory(); 3     ConfigurableListableBeanFactory beanFactory = getBeanFactory(); 4     if (logger.isDebugEnabled()) { 5         logger.debug("Bean factory for " + getDisplayName() + ": " + beanFactory); 6 } 7     return beanFactory; 8 }</pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>其核心是第二行的refreshBeanFactory方法，这是一个抽象方法，有AbstractRefreshableApplicationContext和GenericApplicationContext这两个子类实现了这个方法，看一下上面ClassPathXmlApplicationContext的继承关系图即知，调用的应当是AbstractRefreshableApplicationContext中实现的refreshBeanFactory，其源码为：</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre> 1 protected final void refreshBeanFactory() throws BeansException { 2     if (hasBeanFactory()) { 3         destroyBeans(); 4         closeBeanFactory(); 5     } 6     try { 7         DefaultListableBeanFactory beanFactory = createBeanFactory(); 8         beanFactory.setSerializationId(getId()); 9 customizeBeanFactory(beanFactory); 10 loadBeanDefinitions(beanFactory); 11         synchronized (this.beanFactoryMonitor) { 12             this.beanFactory = beanFactory; 13 } 14 } 15     catch (IOException ex) { 16         throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex); 17 } 18 }</pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>这段代码的核心是第7行，这行点出了DefaultListableBeanFactory这个类，这个类是构造Bean的核心类，这个类的功能会在下一篇文章中详细解读，首先给出DefaultListableBeanFactory的继承关系图：</p><p><img src="https://images2015.cnblogs.com/blog/801753/201702/801753-20170202113720339-1992987568.png" alt=""></p><p>AbstractAutowireCapableBeanFactory这个类的继承层次比较深，版面有限，就没有继续画下去了，本图基本上清楚地展示了DefaultListableBeanFactory的层次结构。</p><p>为了更清晰地说明DefaultListableBeanFactory的作用，列举一下DefaultListableBeanFactory中存储的一些重要对象及对象中的内容，DefaultListableBeanFactory基本就是操作这些对象，以表格形式说明：</p><table><thead><tr><th>对象名</th><th>类  型</th><th>作    用</th><th>归属类</th></tr></thead><tbody><tr><td>aliasMap</td><td>Map&lt;String, String&gt;</td><td>存储Bean名称-&gt;Bean别名映射关系</td><td>SimpleAliasRegistry</td></tr><tr><td>singletonObjects</td><td>Map&lt;String, Object&gt;</td><td>存储单例Bean名称-&gt;单例Bean实现映射关系</td><td>DefaultSingletonBeanRegistry</td></tr><tr><td>singletonFactories</td><td>Map&lt;String, ObjectFactory&gt;</td><td>存储Bean名称-&gt;ObjectFactory实现映射关系</td><td>DefaultSingletonBeanRegistry</td></tr><tr><td>earlySingletonObjects</td><td>Map&lt;String, Object&gt;</td><td>存储Bean名称-&gt;预加载Bean实现映射关系</td><td>DefaultSingletonBeanRegistry</td></tr><tr><td>registeredSingletons</td><td>Set<string></string></td><td>存储注册过的Bean名</td><td>DefaultSingletonBeanRegistry</td></tr><tr><td>singletonsCurrentlyInCreation</td><td>Set<string></string></td><td>存储当前正在创建的Bean名</td><td>DefaultSingletonBeanRegistry</td></tr><tr><td>disposableBeans</td><td>Map&lt;String, Object&gt;</td><td>存储Bean名称-&gt;Disposable接口实现Bean实现映射关系</td><td>DefaultSingletonBeanRegistry</td></tr><tr><td>factoryBeanObjectCache</td><td>Map&lt;String, Object&gt;</td><td>存储Bean名称-&gt;FactoryBean接口Bean实现映射关系</td><td>FactoryBeanRegistrySupport</td></tr><tr><td>propertyEditorRegistrars</td><td>Set<propertyeditorregistrar></propertyeditorregistrar></td><td>存储PropertyEditorRegistrar接口实现集合</td><td>AbstractBeanFactory</td></tr><tr><td>embeddedValueResolvers</td><td>List<stringvalueresolver></stringvalueresolver></td><td>存储StringValueResolver（字符串解析器）接口实现列表</td><td>AbstractBeanFactory</td></tr><tr><td>beanPostProcessors</td><td>List<beanpostprocessor></beanpostprocessor></td><td>存储 BeanPostProcessor接口实现列表</td><td>AbstractBeanFactory</td></tr><tr><td>mergedBeanDefinitions</td><td>Map&lt;String, RootBeanDefinition&gt;</td><td>存储Bean名称-&gt;合并过的根Bean定义映射关系</td><td>AbstractBeanFactory</td></tr><tr><td>alreadyCreated</td><td>Set<string></string></td><td>存储至少被创建过一次的Bean名集合</td><td>AbstractBeanFactory</td></tr><tr><td>ignoredDependencyInterfaces</td><td>Set<class></class></td><td>存储不自动装配的接口Class对象集合</td><td>AbstractAutowireCapableBeanFactory</td></tr><tr><td>resolvableDependencies</td><td>Map&lt;Class, Object&gt;</td><td>存储修正过的依赖映射关系</td><td>DefaultListableBeanFactory</td></tr><tr><td>beanDefinitionMap</td><td>Map&lt;String, BeanDefinition&gt;</td><td>存储Bean名称–&gt;Bean定义映射关系</td><td>DefaultListableBeanFactory</td></tr><tr><td>beanDefinitionNames</td><td>List<string></string></td><td>存储Bean定义名称列表</td><td>DefaultListableBeanFactory</td></tr></tbody></table><p>================================================================================== </p><h2 id="Spring是如何初始化Bean实例对象"><a href="#Spring是如何初始化Bean实例对象" class="headerlink" title="Spring是如何初始化Bean实例对象"></a>Spring是如何初始化Bean实例对象</h2><p>代码入口</p><p>上文<a href="http://www.cnblogs.com/xrq730/p/6285358.html" target="_blank" rel="noopener">【Spring源码分析】Bean加载流程概览</a>，比较详细地分析了Spring上下文加载的代码入口，并且在AbstractApplicationContext的refresh方法中，点出了finishBeanFactoryInitialization方法完成了对于所有非懒加载的Bean的初始化。</p><p>finishBeanFactoryInitialization方法中调用了DefaultListableBeanFactory的preInstantiateSingletons方法，本文针对preInstantiateSingletons进行分析，解读一下Spring是如何初始化Bean实例对象出来的。</p><p>DefaultListableBeanFactory的preInstantiateSingletons方法</p><p>DefaultListableBeanFactory的preInstantiateSingletons方法，顾名思义，初始化所有的单例Bean，看一下方法的定义：</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre> 1 public void preInstantiateSingletons() throws BeansException { 2     if (this.logger.isInfoEnabled()) { 3         this.logger.info("Pre-instantiating singletons in " + this); 4     } 5     synchronized (this.beanDefinitionMap) { 6         // Iterate over a copy to allow for init methods which in turn register new bean definitions. 7         // While this may not be part of the regular factory bootstrap, it does otherwise work fine. 8         List<string> beanNames = new ArrayList<string>(this.beanDefinitionNames); 9         for (String beanName : beanNames) { 10             RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); 11             if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) { 12                 if (isFactoryBean(beanName)) { 13                     final FactoryBean factory = (FactoryBean) getBean(FACTORY_BEAN_PREFIX + beanName); 14                     boolean isEagerInit; 15                     if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) { 16                         isEagerInit = AccessController.doPrivileged(new PrivilegedAction<boolean>() { 17                             public Boolean run() { 18                                 return ((SmartFactoryBean) factory).isEagerInit(); 19 } 20 }, getAccessControlContext()); 21 } 22                     else { 23                         isEagerInit = (factory instanceof SmartFactoryBean &&24 ((SmartFactoryBean) factory).isEagerInit()); 25 } 26                     if (isEagerInit) { 27 getBean(beanName); 28 } 29 } 30                 else { 31 getBean(beanName); 32 } 33 } 34 } 35 } 36 }</boolean></string></string></pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>这里先解释一下getMergedLocalBeanDefinition方法的含义，因为这个方法会常常看到。Bean定义公共的抽象类是AbstractBeanDefinition，普通的Bean在Spring加载Bean定义的时候，实例化出来的是GenericBeanDefinition，而Spring上下文包括实例化所有Bean用的AbstractBeanDefinition是RootBeanDefinition，这时候就使用getMergedLocalBeanDefinition方法做了一次转化，将非RootBeanDefinition转换为RootBeanDefinition以供后续操作。</p><p>解释完了getMergedLocalBeanDefinition方法的作用，第1行~第10行的代码就没什么好说的了，根据beanName拿到RootBeanDefinition而已。由于此方法实例化的是所有非懒加载的单例Bean，因此要实例化Bean，必须满足11行的三个定义：</p><p>（1）不是抽象的</p><p>（2）必须是单例的</p><p>（3）必须是非懒加载的</p><p>接着简单看一下第12行~第29行的代码，这段代码主要做的是一件事情：首先判断一下Bean是否FactoryBean的实现，接着判断Bean是否SmartFactoryBean的实现，假如Bean是SmartFactoryBean的实现并且eagerInit（这个单词字面意思是渴望加载，找不到一个好的词语去翻译，意思就是定义了这个Bean需要立即加载的意思）的话，会立即实例化这个Bean。Java开发人员不需要关注这段代码，因为SmartFactoryBean基本不会用到，我翻译一下Spring官网对于SmartFactoryBean的定义描述：</p><ul><li>FactoryBean接口的扩展接口。接口实现并不表示是否总是返回单独的实例对象，比如FactoryBean.isSingleton()实现返回false的情况并不清晰地表示每次返回的都是单独的实例对象</li><li>不实现这个扩展接口的简单FactoryBean的实现，FactoryBean.isSingleton()实现返回false总是简单地告诉我们每次返回的都是单独的实例对象，暴露出来的对象只能够通过命令访问</li><li>注意：这个接口是一个有特殊用途的接口，主要用于框架内部使用与Spring相关。通常，应用提供的FactoryBean接口实现应当只需要实现简单的FactoryBean接口即可，新方法应当加入到扩展接口中去</li></ul><p>代码示例</p><p>为了后面的代码分析方便，事先我定义一个Bean：</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre> 1 package org.xrq.action; 2  3 import org.springframework.beans.factory.BeanClassLoaderAware; 4 import org.springframework.beans.factory.BeanNameAware; 5 import org.springframework.beans.factory.InitializingBean; 6  7 public class MultiFunctionBean implements InitializingBean, BeanNameAware, BeanClassLoaderAware { 8  9     private int propertyA; 10     11     private int propertyB; 12     13     public int getPropertyA() { 14         return propertyA; 15 } 16 17     public void setPropertyA(int propertyA) { 18         this.propertyA = propertyA; 19 } 20 21     public int getPropertyB() { 22         return propertyB; 23 } 24 25     public void setPropertyB(int propertyB) { 26         this.propertyB = propertyB; 27 } 28     29     public void initMethod() { 30         System.out.println("Enter MultiFunctionBean.initMethod()"); 31 } 32 33 @Override 34     public void setBeanClassLoader(ClassLoader classLoader) { 35         System.out.println("Enter MultiFunctionBean.setBeanClassLoader(ClassLoader classLoader)"); 36 } 37 38 @Override 39     public void setBeanName(String name) { 40         System.out.println("Enter MultiFunctionBean.setBeanName(String name)"); 41 } 42 43 @Override 44     public void afterPropertiesSet() throws Exception { 45         System.out.println("Enter MultiFunctionBean.afterPropertiesSet()"); 46 } 47     48 @Override 49     public String toString() { 50         return "MultiFunctionBean [propertyA=" + propertyA + ", propertyB=" + propertyB + "]"; 51 } 52     53 }</pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>定义对应的spring.xml：</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre>1 <?xml version="1.0" encoding="UTF-8"?>2 <beans 3="" 4="" xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://www.springframework.org/schema/beans 5     http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">6     7     <bean id="multiFunctionBean" class="org.xrq.action.MultiFunctionBean" init-method="initMethod">8     9 </bean></beans></pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>利用这个MultiFunctionBean，我们可以用来探究Spring加载Bean的多种机制。</p><p>doGetBean方法构造Bean流程</p><p>上面把getBean之外的代码都分析了一下，看代码就可以知道，获取Bean对象实例，都是通过getBean方法，getBean方法最终调用的是DefaultListableBeanFactory的父类AbstractBeanFactory类的doGetBean方法，因此这部分重点分析一下doGetBean方法是如何构造出一个单例的Bean的。</p><h2 id="doGetBean方法是如何构造出一个单例的Bean"><a href="#doGetBean方法是如何构造出一个单例的Bean" class="headerlink" title="doGetBean方法是如何构造出一个单例的Bean"></a>doGetBean方法是如何构造出一个单例的Bean</h2><p>看一下doGetBean方法的代码实现，比较长：</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre> 1 protected <t> T doGetBean( 2         final String name, final Class<t> requiredType, final Object[] args, boolean typeCheckOnly) 3         throws BeansException { 4  5     final String beanName = transformedBeanName(name); 6     Object bean; 7  8     // Eagerly check singleton cache for manually registered singletons. 9     Object sharedInstance = getSingleton(beanName); 10     if (sharedInstance != null && args == null) { 11         if (logger.isDebugEnabled()) { 12             if (isSingletonCurrentlyInCreation(beanName)) { 13                 logger.debug("Returning eagerly cached instance of singleton bean '" + beanName + 14                         "' that is not fully initialized yet - a consequence of a circular reference"); 15             } 16             else { 17                 logger.debug("Returning cached instance of singleton bean '" + beanName + "'"); 18             } 19         } 20         bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); 21     } 22  23     else { 24         // Fail if we're already creating this bean instance: 25         // We're assumably within a circular reference. 26         if (isPrototypeCurrentlyInCreation(beanName)) { 27             throw new BeanCurrentlyInCreationException(beanName); 28         } 29  30         // Check if bean definition exists in this factory. 31         BeanFactory parentBeanFactory = getParentBeanFactory(); 32         if (parentBeanFactory != null && !containsBeanDefinition(beanName)) { 33             // Not found -> check parent. 34             String nameToLookup = originalBeanName(name); 35             if (args != null) { 36                 // Delegation to parent with explicit args. 37                 return (T) parentBeanFactory.getBean(nameToLookup, args); 38             } 39             else { 40                 // No args -> delegate to standard getBean method. 41                 return parentBeanFactory.getBean(nameToLookup, requiredType); 42             } 43         } 44  45         if (!typeCheckOnly) { 46             markBeanAsCreated(beanName); 47         } 48  49         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); 50         checkMergedBeanDefinition(mbd, beanName, args); 51  52         // Guarantee initialization of beans that the current bean depends on. 53         String[] dependsOn = mbd.getDependsOn(); 54         if (dependsOn != null) { 55             for (String dependsOnBean : dependsOn) { 56                 getBean(dependsOnBean); 57                 registerDependentBean(dependsOnBean, beanName); 58             } 59         } 60  61         // Create bean instance. 62         if (mbd.isSingleton()) { 63             sharedInstance = getSingleton(beanName, new ObjectFactory() { 64                 public Object getObject() throws BeansException { 65                     try { 66                         return createBean(beanName, mbd, args); 67                     } 68                     catch (BeansException ex) { 69                         // Explicitly remove instance from singleton cache: It might have been put there 70                         // eagerly by the creation process, to allow for circular reference resolution. 71                         // Also remove any beans that received a temporary reference to the bean. 72                         destroySingleton(beanName); 73                         throw ex; 74                     } 75                 } 76             }); 77             bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); 78         } 79  80         else if (mbd.isPrototype()) { 81             // It's a prototype -> create a new instance. 82             Object prototypeInstance = null; 83             try { 84                 beforePrototypeCreation(beanName); 85                 prototypeInstance = createBean(beanName, mbd, args); 86             } 87             finally { 88                 afterPrototypeCreation(beanName); 89             } 90             bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); 91         } 92  93         else { 94             String scopeName = mbd.getScope(); 95             final Scope scope = this.scopes.get(scopeName); 96             if (scope == null) { 97                 throw new IllegalStateException("No Scope registered for scope '" + scopeName + "'"); 98             } 99             try { 100                 Object scopedInstance = scope.get(beanName, new ObjectFactory() { 101                     public Object getObject() throws BeansException { 102 beforePrototypeCreation(beanName); 103                         try { 104                             return createBean(beanName, mbd, args); 105 } 106                         finally { 107 afterPrototypeCreation(beanName); 108 } 109 } 110 }); 111                 bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); 112 } 113             catch (IllegalStateException ex) { 114                 throw new BeanCreationException(beanName, 115                         "Scope '" + scopeName + "' is not active for the current thread; " +116                         "consider defining a scoped proxy for this bean if you intend to refer to it from a singleton", 117 ex); 118 } 119 } 120 } 121 122     // Check if required type matches the type of the actual bean instance.123     if (requiredType != null && bean != null && !requiredType.isAssignableFrom(bean.getClass())) { 124         try { 125             return getTypeConverter().convertIfNecessary(bean, requiredType); 126 } 127         catch (TypeMismatchException ex) { 128             if (logger.isDebugEnabled()) { 129                 logger.debug("Failed to convert bean '" + name + "' to required type [" +130                         ClassUtils.getQualifiedName(requiredType) + "]", ex); 131 } 132             throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); 133 } 134 } 135     return (T) bean; 136 }</t></t></pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>首先第9行~第21行的代码，第9行的代码就不进去看了，简单说一下：首先检查一下本地的单例缓存是否已经加载过Bean，没有的话再检查earlySingleton缓存是否已经加载过Bean（又是early，不好找到词语翻译），没有的话执行后面的逻辑。</p><p>接着第26行~第50行，这里执行的都是一些基本的检查和简单的操作，包括bean是否是prototype的（prototype的Bean当前创建会抛出异常）、是否抽象的、将beanName加入alreadyCreated这个Set中等。 </p><p>接着第53行~第59行，我们经常在bean标签中看到depends-on这个属性，就是通过这段保证了depends-on依赖的Bean会优先于当前Bean被加载。 </p><p>接着第62行~第78行、第80行~第91行、第93行~第120行有三个判断，显然上面的MultiFunctionBean是一个单例的Bean也是本文探究的重点，因此执行第62行~第78行的逻辑。getSingleton方法不贴了，有一些前置的判断，很简单的逻辑，重点就是调用了ObjectFactory的getObject()方法来获取到单例Bean对象，方法的实现是调用了createBean方法，createBean方法是AbstractBeanFactory的子类AbstractAutowireCapableBeanFactory的一个方法，看一下它的方法实现：</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre> 1 protected Object createBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) 2         throws BeanCreationException { 3  4     if (logger.isDebugEnabled()) { 5         logger.debug("Creating instance of bean '" + beanName + "'"); 6     } 7     // Make sure bean class is actually resolved at this point. 8     resolveBeanClass(mbd, beanName); 9 10     // Prepare method overrides.11     try { 12 mbd.prepareMethodOverrides(); 13 } 14     catch (BeanDefinitionValidationException ex) { 15         throw new BeanDefinitionStoreException(mbd.getResourceDescription(), 16                 beanName, "Validation of method overrides failed", ex); 17 } 18 19     try { 20         // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.21         Object bean = resolveBeforeInstantiation(beanName, mbd); 22         if (bean != null) { 23             return bean; 24 } 25 } 26     catch (Throwable ex) { 27         throw new BeanCreationException(mbd.getResourceDescription(), beanName, 28                 "BeanPostProcessor before instantiation of bean failed", ex); 29 } 30 31     Object beanInstance = doCreateBean(beanName, mbd, args); 32     if (logger.isDebugEnabled()) { 33         logger.debug("Finished creating instance of bean '" + beanName + "'"); 34 } 35     return beanInstance; 36 }</pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>前面的代码都没什么意义，代码执行到第31行：</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre> 1 protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) { 2     // Instantiate the bean. 3     BeanWrapper instanceWrapper = null; 4     if (mbd.isSingleton()) { 5         instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); 6     } 7     if (instanceWrapper == null) { 8         instanceWrapper = createBeanInstance(beanName, mbd, args); 9 } 10     final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null); 11     Class beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null); 12 13     // Allow post-processors to modify the merged bean definition.14     synchronized (mbd.postProcessingLock) { 15         if (!mbd.postProcessed) { 16 applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); 17             mbd.postProcessed = true; 18 } 19 } 20 21     // Eagerly cache singletons to be able to resolve circular references 22     // even when triggered by lifecycle interfaces like BeanFactoryAware.23     boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&24 isSingletonCurrentlyInCreation(beanName)); 25     if (earlySingletonExposure) { 26         if (logger.isDebugEnabled()) { 27             logger.debug("Eagerly caching bean '" + beanName +28                     "' to allow for resolving potential circular references"); 29 } 30         addSingletonFactory(beanName, new ObjectFactory() { 31             public Object getObject() throws BeansException { 32                 return getEarlyBeanReference(beanName, mbd, bean); 33 } 34 }); 35 } 36 37     // Initialize the bean instance.38     Object exposedObject = bean; 39     try { 40 populateBean(beanName, mbd, instanceWrapper); 41         if (exposedObject != null) { 42             exposedObject = initializeBean(beanName, exposedObject, mbd); 43 } 44 } 45     catch (Throwable ex) { 46         if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) { 47             throw (BeanCreationException) ex; 48 } 49         else { 50             throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Initialization of bean failed", ex); 51 } 52 } 53 54     if (earlySingletonExposure) { 55         Object earlySingletonReference = getSingleton(beanName, false); 56         if (earlySingletonReference != null) { 57             if (exposedObject == bean) { 58                 exposedObject = earlySingletonReference; 59 } 60             else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) { 61                 String[] dependentBeans = getDependentBeans(beanName); 62                 Set<string> actualDependentBeans = new LinkedHashSet<string>(dependentBeans.length); 63                 for (String dependentBean : dependentBeans) { 64                     if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) { 65 actualDependentBeans.add(dependentBean); 66 } 67 } 68                 if (!actualDependentBeans.isEmpty()) { 69                     throw new BeanCurrentlyInCreationException(beanName, 70                             "Bean with name '" + beanName + "' has been injected into other beans [" +71                                 StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +72                             "] in its raw version as part of a circular reference, but has eventually been " +73                             "wrapped. This means that said other beans do not use the final version of the " +74                             "bean. This is often the result of over-eager type matching - consider using " +75                             "'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."); 76 } 77 } 78 } 79 } 80 81     // Register bean as disposable.82     try { 83 registerDisposableBeanIfNecessary(beanName, bean, mbd); 84 } 85     catch (BeanDefinitionValidationException ex) { 86         throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Invalid destruction signature", ex); 87 } 88 89     return exposedObject; 90 }</string></string></pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><h2 id="doCreateBean方法"><a href="#doCreateBean方法" class="headerlink" title="doCreateBean方法"></a>doCreateBean方法</h2><p>代码跟踪到这里，已经到了主流程，接下来分段分析doCreateBean方法的代码。</p><p>创建Bean实例</p><p>第8行的createBeanInstance方法，会创建出Bean的实例，并包装为BeanWrapper，看一下createBeanInstance方法，只贴最后一段比较关键的：</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre> 1 // Need to determine the constructor... 2 Constructor[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName); 3 if (ctors != null || 4         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR || 5         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  { 6     return autowireConstructor(beanName, mbd, ctors, args); 7 } 8  9 // No special handling: simply use no-arg constructor.10 return instantiateBean(beanName, mbd);</pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>意思是bean标签使用构造函数注入属性的话，执行第6行，否则执行第10行。MultiFunctionBean使用默认构造函数，使用setter注入属性，因此执行第10行代码：</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre> 1 protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) { 2     try { 3         Object beanInstance; 4         final BeanFactory parent = this; 5         if (System.getSecurityManager() != null) { 6             beanInstance = AccessController.doPrivileged(new PrivilegedAction<object>() { 7                 public Object run() { 8                     return getInstantiationStrategy().instantiate(mbd, beanName, parent); 9 } 10 }, getAccessControlContext()); 11 } 12         else { 13             beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent); 14 } 15         BeanWrapper bw = new BeanWrapperImpl(beanInstance); 16 initBeanWrapper(bw); 17         return bw; 18 } 19     catch (Throwable ex) { 20         throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Instantiation of bean failed", ex); 21 } 22 }</object></pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>代码执行到13行：</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre> 1 public Object instantiate(RootBeanDefinition beanDefinition, String beanName, BeanFactory owner) { 2     // Don't override the class with CGLIB if no overrides. 3     if (beanDefinition.getMethodOverrides().isEmpty()) { 4         Constructor<?> constructorToUse; 5         synchronized (beanDefinition.constructorArgumentLock) { 6             constructorToUse = (Constructor<?>) beanDefinition.resolvedConstructorOrFactoryMethod; 7             if (constructorToUse == null) { 8                 final Class clazz = beanDefinition.getBeanClass(); 9                 if (clazz.isInterface()) { 10                     throw new BeanInstantiationException(clazz, "Specified class is an interface"); 11 } 12                 try { 13                     if (System.getSecurityManager() != null) { 14                         constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction<constructor>() { 15                             public Constructor run() throws Exception { 16                                 return clazz.getDeclaredConstructor((Class[]) null); 17 } 18 }); 19 } 20                     else { 21                         constructorToUse = clazz.getDeclaredConstructor((Class[]) null); 22 } 23                     beanDefinition.resolvedConstructorOrFactoryMethod = constructorToUse; 24 } 25                 catch (Exception ex) { 26                     throw new BeanInstantiationException(clazz, "No default constructor found", ex); 27 } 28 } 29 } 30         return BeanUtils.instantiateClass(constructorToUse); 31 } 32     else { 33         // Must generate CGLIB subclass.34         return instantiateWithMethodInjection(beanDefinition, beanName, owner); 35 } 36 }</constructor></pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>整段代码都在做一件事情，就是选择一个使用的构造函数。当然第9行顺带做了一个判断：实例化一个接口将报错。</p><p>最后调用到30行，看一下代码：</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre> 1 public static <t> T instantiateClass(Constructor<t> ctor, Object... args) throws BeanInstantiationException { 2     Assert.notNull(ctor, "Constructor must not be null"); 3     try { 4         ReflectionUtils.makeAccessible(ctor); 5         return ctor.newInstance(args); 6     } 7     catch (InstantiationException ex) { 8         throw new BeanInstantiationException(ctor.getDeclaringClass(), 9                 "Is it an abstract class?", ex); 10 } 11     catch (IllegalAccessException ex) { 12         throw new BeanInstantiationException(ctor.getDeclaringClass(), 13                 "Is the constructor accessible?", ex); 14 } 15     catch (IllegalArgumentException ex) { 16         throw new BeanInstantiationException(ctor.getDeclaringClass(), 17                 "Illegal arguments for constructor", ex); 18 } 19     catch (InvocationTargetException ex) { 20         throw new BeanInstantiationException(ctor.getDeclaringClass(), 21                 "Constructor threw exception", ex.getTargetException()); 22 } 23 }</t></t></pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>通过反射生成Bean的实例。看到前面有一步makeAccessible，这意味着即使Bean的构造函数是private、protected的，依然不影响Bean的构造。</p><p>最后注意一下，这里被实例化出来的Bean并不会直接返回，而是会被包装为BeanWrapper继续在后面使用。</p><h2 id="doCreateBean方法-1"><a href="#doCreateBean方法-1" class="headerlink" title="doCreateBean方法"></a>doCreateBean方法</h2><p>上文<a href="http://www.cnblogs.com/xrq730/p/6361578.html" target="_blank" rel="noopener">【Spring源码分析】非懒加载的单例Bean初始化过程（上篇）</a>，分析了单例的Bean初始化流程，并跟踪代码进入了主流程，看到了Bean是如何被实例化出来的。先贴一下AbstractAutowireCapableBeanFactory的doCreateBean方法代码：</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre> 1 protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) { 2     // Instantiate the bean. 3     BeanWrapper instanceWrapper = null; 4     if (mbd.isSingleton()) { 5         instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); 6     } 7     if (instanceWrapper == null) { 8         instanceWrapper = createBeanInstance(beanName, mbd, args); 9 } 10     final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null); 11     Class beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null); 12 13     // Allow post-processors to modify the merged bean definition.14     synchronized (mbd.postProcessingLock) { 15         if (!mbd.postProcessed) { 16 applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); 17             mbd.postProcessed = true; 18 } 19 } 20 21     // Eagerly cache singletons to be able to resolve circular references 22     // even when triggered by lifecycle interfaces like BeanFactoryAware.23     boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&24 isSingletonCurrentlyInCreation(beanName)); 25     if (earlySingletonExposure) { 26         if (logger.isDebugEnabled()) { 27             logger.debug("Eagerly caching bean '" + beanName +28                     "' to allow for resolving potential circular references"); 29 } 30         addSingletonFactory(beanName, new ObjectFactory() { 31             public Object getObject() throws BeansException { 32                 return getEarlyBeanReference(beanName, mbd, bean); 33 } 34 }); 35 } 36 37     // Initialize the bean instance.38     Object exposedObject = bean; 39     try { 40 populateBean(beanName, mbd, instanceWrapper); 41         if (exposedObject != null) { 42             exposedObject = initializeBean(beanName, exposedObject, mbd); 43 } 44 } 45     catch (Throwable ex) { 46         if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) { 47             throw (BeanCreationException) ex; 48 } 49         else { 50             throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Initialization of bean failed", ex); 51 } 52 } 53 54     if (earlySingletonExposure) { 55         Object earlySingletonReference = getSingleton(beanName, false); 56         if (earlySingletonReference != null) { 57             if (exposedObject == bean) { 58                 exposedObject = earlySingletonReference; 59 } 60             else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) { 61                 String[] dependentBeans = getDependentBeans(beanName); 62                 Set<string> actualDependentBeans = new LinkedHashSet<string>(dependentBeans.length); 63                 for (String dependentBean : dependentBeans) { 64                     if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) { 65 actualDependentBeans.add(dependentBean); 66 } 67 } 68                 if (!actualDependentBeans.isEmpty()) { 69                     throw new BeanCurrentlyInCreationException(beanName, 70                             "Bean with name '" + beanName + "' has been injected into other beans [" +71                             StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +72                             "] in its raw version as part of a circular reference, but has eventually been " +73                             "wrapped. This means that said other beans do not use the final version of the " +74                             "bean. This is often the result of over-eager type matching - consider using " +75                             "'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."); 76 } 77 } 78 } 79 } 80 81     // Register bean as disposable.82     try { 83 registerDisposableBeanIfNecessary(beanName, bean, mbd); 84 } 85     catch (BeanDefinitionValidationException ex) { 86         throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Invalid destruction signature", ex); 87 } 88 89     return exposedObject; 90 }</string></string></pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>下面继续分析初始化一个Bean的流程，不太重要的流程就跳过了。</p><p>属性注入</p><p>属性注入的代码比较好找，可以看一下40行，取名为populateBean，即填充Bean的意思，看一下代码实现：</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre> 1 protected void populateBean(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw) { 2     PropertyValues pvs = mbd.getPropertyValues(); 3  4     if (bw == null) { 5         if (!pvs.isEmpty()) { 6             throw new BeanCreationException( 7                     mbd.getResourceDescription(), beanName, "Cannot apply property values to null instance"); 8         } 9         else { 10             // Skip property population phase for null instance.11             return; 12 } 13 } 14 15     // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the 16     // state of the bean before properties are set. This can be used, for example, 17     // to support styles of field injection.18     boolean continueWithPropertyPopulation = true; 19 20     if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) { 21         for (BeanPostProcessor bp : getBeanPostProcessors()) { 22             if (bp instanceof InstantiationAwareBeanPostProcessor) { 23                 InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; 24                 if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) { 25                     continueWithPropertyPopulation = false; 26                     break; 27 } 28 } 29 } 30 } 31 32     if (!continueWithPropertyPopulation) { 33         return; 34 } 35 36     if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||37             mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) { 38         MutablePropertyValues newPvs = new MutablePropertyValues(pvs); 39 40         // Add property values based on autowire by name if applicable.41         if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) { 42 autowireByName(beanName, mbd, bw, newPvs); 43 } 44 45         // Add property values based on autowire by type if applicable.46         if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) { 47 autowireByType(beanName, mbd, bw, newPvs); 48 } 49 50         pvs = newPvs; 51 } 52 53     boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors(); 54     boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE); 55 56     if (hasInstAwareBpps || needsDepCheck) { 57         PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw); 58         if (hasInstAwareBpps) { 59             for (BeanPostProcessor bp : getBeanPostProcessors()) { 60                 if (bp instanceof InstantiationAwareBeanPostProcessor) { 61                     InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; 62                     pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); 63                     if (pvs == null) { 64                         return; 65 } 66 } 67 } 68 } 69         if (needsDepCheck) { 70 checkDependencies(beanName, mbd, filteredPds, pvs); 71 } 72 } 73 74 applyPropertyValues(beanName, mbd, bw, pvs); 75 }</pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>这段代码层次有点深，跟一下74行的applyPropertyValues方法，最后那个pvs的实现类为MutablePropertyValues，里面持有一个List<propertyvalue>，每一个PropertyValue包含了此Bean属性的属性名与属性值。74行的代码实现为：</propertyvalue></p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre> 1 protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) { 2     if (pvs == null || pvs.isEmpty()) { 3         return; 4     } 5  6     MutablePropertyValues mpvs = null; 7     List<propertyvalue> original; 8          9     if (System.getSecurityManager()!= null) { 10         if (bw instanceof BeanWrapperImpl) { 11 ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext()); 12 } 13 } 14 15     if (pvs instanceof MutablePropertyValues) { 16         mpvs = (MutablePropertyValues) pvs; 17         if (mpvs.isConverted()) { 18             // Shortcut: use the pre-converted values as-is.19             try { 20 bw.setPropertyValues(mpvs); 21                 return; 22 } 23             catch (BeansException ex) { 24                 throw new BeanCreationException( 25                         mbd.getResourceDescription(), beanName, "Error setting property values", ex); 26 } 27 } 28         original = mpvs.getPropertyValueList(); 29 } 30     else { 31         original = Arrays.asList(pvs.getPropertyValues()); 32 } 33 34     TypeConverter converter = getCustomTypeConverter(); 35     if (converter == null) { 36         converter = bw; 37 } 38     BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter); 39 40     // Create a deep copy, resolving any references for values.41     List<propertyvalue> deepCopy = new ArrayList<propertyvalue>(original.size()); 42     boolean resolveNecessary = false; 43     for (PropertyValue pv : original) { 44         if (pv.isConverted()) { 45 deepCopy.add(pv); 46 } 47         else { 48             String propertyName = pv.getName(); 49             Object originalValue = pv.getValue(); 50             Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue); 51             Object convertedValue = resolvedValue; 52             boolean convertible = bw.isWritableProperty(propertyName) &&53                         !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName); 54             if (convertible) { 55                 convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter); 56 } 57             // Possibly store converted value in merged bean definition, 58             // in order to avoid re-conversion for every created bean instance.59             if (resolvedValue == originalValue) { 60                 if (convertible) { 61 pv.setConvertedValue(convertedValue); 62 } 63 deepCopy.add(pv); 64 } 65             else if (convertible && originalValue instanceof TypedStringValue &&66                     !((TypedStringValue) originalValue).isDynamic() &&67                     !(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) { 68 pv.setConvertedValue(convertedValue); 69 deepCopy.add(pv); 70 } 71             else { 72                 resolveNecessary = true; 73                 deepCopy.add(new PropertyValue(pv, convertedValue)); 74 } 75 } 76 } 77     if (mpvs != null && !resolveNecessary) { 78 mpvs.setConverted(); 79 } 80 81     // Set our (possibly massaged) deep copy.82     try { 83         bw.setPropertyValues(new MutablePropertyValues(deepCopy)); 84 } 85     catch (BeansException ex) { 86         throw new BeanCreationException( 87                 mbd.getResourceDescription(), beanName, "Error setting property values", ex); 88 } 89 }</propertyvalue></propertyvalue></propertyvalue></pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>之后在第41行~第76行做了一次深拷贝（只是名字叫做深拷贝而已，其实就是遍历PropertyValue然后一个一个赋值到一个新的List而不是Java语义上的Clone，这里使用深拷贝是为了解析Values值中的所有引用），将PropertyValue一个一个赋值到一个新的List里面去，起名为deepCopy。最后执行83行进行复制，bw即BeanWrapper，持有Bean实例的一个Bean包装类，看一下代码实现：</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre> 1 public void setPropertyValues(PropertyValues pvs, boolean ignoreUnknown, boolean ignoreInvalid) 2         throws BeansException { 3  4     List<propertyaccessexception> propertyAccessExceptions = null; 5     List<propertyvalue> propertyValues = (pvs instanceof MutablePropertyValues ? 6             ((MutablePropertyValues) pvs).getPropertyValueList() : Arrays.asList(pvs.getPropertyValues())); 7     for (PropertyValue pv : propertyValues) { 8         try { 9             // This method may throw any BeansException, which won't be caught 10             // here, if there is a critical failure such as no matching field. 11             // We can attempt to deal only with less serious exceptions.12 setPropertyValue(pv); 13 } 14         catch (NotWritablePropertyException ex) { 15             if (!ignoreUnknown) { 16                 throw ex; 17 } 18             // Otherwise, just ignore it and continue...19 } 20         catch (NullValueInNestedPathException ex) { 21             if (!ignoreInvalid) { 22                 throw ex; 23 } 24             // Otherwise, just ignore it and continue...25 } 26         catch (PropertyAccessException ex) { 27             if (propertyAccessExceptions == null) { 28                 propertyAccessExceptions = new LinkedList<propertyaccessexception>(); 29 } 30 propertyAccessExceptions.add(ex); 31 } 32 } 33 34     // If we encountered individual exceptions, throw the composite exception.35     if (propertyAccessExceptions != null) { 36         PropertyAccessException[] paeArray =37                 propertyAccessExceptions.toArray(new PropertyAccessException[propertyAccessExceptions.size()]); 38         throw new PropertyBatchUpdateException(paeArray); 39 } 40 }</propertyaccessexception></propertyvalue></propertyaccessexception></pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>这段代码没什么特别的，遍历前面的deepCopy，拿每一个PropertyValue，执行第12行的setPropertyValue：</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre> 1 public void setPropertyValue(PropertyValue pv) throws BeansException { 2     PropertyTokenHolder tokens = (PropertyTokenHolder) pv.resolvedTokens; 3     if (tokens == null) { 4         String propertyName = pv.getName(); 5         BeanWrapperImpl nestedBw; 6         try { 7             nestedBw = getBeanWrapperForPropertyPath(propertyName); 8         } 9         catch (NotReadablePropertyException ex) { 10             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, 11                     "Nested property in path '" + propertyName + "' does not exist", ex); 12 } 13         tokens = getPropertyNameTokens(getFinalPath(nestedBw, propertyName)); 14         if (nestedBw == this) { 15             pv.getOriginalPropertyValue().resolvedTokens = tokens; 16 } 17 nestedBw.setPropertyValue(tokens, pv); 18 } 19     else { 20 setPropertyValue(tokens, pv); 21 } 22 }</pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>找一个合适的BeanWrapper，这里就是自身，然后执行17行的setPropertyValue方法进入最后一步，方法非常长，截取核心的一段：</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre> 1 final Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ? 2     ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : 3     pd.getWriteMethod()); 4     if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) { 5     if (System.getSecurityManager()!= null) { 6         AccessController.doPrivileged(new PrivilegedAction<object>() { 7                 public Object run() { 8                     writeMethod.setAccessible(true); 9                     return null; 10 } 11 }); 12 } 13         else { 14             writeMethod.setAccessible(true); 15 } 16 } 17     final Object value = valueToApply; 18     if (System.getSecurityManager() != null) { 19     try { 20         AccessController.doPrivileged(new PrivilegedExceptionAction<object>() { 21             public Object run() throws Exception { 22 writeMethod.invoke(object, value); 23                 return null; 24 } 25 }, acc); 26 } 27     catch (PrivilegedActionException ex) { 28         throw ex.getException(); 29 } 30 } 31 else { 32     writeMethod.invoke(this.object, value); 33 }                </object></object></pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>大致流程就是两步：</p><p>（1）拿到写方法并将方法的可见性设置为true</p><p>（2）拿到Value值，对Bean通过反射调用写方法</p><p>这样完成了对于Bean属性值的设置。</p><h2 id="Aware注入"><a href="#Aware注入" class="headerlink" title="Aware注入"></a>Aware注入</h2><p>接下来是Aware注入。在使用Spring的时候我们将自己的Bean实现BeanNameAware接口、BeanFactoryAware接口等，依赖容器帮我们注入当前Bean的名称或者Bean工厂，其代码实现先追溯到上面doCreateBean方法的42行initializeBean方法：</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre> 1 protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) { 2     if (System.getSecurityManager() != null) { 3         AccessController.doPrivileged(new PrivilegedAction<object>() { 4             public Object run() { 5                 invokeAwareMethods(beanName, bean); 6                 return null; 7             } 8         }, getAccessControlContext()); 9 } 10     else { 11 invokeAwareMethods(beanName, bean); 12 } 13         14     Object wrappedBean = bean; 15     if (mbd == null || !mbd.isSynthetic()) { 16         wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); 17 } 18 19     try { 20 invokeInitMethods(beanName, wrappedBean, mbd); 21 } 22     catch (Throwable ex) { 23         throw new BeanCreationException( 24                 (mbd != null ? mbd.getResourceDescription() : null), 25                 beanName, "Invocation of init method failed", ex); 26 } 27 28     if (mbd == null || !mbd.isSynthetic()) { 29         wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); 30 } 31     return wrappedBean; 32 }</object></pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>看一下上面第5行的实现：</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre> 1 private void invokeAwareMethods(final String beanName, final Object bean) { 2     if (bean instanceof BeanNameAware) { 3         ((BeanNameAware) bean).setBeanName(beanName); 4     } 5     if (bean instanceof BeanClassLoaderAware) { 6         ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader()); 7     } 8     if (bean instanceof BeanFactoryAware) { 9         ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this); 10 } 11 }</pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>看到这里判断，如果bean是BeanNameAware接口的实现类会调用setBeanName方法、如果bean是BeanClassLoaderAware接口的实现类会调用setBeanClassLoader方法、如果是BeanFactoryAware接口的实现类会调用setBeanFactory方法，注入对应的属性值。</p><p>调用BeanPostProcessor的postProcessBeforeInitialization方法</p><p>上面initializeBean方法再看16行其实现：</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre> 1 public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) 2         throws BeansException { 3  4     Object result = existingBean; 5     for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) { 6         result = beanProcessor.postProcessBeforeInitialization(result, beanName); 7         if (result == null) { 8             return result; 9 } 10 } 11     return result; 12 }</pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>遍历每个BeanPostProcessor接口实现，调用postProcessBeforeInitialization方法，这个接口的调用时机之后会总结，这里就代码先简单提一下。</p><h2 id="调用初始化方法"><a href="#调用初始化方法" class="headerlink" title="调用初始化方法"></a>调用初始化方法</h2><p>initializeBean方法的20行，调用Bean的初始化方法，看一下实现：</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre> 1 protected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd) 2         throws Throwable { 3  4     boolean isInitializingBean = (bean instanceof InitializingBean); 5     if (isInitializingBean && (mbd == null || !mbd.isExternallyManagedInitMethod("afterPropertiesSet"))) { 6         if (logger.isDebugEnabled()) { 7             logger.debug("Invoking afterPropertiesSet() on bean with name '" + beanName + "'"); 8         } 9         if (System.getSecurityManager() != null) { 10             try { 11                 AccessController.doPrivileged(new PrivilegedExceptionAction<object>() { 12                     public Object run() throws Exception { 13 ((InitializingBean) bean).afterPropertiesSet(); 14                         return null; 15 } 16 }, getAccessControlContext()); 17 } 18             catch (PrivilegedActionException pae) { 19                 throw pae.getException(); 20 } 21 } 22         else { 23 ((InitializingBean) bean).afterPropertiesSet(); 24 } 25 } 26 27     if (mbd != null) { 28         String initMethodName = mbd.getInitMethodName(); 29         if (initMethodName != null && !(isInitializingBean && "afterPropertiesSet".equals(initMethodName)) &&30                     !mbd.isExternallyManagedInitMethod(initMethodName)) { 31 invokeCustomInitMethod(beanName, bean, mbd); 32 } 33 } 34 }</object></pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>看到，代码做了两件事情：</p><p>1、先判断Bean是否InitializingBean的实现类，是的话，将Bean强转为InitializingBean，直接调用afterPropertiesSet()方法</p><p>2、尝试去拿init-method，假如有的话，通过反射，调用initMethod</p><p>因此，两种方法各有优劣：使用实现InitializingBean接口的方式效率更高一点，因为init-method方法是通过反射进行调用的；从另外一个角度讲，使用init-method方法之后和Spring的耦合度会更低一点。具体使用哪种方式调用初始化方法，看个人喜好。</p><p>调用BeanPostProcessor的postProcessAfterInitialization方法</p><p>最后一步，initializeBean方法的29行：</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre> 1 public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) 2         throws BeansException { 3  4     Object result = existingBean; 5     for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) { 6         result = beanProcessor.postProcessAfterInitialization(result, beanName); 7         if (result == null) { 8             return result; 9 } 10 } 11     return result; 12 }</pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>同样遍历BeanPostProcessor，调用postProcessAfterInitialization方法。因此对于BeanPostProcessor方法总结一下：</p><p>1、在初始化每一个Bean的时候都会调用每一个配置的BeanPostProcessor的方法</p><p>2、在Bean属性设置、Aware设置后调用postProcessBeforeInitialization方法</p><p>3、在初始化方法调用后调用postProcessAfterInitialization方法</p><p>注册需要执行销毁方法的Bean</p><p>接下来看一下最上面doCreateBean方法的第83行registerDisposableBeanIfNecessary(beanName, bean, mbd)这一句，完成了创建Bean的最后一件事情：注册需要执行销毁方法的Bean。</p><p>看一下方法的实现：</p><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><pre> 1 protected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) { 2     AccessControlContext acc = (System.getSecurityManager() != null ? getAccessControlContext() : null); 3     if (!mbd.isPrototype() && requiresDestruction(bean, mbd)) { 4         if (mbd.isSingleton()) { 5             // Register a DisposableBean implementation that performs all destruction 6             // work for the given bean: DestructionAwareBeanPostProcessors, 7             // DisposableBean interface, custom destroy method. 8             registerDisposableBean(beanName, 9                     new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc)); 10 } 11         else { 12             // A bean with a custom scope...13             Scope scope = this.scopes.get(mbd.getScope()); 14             if (scope == null) { 15                 throw new IllegalStateException("No Scope registered for scope '" + mbd.getScope() + "'"); 16 } 17 scope.registerDestructionCallback(beanName, 18                     new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc)); 19 } 20 } 21 }</pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>其中第3行第一个判断为必须不是prototype（原型）的，第二个判断requiresDestruction方法的实现为：</p><pre>1 protected boolean requiresDestruction(Object bean, RootBeanDefinition mbd) { 2     return (bean != null &&3             (bean instanceof DisposableBean || mbd.getDestroyMethodName() != null ||4 hasDestructionAwareBeanPostProcessors())); 5 }</pre><p>要注册销毁方法，Bean需要至少满足以下三个条件之一：</p><p>（1）Bean是DisposableBean的实现类，此时执行DisposableBean的接口方法destroy()</p><p>（2）Bean标签中有配置destroy-method属性，此时执行destroy-method配置指定的方法</p><p>（3）当前Bean对应的BeanFactory中持有DestructionAwareBeanPostProcessor接口的实现类，此时执行DestructionAwareBeanPostProcessor的接口方法postProcessBeforeDestruction</p><p>在满足上面三个条件之一的情况下，容器便会注册销毁该Bean，注册Bean的方法很简单，见registerDisposableBean方法实现：</p><pre>1 public void registerDisposableBean(String beanName, DisposableBean bean) { 2     synchronized (this.disposableBeans) { 3         this.disposableBeans.put(beanName, bean); 4 } 5 }</pre><p>容器销毁的时候，会遍历disposableBeans，逐一执行销毁方法。</p><h2 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h2><p>本文和上篇文章分析了Spring Bean初始化的步骤，最后用一幅图总结一下Spring Bean初始化的流程：</p><p><img src="https://images2015.cnblogs.com/blog/801753/201702/801753-20170204111521089-1301937796.png" alt=""></p><p>图只是起梳理流程作用，抛砖引玉，具体代码实现还需要网友朋友们照着代码自己去一步一步分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自&lt;a href=&quot;https://www.cnblogs.com/xrq730/p/6285358.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【Spring源码分析】Bean加载流程概览&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Spring源码解析 &lt;a href=&quot;https://blog.csdn.net/column/details/21851.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21851.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Spring" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Spring/"/>
    
    
      <category term="Spring" scheme="http://h2pl.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码剖析2：Spring IOC容器的加载过程</title>
    <link href="http://h2pl.github.io/2018/06/02/spring2/"/>
    <id>http://h2pl.github.io/2018/06/02/spring2/</id>
    <published>2018-06-02T14:27:48.000Z</published>
    <updated>2018-06-11T14:29:28.998Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Spring源码解析 <a href="https://blog.csdn.net/column/details/21851.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21851.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a><br>://github.com/h2pl/</p><a id="more"></a><h1 id="spring-ioc-容器的加载流程"><a href="#spring-ioc-容器的加载流程" class="headerlink" title="spring ioc 容器的加载流程"></a>spring ioc 容器的加载流程</h1><p><strong>1.目标：</strong>熟练使用spring，并分析其源码，了解其中的思想。这篇主要介绍spring ioc 容器的加载</p><p><strong>2.前提条件：</strong>会使用debug</p><p><strong>3.源码分析方法：</strong>Intellj idea debug 模式下源码追溯<br>通过ClassPathXmlApplicationContext 进行xml 件的读取，从每个堆栈中读取程序的运行信息</p><p><strong>4.注意：</strong>由于Spring的类继承体系比较复杂,不能全部贴图，所以只将分析源码之后发现的最主要的类继承结构类图贴在下方。</p><p><strong>5.关于Spring Ioc<br>Demo：</strong>我们从demo入手一步步进行代码追溯。</p><h2 id="Spring-Ioc-Demo"><a href="#Spring-Ioc-Demo" class="headerlink" title="Spring Ioc Demo"></a>Spring Ioc Demo</h2><hr><blockquote><p>1.定义数据访问接口IUserDao.java</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>IUserDao &#123;  </span><br><span class="line">    public void InsertUser(String username,String password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.定义IUserDao.java实现类IUserDaoImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">IUserDao</span> </span>&#123;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertUser</span><span class="params">(String username, String password)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"----UserDaoImpl --addUser----"</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.定义业务逻辑接口UserService.java</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>UserService &#123;    </span><br><span class="line">    public void addUser(String username,String password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.定义UserService.java实现类UserServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span>     IUserDao  userDao;    <span class="comment">//set方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setUserDao</span><span class="params">(IUserDao  userDao)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;   </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(String username,String password)</span> </span>&#123; </span><br><span class="line">        userDao.InsertUser(username,password);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bean.xml配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>  </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>    </span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans  </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd         "</span>&gt;</span>  </span><br><span class="line"> <span class="comment">&lt;!--id名字自己取，class表示他代表的类，如果在包里的话需要加上包名--&gt;</span>    </span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span>  <span class="attr">class</span>=<span class="string">"UserServiceImpl"</span> &gt;</span>      </span><br><span class="line">        <span class="comment">&lt;!--property代表是通过set方法注入,ref的值表示注入的内容--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>  <span class="attr">name</span>=<span class="string">"userDao"</span>  <span class="attr">ref</span>=<span class="string">"userDao"</span>/&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span>  <span class="attr">class</span>=<span class="string">"UserDaoImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="ApplicationContext-继承结构"><a href="#ApplicationContext-继承结构" class="headerlink" title="ApplicationContext 继承结构"></a>ApplicationContext 继承结构</h2><hr><blockquote><p>1.顶层接口：ApplicationContext<br>2.ClassPathXmlApplicationContext实现类继承AbstractXmlApplication 抽象类<br>3.AbstractXmlApplication 继承AbstractRefreshableConfigApplicationContext<br>4.AbstractRefreshableConfigApplicationContext抽象类继承AbstractRefreshableApplicationContext<br>5.AbstractRefreshableApplicationContext 继承 AbstractApplicationContext<br>6.AbstractApplicationContext 实现ConfigurableApplicationContext 接口<br>7.ConfigurableApplicationContext 接口继承<br>ApplicationContext接口<br>总体来说继承实现结构较深，内部使用了大量适配器模式。<br>以ClassPathXmlApplicationContext为例，继承类图如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/2836699-357e2bd46ff6f5fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p></blockquote><h2 id="Spring-Ioc容器加载过程源码详解"><a href="#Spring-Ioc容器加载过程源码详解" class="headerlink" title="Spring Ioc容器加载过程源码详解"></a>Spring Ioc容器加载过程源码详解</h2><hr><p>在开始之前，先介绍一个整体的概念。即spring ioc容器的加载，大体上经过以下几个过程：<br>资源文件定位、解析、注册、实例化</p><blockquote><p><strong>1.资源文件定位</strong><br>其中资源文件定位，一般是在ApplicationContext的实现类里完成的，因为ApplicationContext接口继承ResourcePatternResolver 接口，ResourcePatternResolver接口继承ResourceLoader接口，ResourceLoader其中的getResource()方法，可以将外部的资源，读取为Resource类。</p></blockquote><hr><p><strong>2.解析</strong>DefaultBeanDefinitionDocumentReader，<br>解析主要是在BeanDefinitionReader中完成的，最常用的实现类是XmlBeanDefinitionReader，其中的loadBeanDefinitions()方法，负责读取Resource，并完成后续的步骤。ApplicationContext完成资源文件定位之后，是将解析工作委托给XmlBeanDefinitionReader来完成的<br>解析这里涉及到很多步骤，最常见的情况，资源文件来自一个XML配置文件。首先是BeanDefinitionReader，将XML文件读取成w3c的Document文档。<br>DefaultBeanDefinitionDocumentReader对Document进行进一步解析。然后DefaultBeanDefinitionDocumentReader又委托给BeanDefinitionParserDelegate进行解析。如果是标准的xml namespace元素，会在Delegate内部完成解析，如果是非标准的xml namespace元素，则会委托合适的NamespaceHandler进行解析最终解析的结果都封装为BeanDefinitionHolder，至此解析就算完成。<br><strong>后续会进行细致讲解。</strong></p><hr><p><strong>3.注册</strong><br>然后bean的注册是在BeanFactory里完成的，BeanFactory接口最常见的一个实现类是DefaultListableBeanFactory，它实现了BeanDefinitionRegistry接口，所以其中的registerBeanDefinition()方法，可以对BeanDefinition进行注册这里附带一提，最常见的XmlWebApplicationContext不是自己持有BeanDefinition的，它继承自AbstractRefreshableApplicationContext，其持有一个DefaultListableBeanFactory的字段，就是用它来保存BeanDefinition<br>所谓的注册，其实就是将BeanDefinition的name和实例，保存到一个Map中。刚才说到，最常用的实现DefaultListableBeanFactory，其中的字段就是beanDefinitionMap，是一个ConcurrentHashMap。<br>代码如下：<br><strong>&gt;1.DefaultListableBeanFactory继承实现关系</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DefaultListableBeanFactory</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> </span></span><br><span class="line"><span class="class"><span class="title">AbstractAutowireCapableBeanFactory</span>   </span></span><br><span class="line"><span class="class"><span class="keyword">implements</span></span></span><br><span class="line"><span class="class"><span class="title">ConfigurableListableBeanFactory</span>, </span></span><br><span class="line"><span class="class"><span class="title">BeanDefinitionRegistry</span>,</span></span><br><span class="line"><span class="class"><span class="title">Serializable</span> </span>&#123; </span><br><span class="line">     <span class="comment">// DefaultListableBeanFactory的实例中最终保存了所有注册的bean    beanDefinitionMap</span></span><br><span class="line">     <span class="comment"><span class="markdown">/<span class="emphasis">** Map of bean definition objects, keyed by bean name *</span>/</span></span></span><br><span class="line">     private <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, BeanDefinition&gt; beanDefinitionMap </span><br><span class="line">     = <span class="keyword">new</span> ConcurrentHashMap&lt;<span class="built_in">String</span>, BeanDefinition&gt;(<span class="number">64</span>); </span><br><span class="line">     <span class="comment">//实现BeanDefinitionRegistry中定义的registerBeanDefinition()抽象方法</span></span><br><span class="line">     public <span class="keyword">void</span> registerBeanDefinition(<span class="built_in">String</span> beanName, BeanDefinition    beanDefinition)      throws BeanDefinitionStoreException &#123;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p><strong>&gt;2.BeanDefinitionRegistry接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistry</span> <span class="keyword">extends</span> <span class="title">AliasRegistry</span> </span>&#123;   </span><br><span class="line">    <span class="comment">//定义注册BeanDefinition实例的抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span>         <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br></pre></td></tr></table></figure><p><strong>4.实例化</strong></p><hr><p>注册也完成之后，在BeanFactory的getBean()方法之中，会完成初始化，也就是依赖注入的过程<br>大体上的流程就是这样。</p><h1 id="refresh-方法"><a href="#refresh-方法" class="headerlink" title="refresh()方法"></a>refresh()方法</h1><blockquote><p><strong>1.目标：</strong><br>这篇记录debug 追溯源码的过程，大概分三个篇幅，这是第一篇，现整体了解一下运行流程，定位资源加载，资源解析，bean 注册发生的位置。<br>2.<strong>记录结构：</strong><br>1.调试栈截图<br>2.整体流程<br>3.bean.xml的处理<br><strong>每段代码下面有相应的讲解</strong></p></blockquote><h2 id="调试栈截图"><a href="#调试栈截图" class="headerlink" title="调试栈截图"></a>调试栈截图</h2><hr><p><img src="https://upload-images.jianshu.io/upload_images/2836699-f869abb0045bb989.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p><p>每个栈帧中方法的行号都有标明，按照行号追溯源码，然后配合教程能够快速学习。</p><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><hr><p>ioc容器实例化代码</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ApplicationContext applicationContext</span> = new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br></pre></td></tr></table></figure><p>进入代码中一步步追溯，发现重要方法：refresh();<br>如下所示：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">            <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">            prepareRefresh();</span><br><span class="line">            <span class="comment">//beanFactory实例化方法 单步调试入口</span></span><br><span class="line">            <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">            prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">                postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">                invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">                registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">                initMessageSource();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">                initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">                onRefresh();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">                registerListeners();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">                finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">                finishRefresh();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">                destroyBeans();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">                cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先这个方法是同步的，以避免重复刷新。然后刷新的每个步骤，都放在单独的方法里，比较清晰，可以按顺序一个个看</p><p>首先是prepareRefresh()方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> void prepareRefresh() &#123;</span><br><span class="line">        <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        synchronized (<span class="keyword">this</span>.activeMonitor) &#123;</span><br><span class="line">            <span class="keyword">this</span>.active = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize any placeholder property sources in the context environment</span></span><br><span class="line">        initPropertySources();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Validate that all properties marked as required are resolvable</span></span><br><span class="line">        <span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line">        <span class="keyword">this</span>.environment.validateRequiredProperties();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法里做的事情不多，记录了开始时间，输出日志，另外initPropertySources()方法和validateRequiredProperties()方法一般都没有做什么事。</p><p>然后是核心的obtainFreshBeanFactory()方法，这个方法是初始化BeanFactory，是整个refresh()方法的核心，其中完成了配置文件的加载、解析、注册，后面会专门详细说 。</p><p>这里要说明一下，ApplicationContext实现了BeanFactory接口，并实现了ResourceLoader、MessageSource等接口，可以认为是增强的BeanFactory。但是ApplicationContext并不自己重复实现BeanFactory定义的方法，而是委托给DefaultListableBeanFactory来实现。这种设计思路也是值得学习的。<br>后面的 prepareBeanFactory()、postProcessBeanFactory()、invokeBeanFactoryPostProcessors()、registerBeanPostProcessors()、initMessageSource()、initApplicationEventMulticaster()、onRefresh()、registerListeners()、finishBeanFactoryInitialization()、finishRefresh()等方法，是添加一些后处理器、广播、拦截器等，就不一个个细说了</p><p>其中的关键方法是finishBeanFactoryInitialization()，在这个方法中，会对刚才注册的Bean（不延迟加载的），进行实例化，所以也是一个核心方法。</p><h2 id="bean-xml的处理"><a href="#bean-xml的处理" class="headerlink" title="bean.xml的处理"></a>bean.xml的处理</h2><hr><p>从整体上介绍完了流程，接下来就重点看obtainFreshBeanFactory()方法，上文说到，在这个方法里，完成了配置文件的加载、解析、注册</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;</span><br><span class="line">        refreshBeanFactory()<span class="comment">;</span></span><br><span class="line">        ConfigurableListableBeanFactory <span class="keyword">beanFactory </span>= getBeanFactory()<span class="comment">;</span></span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + <span class="keyword">beanFactory);</span></span><br><span class="line"><span class="keyword"> </span>       &#125;</span><br><span class="line">        return <span class="keyword">beanFactory;</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br></pre></td></tr></table></figure><p>这个方法做了2件事，首先通过refreshBeanFactory()方法，创建了DefaultListableBeanFactory的实例，并进行初始化。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">            destroyBeans();</span><br><span class="line">            closeBeanFactory();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">            beanFactory.setSerializationId(getId());</span><br><span class="line">            customizeBeanFactory(beanFactory);</span><br><span class="line">            loadBeanDefinitions(beanFactory);</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先如果已经有BeanFactory实例，就先清空。然后通过createBeanFactory()方法，创建一个DefaultListableBeanFactory的实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DefaultListableBeanFactory <span class="title">createBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultListableBeanFactory(getInternalParentBeanFactory());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接下来设置ID唯一标识</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.setSerializationId(getId())<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>然后允许用户进行一些自定义的配置</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> void customizeBeanFactory(DefaultListableBeanFactory beanFactory) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.allowBeanDefinitionOverriding != <span class="literal">null</span>) &#123;</span><br><span class="line">            beanFactory.setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.allowCircularReferences != <span class="literal">null</span>) &#123;</span><br><span class="line">            beanFactory.setAllowCircularReferences(<span class="keyword">this</span>.allowCircularReferences);</span><br><span class="line">        &#125;</span><br><span class="line">        beanFactory.setAutowireCandidateResolver(new QualifierAnnotationAutowireCandidateResolver());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后，就是核心的loadBeanDefinitions()方法</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Configure the bean definition reader with this context's</span></span><br><span class="line">        <span class="comment">// resource loading environment.</span></span><br><span class="line">        beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">        beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">        beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">        <span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">        initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">        loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里首先会创建一个XmlBeanDefinitionReader的实例，然后进行初始化。这个XmlBeanDefinitionReader中其实传递的BeanDefinitionRegistry类型的实例，为什么可以传递一个beanFactory呢，因为DefaultListableBeanFactory实现了BeanDefinitionRegistry接口，这里是多态的使用。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Configure the bean definition reader with this context's</span></span><br><span class="line">        <span class="comment">// resource loading environment.</span></span><br><span class="line">        beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">        beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">        beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">        <span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">        initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要说明一下，ApplicationContext并不自己负责配置文件的加载、解析、注册，而是将这些工作委托给XmlBeanDefinitionReader来做。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadBeanDefinitions(<span class="name">beanDefinitionReader</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这行代码，就是Bean定义读取实际发生的地方。这里的工作，主要是XmlBeanDefinitionReader来完成的，下一篇博客会详细介绍这个过程。</p><h1 id="loadBeanDefinitions"><a href="#loadBeanDefinitions" class="headerlink" title="loadBeanDefinitions"></a>loadBeanDefinitions</h1><h2 id="loadBeanDefinitions-源码阅读"><a href="#loadBeanDefinitions-源码阅读" class="headerlink" title="loadBeanDefinitions: 源码阅读"></a>loadBeanDefinitions: 源码阅读</h2><hr><p>入口是loadBeanDefinitions方法</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> loadBeanDefinitions(XmlBeanDefinitionReader reader) </span><br><span class="line"><span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">String</span>[] configLocations = getConfigLocations();</span><br><span class="line">        <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">String</span> configLocation : configLocations) &#123;</span><br><span class="line">                reader.loadBeanDefinitions(configLocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是解析过程最外围的代码，首先要获取到配置文件的路径，这在之前已经完成了。<br>然后将每个配置文件的路径，作为参数传给BeanDefinitionReader的loadBeanDefinitions方法里</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">loadBeanDefinitions</span><span class="params">(location, <span class="keyword">null</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法又调用了重载方法</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> loadBeanDefinitions(<span class="keyword">String</span> location, Set&lt;Resource&gt; actualResources) </span><br><span class="line"><span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">        ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">        <span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                    <span class="string">"Cannot import bean definitions from location ["</span> + location + <span class="string">"]: no ResourceLoader available"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">            <span class="comment">// Resource pattern matching available.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">                <span class="built_in">int</span> loadCount = loadBeanDefinitions(resources);</span><br><span class="line">                <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">                        actualResources.<span class="built_in">add</span>(resource);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Loaded "</span> + loadCount + <span class="string">" bean definitions from location pattern ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> loadCount;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                        <span class="string">"Could not resolve bean definition resource pattern ["</span> + location + <span class="string">"]"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Can only load single resources by absolute URL.</span></span><br><span class="line">            Resource resource = resourceLoader.getResource(location);</span><br><span class="line">            <span class="built_in">int</span> loadCount = loadBeanDefinitions(resource);</span><br><span class="line">            <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">                actualResources.<span class="built_in">add</span>(resource);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Loaded "</span> + loadCount + <span class="string">" bean definitions from location ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> loadCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先getResourceLoader()的实现的前提条件是因为XmlBeanDefinitionReader在实例化的时候已经确定了创建了实例ResourceLoader实例, 代码位于 AbstractBeanDefinitionReader</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> AbstractBeanDefinitionReader(BeanDefinitionRegistry registry) &#123;   </span><br><span class="line">     Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>); </span><br><span class="line">     <span class="keyword">this</span>.registry = registry;   </span><br><span class="line">     <span class="comment">// Determine ResourceLoader to use.  </span></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.registry instanceof ResourceLoader) &#123;     </span><br><span class="line">         <span class="keyword">this</span>.resourceLoader = (ResourceLoader) <span class="keyword">this</span>.registry;   </span><br><span class="line">      &#125;  <span class="keyword">else</span> &#123;      </span><br><span class="line">         <span class="keyword">this</span>.resourceLoader = new PathMatchingResourcePatternResolver();  </span><br><span class="line">      &#125;   </span><br><span class="line">     <span class="comment">// Inherit Environment if possible   </span></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.registry instanceof EnvironmentCapable) &#123;      </span><br><span class="line">          <span class="keyword">this</span>.environment = ((EnvironmentCapable)<span class="keyword">this</span>.registry).getEnvironment();  </span><br><span class="line">      &#125;  <span class="keyword">else</span> &#123;      </span><br><span class="line">          <span class="keyword">this</span>.environment = new StandardEnvironment(); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法比较长，BeanDefinitionReader不能直接加载配置文件，需要把配置文件封装成Resource，然后才能调用重载方法loadBeanDefinitions()。所以这个方法其实就是2段，第一部分是委托ResourceLoader将配置文件封装成Resource，第二部分是调用loadBeanDefinitions()，对Resource进行解析</p><p>而这里的ResourceLoader，就是前面的XmlWebApplicationContext，因为ApplicationContext接口，是继承自ResourceLoader接口的</p><p>Resource也是一个接口体系，在web环境下，这里就是ServletContextResource</p><p>接下来进入重载方法loadBeanDefinitions()</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int loadBeanDefinitions(Resource<span class="built_in">..</span>. resources) throws BeanDefinitionStoreException &#123;</span><br><span class="line">        Assert.notNull(resources, <span class="string">"Resource array must not be null"</span>);</span><br><span class="line">        int counter = 0;</span><br><span class="line">        <span class="keyword">for</span> (Resource<span class="built_in"> resource </span>: resources) &#123;</span><br><span class="line">            counter += loadBeanDefinitions(resource);</span><br><span class="line">        &#125;</span><br><span class="line">        return counter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里就不用说了，就是把每一个Resource作为参数，继续调用重载方法。读spring源码，会发现重载方法特别多。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> loadBeanDefinitions(Resource resource)  <span class="keyword">throws</span></span><br><span class="line"> BeanDefinitionStoreException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是重载方法，不过这里对传进来的Resource又进行了一次封装，变成了编码后的Resource。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span>(<span class="params">EncodedResource encodedResource</span>) </span></span><br><span class="line"><span class="function">throws BeanDefinitionStoreException </span>&#123;</span><br><span class="line">        Assert.notNull(encodedResource, <span class="string">"EncodedResource must not be null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Loading XML bean definitions from "</span> + encodedResource.getResource());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.<span class="keyword">get</span>();</span><br><span class="line">        <span class="keyword">if</span> (currentResources == <span class="literal">null</span>) &#123;</span><br><span class="line">            currentResources = <span class="keyword">new</span> HashSet&lt;EncodedResource&gt;(<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.<span class="keyword">set</span>(currentResources);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!currentResources.<span class="keyword">add</span>(encodedResource)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                    <span class="string">"Detected cyclic loading of "</span> + encodedResource + <span class="string">" - check your import definitions!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">                <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="literal">null</span>) &#123;</span><br><span class="line">                    inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                    <span class="string">"IOException parsing XML document from "</span> + encodedResource.getResource(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            currentResources.<span class="keyword">remove</span>(encodedResource);</span><br><span class="line">            <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.<span class="keyword">remove</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个就是loadBeanDefinitions()的最后一个重载方法，比较长，可以拆看来看。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Assert.notNull(encodedResource, <span class="string">"EncodedResource must not be null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Loading XML bean definitions from "</span> + encodedResource.getResource());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;EncodedResource&gt; currentResources = <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.<span class="keyword">get</span>();</span><br><span class="line">        <span class="keyword">if</span> (currentResources == <span class="literal">null</span>) &#123;</span><br><span class="line">            currentResources = <span class="keyword">new</span> <span class="type">HashSet</span>&lt;EncodedResource&gt;(<span class="number">4</span>);</span><br><span class="line">            <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.<span class="keyword">set</span>(currentResources);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">BeanDefinitionStoreException</span>(</span><br><span class="line">                    <span class="string">"Detected cyclic loading of "</span> + encodedResource + <span class="string">" - check your import definitions!"</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这第一部分，是处理线程相关的工作，把当前正在解析的Resource，设置为当前Resource。</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">InputSource</span> inputSource = <span class="function"><span class="keyword">new</span> <span class="title">InputSource</span>(inputStream);</span></span><br><span class="line"><span class="function">                <span class="title">if</span> (encodedResource.getEncoding() != <span class="title">null</span>) &#123;</span></span><br><span class="line"><span class="function">                    <span class="title">inputSource</span>.<span class="title">setEncoding</span>(encodedResource.getEncoding());</span></span><br><span class="line"><span class="function">                &#125;</span></span><br><span class="line"><span class="function">                <span class="title">return</span> <span class="title">doLoadBeanDefinitions</span>(inputSource, encodedResource.getResource());</span></span><br><span class="line"><span class="function">            &#125;</span></span><br><span class="line"><span class="function">            <span class="title">finally</span> &#123;</span></span><br><span class="line"><span class="function">                <span class="title">inputStream</span>.<span class="title">close</span>();</span></span><br><span class="line"><span class="function">            &#125;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br></pre></td></tr></table></figure><p>这里是第二部分，是核心，首先把Resource还原为InputStream，然后调用实际解析的方法doLoadBeanDefinitions()。<strong>可以看到，这种命名方式是很值得学习的，一种业务方法，比如parse()，可能需要做一些外围的工作，然后实际解析的方法，可以命名为doParse()。这种doXXX()的命名方法，在很多开源框架中都有应用，比如logback等。</strong><br>接下来就看一下这个doLoadBeanDefinitions()方法</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">protected int doLoadBeanDefinitions(InputSource inputSource,<span class="built_in"> Resource </span>resource)</span><br><span class="line">            throws BeanDefinitionStoreException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Document doc = doLoadDocument(inputSource, resource);return registerBeanDefinitions(doc, resource);</span><br><span class="line">            return registerBeanDefinitions(doc, resource);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            throw ex;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (SAXParseException ex) &#123;</span><br><span class="line">            throw new XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                    <span class="string">"Line "</span> + ex.getLineNumber() + <span class="string">" in XML document from "</span> +<span class="built_in"> resource </span>+ <span class="string">" is invalid"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (SAXException ex) &#123;</span><br><span class="line">            throw new XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                    <span class="string">"XML document from "</span> +<span class="built_in"> resource </span>+ <span class="string">" is invalid"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (ParserConfigurationException ex) &#123;</span><br><span class="line">            throw new BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                    <span class="string">"Parser configuration exception parsing XML from "</span> + resource, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (IOException ex) &#123;</span><br><span class="line">            throw new BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                    <span class="string">"IOException parsing XML document from "</span> + resource, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable ex) &#123;</span><br><span class="line">            throw new BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                    <span class="string">"Unexpected exception parsing XML document from "</span> + resource, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>抛开异常处理：核心代码如下：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Document doc = doLoadDocument(<span class="name">inputSource</span>, resource)<span class="comment">;</span></span><br><span class="line">return  registerBeanDefinitions(<span class="name">doc</span>, resource)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>doLoadDocument方法将InputStream读取成标准的Document对象，然后调用registerBeanDefinitions()，进行解析工作。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected Document doLoadDocument(InputSource inputSource,<span class="built_in"> Resource </span>resource) throws Exception &#123;   </span><br><span class="line">    return this.documentLoader.loadDocument(inputSource,  </span><br><span class="line">                                            getEntityResolver(), this.errorHandler,  </span><br><span class="line">                                            getValidationModeForResource(resource),  </span><br><span class="line">                                            isNamespaceAware());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就看一下这个核心方法registerBeanDefinitions</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">        <span class="comment">//创建的其实是DefaultBeanDefinitionDocumentReader 的实例，利用反射创建的。</span></span><br><span class="line">        BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">        documentReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">        <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">        documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">        <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里注意两点 :</strong></p><blockquote><p><strong>1.Document对象</strong><br>首先这个Document对象，是W3C定义的标准XML对象，跟spring无关。其次这个registerBeanDefinitions方法，我觉得命名有点误导性。因为这个时候实际上解析还没有开始，怎么直接就注册了呢。比较好的命名，我觉得可以是parseAndRegisterBeanDefinitions()。<br><strong>2.documentReader的创建时使用反射创建的，代码如下</strong></p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> BeanDefinitionDocumentReader    </span><br><span class="line"> createBeanDefinitionDocumentReader() &#123;   </span><br><span class="line">          <span class="keyword">return</span> BeanDefinitionDocumentReader.<span class="keyword">class</span>.cast(BeanUtils.</span><br><span class="line">            instantiateClass(<span class="keyword">this</span>.documentReaderClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>instantiateClass方法中传入了一个Class类型的参数。追溯发现下述代码：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">Class</span>&lt;?&gt; documentReaderClass = </span><br><span class="line">DefaultBeanDefinitionDocumentReader.<span class="keyword">class</span>;</span><br></pre></td></tr></table></figure><p>所以创建的documentReaderClass是DefaultBeanDefinitionDocumentReader类的实例。<br>接下来就进入BeanDefinitionDocumentReader 中定义的registerBeanDefinitions()方法看看</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">        logger.debug(<span class="string">"Loading bean definitions"</span>);</span><br><span class="line">        Element root = doc.getDocumentElement();</span><br><span class="line">        doRegisterBeanDefinitions(root);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>处理完外围事务之后，进入doRegisterBeanDefinitions()方法，这种命名规范，上文已经介绍过了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> void doRegisterBeanDefinitions(Element root) &#123;</span><br><span class="line">        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">            Assert.state(<span class="keyword">this</span>.environment != <span class="literal">null</span>, <span class="string">"environment property must not be null"</span>);</span><br><span class="line">            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.environment.acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line">        <span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line">        <span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line">        <span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line">        <span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line">        <span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line">        BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">        <span class="keyword">this</span>.delegate = createHelper(readerContext, root, parent);</span><br><span class="line">        preProcessXml(root);</span><br><span class="line">        parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">        postProcessXml(root);</span><br><span class="line">        <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法也比较长，拆开来看</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">            Assert.state(<span class="keyword">this</span>.environment != <span class="literal">null</span>, <span class="string">"environment property must not be null"</span>);</span><br><span class="line">            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.environment.acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果配置文件中元素，配有profile属性，就会进入这一段，不过一般都是不会的</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.<span class="keyword">delegate</span>;</span><br><span class="line"><span class="keyword">this</span>.<span class="keyword">delegate</span> = createHelper(readerContext, root, parent);</span><br><span class="line">preProcessXml(root);</span><br><span class="line">parseBeanDefinitions(root, <span class="keyword">this</span>.<span class="keyword">delegate</span>);</span><br><span class="line">postProcessXml(root);</span><br><span class="line"><span class="keyword">this</span>.<span class="keyword">delegate</span> = parent;</span><br></pre></td></tr></table></figure><p>然后这里创建了BeanDefinitionParserDelegate对象，preProcessXml()和postProcessXml()都是空方法，核心就是parseBeanDefinitions()方法。这里又把BeanDefinition解析和注册的工作，委托给了BeanDefinitionParserDelegate对象，在parseBeanDefinitions()方法中完成<br>总的来说，解析工作的委托链是这样的：ClassPathXmlApplicationContext，XmlBeanDefinitionReader，DefaultBeanDefinitionDocumentReader，BeanDefinitionParserDelegate<br>ClassPathXmlApplicationContext作为最外围的组件，发起解析的请求<br>XmlBeanDefinitionReader将配置文件路径封装为Resource，读取出w3c定义的Document对象，然后委托给DefaultBeanDefinitionDocumentReader<br>DefaultBeanDefinitionDocumentReader就开始做实际的解析工作了，但是涉及到bean的具体解析，它还是会继续委托给BeanDefinitionParserDelegate来做。<br>接下来在parseBeanDefinitions()方法中发生了什么，以及BeanDefinitionParserDelegate类完成的工作，在下一篇博客中继续介绍。</p><h1 id="loadBeanDefinitions-1"><a href="#loadBeanDefinitions-1" class="headerlink" title="loadBeanDefinitions"></a>loadBeanDefinitions</h1><blockquote><p>BeanDefinition的解析,已经走到了DefaultBeanDefinitionDocumentR<br>eader里，这时候配置文件已经被加载，并解析成w3c的Document对象。这篇博客就接着介绍，DefaultBeanDefinitionDocumentReader和BeanDefinitionParserDelegate类，是怎么协同完成bean的解析和注册的。</p></blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.<span class="keyword">delegate</span>;</span><br><span class="line"><span class="keyword">this</span>.<span class="keyword">delegate</span> = createHelper(readerContext, root, parent);</span><br><span class="line">preProcessXml(root);</span><br><span class="line">parseBeanDefinitions(root, <span class="keyword">this</span>.<span class="keyword">delegate</span>);</span><br><span class="line">postProcessXml(root);</span><br><span class="line"><span class="keyword">this</span>.<span class="keyword">delegate</span> = parent;</span><br></pre></td></tr></table></figure><p>这段代码，创建了一个BeanDefinitionParserDelegate组件，然后就是preProcessXml()、parseBeanDefinitions()、postProcessXml()方法<br>其中preProcessXml()和postProcessXml()默认是空方法，接下来就看下parseBeanDefinitions()方法</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span>(<span class="params">Element root, BeanDefinitionParserDelegate <span class="keyword">delegate</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">delegate</span>.isDefaultNamespace(root)) &#123;</span><br><span class="line">            NodeList nl = root.getChildNodes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">                Node node = nl.item(i);</span><br><span class="line">                <span class="keyword">if</span> (node instanceof Element) &#123;</span><br><span class="line">                    Element ele = (Element) node;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">delegate</span>.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                        parseDefaultElement(ele, <span class="keyword">delegate</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">delegate</span>.parseCustomElement(ele);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">delegate</span>.parseCustomElement(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从这个方法开始，BeanDefinitionParserDelegate就开始发挥作用了，判断当前解析元素是否属于默认的命名空间，如果是的话，就调用parseDefaultElement()方法，否则调用delegate上parseCustomElement()方法</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isDefaultNamespace</span><span class="params">(String namespaceUri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (!StringUtils.hasLength(namespaceUri) || BEANS_NAMESPACE_URI.equals(namespaceUri));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isDefaultNamespace</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isDefaultNamespace(getNamespaceURI(node));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>只有<strong><a href="https://link.jianshu.com/?t=http://www.springframework.org/schema/beans" target="_blank" rel="noopener">http://www.springframework.org/schema/beans</a></strong>，会被认为是默认的命名空间。也就是说，beans、bean这些元素，会认为属于默认的命名空间，而像task:scheduled这些，就认为不属于默认命名空间。<br>根节点beans的一个子节点bean，是属于默认命名空间的，所以会进入parseDefaultElement()方法</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span>(<span class="params">Element ele, BeanDefinitionParserDelegate <span class="keyword">delegate</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">delegate</span>.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">            importBeanDefinitionResource(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">delegate</span>.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">            processAliasRegistration(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">delegate</span>.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">            processBeanDefinition(ele, <span class="keyword">delegate</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">delegate</span>.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">            <span class="comment">// recurse</span></span><br><span class="line">            doRegisterBeanDefinitions(ele);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里可能会有4种情况，import、alias、bean、beans，分别有一个方法与之对应，这里解析的是bean元素，所以会进入processBeanDefinition()方法</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span>(<span class="params">Element ele, BeanDefinitionParserDelegate <span class="keyword">delegate</span></span>) </span>&#123;</span><br><span class="line">        BeanDefinitionHolder bdHolder = <span class="keyword">delegate</span>.parseBeanDefinitionElement(ele);</span><br><span class="line">        <span class="keyword">if</span> (bdHolder != <span class="literal">null</span>) &#123;</span><br><span class="line">            bdHolder = <span class="keyword">delegate</span>.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">                getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">                        bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Send registration event.</span></span><br><span class="line">            getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里主要有3个步骤，先是委托delegate对bean进行解析，然后委托delegate对bean进行装饰，最后由一个工具类来完成BeanDefinition的注册<br>可以看出来，DefaultBeanDefinitionDocumentReader不负责任何具体的bean解析，它面向的是xml Document对象，根据其元素的命名空间和名称，起一个类似路由的作用（不过，命名空间的判断，也是委托给delegate来做的）。所以这个类的命名，是比较贴切的，突出了其面向Document的特性。具体的工作，是由BeanDefinitionParserDelegate来完成的<br>下面就看下parseBeanDefinitionElement()方法</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">public</span> <span class="keyword">BeanDefinitionHolder </span>parseBeanDefinitionElement(Element ele, <span class="keyword">BeanDefinition </span>containingBean) &#123;</span><br><span class="line">        <span class="keyword">String </span>id = ele.getAttribute(ID_ATTRIBUTE)<span class="comment">;</span></span><br><span class="line">        <span class="keyword">String </span>nameAttr = ele.getAttribute(NAME_ATTRIBUTE)<span class="comment">;</span></span><br><span class="line">        List&lt;<span class="keyword">String&gt; </span>aliases = new ArrayList&lt;<span class="keyword">String&gt;();</span></span><br><span class="line"><span class="keyword"> </span>       <span class="meta">if</span> (<span class="keyword">StringUtils.hasLength(nameAttr)) </span>&#123;</span><br><span class="line">            <span class="keyword">String[] </span>nameArr = <span class="keyword">StringUtils.tokenizeToStringArray(nameAttr, </span><span class="keyword">MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span></span><br><span class="line"><span class="keyword"> </span>           aliases.<span class="keyword">addAll(Arrays.asList(nameArr));</span></span><br><span class="line"><span class="keyword"> </span>       &#125;</span><br><span class="line">        <span class="keyword">String </span><span class="keyword">beanName </span>= id<span class="comment">;</span></span><br><span class="line">        <span class="meta">if</span> (!<span class="keyword">StringUtils.hasText(beanName) </span>&amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">beanName </span>= aliases.remove(<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">            <span class="meta">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"No XML 'id' specified - using '"</span> + <span class="keyword">beanName </span>+</span><br><span class="line">                        <span class="string">"' as bean name and "</span> + aliases + <span class="string">" as aliases"</span>)<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">if</span> (containingBean == null) &#123;</span><br><span class="line">            checkNameUniqueness(<span class="keyword">beanName, </span>aliases, ele)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        AbstractBeanDefinition <span class="keyword">beanDefinition </span>= parseBeanDefinitionElement(ele, <span class="keyword">beanName, </span>containingBean)<span class="comment">;</span></span><br><span class="line">        <span class="meta">if</span> (<span class="keyword">beanDefinition </span>!= null) &#123;</span><br><span class="line">            <span class="meta">if</span> (!<span class="keyword">StringUtils.hasText(beanName)) </span>&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    <span class="meta">if</span> (containingBean != null) &#123;</span><br><span class="line">                        <span class="keyword">beanName </span>= <span class="keyword">BeanDefinitionReaderUtils.generateBeanName(</span></span><br><span class="line"><span class="keyword"> </span>                               <span class="keyword">beanDefinition, </span>this.readerContext.getRegistry(), true)<span class="comment">;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">else</span> &#123;</span><br><span class="line">                        <span class="keyword">beanName </span>= this.readerContext.generateBeanName(<span class="keyword">beanDefinition);</span></span><br><span class="line"><span class="keyword"> </span>                       // Register an <span class="meta">alias</span> for the plain <span class="keyword">bean </span>class name, <span class="meta">if</span> still possible,</span><br><span class="line">                        // <span class="meta">if</span> the generator returned the class name plus a suffix.</span><br><span class="line">                        // This is expected for Spring <span class="number">1</span>.<span class="number">2</span>/<span class="number">2</span>.<span class="number">0</span> <span class="keyword">backwards </span>compatibility.</span><br><span class="line">                        <span class="keyword">String </span><span class="keyword">beanClassName </span>= <span class="keyword">beanDefinition.getBeanClassName();</span></span><br><span class="line"><span class="keyword"> </span>                       <span class="meta">if</span> (<span class="keyword">beanClassName </span>!= null &amp;&amp;</span><br><span class="line">                                <span class="keyword">beanName.startsWith(beanClassName) </span>&amp;&amp; <span class="keyword">beanName.length() </span>&gt; <span class="keyword">beanClassName.length() </span>&amp;&amp;                      !this.readerContext.getRegistry().<span class="keyword">isBeanNameInUse(beanClassName)) </span>&#123;</span><br><span class="line">                            aliases.<span class="keyword">add(beanClassName);</span></span><br><span class="line"><span class="keyword"> </span>                       &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                        logger.debug(<span class="string">"Neither XML 'id' nor 'name' specified - "</span> +</span><br><span class="line">                                <span class="string">"using generated bean name ["</span> + <span class="keyword">beanName </span>+ <span class="string">"]"</span>)<span class="comment">;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                catch (Exception ex) &#123;</span><br><span class="line">                    error(ex.getMessage(), ele)<span class="comment">;</span></span><br><span class="line">                    return null<span class="comment">;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">String[] </span>aliasesArray = <span class="keyword">StringUtils.toStringArray(aliases);</span></span><br><span class="line"><span class="keyword"> </span>           return new <span class="keyword">BeanDefinitionHolder(beanDefinition, </span><span class="keyword">beanName, </span>aliasesArray)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        return null<span class="comment">;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法很长，可以分成三段来看</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String </span>id = ele.getAttribute(ID_ATTRIBUTE)<span class="comment">;</span></span><br><span class="line">        <span class="keyword">String </span>nameAttr = ele.getAttribute(NAME_ATTRIBUTE)<span class="comment">;</span></span><br><span class="line">        List&lt;<span class="keyword">String&gt; </span>aliases = new ArrayList&lt;<span class="keyword">String&gt;();</span></span><br><span class="line"><span class="keyword"> </span>       <span class="meta">if</span> (<span class="keyword">StringUtils.hasLength(nameAttr)) </span>&#123;</span><br><span class="line">            <span class="keyword">String[] </span>nameArr = <span class="keyword">StringUtils.tokenizeToStringArray(nameAttr, </span><span class="keyword">MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span></span><br><span class="line"><span class="keyword"> </span>           aliases.<span class="keyword">addAll(Arrays.asList(nameArr));</span></span><br><span class="line"><span class="keyword"> </span>       &#125;</span><br><span class="line">        <span class="keyword">String </span><span class="keyword">beanName </span>= id<span class="comment">;</span></span><br><span class="line">        <span class="meta">if</span> (!<span class="keyword">StringUtils.hasText(beanName) </span>&amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">beanName </span>= aliases.remove(<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">            <span class="meta">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"No XML 'id' specified - using '"</span> + <span class="keyword">beanName </span>+</span><br><span class="line">                        <span class="string">"' as bean name and "</span> + aliases + <span class="string">" as aliases"</span>)<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">if</span> (containingBean == null) &#123;</span><br><span class="line">            checkNameUniqueness(<span class="keyword">beanName, </span>aliases, ele)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这一段，主要是处理一些跟alias，id等标识相关的东西</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbstractBeanDefinition <span class="keyword">beanDefinition </span>= parseBeanDefinitionElement(ele, <span class="keyword">beanName, </span>containingBean)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这一行是核心，进行实际的解析</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">if</span> (<span class="keyword">beanDefinition </span>!= null) &#123;</span><br><span class="line">            <span class="meta">if</span> (!<span class="keyword">StringUtils.hasText(beanName)) </span>&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    <span class="meta">if</span> (containingBean != null) &#123;</span><br><span class="line">                        <span class="keyword">beanName </span>= <span class="keyword">BeanDefinitionReaderUtils.generateBeanName(</span></span><br><span class="line"><span class="keyword"> </span>                               <span class="keyword">beanDefinition, </span>this.readerContext.getRegistry(), true)<span class="comment">;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">else</span> &#123;</span><br><span class="line">                        <span class="keyword">beanName </span>= this.readerContext.generateBeanName(<span class="keyword">beanDefinition);</span></span><br><span class="line"><span class="keyword"> </span>                       // Register an <span class="meta">alias</span> for the plain <span class="keyword">bean </span>class name, <span class="meta">if</span> still possible,</span><br><span class="line">                        // <span class="meta">if</span> the generator returned the class name plus a suffix.</span><br><span class="line">                        // This is expected for Spring <span class="number">1</span>.<span class="number">2</span>/<span class="number">2</span>.<span class="number">0</span> <span class="keyword">backwards </span>compatibility.</span><br><span class="line">                        <span class="keyword">String </span><span class="keyword">beanClassName </span>= <span class="keyword">beanDefinition.getBeanClassName();</span></span><br><span class="line"><span class="keyword"> </span>                       <span class="meta">if</span> (<span class="keyword">beanClassName </span>!= null &amp;&amp;</span><br><span class="line">                                <span class="keyword">beanName.startsWith(beanClassName) </span>&amp;&amp; <span class="keyword">beanName.length() </span>&gt; <span class="keyword">beanClassName.length() </span>&amp;&amp;</span><br><span class="line">                                !this.readerContext.getRegistry().<span class="keyword">isBeanNameInUse(beanClassName)) </span>&#123;</span><br><span class="line">                            aliases.<span class="keyword">add(beanClassName);</span></span><br><span class="line"><span class="keyword"> </span>                       &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                        logger.debug(<span class="string">"Neither XML 'id' nor 'name' specified - "</span> +</span><br><span class="line">                                <span class="string">"using generated bean name ["</span> + <span class="keyword">beanName </span>+ <span class="string">"]"</span>)<span class="comment">;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                catch (Exception ex) &#123;</span><br><span class="line">                    error(ex.getMessage(), ele)<span class="comment">;</span></span><br><span class="line">                    return null<span class="comment">;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">String[] </span>aliasesArray = <span class="keyword">StringUtils.toStringArray(aliases);</span></span><br><span class="line"><span class="keyword"> </span>           return new <span class="keyword">BeanDefinitionHolder(beanDefinition, </span><span class="keyword">beanName, </span>aliasesArray)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这段是后置处理，对beanName进行处理<br>前置处理和后置处理，不是核心，就不细看了，重点看下核心的那一行调用</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public AbstractBeanDefinition parseBeanDefinitionElement(</span><br><span class="line">            Element ele, String <span class="keyword">beanName, </span><span class="keyword">BeanDefinition </span>containingBean) &#123;</span><br><span class="line">        this.parseState.push(new <span class="keyword">BeanEntry(beanName));</span></span><br><span class="line"><span class="keyword"> </span>       String className = null<span class="comment">;</span></span><br><span class="line">        if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">            className = ele.getAttribute(CLASS_ATTRIBUTE).trim()<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            String parent = null<span class="comment">;</span></span><br><span class="line">            if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">                parent = ele.getAttribute(PARENT_ATTRIBUTE)<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">            AbstractBeanDefinition <span class="keyword">bd </span>= createBeanDefinition(className, parent)<span class="comment">;</span></span><br><span class="line">            parseBeanDefinitionAttributes(ele, <span class="keyword">beanName, </span>containingBean, <span class="keyword">bd);</span></span><br><span class="line"><span class="keyword"> </span>           <span class="keyword">bd.setDescription(DomUtils.getChildElementValueByTagName(ele, </span>DESCRIPTION_ELEMENT))<span class="comment">;</span></span><br><span class="line">            parseMetaElements(ele, <span class="keyword">bd);</span></span><br><span class="line"><span class="keyword"> </span>           parseLookupOverrideSubElements(ele, <span class="keyword">bd.getMethodOverrides());</span></span><br><span class="line"><span class="keyword"> </span>           parseReplacedMethodSubElements(ele,   <span class="keyword">bd.getMethodOverrides());</span></span><br><span class="line"><span class="keyword"> </span>           parseConstructorArgElements(ele, <span class="keyword">bd);</span></span><br><span class="line"><span class="keyword"> </span>           parsePropertyElements(ele, <span class="keyword">bd);</span></span><br><span class="line"><span class="keyword"> </span>           parseQualifierElements(ele, <span class="keyword">bd);</span></span><br><span class="line"><span class="keyword"> </span>           <span class="keyword">bd.setResource(this.readerContext.getResource());</span></span><br><span class="line"><span class="keyword"> </span>           <span class="keyword">bd.setSource(extractSource(ele));</span></span><br><span class="line"><span class="keyword"> </span>           return <span class="keyword">bd;</span></span><br><span class="line"><span class="keyword"> </span>       &#125;</span><br><span class="line">        catch (ClassNotFoundException ex) &#123;</span><br><span class="line">            error(<span class="string">"Bean class ["</span> + className + <span class="string">"] not found"</span>, ele, ex)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        catch (NoClassDefFoundError err) &#123;</span><br><span class="line">            error(<span class="string">"Class that bean class ["</span> + className + <span class="string">"] depends on not found"</span>, ele, err)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable ex) &#123;</span><br><span class="line">            error(<span class="string">"Unexpected failure during bean definition parsing"</span>, ele, ex)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            this.parseState.pop()<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        return null<span class="comment">;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法也挺长的，拆开看看</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.parseState.push(<span class="keyword">new</span> <span class="type">BeanEntry</span>(beanName));</span><br><span class="line">        <span class="keyword">String</span> className = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">            className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这段是从配置中抽取出类名。接下来的长长一段，把异常处理先抛开，看看实际的业务</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String parent = null<span class="comment">;</span></span><br><span class="line">if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">    parent = ele.getAttribute(PARENT_ATTRIBUTE)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">AbstractBeanDefinition <span class="keyword">bd </span>= createBeanDefinition(className, parent)<span class="comment">;</span></span><br><span class="line">parseBeanDefinitionAttributes(ele, <span class="keyword">beanName, </span>containingBean, <span class="keyword">bd); </span>                 </span><br><span class="line"><span class="keyword">bd.setDescription(DomUtils.getChildElementValueByTagName(ele, </span>DESCRIPTION_ELEMENT))<span class="comment">;</span></span><br><span class="line">parseMetaElements(ele, <span class="keyword">bd);</span></span><br><span class="line"><span class="keyword">parseLookupOverrideSubElements(ele, </span><span class="keyword">bd.getMethodOverrides());</span></span><br><span class="line"><span class="keyword">parseReplacedMethodSubElements(ele, </span><span class="keyword">bd.getMethodOverrides());</span></span><br><span class="line"><span class="keyword">parseConstructorArgElements(ele, </span><span class="keyword">bd);</span></span><br><span class="line"><span class="keyword">parsePropertyElements(ele, </span><span class="keyword">bd);</span></span><br><span class="line"><span class="keyword">parseQualifierElements(ele, </span><span class="keyword">bd);</span></span><br><span class="line"><span class="keyword">bd.setResource(this.readerContext.getResource());</span></span><br><span class="line"><span class="keyword">bd.setSource(extractSource(ele));</span></span><br><span class="line"><span class="keyword">return </span><span class="keyword">bd;</span></span><br></pre></td></tr></table></figure><p>这里每个方法的命名，就说明了是要干什么，可以一个个跟进去看，本文就不细说了。总之，经过这里的解析，就得到了一个完整的BeanDefinitionHolder。只是说明一下，如果在配置文件里，没有对一些属性进行设置，比如autowire-candidate等，那么这个解析生成的BeanDefinition，都会得到一个默认值<br><strong>然后，对这个Bean做一些必要的装饰</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">decorateBeanDefinitionIfRequired</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Element ele, BeanDefinitionHolder definitionHolder, BeanDefinition containingBd)</span> </span>&#123;</span><br><span class="line">        BeanDefinitionHolder finalDefinition = definitionHolder;</span><br><span class="line">        <span class="comment">// Decorate based on custom attributes first.</span></span><br><span class="line">        NamedNodeMap attributes = ele.getAttributes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; attributes.getLength(); i++) &#123;</span><br><span class="line">            Node node = attributes.item(i);</span><br><span class="line">            finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Decorate based on custom nested elements.</span></span><br><span class="line">        NodeList children = ele.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">            Node node = children.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">                finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finalDefinition;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>持续单步调试，代码继续运行到DefaultBeanDefinitionDocumentReader中的processBeanDefinition中的registerBeanDefinition()</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">BeanDefinitionReaderUtils</span><span class="selector-class">.registerBeanDefinition</span>(<span class="selector-tag">bdHolder</span>, </span><br><span class="line"><span class="selector-tag">getReaderContext</span>()<span class="selector-class">.getRegistry</span>());</span><br></pre></td></tr></table></figure><p>单步进入代码发现BeanDefinitionReaderUtils静态方法registerBeanDefinition()</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">public</span> static void registerBeanDefinition(</span><br><span class="line">            <span class="keyword">BeanDefinitionHolder </span>definitionHolder, <span class="keyword">BeanDefinitionRegistry </span>registry)</span><br><span class="line">            throws <span class="keyword">BeanDefinitionStoreException </span>&#123;</span><br><span class="line">        // Register <span class="keyword">bean </span>definition under primary name.</span><br><span class="line">        <span class="keyword">String </span><span class="keyword">beanName </span>= definitionHolder.getBeanName()<span class="comment">;</span></span><br><span class="line">        // 其实调用的是DefaultListableBeanFactory中的registerBeanDefinition方法</span><br><span class="line">        registry.registerBeanDefinition(<span class="keyword">beanName, </span>definitionHolder.getBeanDefinition())<span class="comment">;</span></span><br><span class="line">        // Register aliases for <span class="keyword">bean </span>name, <span class="meta">if</span> any.</span><br><span class="line">        <span class="keyword">String[] </span>aliases = definitionHolder.getAliases()<span class="comment">;</span></span><br><span class="line">        <span class="meta">if</span> (aliases != null) &#123;</span><br><span class="line">            for (<span class="keyword">String </span>aliase : aliases) &#123;</span><br><span class="line">                registry.registerAlias(<span class="keyword">beanName, </span>aliase)<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>解释一下<strong>其实调用的是DefaultListableBeanFactory中的registerBeanDefinition方法</strong>这句话，因为DefaultListableBeanFactory实现BeanDefinitionRegistry接口，BeanDefinitionRegistry接口中定义了registerBeanDefinition()方法<br>看下DefaultListableBeanFactory中registerBeanDefinition()实例方法的具体实现：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">public</span> void registerBeanDefinition(<span class="keyword">String </span><span class="keyword">beanName, </span><span class="keyword">BeanDefinition </span><span class="keyword">beanDefinition)</span></span><br><span class="line"><span class="keyword"> </span>           throws <span class="keyword">BeanDefinitionStoreException </span>&#123;</span><br><span class="line">        <span class="meta">Assert</span>.hasText(<span class="keyword">beanName, </span><span class="string">"Bean name must not be empty"</span>)<span class="comment">;</span></span><br><span class="line">        <span class="meta">Assert</span>.notNull(<span class="keyword">beanDefinition, </span><span class="string">"BeanDefinition must not be null"</span>)<span class="comment">;</span></span><br><span class="line">        <span class="meta">if</span> (<span class="keyword">beanDefinition </span>instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ((AbstractBeanDefinition) <span class="keyword">beanDefinition).validate();</span></span><br><span class="line"><span class="keyword"> </span>           &#125;</span><br><span class="line">            catch (<span class="keyword">BeanDefinitionValidationException </span>ex) &#123;</span><br><span class="line">                throw new <span class="keyword">BeanDefinitionStoreException(beanDefinition.getResourceDescription(), </span><span class="keyword">beanName,</span></span><br><span class="line"><span class="keyword"> </span>                       <span class="string">"Validation of bean definition failed"</span>, ex)<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (this.<span class="keyword">beanDefinitionMap) </span>&#123;</span><br><span class="line">            Object oldBeanDefinition = this.<span class="keyword">beanDefinitionMap.get(beanName);</span></span><br><span class="line"><span class="keyword"> </span>           <span class="meta">if</span> (oldBeanDefinition != null) &#123;</span><br><span class="line">                <span class="meta">if</span> (!this.allowBeanDefinitionOverriding) &#123;</span><br><span class="line">                    throw new <span class="keyword">BeanDefinitionStoreException(beanDefinition.getResourceDescription(), </span><span class="keyword">beanName,</span></span><br><span class="line"><span class="keyword"> </span>                           <span class="string">"Cannot register bean definition ["</span> + <span class="keyword">beanDefinition </span>+ <span class="string">"] for bean '"</span> + <span class="keyword">beanName </span>+</span><br><span class="line">                            <span class="string">"': There is already ["</span> + oldBeanDefinition + <span class="string">"] bound."</span>)<span class="comment">;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">else</span> &#123;</span><br><span class="line">                    <span class="meta">if</span> (this.logger.isInfoEnabled()) &#123;</span><br><span class="line">                        this.logger.info(<span class="string">"Overriding bean definition for bean '"</span> + <span class="keyword">beanName </span>+</span><br><span class="line">                                <span class="string">"': replacing ["</span> + oldBeanDefinition + <span class="string">"] with ["</span> + <span class="keyword">beanDefinition </span>+ <span class="string">"]"</span>)<span class="comment">;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">else</span> &#123;</span><br><span class="line">                this.<span class="keyword">beanDefinitionNames.add(beanName);</span></span><br><span class="line"><span class="keyword"> </span>               this.frozenBeanDefinitionNames = null<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">            this.<span class="keyword">beanDefinitionMap.put(beanName, </span><span class="keyword">beanDefinition);</span></span><br><span class="line"><span class="keyword"> </span>           resetBeanDefinition(<span class="keyword">beanName);</span></span><br><span class="line"><span class="keyword"> </span>       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码追溯之后发现这个方法里，最关键的是以下2行：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">this</span><span class="selector-class">.beanDefinitionNames</span><span class="selector-class">.add</span>(<span class="selector-tag">beanName</span>);</span><br><span class="line"><span class="selector-tag">this</span><span class="selector-class">.beanDefinitionMap</span><span class="selector-class">.put</span>(<span class="selector-tag">beanName</span>, <span class="selector-tag">beanDefinition</span>);</span><br></pre></td></tr></table></figure><p>前者是把beanName放到队列里，后者是把BeanDefinition放到map中，到此注册就完成了。在后面实例化的时候，就是把beanDefinitionMap中的BeanDefinition取出来，逐一实例化<br>BeanFactory准备完毕之后，代码又回到了ClassPathXmlApplicationContext里</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">            <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">            prepareRefresh();</span><br><span class="line">            <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">            <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">            prepareBeanFactory(beanFactory);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">                postProcessBeanFactory(beanFactory);</span><br><span class="line">                <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">                invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">                <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">                registerBeanPostProcessors(beanFactory);</span><br><span class="line">                <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">                initMessageSource();</span><br><span class="line">                <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">                initApplicationEventMulticaster();</span><br><span class="line">                <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">                onRefresh();</span><br><span class="line">                <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">                registerListeners();</span><br><span class="line">                <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">                finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">                <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">                finishRefresh();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">                destroyBeans();</span><br><span class="line">                <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">                cancelRefresh(ex);</span><br><span class="line">                <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>也就是obtainFreshBeanFactory()方法执行之后，再进行下面的步骤。<br>总结来说，ApplicationContext将解析配置文件的工作委托给BeanDefinitionReader，然后BeanDefinitionReader将配置文件读取为xml的Document文档之后，又委托给BeanDefinitionDocumentReader<br>BeanDefinitionDocumentReader这个组件是根据xml元素的命名空间和元素名，起到一个路由的作用，实际的解析工作，是委托给BeanDefinitionParserDelegate来完成的<br>BeanDefinitionParserDelegate的解析工作完成以后，会返回BeanDefinitionHolder给BeanDefinitionDocumentReader，在这里，会委托给DefaultListableBeanFactory完成bean的注册<br>XmlBeanDefinitionReader（计数、解析XML文档），BeanDefinitionDocumentReader（依赖xml文档，进行解析和注册），BeanDefinitionParserDelegate（实际的解析工作）。可以看出，在解析bean的过程中，这3个组件的分工是比较清晰的，各司其职，这种设计思想值得学习<br>到此为止，bean的解析、注册、spring ioc 容器的实例化过程就基本分析结束了。</p><p>作者：fxliutao<br>链接：<a href="https://www.jianshu.com/p/963f87a5c4d7" target="_blank" rel="noopener">https://www.jianshu.com/p/963f87a5c4d7</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Spring源码解析 &lt;a href=&quot;https://blog.csdn.net/column/details/21851.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21851.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;br&gt;://github.com/h2pl/&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Spring" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Spring/"/>
    
    
      <category term="Spring IOC" scheme="http://h2pl.github.io/tags/Spring-IOC/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码剖析1：初探Spring IOC核心流程</title>
    <link href="http://h2pl.github.io/2018/06/02/spring1/"/>
    <id>http://h2pl.github.io/2018/06/02/spring1/</id>
    <published>2018-06-02T14:27:45.000Z</published>
    <updated>2018-06-11T14:16:32.029Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Spring源码解析 <a href="https://blog.csdn.net/column/details/21851.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21851.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><p>本文大致地介绍了IOC容器的初始化过程，只列出了比较重要的过程和代码，可以从中看出IOC容器执行的大致流程。</p><p>接下来的文章会更加深入剖析Bean容器如何解析xml，注册和初始化bean，以及如何获取bean实例等详细的过程。</p><p>转自：<a href="http://www.importnew.com/19243.html" target="_blank" rel="noopener">http://www.importnew.com/19243.html</a></p><p>1. 初始化</p><p>大致单步跟了下Spring IOC的初始化过程，整个脉络很庞大，初始化的过程主要就是读取XML资源，并解析，最终注册到Bean Factory中：</p><p><a href="https://cloud.githubusercontent.com/assets/1736354/7897341/032179be-070b-11e5-9ecf-d7befc804e9d.png" title="flow" target="_blank" rel="noopener"><img src="https://cloud.githubusercontent.com/assets/1736354/7897341/032179be-070b-11e5-9ecf-d7befc804e9d.png" alt="" title="flow"></a></p><p>在完成初始化的过程后，Bean们就在BeanFactory中蓄势以待地等调用了。下面通过一个具体的例子，来详细地学习一下初始化过程，例如当加载下面一个bean：</p><pre><code>&lt;bean id=&quot;XiaoWang&quot; class=&quot;com.springstudy.talentshow.SuperInstrumentalist&quot;&gt;    &lt;property name=&quot;instruments&quot;&gt;        &lt;list&gt;            &lt;ref bean=&quot;piano&quot;/&gt;            &lt;ref bean=&quot;saxophone&quot;/&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><p>加载时需要读取、解析、注册bean，这个过程具体的调用栈如下所示：<br><a href="https://cloud.githubusercontent.com/assets/1736354/7896285/8a488060-06e6-11e5-9ad9-4ddd3375984f.png" title="load" target="_blank" rel="noopener"><img src="https://cloud.githubusercontent.com/assets/1736354/7896285/8a488060-06e6-11e5-9ad9-4ddd3375984f.png" alt="" title="load"></a></p><p>下面对每一步的关键的代码进行详细分析：</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>保存配置位置，并刷新<br>在调用ClassPathXmlApplicationContext后，先会将配置位置信息保存到configLocations，供后面解析使用，之后，会调用<code>AbstractApplicationContext</code>的refresh方法进行刷新：</p><pre><code>public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh,        ApplicationContext parent) throws BeansException {    super(parent);    // 保存位置信息，比如`com/springstudy/talentshow/talent-show.xml`    setConfigLocations(configLocations);    if (refresh) {        // 刷新        refresh();    }}public void refresh() throws BeansException, IllegalStateException {    synchronized (this.startupShutdownMonitor) {        // Prepare this context for refreshing.        prepareRefresh();        // Tell the subclass to refresh the internal bean factory.        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();        // Prepare the bean factory for use in this context.        prepareBeanFactory(beanFactory);        try {            // Allows post-processing of the bean factory in context subclasses.            postProcessBeanFactory(beanFactory);            // Invoke factory processors registered as beans in the context.            invokeBeanFactoryPostProcessors(beanFactory);            // Register bean processors that intercept bean creation.            registerBeanPostProcessors(beanFactory);            // Initialize message source for this context.            initMessageSource();            // Initialize event multicaster for this context.            initApplicationEventMulticaster();            // Initialize other special beans in specific context subclasses.            onRefresh();            // Check for listener beans and register them.            registerListeners();            // Instantiate all remaining (non-lazy-init) singletons.            finishBeanFactoryInitialization(beanFactory);            // Last step: publish corresponding event.            finishRefresh();        }        catch (BeansException ex) {            // Destroy already created singletons to avoid dangling resources.            destroyBeans();            // Reset &apos;active&apos; flag.            cancelRefresh(ex);            // Propagate exception to caller.            throw ex;        }    }}</code></pre><p>创建载入BeanFactory</p><pre><code>protected final void refreshBeanFactory() throws BeansException {    // ... ...    DefaultListableBeanFactory beanFactory = createBeanFactory();    // ... ...    loadBeanDefinitions(beanFactory);    // ... ...}</code></pre><p>创建XMLBeanDefinitionReader</p><pre><code>protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory)     throws BeansException, IOException {    // Create a new XmlBeanDefinitionReader for the given BeanFactory.    XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);    // ... ...    // Allow a subclass to provide custom initialization of the reader,    // then proceed with actually loading the bean definitions.    initBeanDefinitionReader(beanDefinitionReader);    loadBeanDefinitions(beanDefinitionReader);</code></pre><h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><p>创建处理每一个resource</p><pre><code>public int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources)     throws BeanDefinitionStoreException {    // ... ...    // 通过Location来读取Resource    Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);    int loadCount = loadBeanDefinitions(resources);    // ... ...}public int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException {    Assert.notNull(resources, &quot;Resource array must not be null&quot;);    int counter = 0;    for (Resource resource : resources) {        // 载入每一个resource        counter += loadBeanDefinitions(resource);    }    return counter;}</code></pre><p>处理XML每个元素</p><pre><code>protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {    // ... ...    NodeList nl = root.getChildNodes();    for (int i = 0; i &lt; nl.getLength(); i++) {        Node node = nl.item(i);        if (node instanceof Element) {            Element ele = (Element) node;            if (delegate.isDefaultNamespace(ele)) {                // 处理每个xml中的元素，可能是import、alias、bean                parseDefaultElement(ele, delegate);            }            else {                delegate.parseCustomElement(ele);            }        }    }    // ... ...}</code></pre><p>解析和注册bean</p><pre><code>protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {    // 解析    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);    if (bdHolder != null) {        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);        try {            // 注册            // Register the final decorated instance.            BeanDefinitionReaderUtils.registerBeanDefinition(                bdHolder, getReaderContext().getRegistry());        }        catch (BeanDefinitionStoreException ex) {            getReaderContext().error(&quot;Failed to register bean definition with name &apos;&quot; +                    bdHolder.getBeanName() + &quot;&apos;&quot;, ele, ex);        }        // Send registration event.        getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));    }}</code></pre><p>本步骤中，通过parseBeanDefinitionElement将XML的元素解析为BeanDefinition，然后存在BeanDefinitionHolder中，然后再利用BeanDefinitionHolder将BeanDefinition注册，实质就是把BeanDefinition的实例put进BeanFactory中，和后面将详细的介绍解析和注册过程。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p><a href="https://cloud.githubusercontent.com/assets/1736354/7896302/eae02bc6-06e6-11e5-941a-d1f59e3b363f.png" title="process" target="_blank" rel="noopener"><img src="https://cloud.githubusercontent.com/assets/1736354/7896302/eae02bc6-06e6-11e5-941a-d1f59e3b363f.png" alt="" title="process"></a></p><p>处理每个Bean的元素</p><pre><code>public AbstractBeanDefinition parseBeanDefinitionElement(        Element ele, String beanName, BeanDefinition containingBean) {    // ... ...    // 创建beandefinition    AbstractBeanDefinition bd = createBeanDefinition(className, parent);    parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);    bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));    parseMetaElements(ele, bd);    parseLookupOverrideSubElements(ele, bd.getMethodOverrides());    parseReplacedMethodSubElements(ele, bd.getMethodOverrides());    // 处理“Constructor”    parseConstructorArgElements(ele, bd);    // 处理“Preperty”    parsePropertyElements(ele, bd);    parseQualifierElements(ele, bd);    // ... ...}</code></pre><p>处理属性的值</p><pre><code>public Object parsePropertyValue(Element ele, BeanDefinition bd, String propertyName) {    String elementName = (propertyName != null) ?                    &quot;&lt;property&gt; element for property &apos;&quot; + propertyName + &quot;&apos;&quot; :                    &quot;&lt;constructor-arg&gt; element&quot;;    // ... ...    if (hasRefAttribute) {    // 处理引用        String refName = ele.getAttribute(REF_ATTRIBUTE);        if (!StringUtils.hasText(refName)) {            error(elementName + &quot; contains empty &apos;ref&apos; attribute&quot;, ele);        }        RuntimeBeanReference ref = new RuntimeBeanReference(refName);        ref.setSource(extractSource(ele));        return ref;    }    else if (hasValueAttribute) {    // 处理值        TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));        valueHolder.setSource(extractSource(ele));        return valueHolder;    }    else if (subElement != null) {    // 处理子类型（比如list、map等）        return parsePropertySubElement(subElement, bd);    }    // ... ...}</code></pre><p>1.4 注册</p><pre><code>public static void registerBeanDefinition(        BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)        throws BeanDefinitionStoreException {    // Register bean definition under primary name.    String beanName = definitionHolder.getBeanName();    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());    // Register aliases for bean name, if any.    String[] aliases = definitionHolder.getAliases();    if (aliases != null) {        for (String alias : aliases) {            registry.registerAlias(beanName, alias);        }    }}public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)        throws BeanDefinitionStoreException {    // ......    // 将beanDefinition注册    this.beanDefinitionMap.put(beanName, beanDefinition);    // ......}</code></pre><p>注册过程中，最核心的一句就是：this.beanDefinitionMap.put(beanName, beanDefinition)，也就是说注册的实质就是以beanName为key，以beanDefinition为value，将其put到HashMap中。</p><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><pre><code>    public static void registerBeanDefinition(        BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)        throws BeanDefinitionStoreException {    // Register bean definition under primary name.    String beanName = definitionHolder.getBeanName();    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());    // Register aliases for bean name, if any.    String[] aliases = definitionHolder.getAliases();    if (aliases != null) {        for (String alias : aliases) {            registry.registerAlias(beanName, alias);        }    }}public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)        throws BeanDefinitionStoreException {    // ......    // 将beanDefinition注册    this.beanDefinitionMap.put(beanName, beanDefinition);    // ......</code></pre><p>理解了以上两个过程，我们就可以自己实现一个简单的Spring框架了。于是，我根据自己的理解实现了一个简单的IOC框架Simple Spring，有兴趣可以看看。</p><p>注册过程中，最核心的一句就是：<code>this.beanDefinitionMap.put(beanName, beanDefinition)</code>，也就是说注册的实质就是以beanName为key，以beanDefinition为value，将其put到HashMap中。</p><h3 id="注入依赖"><a href="#注入依赖" class="headerlink" title="注入依赖"></a>注入依赖</h3><p>当完成初始化IOC容器后，如果bean没有设置lazy-init(延迟加载)属性，那么bean的实例就会在初始化IOC完成之后，及时地进行初始化。初始化时会先建立实例，然后根据配置利用反射对实例进行进一步操作，具体流程如下所示：<br><a href="https://cloud.githubusercontent.com/assets/1736354/7929429/615570ea-0930-11e5-8097-ae982ef7709d.png" title="bean_flow" target="_blank" rel="noopener"><img src="https://cloud.githubusercontent.com/assets/1736354/7929429/615570ea-0930-11e5-8097-ae982ef7709d.png" alt="" title="bean_flow"></a></p><p>创建bean的实例<br>创建bean的实例过程函数调用栈如下所示：<br><a href="https://cloud.githubusercontent.com/assets/1736354/7929379/cec01bcc-092f-11e5-81ad-88c285f33845.png" title="create_bean" target="_blank" rel="noopener"><img src="https://cloud.githubusercontent.com/assets/1736354/7929379/cec01bcc-092f-11e5-81ad-88c285f33845.png" alt="" title="create_bean"></a></p><p>注入bean的属性<br>注入bean的属性过程函数调用栈如下所示：<br><a href="https://cloud.githubusercontent.com/assets/1736354/7929381/db58350e-092f-11e5-82a4-caaf349291ea.png" title="inject_property" target="_blank" rel="noopener"><img src="https://cloud.githubusercontent.com/assets/1736354/7929381/db58350e-092f-11e5-82a4-caaf349291ea.png" alt="" title="inject_property"></a></p><p>在创建bean和注入bean的属性时，都是在doCreateBean函数中进行的，我们重点看下：</p><pre><code>protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd,            final Object[] args) {        // Instantiate the bean.        BeanWrapper instanceWrapper = null;        if (mbd.isSingleton()) {            instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);        }        if (instanceWrapper == null) {            // 创建bean的实例            instanceWrapper = createBeanInstance(beanName, mbd, args);        }        // ... ...        // Initialize the bean instance.        Object exposedObject = bean;        try {            // 初始化bean的实例，如注入属性            populateBean(beanName, mbd, instanceWrapper);            if (exposedObject != null) {                exposedObject = initializeBean(beanName, exposedObject, mbd);            }        }        // ... ...    }</code></pre><p>理解了以上两个过程，我们就可以自己实现一个简单的Spring框架了。于是，我根据自己的理解实现了一个简单的IOC框架<a href="https://github.com/Yikun/simple-spring" target="_blank" rel="noopener">Simple Spring</a>，有兴趣可以看看。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Spring源码解析 &lt;a href=&quot;https://blog.csdn.net/column/details/21851.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21851.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Spring" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Spring/"/>
    
    
      <category term="Spring IOC" scheme="http://h2pl.github.io/tags/Spring-IOC/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码剖析开篇：什么是Spring</title>
    <link href="http://h2pl.github.io/2018/06/02/spring/"/>
    <id>http://h2pl.github.io/2018/06/02/spring/</id>
    <published>2018-06-02T14:27:42.000Z</published>
    <updated>2018-06-11T14:15:55.625Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Spring源码解析 <a href="https://blog.csdn.net/column/details/21851.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21851.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><p>在讲源码之前，先让我们回顾一下一下Spring的基本概念，当然，在看源码之前你需要使用过spring或者spirngmvc。</p><h3 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么"></a>Spring是什么</h3><p>Spring是一个开源的轻量级Java SE（Java 标准版本）/Java EE（Java 企业版本）开发应用框架，其目的是用于简化企业级应用程序开发。应用程序是由一组相互协作的对象组成。而在传统应用程序开发中，一个完整的应用是由一组相互协作的对象组成。所以开发一个应用除了要开发业务逻辑之外，最多的是关注如何使这些对象协作来完成所需功能，而且要低耦合、高内聚。业务逻辑开发是不可避免的，那如果有个框架出来帮我们来创建对象及管理这些对象之间的依赖关系。可能有人说了，比如“抽象工厂、工厂方法<a href="http://www.amazon.cn/gp/product/B001130JN8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;tag=importnew-23&amp;linkCode=as2&amp;camp=536&amp;creative=3200&amp;creativeASIN=B001130JN8" title="设计模式:可复用面向对象软件的基础" target="_blank" rel="noopener">设计模式</a>”不也可以帮我们创建对象，“生成器模式”帮我们处理对象间的依赖关系，不也能完成这些功能吗？可是这些又需要我们创建另一些工厂类、生成器类，我们又要而外管理这些类，增加了我们的负担，如果能有种通过配置方式来创建对象，管理对象之间依赖关系，我们不需要通过工厂和生成器来创建及管理对象之间的依赖关系，这样我们是不是减少了许多工作，加速了开发，能节省出很多时间来干其他事。Spring框架刚出来时主要就是来完成这个功能。</p><p>Spring框架除了帮我们管理对象及其依赖关系，还提供像通用日志记录、性能统计、安全控制、异常处理等面向切面的能力，还能帮我管理最头疼的数据库事务，本身提供了一套简单的JDBC访问实现，提供与第三方数据访问框架集成（如Hibernate、JPA），与各种Java EE技术整合（如Java Mail、任务调度等等），提供一套自己的web层框架Spring MVC、而且还能非常简单的与第三方web框架集成。从这里我们可以认为Spring是一个超级粘合平台，除了自己提供功能外，还提供粘合其他技术和框架的能力，从而使我们可以更自由的选择到底使用什么技术进行开发。而且不管是JAVA SE（C/S架构）应用程序还是JAVA EE（B/S架构）应用程序都可以使用这个平台进行开发。让我们来深入看一下Spring到底能帮我们做些什么？</p><h3 id="Spring能帮我们做什么"><a href="#Spring能帮我们做什么" class="headerlink" title="Spring能帮我们做什么"></a>Spring能帮我们做什么</h3><p>Spring除了不能帮我们写业务逻辑，其余的几乎什么都能帮助我们简化开发：</p><p>一、传统程序开发，创建对象及组装对象间依赖关系由我们在程序内部进行控制，这样会加大各个对象间的耦合，如果我们要修改对象间的依赖关系就必须修改源代码，重新编译、部署；而如果采用Spring，则由Spring根据配置文件来进行创建及组装对象间依赖关系，只需要改配置文件即可，无需重新编译。所以，Spring能帮我们根据配置文件创建及组装对象之间的依赖关系。</p><p>二、当我们要进行一些日志记录、权限控制、性能统计等时，在传统应用程序当中我们可能在需要的对象或方法中进行，而且比如权限控制、性能统计大部分是重复的，这样代码中就存在大量重复代码，即使有人说我把通用部分提取出来，那必然存在调用还是存在重复，像性能统计我们可能只是在必要时才进行，在诊断完毕后要删除这些代码；还有日志记录，比如记录一些方法访问日志、数据访问日志等等，这些都会渗透到各个要访问方法中；还有权限控制，必须在方法执行开始进行审核，想想这些是多么可怕而且是多么无聊的工作。如果采用Spring，这些日志记录、权限控制、性能统计从业务逻辑中分离出来，通过Spring支持的面向切面编程，在需要这些功能的地方动态添加这些功能，无需渗透到各个需要的方法或对象中；有人可能说了，我们可以使用“代理设计模式”或“包装器设计模式”，你可以使用这些，但还是需要通过编程方式来创建代理对象，还是要耦合这些代理对象，而采用Spring 面向切面编程能提供一种更好的方式来完成上述功能，一般通过配置方式，而且不需要在现有代码中添加任何额外代码，现有代码专注业务逻辑。所以，Spring 面向切面编程能帮助我们无耦合的实现日志记录，性能统计，安全控制。</p><p>三、在传统应用程序当中，我们如何来完成数据库事务管理？需要一系列“获取连接，执行SQL，提交或回滚事务，关闭连接”，而且还要保证在最后一定要关闭连接，多么可怕的事情，而且也很无聊；如果采用Spring，我们只需获取连接，执行SQL，其他的都交给Spring来管理了，简单吧。所以，Spring能非常简单的帮我们管理数据库事务。</p><p>四、Spring还提供了与第三方数据访问框架（如Hibernate、JPA）无缝集成，而且自己也提供了一套JDBC访问模板，来方便数据库访问。</p><p>五、Spring还提供与第三方Web（如Struts、JSF）框架无缝集成，而且自己也提供了一套Spring MVC框架，来方便web层搭建。</p><p>六、Spring能方便的与Java EE（如Java Mail、任务调度）整合，与更多技术整合（比如缓存框架）。</p><p>Spring能帮我们做这么多事情，提供这么多功能和与那么多主流技术整合，而且是帮我们做了开发中比较头疼和困难的事情，那可能有人会问，难道只有Spring这一个框架，没有其他选择？当然有，比如EJB需要依赖应用服务器、开发效率低、在开发中小型项目是宰鸡拿牛刀，虽然发展到现在EJB比较好用了，但还是比较笨重还需要依赖应用服务器等。那为何需要使用Spring，而不是其他框架呢？让我们接着往下看。</p><h3 id="为何需要Spring"><a href="#为何需要Spring" class="headerlink" title="为何需要Spring"></a>为何需要Spring</h3><p>一 首先阐述几个概念</p><p>1、应用程序：是能完成我们所需要功能的成品，比如购物网站、OA系统。</p><p>2、框架：是能完成一定功能的半成品，比如我们可以使用框架进行购物网站开发；框架做一部分功能，我们自己做一部分功能，这样应用程序就创建出来了。而且框架规定了你在开发应用程序时的整体架构，提供了一些基础功能，还规定了类和对象的如何创建、如何协作等，从而简化我们开发，让我们专注于业务逻辑开发。</p><p>3、非侵入式设计：从框架角度可以这样理解，无需继承框架提供的类，这种设计就可以看作是非侵入式设计，如果继承了这些框架类，就是侵入设计，如果以后想更换框架之前写过的代码几乎无法重用，如果非侵入式设计则之前写过的代码仍然可以继续使用。</p><p>4、轻量级及重量级：轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。</p><p>5、POJO：POJO（Plain Old Java Objects）简单的Java对象，它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它Java框架的类或接口。</p><p>6、容器：在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。</p><p>7、控制反转：即Inversion of Control，缩写为IoC，控制反转还有一个名字叫做依赖注入（Dependency Injection），就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。</p><p>8、Bean：一般指容器管理对象，在Spring中指Spring IoC容器管理对象。</p><p>二 为什么需要Spring及Spring的优点</p><p>●非常轻量级的容器：以集中的、自动化的方式进行应用程序对象创建和装配，负责对象创建和装配，管理对象生命周期，能组合成复杂的应用程序。Spring容器是非侵入式的（不需要依赖任何Spring特定类），而且完全采用POJOs进行开发，使应用程序更容易测试、更容易管理。而且核心JAR包非常小，Spring3.0.5不到1M，而且不需要依赖任何应用服务器，可以部署在任何环境（Java SE或Java EE）。</p><p>●AOP：AOP是Aspect Oriented Programming的缩写，意思是面向切面编程，提供从另一个角度来考虑程序结构以完善面向对象编程（相对于OOP），即可以通过在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能的一种技术。通俗点说就是把可重用的功能提取出来，然后将这些通用功能在合适的时候织入到应用程序中；比如安全，日记记录，这些都是通用的功能，我们可以把它们提取出来，然后在程序执行的合适地方织入这些代码并执行它们，从而完成需要的功能并复用了这些功能。</p><p>● 简单的数据库事务管理：在使用数据库的应用程序当中，自己管理数据库事务是一项很让人头疼的事，而且很容易出现错误，Spring支持可插入的事务管理支持，而且无需JEE环境支持，通过Spring管理事务可以把我们从事务管理中解放出来来专注业务逻辑。</p><p>●JDBC抽象及ORM框架支持：Spring使JDBC更加容易使用；提供DAO（数据访问对象）支持，非常方便集成第三方ORM框架，比如Hibernate等；并且完全支持Spring事务和使用Spring提供的一致的异常体系。</p><p>●灵活的Web层支持：Spring本身提供一套非常强大的MVC框架，而且可以非常容易的与第三方MVC框架集成，比如Struts等。</p><p>●简化各种技术集成：提供对Java Mail、任务调度、JMX、JMS、JNDI、EJB、动态语言、远程访问、Web Service等的集成。</p><p>Spring能帮助我们简化应用程序开发，帮助我们创建和组装对象，为我们管理事务，简单的MVC框架，可以把Spring看作是一个超级粘合平台，能把很多技术整合在一起，形成一个整体，使系统结构更优良、性能更出众，从而加速我们程序开发，有如上优点，我们没有理由不考虑使用它。</p><h3 id="如何学好Spring"><a href="#如何学好Spring" class="headerlink" title="如何学好Spring"></a>如何学好Spring</h3><p>要学好Spring，首先要明确Spring是个什么东西，能帮我们做些什么事情，知道了这些然后做个简单的例子，这样就基本知道怎么使用Spring了。Spring核心是IoC容器，所以一定要透彻理解什么是IoC容器，以及如何配置及使用容器，其他所有技术都是基于容器实现的；理解好IoC后，接下来是面向切面编程，首先还是明确概念，基本配置，最后是实现原理，接下来就是数据库事务管理，其实Spring管理事务是通过面向切面编程实现的，所以基础很重要，IoC容器和面向切面编程搞定后，其余都是基于这俩东西的实现，学起来就更加轻松了。要学好Spring不能急，一定要把基础打牢，基础牢固了，这就是磨刀不误砍柴工。</p><h2 id="Spring基础"><a href="#Spring基础" class="headerlink" title="Spring基础"></a>Spring基础</h2><h3 id="Spring架构图"><a href="#Spring架构图" class="headerlink" title="Spring架构图"></a>Spring架构图</h3><p> <img src="http://sishuok.com/forum/upload/2012/2/19/c7d3b7851018141de052e5133093873b__1.JPG" alt=""></p><p>图 1-1 Spring架构图</p><p>核心容器：包括Core、Beans、Context、EL模块。</p><p>●Core模块：封装了框架依赖的最底层部分，包括资源访问、类型转换及一些常用工具类。</p><p>●Beans模块：提供了框架的基础部分，包括反转控制和依赖注入。其中Bean Factory是容器核心，本质是“工厂设计模式”的实现，而且无需编程实现“单例设计模式”，单例完全由容器控制，而且提倡面向接口编程，而非面向实现编程；所有应用程序对象及对象间关系由框架管理，从而真正把你从程序逻辑中把维护对象之间的依赖关系提取出来，所有这些依赖关系都由BeanFactory来维护。</p><p>●Context模块：以Core和Beans为基础，集成Beans模块功能并添加资源绑定、数据验证、国际化、Java EE支持、容器生命周期、事件传播等；核心接口是ApplicationContext。</p><p>●EL模块：提供强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从Spring 容器获取Bean，它也支持列表投影、选择和一般的列表聚合等。</p><p>AOP、Aspects模块：</p><p>●AOP模块：Spring AOP模块提供了符合 AOP Alliance规范的面向方面的编程（aspect-oriented programming）实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中；这样各专其职，降低业务逻辑和通用功能的耦合。</p><p>●Aspects模块：提供了对AspectJ的集成，AspectJ提供了比Spring ASP更强大的功能。</p><p>数据访问/集成模块：该模块包括了JDBC、ORM、OXM、JMS和事务管理。</p><p>●事务模块：该模块用于Spring管理事务，只要是Spring管理对象都能得到Spring管理事务的好处，无需在代码中进行事务控制了，而且支持编程和声明性的事物管理。</p><p>●JDBC模块：提供了一个JBDC的样例模板，使用这些模板能消除传统冗长的JDBC编码还有必须的事务控制，而且能享受到Spring管理事务的好处。</p><p>●ORM模块：提供与流行的“对象-关系”映射框架的无缝集成，包括Hibernate、JPA、Ibatiss等。而且可以使用Spring事务管理，无需额外控制事务。</p><p>●OXM模块：提供了一个对Object/XML映射实现，将java对象映射成XML数据，或者将XML数据映射成java对象，Object/XML映射实现包括JAXB、Castor、XMLBeans和XStream。</p><p>●JMS模块：用于JMS(Java Messaging Service)，提供一套 “消息生产者、消息消费者”模板用于更加简单的使用JMS，JMS用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</p><p>●Web/Remoting模块：Web/Remoting模块包含了Web、Web-Servlet、Web-Struts、Web-Porlet模块。</p><p>●Web模块：提供了基础的web功能。例如多文件上传、集成IoC容器、远程过程访问（RMI、Hessian、Burlap）以及Web Service支持，并提供一个RestTemplate类来提供方便的Restful services访问。</p><p>●Web-Servlet模块：提供了一个Spring MVC Web框架实现。Spring MVC框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的JSP标签，完全无缝与Spring其他技术协作。</p><p>●Web-Struts模块：提供了与Struts无缝集成，Struts1.x 和Struts2.x都支持</p><p>Test模块： Spring支持Junit和TestNG测试框架，而且还额外提供了一些基于Spring的测试功能，比如在测试Web框架时，模拟Http请求的功能。</p><h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><p>Spring可以应用到许多场景，从最简单的标准Java SE程序到企业级应用程序都能使用Spring来构建。以下介绍几个比较流行的应用场景：</p><p>●典型Web应用程序应用场景：</p><p> <img src="http://sishuok.com/forum/upload/2012/2/19/8408cf6209ae50fad705cb37aa963b98__2.JPG" alt=""></p><p>图1-2 web应用程序应用场景</p><p>在Web应用程序应用场景中，典型的三层架构：数据模型层实现域对象；数据访问层实现数据访问；逻辑层实现业务逻辑；web层提供页面展示；所有这些层组件都由Spring进行管理，享受到Spring事务管理、AOP等好处，而且请求唯一入口就是DispachterServlet，它通过把请求映射为相应web层组件来实现相应请求功能。</p><p>●远程访问应用场景：</p><p>Spring能非常方便的提供暴露RMI服务，远程访问服务如Hessian、Burlap等，实现非常简单只需通过在Spring中配置相应的地址及需要暴露的服务即可轻松实现，后边会有介绍；</p><p>●EJB应用场景：</p><p>Spring也可以与EJB轻松集成，后边会详细介绍。</p><p>注：如果想要更加深入的了解IoC和DI，请参考大师级人物Martin Fowler的一篇经典文章《Inversion of Control Containers and the Dependency Injection pattern》，原文地址：<a href="http://www.martinfowler.com/articles/injection.html。" target="_blank" rel="noopener">http://www.martinfowler.com/articles/injection.html。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Spring源码解析 &lt;a href=&quot;https://blog.csdn.net/column/details/21851.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21851.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Spring" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Spring/"/>
    
    
      <category term="Spring" scheme="http://h2pl.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程与NIO详解15：Tomcat中的Connector源码分析（NIO）</title>
    <link href="http://h2pl.github.io/2018/05/29/Javanet15/"/>
    <id>http://h2pl.github.io/2018/05/29/Javanet15/</id>
    <published>2018-05-29T03:54:25.000Z</published>
    <updated>2018-06-11T12:45:24.822Z</updated>
    
    <content type="html"><![CDATA[<p>Tomcat 中的 NIO 源码分析</p><p>转自<a href="https://www.javadoop.com/post/tomcat-nio#toc1" target="_blank" rel="noopener">https://www.javadoop.com/post/tomcat-nio#toc1</a></p><p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java网络编程和NIO<br><a href="https://blog.csdn.net/column/details/21963.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21963.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><p>之前写了两篇关于 NIO 的文章，第一篇介绍了 NIO 的 Channel、Buffer、Selector 使用，第二篇介绍了非阻塞 IO 和异步 IO，并展示了简单的用例。</p><p>本文将介绍 Tomcat 中的 NIO 使用，使大家对 Java NIO 的生产使用有更加直观的认识。</p><p>虽然本文的源码篇幅也不短，但是 Tomcat 的源码毕竟不像 Doug Lea 的并发源码那么“变态”，对于大部分读者来说，阅读难度比之前介绍的其他并发源码要简单一些，所以读者不要觉得有什么压力。</p><p>本文基于 Tomcat 当前（2018-03-20）最新版本 9.0.6。</p><p>先简单画一张图示意一下本文的主要内容：</p><p><img src="https://www.javadoop.com/blogimages/tomcat-nio/0.png" alt="0"></p><p>目录</p><ul><li><a href="https://www.javadoop.com/post/tomcat-nio#%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87" target="_blank" rel="noopener">源码环境准备</a></li><li><a href="https://www.javadoop.com/post/tomcat-nio#endpoint" target="_blank" rel="noopener">endpoint</a></li><li><a href="https://www.javadoop.com/post/tomcat-nio#init%20%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90" target="_blank" rel="noopener">init 过程分析</a></li><li><a href="https://www.javadoop.com/post/tomcat-nio#start%20%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90" target="_blank" rel="noopener">start 过程分析</a></li><li><a href="https://www.javadoop.com/post/tomcat-nio#Acceptor" target="_blank" rel="noopener">Acceptor</a></li><li><a href="https://www.javadoop.com/post/tomcat-nio#Poller" target="_blank" rel="noopener">Poller</a></li><li><a href="https://www.javadoop.com/post/tomcat-nio#processKey" target="_blank" rel="noopener">processKey</a></li><li><a href="https://www.javadoop.com/post/tomcat-nio#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">总结</a></li></ul><h2 id="源码环境准备"><a href="#源码环境准备" class="headerlink" title="源码环境准备"></a>源码环境准备</h2><p>Tomcat 9.0.6 下载地址：<a href="https://tomcat.apache.org/download-90.cgi" target="_blank" rel="noopener">https://tomcat.apache.org/download-90.cgi</a></p><p>由于上面下载的 tomcat 的源码并没有使用 maven 进行组织，不方便我们看源码，也不方便我们进行调试。这里我们将使用 maven 仓库中的 tomcat-embed-core，自己编写代码进行启动的方式来进行调试。</p><p>首先，创建一个空的 maven 工程，然后添加以下依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    tomcat-embed-core</span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的依赖，只会将 tomcat-embed-core-9.0.6.jar 和 tomcat-annotations-api-9.0.6.jar 两个包引进来，对于本文来说，已经足够了，如果你需要其他功能，需要额外引用其他的依赖，如 Jasper。</p></blockquote><p>然后，使用以下启动方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">   Tomcat tomcat = <span class="keyword">new</span> Tomcat();</span><br><span class="line"></span><br><span class="line">   Connector connector = <span class="keyword">new</span> Connector(<span class="string">"HTTP/1.1"</span>);</span><br><span class="line">   connector.setPort(<span class="number">8080</span>);</span><br><span class="line">   tomcat.setConnector(connector);</span><br><span class="line"></span><br><span class="line">   tomcat.start();</span><br><span class="line">   tomcat.getServer().await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过以上的代码，我们的 Tomcat 就启动起来了。</p><blockquote><p>Tomcat 中的其他接口感兴趣的读者请自行探索，如设置 webapp 目录，设置 resources 等</p></blockquote><p>这里，介绍第一个重要的概念：Connector。在 Tomcat 中，使用 Connector 来处理连接，一个 Tomcat 可以配置多个 Connector，分别用于监听不同端口，或处理不同协议。</p><p>在 Connector 的构造方法中，我们可以传 <code>HTTP/1.1</code> 或 <code>AJP/1.3</code> 用于指定协议，也可以传入相应的协议处理类，毕竟协议不是重点，将不同端口进来的连接对应不同处理类才是正道。典型地，我们可以指定以下几个协议处理类：</p><ul><li>org.apache.coyote.http11.Http11NioProtocol：对应非阻塞 IO</li><li>org.apache.coyote.http11.Http11Nio2Protocol：对应异步 IO</li><li>org.apache.coyote.http2.Http2Protocol：对应 http2 协议，对 http2 感兴趣的读者，赶紧看起来吧。</li></ul><p>本文的重点当然是非阻塞 IO 了，之前已经介绍过<code>异步 IO</code>的基础知识了，读者看完本文后，如果对异步 IO 的处理流程感兴趣，可以自行去分析一遍。</p><blockquote><p>如果你使用 9.0 以前的版本，Tomcat 在启动的时候是会自动配置一个 connector 的，我们可以不用显示配置。</p><p>9.0 版本的 Tomcat#start() 方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> public void start() throws LifecycleException &#123;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     getServer();</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     server.start();</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>8.5 及之前版本的 Tomcat#start() 方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> public void start() throws LifecycleException &#123;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     getServer();</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     // 自动配置一个使用非阻塞 IO 的 connector</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     getConnector();</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     server.start();</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><h2 id="endpoint"><a href="#endpoint" class="headerlink" title="endpoint"></a>endpoint</h2><p>前面我们说过一个 Connector 对应一个协议，当然这描述也不太对，NIO 和 NIO2 就都是处理 HTTP/1.1 的，只不过一个使用非阻塞，一个使用异步。进到指定 protocol 代码，我们就会发现，它们的代码及其简单，只不过是指定了特定的 endpoint。</p><p>打开 <code>Http11NioProtocol</code> 和 <code>Http11Nio2Protocol</code>源码，我们可以看到，在构造方法中，它们分别指定了 NioEndpoint 和 Nio2Endpoint。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非阻塞模式</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Http11NioProtocol</span> <span class="keyword">extends</span> <span class="title">AbstractHttp11JsseProtocol&lt;NioChannel&gt;</span> </span>&#123;</span><br><span class="line">    public <span class="type">Http11NioProtocol</span>() &#123;</span><br><span class="line">        <span class="comment">// NioEndpoint</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> <span class="type">NioEndpoint</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异步模式</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Http11Nio2Protocol</span> <span class="keyword">extends</span> <span class="title">AbstractHttp11JsseProtocol&lt;Nio2Channel&gt;</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    public <span class="type">Http11Nio2Protocol</span>() &#123;</span><br><span class="line">        <span class="comment">// Nio2Endpoint</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> <span class="type">Nio2Endpoint</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里介绍第二个重要的概念：endpoint。Tomcat 使用不同的 endpoint 来处理不同的协议请求，今天我们的重点是 NioEndpoint，其使用非阻塞 IO 来进行处理 HTTP/1.1 协议的请求。</p><p>NioEndpoint 继承 =&gt; AbstractJsseEndpoint 继承 =&gt; AbstractEndpoint。中间的 AbstractJsseEndpoint 主要是提供了一些关于 <code>HTTPS</code> 的方法，这块我们暂时忽略它，后面所有关于 HTTPS 的我们都直接忽略，感兴趣的读者请自行分析。</p><h2 id="init-过程分析"><a href="#init-过程分析" class="headerlink" title="init 过程分析"></a>init 过程分析</h2><p>下面，我们看看从 tomcat.start() 一直到 NioEndpoint 的过程。</p><p>1. AbstractProtocol # init</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    String endpointName = getName();</span><br><span class="line">    endpoint.setName(endpointName.substring(<span class="number">1</span>, endpointName.length()<span class="number">-1</span>));</span><br><span class="line">    endpoint.setDomain(domain);</span><br><span class="line">    <span class="comment">// endpoint 的 name=http-nio-8089,domain=Tomcat</span></span><br><span class="line">    endpoint.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2. AbstractEndpoint # init</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bindOnInit) &#123;</span><br><span class="line">        bind(); <span class="comment">// 这里对应的当然是子类 NioEndpoint 的 bind() 方法</span></span><br><span class="line">        bindState = BindState.BOUND_ON_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3. NioEndpoint # bind</p><p>这里就到我们的 NioEndpoint 了，要使用到我们之前学习的 NIO 的知识了。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// initServerSocket(); 原代码是这行，我们 “内联” 过来一起说</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启 ServerSocketChannel</span></span><br><span class="line">    serverSock = ServerSocketChannel.open();</span><br><span class="line">    socketProperties.setProperties(serverSock.socket());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getPort() 会返回我们最开始设置的 8080，得到我们的 address 是 0.0.0.0:8080</span></span><br><span class="line">    InetSocketAddress addr = (getAddress()!=<span class="keyword">null</span>?<span class="keyword">new</span> InetSocketAddress(getAddress(),getPort()):<span class="keyword">new</span> InetSocketAddress(getPort()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ServerSocketChannel 绑定地址、端口，</span></span><br><span class="line">    <span class="comment">// 第二个参数 backlog 默认为 100，超过 100 的时候，新连接会被拒绝(不过源码注释也说了，这个值的真实语义取决于具体实现)</span></span><br><span class="line">    serverSock.socket().bind(addr,getAcceptCount());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ※※※ 设置 ServerSocketChannel 为阻塞模式 ※※※</span></span><br><span class="line">    serverSock.configureBlocking(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 acceptor 和 poller 的数量，至于它们是什么角色，待会说</span></span><br><span class="line">    <span class="comment">// acceptorThreadCount 默认为 1</span></span><br><span class="line">    <span class="keyword">if</span> (acceptorThreadCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> Doesn't seem to work that well with multiple accept threads</span></span><br><span class="line">        <span class="comment">// 作者想表达的意思应该是：使用多个 acceptor 线程并不见得性能会更好</span></span><br><span class="line">        acceptorThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// poller 线程数，默认值定义如下，所以在多核模式下，默认为 2</span></span><br><span class="line">    <span class="comment">// pollerThreadCount = Math.min(2,Runtime.getRuntime().availableProcessors());</span></span><br><span class="line">    <span class="keyword">if</span> (pollerThreadCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        pollerThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    setStopLatch(<span class="keyword">new</span> CountDownLatch(pollerThreadCount));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 ssl，我们忽略 ssl</span></span><br><span class="line">    initialiseSsl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开 NioSelectorPool，先忽略它</span></span><br><span class="line">    selectorPool.open();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>ServerSocketChannel 已经打开，并且绑定要了之前指定的 8080 端口，设置成了阻塞模式。</li><li>设置了 acceptor 的线程数为 1</li><li>设置了 poller 的线程数，单核 CPU 为 1，多核为 2</li><li>打开了一个 SelectorPool，我们先忽略这个</li></ol><p>到这里，我们还不知道 Acceptor 和 Poller 是什么东西，我们只是设置了它们的数量，我们先来看看最后面提到的 SelectorPool。</p><h2 id="start-过程分析"><a href="#start-过程分析" class="headerlink" title="start 过程分析"></a>start 过程分析</h2><p>刚刚我们分析完了 init() 过程，下面是启动过程 start() 分析。</p><p>AbstractProtocol # start</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="literal">void</span> start() throws Exception &#123;</span><br><span class="line">    <span class="params">...</span></span><br><span class="line">    <span class="comment">// 调用 endpoint 的 start 方法</span></span><br><span class="line">    endpoint.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start async timeout thread</span></span><br><span class="line">    asyncTimeout = <span class="literal">new</span> AsyncTimeout();</span><br><span class="line">    <span class="keyword">Thread</span> timeoutThread = <span class="literal">new</span> <span class="keyword">Thread</span>(asyncTimeout, getNameInternal() + <span class="string">"-AsyncTimeout"</span>);</span><br><span class="line">    int priority = endpoint.getThreadPriority();</span><br><span class="line">    <span class="keyword">if</span> (priority &lt; <span class="keyword">Thread</span>.MIN_PRIORITY || priority &gt; <span class="keyword">Thread</span>.MAX_PRIORITY) &#123;</span><br><span class="line">        priority = <span class="keyword">Thread</span>.NORM_PRIORITY;</span><br><span class="line">    &#125;</span><br><span class="line">    timeoutThread.setPriority(priority);</span><br><span class="line">    timeoutThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">    timeoutThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractEndpoint # start</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">public</span> final void start() throws Exception &#123;</span><br><span class="line">    // 按照我们的流程，刚刚 init 的时候，已经把 <span class="keyword">bindState </span>改为 <span class="keyword">BindState.BOUND_ON_INIT </span>了，</span><br><span class="line">    // 所以下面的 <span class="meta">if</span> 分支我们就不进去了</span><br><span class="line">    <span class="meta">if</span> (<span class="keyword">bindState </span>== <span class="keyword">BindState.UNBOUND) </span>&#123;</span><br><span class="line">        <span class="keyword">bind();</span></span><br><span class="line"><span class="keyword"> </span>       <span class="keyword">bindState </span>= <span class="keyword">BindState.BOUND_ON_START;</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">    // 往里看 NioEndpoint 的实现</span><br><span class="line">    startInternal()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个方法还是比较重要的，这里会创建前面说过的 acceptor 和 poller。</p><p>NioEndpoint # startInternal</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> void startInternal() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">        running = <span class="literal">true</span>;</span><br><span class="line">        paused = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下几个是缓存用的，之后我们也会看到很多这样的代码，为了减少 new 很多对象出来</span></span><br><span class="line">        processorCache = <span class="keyword">new</span> <span class="type">SynchronizedStack</span>&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                socketProperties.getProcessorCache());</span><br><span class="line">        eventCache = <span class="keyword">new</span> <span class="type">SynchronizedStack</span>&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                        socketProperties.getEventCache());</span><br><span class="line">        nioChannels = <span class="keyword">new</span> <span class="type">SynchronizedStack</span>&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                socketProperties.getBufferPool());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建【工作线程池】，Tomcat 自己包装了一下 ThreadPoolExecutor，</span></span><br><span class="line">        <span class="comment">// 1\. 为了在创建线程池以后，先启动 corePoolSize 个线程(这个属于线程池的知识了，不熟悉的读者可以看看我之前的文章)</span></span><br><span class="line">        <span class="comment">// 2\. 自己管理线程池的增长方式（默认 corePoolSize 10, maxPoolSize 200），不是本文重点，不分析</span></span><br><span class="line">        <span class="keyword">if</span> ( getExecutor() == <span class="literal">null</span> ) &#123;</span><br><span class="line">            createExecutor();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置一个栅栏（tomcat 自定义了类 LimitLatch），控制最大的连接数，默认是 10000</span></span><br><span class="line">        initializeConnectionLatch();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启 poller 线程</span></span><br><span class="line">        <span class="comment">// 还记得之前 init 的时候，默认地设置了 poller 的数量为 2，所以这里启动 2 个 poller 线程</span></span><br><span class="line">        pollers = <span class="keyword">new</span> <span class="type">Poller</span>[getPollerThreadCount()];</span><br><span class="line">        <span class="keyword">for</span> (int i=<span class="number">0</span>; i&lt;pollers.length; i++) &#123;</span><br><span class="line">            pollers[i] = <span class="keyword">new</span> <span class="type">Poller</span>();</span><br><span class="line">            Thread pollerThread = <span class="keyword">new</span> <span class="type">Thread</span>(pollers[i], getName() + <span class="string">"-ClientPoller-"</span>+i);</span><br><span class="line">            pollerThread.setPriority(threadPriority);</span><br><span class="line">            pollerThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">            pollerThread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启 acceptor 线程，和开启 poller 线程组差不多。</span></span><br><span class="line">        <span class="comment">// init 的时候，默认地，acceptor 的线程数是 1</span></span><br><span class="line">        startAcceptorThreads();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们启动了工作线程池、 poller 线程组、acceptor 线程组。同时，工作线程池初始就已经启动了 10 个线程。我们用 jconsole 来看看此时的线程，请看下图：</p><p><img src="https://www.javadoop.com/blogimages/tomcat-nio/1.png" alt="1"></p><p>从 jconsole 中，我们可以看到，此时启动了 BlockPoller、worker、poller、acceptor、AsyncTimeout，大家应该都已经清楚了每个线程是哪里启动的吧。</p><blockquote><p>Tomcat 中并没有 Worker 这个类，此名字是我瞎编。</p></blockquote><p>此时，我们还是不知道 acceptor、poller 甚至 worker 到底是干嘛的，下面，我们从 acceptor 线程开始看起。</p><h2 id="Acceptor"><a href="#Acceptor" class="headerlink" title="Acceptor"></a>Acceptor</h2><p>它的结构非常简单，在构造函数中，已经把 endpoint 传进来了，此外就只有 threadName 和 state 两个简单的属性。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AbstractEndpoint&lt;?,U&gt; endpoint;</span><br><span class="line"><span class="keyword">private</span> String threadName;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> AcceptorState state = AcceptorState.NEW;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Acceptor</span><span class="params">(AbstractEndpoint&lt;?,U&gt; endpoint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.endpoint = endpoint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>threadName 就是一个线程名字而已，Acceptor 的状态 state 主要是随着 endpoint 来的。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">AcceptorState</span> &#123;</span></span><br><span class="line">    NEW, RUNNING, PAUSED, ENDED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们直接来看 acceptor 的 run 方法吧：</p><p>Acceptor # run</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> errorDelay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要 endpoint 处于 running，这里就一直循环</span></span><br><span class="line">    <span class="keyword">while</span> (endpoint.isRunning()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 endpoint 处于 pause 状态，这边 Acceptor 用一个 while 循环将自己也挂起</span></span><br><span class="line">        <span class="keyword">while</span> (endpoint.isPaused() &amp;&amp; endpoint.isRunning()) &#123;</span><br><span class="line">            state = AcceptorState.PAUSED;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// endpoint 结束了，Acceptor 自然也要结束嘛</span></span><br><span class="line">        <span class="keyword">if</span> (!endpoint.isRunning()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        state = AcceptorState.RUNNING;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果此时达到了最大连接数(之前我们说过，默认是10000)，就等待</span></span><br><span class="line">            endpoint.countUpOrAwaitConnection();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Endpoint might have been paused while waiting for latch</span></span><br><span class="line">            <span class="comment">// If that is the case, don't accept new connections</span></span><br><span class="line">            <span class="keyword">if</span> (endpoint.isPaused()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            U socket = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 这里就是接收下一个进来的 SocketChannel</span></span><br><span class="line">                <span class="comment">// 之前我们设置了 ServerSocketChannel 为阻塞模式，所以这边的 accept 是阻塞的</span></span><br><span class="line">                socket = endpoint.serverSocketAccept();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ioe) &#123;</span><br><span class="line">                <span class="comment">// We didn't get a socket</span></span><br><span class="line">                endpoint.countDownConnection();</span><br><span class="line">                <span class="keyword">if</span> (endpoint.isRunning()) &#123;</span><br><span class="line">                    <span class="comment">// Introduce delay if necessary</span></span><br><span class="line">                    errorDelay = handleExceptionWithDelay(errorDelay);</span><br><span class="line">                    <span class="comment">// re-throw</span></span><br><span class="line">                    <span class="keyword">throw</span> ioe;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// accept 成功，将 errorDelay 设置为 0</span></span><br><span class="line">            errorDelay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (endpoint.isRunning() &amp;&amp; !endpoint.isPaused()) &#123;</span><br><span class="line">                <span class="comment">// setSocketOptions() 是这里的关键方法，也就是说前面千辛万苦都是为了能到这里进行处理</span></span><br><span class="line">                <span class="keyword">if</span> (!endpoint.setSocketOptions(socket)) &#123;</span><br><span class="line">                    <span class="comment">// 如果上面的方法返回 false，关闭 SocketChannel</span></span><br><span class="line">                    endpoint.closeSocket(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 由于 endpoint 不 running 了，或者处于 pause 了，将此 SocketChannel 关闭</span></span><br><span class="line">                endpoint.destroySocket(socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(t);</span><br><span class="line">            String msg = sm.getString(<span class="string">"endpoint.accept.fail"</span>);</span><br><span class="line">            <span class="comment">// APR specific.</span></span><br><span class="line">            <span class="comment">// Could push this down but not sure it is worth the trouble.</span></span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                Error e = (Error) t;</span><br><span class="line">                <span class="keyword">if</span> (e.getError() == <span class="number">233</span>) &#123;</span><br><span class="line">                    <span class="comment">// Not an error on HP-UX so log as a warning</span></span><br><span class="line">                    <span class="comment">// so it can be filtered out on that platform</span></span><br><span class="line">                    <span class="comment">// See bug 50273</span></span><br><span class="line">                    log.warn(msg, t);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.<span class="keyword">error</span>(msg, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.<span class="keyword">error</span>(msg, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    state = AcceptorState.ENDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家应该发现了，Acceptor 绕来绕去，都是在调用 NioEndpoint 的方法，我们简单分析一下这个。</p><p>在 NioEndpoint init 的时候，我们开启了一个 ServerSocketChannel，后来 start 的时候，我们开启多个 acceptor（实际上，默认是 1 个），每个 acceptor 启动以后就开始循环调用 ServerSocketChannel 的 accept() 方法获取新的连接，然后调用 endpoint.setSocketOptions(socket) 处理新的连接，之后再进入循环 accept 下一个连接。</p><p>到这里，大家应该也就知道了，为什么这个叫 acceptor 了吧？接下来，我们来看看 setSocketOptions 方法到底做了什么。</p><p>NioEndpoint # setSocketOptions</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">setSocketOptions</span><span class="params">(SocketChannel socket)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 设置该 SocketChannel 为非阻塞模式</span></span><br><span class="line">        socket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        Socket sock = socket.socket();</span><br><span class="line">        <span class="comment">// 设置 socket 的一些属性</span></span><br><span class="line">        socketProperties.setProperties(sock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还记得 startInternal 的时候，说过了 nioChannels 是缓存用的。</span></span><br><span class="line">        <span class="comment">// 限于篇幅，这里的 NioChannel 就不展开了，它包括了 socket 和 buffer</span></span><br><span class="line">        NioChannel channel = nioChannels.pop();</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 主要是创建读和写的两个 buffer，默认地，读和写 buffer 都是 8192 字节，8k</span></span><br><span class="line">            SocketBufferHandler bufhandler = <span class="keyword">new</span> SocketBufferHandler(</span><br><span class="line">                    socketProperties.getAppReadBufSize(),</span><br><span class="line">                    socketProperties.getAppWriteBufSize(),</span><br><span class="line">                    socketProperties.getDirectBuffer());</span><br><span class="line">            <span class="keyword">if</span> (isSSLEnabled()) &#123;</span><br><span class="line">                channel = <span class="keyword">new</span> SecureNioChannel(socket, bufhandler, selectorPool, <span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channel = <span class="keyword">new</span> NioChannel(socket, bufhandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.setIOChannel(socket);</span><br><span class="line">            channel.reset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getPoller0() 会选取所有 poller 中的一个 poller</span></span><br><span class="line">        getPoller0().register(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.<span class="keyword">error</span>(<span class="string">""</span>,t);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable tt) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(tt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Tell to close the socket</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，这里又没有进行实际的处理，而是将这个 SocketChannel 注册到了其中一个 poller 上。因为我们知道，acceptor 应该尽可能的简单，只做 accept 的工作，简单处理下就往后面扔。acceptor 还得回到之前的循环去 accept 新的连接呢。</p><p>我们只需要明白，此时，往 poller 中注册了一个 NioChannel 实例，此实例包含客户端过来的 SocketChannel 和一个 SocketBufferHandler 实例。</p><h2 id="Poller"><a href="#Poller" class="headerlink" title="Poller"></a>Poller</h2><p>之前我们看到 acceptor 将一个 NioChannel 实例 register 到了一个 poller 中。在看 register 方法之前，我们需要先对 poller 要有个简单的认识。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Poller</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 每个 poller 开启一个 Selector</span></span><br><span class="line">        <span class="keyword">this</span>.selector = Selector.open();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="comment">// events 队列，此类的核心</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SynchronizedQueue&lt;PollerEvent&gt; events =</span><br><span class="line">            <span class="keyword">new</span> SynchronizedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> close = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> nextExpiration = <span class="number">0</span>;<span class="comment">//optimize expiration handling</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个值后面有用，记住它的初始值为 0</span></span><br><span class="line">    <span class="keyword">private</span> AtomicLong wakeupCounter = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> keyCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>敲重点：每个 poller 关联了一个 Selector。</p></blockquote><p>Poller 内部围着一个 events 队列转，来看看其 events() 方法：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> events() &#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    PollerEvent pe = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, <span class="keyword">size</span> = events.<span class="keyword">size</span>(); i &lt; <span class="keyword">size</span> &amp;&amp; (pe = events.poll()) != <span class="keyword">null</span>; i++ ) &#123;</span><br><span class="line">        result = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 逐个执行 event.run()</span></span><br><span class="line">            pe.run();</span><br><span class="line">            <span class="comment">// 该 PollerEvent 还得给以后用，这里 reset 一下(还是之前说过的缓存)</span></span><br><span class="line">            pe.reset();</span><br><span class="line">            <span class="keyword">if</span> (running &amp;&amp; !paused) &#123;</span><br><span class="line">                eventCache.<span class="keyword">push</span>(pe);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> ( Throwable x ) &#123;</span><br><span class="line">            log.error(<span class="string">""</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>events() 方法比较简单，就是取出当前队列中的 PollerEvent 对象，逐个执行 event.run() 方法。</p><p>然后，现在来看 Poller 的 run() 方法，该方法会一直循环，直到 poller.destroy() 被调用。</p><p>Poller # run</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        boolean hasEvents = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!close) &#123;</span><br><span class="line">                <span class="comment">// 执行 events 队列中每个 event 的 run() 方法</span></span><br><span class="line">                hasEvents = events();</span><br><span class="line">                <span class="comment">// wakeupCounter 的初始值为 0，这里设置为 -1</span></span><br><span class="line">                <span class="keyword">if</span> (wakeupCounter.getAndSet(<span class="number">-1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//if we are here, means we have other stuff to do</span></span><br><span class="line">                    <span class="comment">//do a non blocking select</span></span><br><span class="line">                    keyCount = selector.selectNow();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// timeout 默认值 1 秒</span></span><br><span class="line">                    keyCount = selector.<span class="keyword">select</span>(selectorTimeout);</span><br><span class="line">                &#125;</span><br><span class="line">                wakeupCounter.<span class="keyword">set</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 篇幅所限，我们就不说 close 的情况了</span></span><br><span class="line">            <span class="keyword">if</span> (close) &#123;</span><br><span class="line">                events();</span><br><span class="line">                timeout(<span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                    log.error(sm.getString(<span class="string">"endpoint.nio.selectorCloseFail"</span>), ioe);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(x);</span><br><span class="line">            log.error(<span class="string">""</span>,x);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//either we timed out or we woke up, process events first</span></span><br><span class="line">        <span class="comment">// 这里没什么好说的，顶多就再执行一次 events() 方法</span></span><br><span class="line">        <span class="keyword">if</span> ( keyCount == <span class="number">0</span> ) hasEvents = (hasEvents | events());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果刚刚 select 有返回 ready keys，进行处理</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">            keyCount &gt; <span class="number">0</span> ? selector.selectedKeys().iterator() : <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// Walk through the collection of ready keys and dispatch</span></span><br><span class="line">        <span class="comment">// any active event.</span></span><br><span class="line">        <span class="keyword">while</span> (iterator != <span class="literal">null</span> &amp;&amp; iterator.hasNext()) &#123;</span><br><span class="line">            SelectionKey sk = iterator.next();</span><br><span class="line">            NioSocketWrapper attachment = (NioSocketWrapper)sk.attachment();</span><br><span class="line">            <span class="comment">// Attachment may be null if another thread has called</span></span><br><span class="line">            <span class="comment">// cancelledKey()</span></span><br><span class="line">            <span class="keyword">if</span> (attachment == <span class="literal">null</span>) &#123;</span><br><span class="line">                iterator.<span class="keyword">remove</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                iterator.<span class="keyword">remove</span>();</span><br><span class="line">                <span class="comment">// ※※※※※ 处理 ready key ※※※※※</span></span><br><span class="line">                processKey(sk, attachment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//while</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//process timeouts</span></span><br><span class="line">        timeout(keyCount,hasEvents);</span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line"></span><br><span class="line">    getStopLatch().countDown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>poller 的 run() 方法主要做了调用 events() 方法和处理注册到 Selector 上的 ready key，这里我们暂时不展开 processKey 方法，因为此方法必定是及其复杂的。</p><p>我们回过头来看之前从 acceptor 线程中调用的 register 方法。</p><p>Poller # register</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void register(final <span class="type">NioChannel</span> socket) &#123;</span><br><span class="line">    socket.setPoller(<span class="literal">this</span>);</span><br><span class="line">    <span class="type">NioSocketWrapper</span> ka = <span class="function"><span class="keyword">new</span> <span class="title">NioSocketWrapper</span>(socket, <span class="type">NioEndpoint</span>.this);</span></span><br><span class="line"><span class="function">    <span class="title">socket</span>.<span class="title">setSocketWrapper</span>(ka);</span></span><br><span class="line"><span class="function">    <span class="title">ka</span>.<span class="title">setPoller</span>(this);</span></span><br><span class="line"><span class="function">    <span class="title">ka</span>.<span class="title">setReadTimeout</span>(getConnectionTimeout());</span></span><br><span class="line"><span class="function">    <span class="title">ka</span>.<span class="title">setWriteTimeout</span>(getConnectionTimeout());</span></span><br><span class="line"><span class="function">    <span class="title">ka</span>.<span class="title">setKeepAliveLeft</span>(<span class="type">NioEndpoint</span>.this.getMaxKeepAliveRequests());</span></span><br><span class="line"><span class="function">    <span class="title">ka</span>.<span class="title">setSecure</span>(isSSLEnabled());</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">PollerEvent</span> <span class="title">r</span> = <span class="title">eventCache</span>.<span class="title">pop</span>();</span></span><br><span class="line"><span class="function">    <span class="title">ka</span>.<span class="title">interestOps</span>(<span class="type">SelectionKey</span>.<span class="type">OP_READ</span>);<span class="comment">//this is what OP_REGISTER turns into.</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 注意第三个参数值 OP_REGISTER</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> ( r==null) <span class="title">r</span> = <span class="title">new</span> <span class="title">PollerEvent</span>(socket,ka,<span class="type">OP_REGISTER</span>);</span></span><br><span class="line"><span class="function">    <span class="title">else</span> <span class="title">r</span>.<span class="title">reset</span>(socket,ka,<span class="type">OP_REGISTER</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 添加 event 到 poller 中</span></span></span><br><span class="line"><span class="function">    <span class="title">addEvent</span>(r);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>这里将这个 socket（包含 socket 和 buffer 的 NioChannel 实例） 包装为一个 PollerEvent，然后添加到 events 中，此时调用此方法的 acceptor 结束返回，去处理新的 accepted 连接了。</p><p>接下来，我们已经知道了，poller 线程在循环过程中会不断调用 events() 方法，那么 PollerEvent 的 run() 方法很快就会被执行，我们就来看看刚刚这个新的连接被注册到这个 poller 后，会发生什么。</p><p>PollerEvent # run</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">    <span class="comment">// 对于新来的连接，前面我们说过，interestOps == OP_REGISTER</span></span><br><span class="line">    <span class="keyword">if</span> (interestOps == OP_REGISTER) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这步很关键！！！</span></span><br><span class="line">            <span class="comment">// 将这个新连接 SocketChannel 注册到该 poller 的 Selector 中，</span></span><br><span class="line">            <span class="comment">// 设置监听 OP_READ 事件，</span></span><br><span class="line">            <span class="comment">// 将 socketWrapper 设置为 attachment 进行传递(这个对象可是什么鬼都有，往上看就知道了)</span></span><br><span class="line">            socket.getIOChannel().register(</span><br><span class="line">                    socket.getPoller().getSelector(), SelectionKey.OP_READ, socketWrapper);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception x) &#123;</span><br><span class="line">            <span class="built_in">log</span>.error(sm.getString(<span class="string">"endpoint.nio.registerFail"</span>), x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* else 这块不介绍，省得大家头大 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> SelectionKey <span class="built_in">key</span> = socket.getIOChannel().keyFor(socket.getPoller().getSelector());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// The key was cancelled (e.g. due to socket closure)</span></span><br><span class="line">                <span class="comment">// and removed from the selector while it was being</span></span><br><span class="line">                <span class="comment">// processed. Count down the connections at this point</span></span><br><span class="line">                <span class="comment">// since it won't have been counted down when the socket</span></span><br><span class="line">                <span class="comment">// closed.</span></span><br><span class="line">                socket.socketWrapper.getEndpoint().countDownConnection();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> NioSocketWrapper socketWrapper = (NioSocketWrapper) <span class="built_in">key</span>.attachment();</span><br><span class="line">                <span class="keyword">if</span> (socketWrapper != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//we are registering the key to start with, reset the fairness counter.</span></span><br><span class="line">                    <span class="built_in">int</span> ops = <span class="built_in">key</span>.interestOps() | interestOps;</span><br><span class="line">                    socketWrapper.interestOps(ops);</span><br><span class="line">                    <span class="built_in">key</span>.interestOps(ops);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    socket.getPoller().cancelledKey(<span class="built_in">key</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException ckx) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.getPoller().cancelledKey(<span class="built_in">key</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ignore) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们再回顾一下：刚刚在 PollerEvent 的 run() 方法中，我们看到，新的 SocketChannel 注册到了 Poller 内部的 Selector 中，监听 OP_READ 事件，然后我们再回到 Poller 的 run() 看下，一旦该 SocketChannel 是 readable 的状态，那么就会进入到 poller 的 processKey 方法。</p><h2 id="processKey"><a href="#processKey" class="headerlink" title="processKey"></a>processKey</h2><p>Poller # processKey</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">processKey</span><span class="params">(SelectionKey sk, NioSocketWrapper attachment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( close ) &#123;</span><br><span class="line">            cancelledKey(sk);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( sk.isValid() &amp;&amp; attachment != <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sk.isReadable() || sk.isWritable() ) &#123;</span><br><span class="line">                <span class="comment">// 忽略 sendfile</span></span><br><span class="line">                <span class="keyword">if</span> ( attachment.getSendfileData() != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                    processSendfile(sk,attachment, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// unregister 相应的 interest set，</span></span><br><span class="line">                    <span class="comment">// 如接下来是处理 SocketChannel 进来的数据，那么就不再监听该 channel 的 OP_READ 事件</span></span><br><span class="line">                    unreg(sk, attachment, sk.readyOps());</span><br><span class="line">                    <span class="keyword">boolean</span> closeSocket = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// Read goes before write</span></span><br><span class="line">                    <span class="keyword">if</span> (sk.isReadable()) &#123;</span><br><span class="line">                        <span class="comment">// 处理读</span></span><br><span class="line">                        <span class="keyword">if</span> (!processSocket(attachment, SocketEvent.OPEN_READ, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                            closeSocket = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!closeSocket &amp;&amp; sk.isWritable()) &#123;</span><br><span class="line">                        <span class="comment">// 处理写</span></span><br><span class="line">                        <span class="keyword">if</span> (!processSocket(attachment, SocketEvent.OPEN_WRITE, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                            closeSocket = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (closeSocket) &#123;</span><br><span class="line">                        cancelledKey(sk);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//invalid key</span></span><br><span class="line">            cancelledKey(sk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> ( CancelledKeyException ckx ) &#123;</span><br><span class="line">        cancelledKey(sk);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        log.<span class="keyword">error</span>(<span class="string">""</span>,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是 processSocket 方法，注意第三个参数，上面进来的时候是 true。</p><p>AbstractEndpoint # processSocket</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> processSocket(SocketWrapperBase&lt;S&gt; socketWrapper,</span><br><span class="line">        SocketEvent event, <span class="keyword">boolean</span> dispatch) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (socketWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SocketProcessorBase&lt;S&gt; sc = processorCache.pop();</span><br><span class="line">        <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建一个 SocketProcessor 的实例</span></span><br><span class="line">            sc = createSocketProcessor(socketWrapper, event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sc.reset(socketWrapper, event);</span><br><span class="line">        &#125;</span><br><span class="line">        Executor executor = getExecutor();</span><br><span class="line">        <span class="keyword">if</span> (dispatch &amp;&amp; executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将任务放到之前建立的 worker 线程池中执行</span></span><br><span class="line">            executor.execute(sc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sc.run(); <span class="comment">// ps: 如果 dispatch 为 false，那么就当前线程自己执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException ree) &#123;</span><br><span class="line">        getLog().warn(sm.getString(<span class="string">"endpoint.executor.fail"</span>, socketWrapper) , ree);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        <span class="comment">// This means we got an OOM or similar creating a thread, or that</span></span><br><span class="line">        <span class="comment">// the pool and its queue are full</span></span><br><span class="line">        getLog().<span class="keyword">error</span>(sm.getString(<span class="string">"endpoint.process.fail"</span>), t);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NioEndpoint # createSocketProcessor</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">protected</span> SocketProcessorBase&lt;NioChannel&gt; <span class="title">createSocketProcessor</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        SocketWrapperBase&lt;NioChannel&gt; socketWrapper, SocketEvent <span class="keyword">event</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SocketProcessor(socketWrapper, <span class="keyword">event</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，提交到 worker 线程池中的是 NioEndpoint.SocketProcessor 的实例，至于它的 run() 方法之后的逻辑，我们就不再继续往里分析了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，再祭出文章开始的那张图来总结一下：</p><p><img src="https://www.javadoop.com/blogimages/tomcat-nio/0.png" alt="0"></p><p>这里简单梳理下前面我们说的流程，帮大家回忆一下：</p><ol><li>指定 Protocol，初始化相应的 Endpoint，我们分析的是 NioEndpoint；</li><li>init 过程：在 NioEndpoint 中做 bind 操作；</li><li>start 过程：启动 worker 线程池，启动 1 个 Acceptor 和 2 个 Poller，当然它们都是默认值，可配；</li><li>Acceptor 获取到新的连接后，getPoller0() 获取其中一个 Poller，然后 register 到 Poller 中；</li><li>Poller 循环 selector.select(xxx)，如果有通道 readable，那么在 processKey 中将其放到 worker 线程池中。</li></ol><p>后续的流程，感兴趣的读者请自行分析，本文就说到这里了。</p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tomcat 中的 NIO 源码分析&lt;/p&gt;
&lt;p&gt;转自&lt;a href=&quot;https://www.javadoop.com/post/tomcat-nio#toc1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.javadoop.com/post/tomcat-nio#toc1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java网络编程和NIO&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/21963.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21963.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java网络编程与NIO" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO/"/>
    
    
      <category term="NIO" scheme="http://h2pl.github.io/tags/NIO/"/>
    
      <category term="Tomcat" scheme="http://h2pl.github.io/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程与NIO详解14：深度解读Tomcat中的NIO模型</title>
    <link href="http://h2pl.github.io/2018/05/29/Javanet14/"/>
    <id>http://h2pl.github.io/2018/05/29/Javanet14/</id>
    <published>2018-05-29T03:54:22.000Z</published>
    <updated>2018-06-11T12:45:42.522Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="http://www.linkedkeeper.com/detail/blog.action?bid=1046*" target="_blank" rel="noopener">http://www.linkedkeeper.com/detail/blog.action?bid=1046*</a>*</p><p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java网络编程和NIO <a href="https://blog.csdn.net/column/details/21963.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21963.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a><br>://github.com/h2pl/</p><a id="more"></a><p><strong>一、I/O复用模型解读</strong></p><p>Tomcat的NIO是基于I/O复用来实现的。对这点一定要清楚，不然我们的讨论就不在一个逻辑线上。下面这张图学习过I/O模型知识的一般都见过，出自《UNIX网络编程》，I/O模型一共有阻塞式I/O，非阻塞式I/O，I/O复用(select/poll/epoll)，信号驱动式I/O和异步I/O。这篇文章讲的是I/O复用。</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_27fb058a-424a-44d0-8c0f-8ec345f7c446.jpg" alt=""></p><p>这里先来说下用户态和内核态，直白来讲，如果线程执行的是用户代码，当前线程处在用户态，如果线程执行的是内核里面的代码，当前线程处在内核态。更深层来讲，操作系统为代码所处的特权级别分了4个级别。不过现代操作系统只用到了0和3两个级别。0和3的切换就是用户态和内核态的切换。更详细的可参照《深入理解计算机操作系统》。I/O复用模型，是同步非阻塞，这里的非阻塞是指I/O读写，对应的是recvfrom操作，因为数据报文已经准备好，无需阻塞。说它是同步，是因为，这个执行是在一个线程里面执行的。有时候，还会说它又是阻塞的，实际上是指阻塞在select上面，必须等到读就绪、写就绪等网络事件。有时候我们又说I/O复用是多路复用，这里的多路是指N个连接，每一个连接对应一个channel，或者说多路就是多个channel。复用，是指多个连接复用了一个线程或者少量线程(在Tomcat中是Math.min(2,Runtime.getRuntime().availableProcessors()))。</p><p>上面提到的网络事件有连接就绪，接收就绪，读就绪，写就绪四个网络事件。I/O复用主要是通过Selector复用器来实现的，可以结合下面这个图理解上面的叙述。</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_f90c676a-08ff-4777-9cb1-d73920977c54.jpg" alt=""></p><p><strong>二、TOMCAT对IO模型的支持</strong></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_b845018f-63ab-4651-ba62-89ceefd82c29.jpg" alt=""></p><p>tomcat从6以后开始支持NIO模型，实现是基于JDK的java.nio包。这里可以看到对read body 和response body是Blocking的。关于这点在第6.3节源代码阅读有重点介绍。</p><p><strong>三、TOMCAT中NIO的配置与使用</strong></p><p>在Connector节点配置protocol=”org.apache.coyote.http11.Http11NioProtocol”，Http11NioProtocol协议下默认最大连接数是10000，也可以重新修改maxConnections的值，同时我们可以设置最大线程数maxThreads，这里设置的最大线程数就是Excutor的线程池的大小。在BIO模式下实际上是没有maxConnections，即使配置也不会生效，BIO模式下的maxConnections是保持跟maxThreads大小一致，因为它是一请求一线程模式。</p><p><strong>四、NioEndpoint组件关系图解读</strong></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_6ad52ffb-52f7-4c7b-a226-570dc766e2dd.jpg" alt=""></p><p>我们要理解tomcat的nio最主要就是对NioEndpoint的理解。它一共包含LimitLatch、Acceptor、Poller、SocketProcessor、Excutor5个部分。LimitLatch是连接控制器，它负责维护连接数的计算，nio模式下默认是10000，达到这个阈值后，就会拒绝连接请求。Acceptor负责接收连接，默认是1个线程来执行，将请求的事件注册到事件列表。有Poller来负责轮询，Poller线程数量是cpu的核数Math.min(2,Runtime.getRuntime().availableProcessors())。</p><p>由Poller将就绪的事件生成SocketProcessor同时交给Excutor去执行。Excutor线程池的大小就是我们在Connector节点配置的maxThreads的值。</p><p>在Excutor的线程中，会完成从socket中读取httprequest，解析成HttpServletRequest对象，分派到相应的servlet并完成逻辑，然后将response通过socket发回client。在从socket中读数据和往socket中写数据的过程，并没有像典型的非阻塞的NIO的那样，注册OP_READ或OP_WRITE事件到主Selector，而是<strong>直接通过socket完成读写，这时是阻塞完成的</strong>，但是在timeout控制上，使用了NIO的Selector机制，但是这个Selector并不是Poller线程维护的主Selector，而是BlockPoller线程中维护的Selector，称之为辅Selector。详细源代码可以参照 第6.3节。</p><p><strong>五、NioEndpoint执行序列图</strong></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_7f7ff50e-d4db-4213-878c-fc8dc7ab662f.jpg" alt=""></p><p>在下一小节NioEndpoint源码解读中我们将对步骤1-步骤11依次找到对应的代码来说明。</p><p><strong>六、NioEndpoint源码解读</strong></p><p>6.1、初始化</p><p>无论是BIO还是NIO，开始都会初始化连接限制，不可能无限增大，NIO模式下默认是10000。</p><pre><code>public void startInternal() throws Exception {    if (!running) {        //省略代码...        initializeConnectionLatch();        //省略代码...    }}protected LimitLatch initializeConnectionLatch() {    if (maxConnections==-1)     return null;    if (connectionLimitLatch==null) {        connectionLimitLatch = new LimitLatch(getMaxConnections());    }    return connectionLimitLatch;}</code></pre><p>6.2、步骤解读</p><p>下面我们着重叙述跟NIO相关的流程，共分为11个步骤，分别对应上面序列图中的步骤。</p><p><strong>步骤1</strong>：绑定IP地址及端口，将ServerSocketChannel设置为阻塞。</p><p>这里为什么要设置成阻塞呢，我们一直都在说非阻塞。Tomcat的设计初衷主要是为了操作方便。这样这里就跟BIO模式下一样了。只不过在BIO下这里返回的是Socket，NIO下这里返回的是SocketChannel。</p><pre><code>public void bind() throws Exception {    //省略代码...    serverSock.socket().bind(addr,getBacklog());    serverSock.configureBlocking(true);     //省略代码...    selectorPool.open();}</code></pre><p><strong>步骤2</strong>：启动接收线程</p><pre><code>public void startInternal() throws Exception {    if (!running) {        //省略代码...        startAcceptorThreads();    }}//这个方法实际是在它的超类AbstractEndpoint里面    protected final void startAcceptorThreads() {    int count = getAcceptorThreadCount();    acceptors = new Acceptor[count];    for (int i = 0; i &lt; count; i++) {        acceptors[i] = createAcceptor();        Thread t = new Thread(acceptors[i], getName() + &quot;-Acceptor-&quot; + i);        t.setPriority(getAcceptorThreadPriority());        t.setDaemon(getDaemon());        t.start();    }}   </code></pre><p><strong>步骤3</strong>：ServerSocketChannel.accept()接收新连接</p><pre><code>protected class Acceptor extends AbstractEndpoint.Acceptor {    @Override    public void run() {        while (running) {            try {                //省略代码...                SocketChannel socket = null;                try {                                            socket = serverSock.accept();//接收新连接                } catch (IOException ioe) {                    //省略代码...                    throw ioe;                }                //省略代码...                if (running &amp;&amp; !paused) {                    if (!setSocketOptions(socket)) {                        //省略代码...                    }                } else {                    //省略代码...                }            } catch (SocketTimeoutException sx) {            } catch (IOException x) {                //省略代码...            } catch (OutOfMemoryError oom) {                //省略代码...            } catch (Throwable t) {                //省略代码...            }        }    }}</code></pre><p><strong>步骤4</strong>：将接收到的链接通道设置为非阻塞</p><p><strong>步骤5</strong>：构造NioChannel对象</p><p><strong>步骤6</strong>：register注册到轮询线程</p><pre><code>protected boolean setSocketOptions(SocketChannel socket) {    try {        socket.configureBlocking(false);//将连接通道设置为非阻塞        Socket sock = socket.socket();        socketProperties.setProperties(sock);        NioChannel channel = nioChannels.poll();//构造NioChannel对象        //省略代码...        getPoller0().register(channel);//register注册到轮询线程    } catch (Throwable t) {        //省略代码...    }    //省略代码...}</code></pre><p><strong>步骤7</strong>：构造PollerEvent，并添加到事件队列</p><pre><code>protected ConcurrentLinkedQueue&lt;Runnable&gt; events = new ConcurrentLinkedQueue&lt;Runnable&gt;();public void register(final NioChannel socket) {    //省略代码...    PollerEvent r = eventCache.poll();    //省略代码...    addEvent(r);}</code></pre><p><strong>步骤8</strong>：启动轮询线程</p><pre><code>public void startInternal() throws Exception {    if (!running) {        //省略代码...        // Start poller threads        pollers = new Poller[getPollerThreadCount()];        for (int i=0; i&lt;pollers.length; i++) {            pollers[i] = new Poller();            Thread pollerThread = new Thread(pollers[i], getName() + &quot;-ClientPoller-&quot;+i);            pollerThread.setPriority(threadPriority);            pollerThread.setDaemon(true);            pollerThread.start();        }        //省略代码...    }}   </code></pre><p><strong>步骤9</strong>：取出队列中新增的PollerEvent并注册到Selector</p><pre><code>public static class PollerEvent implements Runnable {    //省略代码...    @Override    public void run() {        if ( interestOps == OP_REGISTER ) {            try {                socket.getIOChannel().register(socket.getPoller().getSelector(), SelectionKey.OP_READ, key);            } catch (Exception x) {                log.error(&quot;&quot;, x);            }        } else {            //省略代码...        }//end if    }//run    //省略代码...}</code></pre><p><strong>步骤10</strong>：Selector.select()</p><pre><code>public void run() {    // Loop until destroy() is called    while (true) {        try {            //省略代码...            try {                if ( !close ) {                    if (wakeupCounter.getAndSet(-1) &gt; 0) {                        keyCount = selector.selectNow();                    } else {                        keyCount = selector.select(selectorTimeout);                    }                    //省略代码...                }                //省略代码...            } catch ( NullPointerException x ) {                //省略代码...            } catch ( CancelledKeyException x ) {                //省略代码...            } catch (Throwable x) {                //省略代码...            }            //省略代码...            Iterator&lt;SelectionKey&gt; iterator =                        keyCount &gt; 0 ? selector.selectedKeys().iterator() : null;            while (iterator != null &amp;&amp; iterator.hasNext()) {                SelectionKey sk = iterator.next();                KeyAttachment attachment = (KeyAttachment)sk.attachment();                if (attachment == null) {                    iterator.remove();                } else {                    attachment.access();                    iterator.remove();                    processKey(sk, attachment);//此方法跟下去就是把SocketProcessor交给Excutor去执行                }            }//while            //省略代码...        } catch (OutOfMemoryError oom) {            //省略代码...        }    }//while    //省略代码...}</code></pre><p><strong>步骤11</strong>：根据选择的SelectionKey构造SocketProcessor提交到请求处理线程</p><pre><code>public boolean processSocket(NioChannel socket, SocketStatus status, boolean dispatch) {    try {        //省略代码...        SocketProcessor sc = processorCache.poll();        if ( sc == null )             sc = new SocketProcessor(socket,status);        else             sc.reset(socket,status);        if ( dispatch &amp;&amp; getExecutor()!=null )             getExecutor().execute(sc);        else             sc.run();    } catch (RejectedExecutionException rx) {        //省略代码...    } catch (Throwable t) {        //省略代码...    }    //省略代码...}</code></pre><p>6.3、NioBlockingSelector和BlockPoller介绍</p><p>上面的序列图有个地方我没有描述，就是NioSelectorPool这个内部类，是因为在整体理解tomcat的nio上面在序列图里面不包括它更好理解。在有了上面的基础后，我们在来说下NioSelectorPool这个类，对更深层了解Tomcat的NIO一定要知道它的作用。NioEndpoint对象中维护了一个NioSelecPool对象，这个NioSelectorPool中又维护了一个BlockPoller线程，这个线程就是基于辅Selector进行NIO的逻辑。以执行servlet后，得到response，往socket中写数据为例，最终写的过程调用NioBlockingSelector的write方法。代码如下：</p><pre><code>public int write(ByteBuffer buf, NioChannel socket, long writeTimeout,MutableInteger lastWrite)                 throws IOException {      SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());      if ( key == null ) throw new IOException(&quot;Key no longer registered&quot;);      KeyAttachment att = (KeyAttachment) key.attachment();      int written = 0;      boolean timedout = false;      int keycount = 1; //assume we can write      long time = System.currentTimeMillis(); //start the timeout timer      try {          while ( (!timedout) &amp;&amp; buf.hasRemaining()) {              if (keycount &gt; 0) { //only write if we were registered for a write                  //直接往socket中写数据                  int cnt = socket.write(buf); //write the data                  lastWrite.set(cnt);                  if (cnt == -1)                      throw new EOFException();                  written += cnt;                  //写数据成功，直接进入下一次循环，继续写                  if (cnt &gt; 0) {                      time = System.currentTimeMillis(); //reset our timeout timer                      continue; //we successfully wrote, try again without a selector                  }              }              //如果写数据返回值cnt等于0，通常是网络不稳定造成的写数据失败              try {                  //开始一个倒数计数器                   if ( att.getWriteLatch()==null || att.getWriteLatch().getCount()==0)                     att.startWriteLatch(1);                  //将socket注册到辅Selector，这里poller就是BlockSelector线程                  poller.add(att,SelectionKey.OP_WRITE);                  //阻塞，直至超时时间唤醒，或者在还没有达到超时时间，在BlockSelector中唤醒                  att.awaitWriteLatch(writeTimeout,TimeUnit.MILLISECONDS);              }catch (InterruptedException ignore) {                  Thread.interrupted();              }              if ( att.getWriteLatch()!=null &amp;&amp; att.getWriteLatch().getCount()&gt; 0) {                  keycount = 0;              }else {                  //还没超时就唤醒，说明网络状态恢复，继续下一次循环，完成写socket                  keycount = 1;                  att.resetWriteLatch();              }              if (writeTimeout &gt; 0 &amp;&amp; (keycount == 0))                  timedout = (System.currentTimeMillis() - time) &gt;= writeTimeout;          } //while          if (timedout)               throw new SocketTimeoutException();      } finally {          poller.remove(att,SelectionKey.OP_WRITE);          if (timedout &amp;&amp; key != null) {              poller.cancelKey(socket, key);          }      }      return written;  }</code></pre><p>也就是说当socket.write()返回0时，说明网络状态不稳定，这时将socket注册OP_WRITE事件到辅Selector，由BlockPoller线程不断轮询这个辅Selector，直到发现这个socket的写状态恢复了，通过那个倒数计数器，通知Worker线程继续写socket动作。看一下BlockSelector线程的代码逻辑：</p><pre><code>public void run() {      while (run) {          try {              ......              Iterator iterator = keyCount &gt; 0 ? selector.selectedKeys().iterator() : null;              while (run &amp;&amp; iterator != null &amp;&amp; iterator.hasNext()) {                  SelectionKey sk = (SelectionKey) iterator.next();                  KeyAttachment attachment = (KeyAttachment)sk.attachment();                  try {                      attachment.access();                      iterator.remove(); ;                      sk.interestOps(sk.interestOps() &amp; (~sk.readyOps()));                      if ( sk.isReadable() ) {                          countDown(attachment.getReadLatch());                      }                      //发现socket可写状态恢复，将倒数计数器置位，通知Worker线程继续                      if (sk.isWritable()) {                          countDown(attachment.getWriteLatch());                      }                  }catch (CancelledKeyException ckx) {                      if (sk!=null) sk.cancel();                      countDown(attachment.getReadLatch());                      countDown(attachment.getWriteLatch());                  }              }//while          }catch ( Throwable t ) {              log.error(&quot;&quot;,t);          }      }      events.clear();      try {          selector.selectNow();//cancel all remaining keys      }catch( Exception ignore ) {          if (log.isDebugEnabled())log.debug(&quot;&quot;,ignore);      }  }</code></pre><p>使用这个辅Selector主要是减少线程间的切换，同时还可减轻主Selector的负担。</p><p><strong>七、关于性能</strong></p><p>下面这份报告是我们压测的一个结果，跟想象的是不是不太一样？几乎没有差别，实际上NIO优化的是I/O的读写，如果瓶颈不在这里的话，比如传输字节数很小的情况下，BIO和NIO实际上是没有差别的。NIO的优势更在于用少量的线程hold住大量的连接。还有一点，我们在压测的过程中，遇到在NIO模式下刚开始的一小段时间内容，会有错误，这是因为一般的压测工具是基于一种长连接，也就是说比如模拟1000并发，那么同时建立1000个连接，下一时刻再发送请求就是基于先前的这1000个连接来发送，还有TOMCAT的NIO处理是有POLLER线程来接管的，它的线程数一般等于CPU的核数，如果一瞬间有大量并发过来，POLLER也会顿时处理不过来。</p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_d89ab30f-92a5-4839-98fa-9d760f1df330.jpg" alt=""></p><p><img src="http://misc.linkedkeeper.com/misc/img/blog/201711/linkedkeeper0_6c3edafa-e690-49ec-a872-fab8bb3ae295.jpg" alt=""></p><p><strong>八、总结</strong></p><p>NIO只是优化了网络IO的读写，如果系统的瓶颈不在这里，比如每次读取的字节说都是500b，那么BIO和NIO在性能上没有区别。NIO模式是最大化压榨CPU，把时间片都更好利用起来。对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源如内存，有关线程资源可参照这篇文章《一台java服务器可以跑多少个线程》。因此，使用的线程越少越好。而I/O复用模型正是利用少量的线程来管理大量的连接。在对于维护大量长连接的应用里面更适合用基于I/O复用模型NIO，比如web qq这样的应用。所以我们要清楚系统的瓶颈是I/O还是CPU的计算。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;http://www.linkedkeeper.com/detail/blog.action?bid=1046*&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.linkedkeeper.com/detail/blog.action?bid=1046*&lt;/a&gt;*&lt;/p&gt;
&lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java网络编程和NIO &lt;a href=&quot;https://blog.csdn.net/column/details/21963.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21963.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;br&gt;://github.com/h2pl/&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java网络编程与NIO" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO/"/>
    
    
      <category term="NIO" scheme="http://h2pl.github.io/tags/NIO/"/>
    
      <category term="Tomcat" scheme="http://h2pl.github.io/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程和NIO详解13：浅析Tomcat9请求处理流程与启动部署过程</title>
    <link href="http://h2pl.github.io/2018/05/28/Javanet13/"/>
    <id>http://h2pl.github.io/2018/05/28/Javanet13/</id>
    <published>2018-05-28T03:54:20.000Z</published>
    <updated>2018-06-11T13:43:19.596Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes" target="_blank" rel="noopener">https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes</a></p><p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java网络编程和NIO <a href="https://blog.csdn.net/column/details/21963.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21963.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java网络编程和NIO <a href="https://blog.csdn.net/column/details/21963.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21963.html</a></p><p>相关代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><!-- more --><p>《谈谈 Tomcat 架构及启动过程[含部署]》已重新修订!（与本文在 GitHub 同一目录下）包括架构和 Tomcat Start 过程中的 <code>MapperListener</code> 相关描述。<code>Connector</code> 启动相关的内容与请求处理关系比较紧密，所以就独立出来放在本文中了。</p><p>建议结合《谈谈 Tomcat 架构及启动过程[含部署]》一起看!</p><p>很多东西在时序图中体现的已经非常清楚了，没有必要再一步一步的作介绍，所以本文以图为主，然后对部分内容加以简单解释。</p><ul><li>绘制图形使用的工具是 <a href="http://plantuml.com/" target="_blank" rel="noopener">PlantUML</a> + <a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a> + <a href="https://marketplace.visualstudio.com/items?itemName=jebbs.plantuml" target="_blank" rel="noopener">PlantUML Extension</a></li></ul><p>本文对 Tomcat 的介绍以 <code>Tomcat-9.0.0.M22</code> 为标准。</p><p><code>Tomcat-9.0.0.M22</code> 是 Tomcat 目前最新的版本，但尚未发布，它实现了 <code>Servlet4.0</code> 及 <code>JSP2.3</code> 并提供了很多新特性，需要 1.8 及以上的 JDK 支持等等，详情请查阅 <a href="https://tomcat.apache.org/tomcat-9.0-doc/index.html" target="_blank" rel="noopener">Tomcat-9.0-doc</a></p><ul><li><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88Tomcat%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.md#overview" target="_blank" rel="noopener">Overview</a></li><li><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88Tomcat%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.md#connector-init-and-start" target="_blank" rel="noopener">Connector Init and Start</a></li><li><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88Tomcat%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.md#requtst-process" target="_blank" rel="noopener">Requtst Process</a><ul><li><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88Tomcat%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.md#acceptor" target="_blank" rel="noopener">Acceptor</a></li><li><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88Tomcat%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.md#poller" target="_blank" rel="noopener">Poller</a></li><li><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88Tomcat%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.md#worker" target="_blank" rel="noopener">Worker</a></li><li><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88Tomcat%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.md#container" target="_blank" rel="noopener">Container</a></li></ul></li><li><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88Tomcat%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.md#at-last" target="_blank" rel="noopener">At last</a></li></ul><hr><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88Tomcat%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.md#overview" target="_blank" rel="noopener"></a>Overview</h2><p><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/res/tomcat-request-process-model.jpg" target="_blank" rel="noopener"><img src="https://github.com/c-rainstorm/blog/raw/tomcat-request-process/res/tomcat-request-process-model.jpg" alt=""></a></p><ol><li>Connector 启动以后会启动一组线程用于不同阶段的请求处理过程。<ol><li><code>Acceptor</code> 线程组。用于接受新连接，并将新连接封装一下，选择一个 <code>Poller</code> 将新连接添加到 <code>Poller</code> 的事件队列中。</li><li><code>Poller</code> 线程组。用于监听 Socket 事件，当 Socket 可读或可写等等时，将 Socket 封装一下添加到 <code>worker</code> 线程池的任务队列中。</li><li><code>worker</code> 线程组。用于对请求进行处理，包括分析请求报文并创建 Request 对象，调用容器的 pipeline 进行处理。</li></ol></li></ol><ul><li><code>Acceptor</code>、<code>Poller</code>、<code>worker</code> 所在的 <code>ThreadPoolExecutor</code> 都维护在 <code>NioEndpoint</code> 中。</li></ul><h2 id="Connector-Init-and-Start"><a href="#Connector-Init-and-Start" class="headerlink" title="Connector Init and Start"></a><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88Tomcat%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.md#connector-init-and-start" target="_blank" rel="noopener"></a>Connector Init and Start</h2><p><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/res/tomcat-connector-start.png" target="_blank" rel="noopener"><img src="https://github.com/c-rainstorm/blog/raw/tomcat-request-process/res/tomcat-connector-start.png" alt=""></a></p><ol><li><code>initServerSocket()</code>，通过 <code>ServerSocketChannel.open()</code> 打开一个 ServerSocket，默认绑定到 8080 端口，默认的连接等待队列长度是 100， 当超过 100 个时会拒绝服务。我们可以通过配置 <code>conf/server.xml</code> 中 <code>Connector</code> 的 <code>acceptCount</code> 属性对其进行定制。</li><li><code>createExecutor()</code> 用于创建 <code>Worker</code> 线程池。默认会启动 10 个 <code>Worker</code> 线程，Tomcat 处理请求过程中，Woker 最多不超过 200 个。我们可以通过配置 <code>conf/server.xml</code> 中 <code>Connector</code> 的 <code>minSpareThreads</code> 和 <code>maxThreads</code> 对这两个属性进行定制。</li><li><code>Pollor</code> 用于检测已就绪的 Socket。 默认最多不超过 2 个，<code>Math.min(2,Runtime.getRuntime().availableProcessors());</code>。我们可以通过配置 <code>pollerThreadCount</code> 来定制。</li><li><code>Acceptor</code> 用于接受新连接。默认是 1 个。我们可以通过配置 <code>acceptorThreadCount</code> 对其进行定制。</li></ol><h2 id="Requtst-Process"><a href="#Requtst-Process" class="headerlink" title="Requtst Process"></a><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88Tomcat%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.md#requtst-process" target="_blank" rel="noopener"></a>Requtst Process</h2><h3 id="Acceptor"><a href="#Acceptor" class="headerlink" title="Acceptor"></a><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88Tomcat%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.md#acceptor" target="_blank" rel="noopener"></a>Acceptor</h3><p><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/res/tomcat-request-process-acceptor.png" target="_blank" rel="noopener"><img src="https://github.com/c-rainstorm/blog/raw/tomcat-request-process/res/tomcat-request-process-acceptor.png" alt=""></a></p><ol><li><code>Acceptor</code> 在启动后会阻塞在 <code>ServerSocketChannel.accept();</code> 方法处，当有新连接到达时，该方法返回一个 <code>SocketChannel</code>。</li><li>配置完 Socket 以后将 Socket 封装到 <code>NioChannel</code> 中，并注册到 <code>Poller</code>,值的一提的是，我们一开始就启动了多个 <code>Poller</code> 线程，注册的时候，连接是公平的分配到每个 <code>Poller</code> 的。<code>NioEndpoint</code> 维护了一个 <code>Poller</code> 数组，当一个连接分配给 <code>pollers[index]</code> 时，下一个连接就会分配给 <code>pollers[(index+1)%pollers.length]</code>.</li><li><code>addEvent()</code> 方法会将 Socket 添加到该 <code>Poller</code> 的 <code>PollerEvent</code> 队列中。到此 <code>Acceptor</code> 的任务就完成了。</li></ol><h3 id="Poller"><a href="#Poller" class="headerlink" title="Poller"></a><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88Tomcat%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.md#poller" target="_blank" rel="noopener"></a>Poller</h3><p><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/res/tomcat-request-process-poller.png" target="_blank" rel="noopener"><img src="https://github.com/c-rainstorm/blog/raw/tomcat-request-process/res/tomcat-request-process-poller.png" alt=""></a></p><ol><li><code>selector.select(1000)</code>。当 <code>Poller</code> 启动后因为 selector 中并没有已注册的 <code>Channel</code>，所以当执行到该方法时只能阻塞。所有的 <code>Poller</code> 共用一个 Selector，其实现类是 <code>sun.nio.ch.EPollSelectorImpl</code></li><li><code>events()</code> 方法会将通过 <code>addEvent()</code> 方法添加到事件队列中的 Socket 注册到 <code>EPollSelectorImpl</code>，当 Socket 可读时，<code>Poller</code> 才对其进行处理</li><li><code>createSocketProcessor()</code> 方法将 Socket 封装到 <code>SocketProcessor</code> 中，<code>SocketProcessor</code> 实现了 <code>Runnable</code> 接口。<code>worker</code> 线程通过调用其 <code>run()</code> 方法来对 Socket 进行处理。</li><li><code>execute(SocketProcessor)</code> 方法将 <code>SocketProcessor</code> 提交到线程池，放入线程池的 <code>workQueue</code> 中。<code>workQueue</code> 是 <code>BlockingQueue</code> 的实例。到此 <code>Poller</code> 的任务就完成了。</li></ol><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88Tomcat%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.md#worker" target="_blank" rel="noopener"></a>Worker</h3><p><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/res/tomcat-request-process-worker.png" target="_blank" rel="noopener"><img src="https://github.com/c-rainstorm/blog/raw/tomcat-request-process/res/tomcat-request-process-worker.png" alt=""></a></p><ol><li><code>worker</code> 线程被创建以后就执行 <code>ThreadPoolExecutor</code> 的 <code>runWorker()</code> 方法，试图从 <code>workQueue</code> 中取待处理任务，但是一开始 <code>workQueue</code> 是空的，所以 <code>worker</code> 线程会阻塞在 <code>workQueue.take()</code> 方法。</li><li>当新任务添加到 <code>workQueue</code>后，<code>workQueue.take()</code> 方法会返回一个 <code>Runnable</code>，通常是 <code>SocketProcessor</code>,然后 <code>worker</code> 线程调用 <code>SocketProcessor</code> 的 <code>run()</code> 方法对 Socket 进行处理。</li><li><code>createProcessor()</code> 会创建一个 <code>Http11Processor</code>, 它用来解析 Socket，将 Socket 中的内容封装到 <code>Request</code> 中。注意这个 <code>Request</code> 是临时使用的一个类，它的全类名是 <code>org.apache.coyote.Request</code>，</li><li><code>postParseRequest()</code> 方法封装一下 Request，并处理一下映射关系(从 URL 映射到相应的 <code>Host</code>、<code>Context</code>、<code>Wrapper</code>)。<ol><li><code>CoyoteAdapter</code> 将 Rquest 提交给 <code>Container</code> 处理之前，并将 <code>org.apache.coyote.Request</code> 封装到 <code>org.apache.catalina.connector.Request</code>，传递给 <code>Container</code> 处理的 Request 是 <code>org.apache.catalina.connector.Request</code>。</li><li><code>connector.getService().getMapper().map()</code>，用来在 <code>Mapper</code> 中查询 URL 的映射关系。映射关系会保留到 <code>org.apache.catalina.connector.Request</code> 中，<code>Container</code> 处理阶段 <code>request.getHost()</code> 是使用的就是这个阶段查询到的映射主机，以此类推 <code>request.getContext()</code>、<code>request.getWrapper()</code> 都是。</li></ol></li><li><code>connector.getService().getContainer().getPipeline().getFirst().invoke()</code> 会将请求传递到 <code>Container</code> 处理，当然了 <code>Container</code> 处理也是在 <code>Worker</code> 线程中执行的，但是这是一个相对独立的模块，所以单独分出来一节。</li></ol><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88Tomcat%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.md#container" target="_blank" rel="noopener"></a>Container</h3><p><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/res/tomcat-request-process-container.png" target="_blank" rel="noopener"><img src="https://github.com/c-rainstorm/blog/raw/tomcat-request-process/res/tomcat-request-process-container.png" alt=""></a></p><ol><li>需要注意的是，基本上每一个容器的 <code>StandardPipeline</code> 上都会有多个已注册的 <code>Valve</code>，我们只关注每个容器的 Basic Valve。其他 Valve 都是在 Basic Valve 前执行。</li><li><code>request.getHost().getPipeline().getFirst().invoke()</code> 先获取对应的 <code>StandardHost</code>，并执行其 pipeline。</li><li><code>request.getContext().getPipeline().getFirst().invoke()</code> 先获取对应的 <code>StandardContext</code>,并执行其 pipeline。</li><li><code>request.getWrapper().getPipeline().getFirst().invoke()</code> 先获取对应的 <code>StandardWrapper</code>，并执行其 pipeline。</li><li>最值得说的就是 <code>StandardWrapper</code> 的 Basic Valve，<code>StandardWrapperValve</code><ol><li><code>allocate()</code> 用来加载并初始化 <code>Servlet</code>，值的一提的是 Servlet 并不都是单例的，当 Servlet 实现了 <code>SingleThreadModel</code> 接口后，<code>StandardWrapper</code> 会维护一组 Servlet 实例，这是享元模式。当然了 <code>SingleThreadModel</code>在 Servlet 2.4 以后就弃用了。</li><li><code>createFilterChain()</code> 方法会从 <code>StandardContext</code> 中获取到所有的过滤器，然后将匹配 Request URL 的所有过滤器挑选出来添加到 <code>filterChain</code> 中。</li><li><code>doFilter()</code> 执行过滤链,当所有的过滤器都执行完毕后调用 Servlet 的 <code>service()</code> 方法。</li></ol></li></ol><h1 id="谈谈-Tomcat-架构及启动过程-含部署"><a href="#谈谈-Tomcat-架构及启动过程-含部署" class="headerlink" title="谈谈 Tomcat 架构及启动过程[含部署]"></a>谈谈 Tomcat 架构及启动过程[含部署]</h1><p>这个题目命的其实是很大的，写的时候还是很忐忑的，但我尽可能把这个过程描述清楚。因为这是读过源码以后写的总结，在写的过程中可能会忽略一些前提条件，如果有哪些比较突兀就出现，或不好理解的地方可以给我提 Issue，我会尽快补充修订相关内容。</p><p>很多东西在时序图中体现的已经非常清楚了，没有必要再一步一步的作介绍，所以本文以图为主，然后对部分内容加以简单解释。</p><ul><li>绘制图形使用的工具是 <a href="http://plantuml.com/" target="_blank" rel="noopener">PlantUML</a> + <a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a> + <a href="https://marketplace.visualstudio.com/items?itemName=jebbs.plantuml" target="_blank" rel="noopener">PlantUML Extension</a></li><li>图形 <code>PlantUML</code> 源文件：<ol><li><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/res/tomcat-architecture.pu" target="_blank" rel="noopener">tomcat-architecture.pu</a></li><li><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/res/tomcat-init.pu" target="_blank" rel="noopener">tomcat-init.pu</a></li><li><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/res/start.pu" target="_blank" rel="noopener">tomcat-start.pu</a></li><li><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/res/tomcat-context-start.pu" target="_blank" rel="noopener">tomcat-context-start.pu</a></li><li><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/res/tomcat-background-thread.pu" target="_blank" rel="noopener">tomcat-background-thread.pu</a></li></ol></li></ul><p>本文对 Tomcat 的介绍以 <code>Tomcat-9.0.0.M22</code> 为标准。</p><p><code>Tomcat-9.0.0.M22</code> 是 Tomcat 目前最新的版本，但尚未发布，它实现了 <code>Servlet4.0</code> 及 <code>JSP2.3</code> 并提供了很多新特性，需要 1.8 及以上的 JDK 支持等等，详情请查阅 <a href="https://tomcat.apache.org/tomcat-9.0-doc/index.html" target="_blank" rel="noopener">Tomcat-9.0-doc</a></p><ul><li><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88%20Tomcat%20%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%5B%E5%90%AB%E9%83%A8%E7%BD%B2%5D.md#overview" target="_blank" rel="noopener">Overview</a></li><li><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88%20Tomcat%20%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%5B%E5%90%AB%E9%83%A8%E7%BD%B2%5D.md#tomcat-init" target="_blank" rel="noopener">Tomcat init</a></li><li><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88%20Tomcat%20%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%5B%E5%90%AB%E9%83%A8%E7%BD%B2%5D.md#tomcat-startdeployment" target="_blank" rel="noopener">Tomcat Start[Deployment]</a><ul><li><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88%20Tomcat%20%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%5B%E5%90%AB%E9%83%A8%E7%BD%B2%5D.md#context-start" target="_blank" rel="noopener">Context Start</a></li></ul></li><li><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88%20Tomcat%20%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%5B%E5%90%AB%E9%83%A8%E7%BD%B2%5D.md#background-process" target="_blank" rel="noopener">Background process</a></li><li><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88%20Tomcat%20%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%5B%E5%90%AB%E9%83%A8%E7%BD%B2%5D.md#how-to-read-excellent-open-source-projects" target="_blank" rel="noopener">How to read excellent open source projects</a></li><li><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88%20Tomcat%20%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%5B%E5%90%AB%E9%83%A8%E7%BD%B2%5D.md#at-last" target="_blank" rel="noopener">At last</a></li><li><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88%20Tomcat%20%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%5B%E5%90%AB%E9%83%A8%E7%BD%B2%5D.md#reference" target="_blank" rel="noopener">Reference</a></li></ul><hr><h2 id="Overview-1"><a href="#Overview-1" class="headerlink" title="Overview"></a><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88%20Tomcat%20%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%5B%E5%90%AB%E9%83%A8%E7%BD%B2%5D.md#overview" target="_blank" rel="noopener"></a>Overview</h2><p><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/res/tomcat-architecture.png" target="_blank" rel="noopener"><img src="https://github.com/c-rainstorm/blog/raw/tomcat-request-process/res/tomcat-architecture.png" alt=""></a></p><ol><li><code>Bootstrap</code> 作为 Tomcat 对外界的启动类,在 <code>$CATALINA_BASE/bin</code> 目录下，它通过反射创建 <code>Catalina</code> 的实例并对其进行初始化及启动。</li><li><code>Catalina</code> 解析 <code>$CATALINA_BASE/conf/server.xml</code> 文件并创建 <code>StandardServer</code>、<code>StandardService</code>、<code>StandardEngine</code>、<code>StandardHost</code> 等</li><li><code>StandardServer</code> 代表的是整个 Servlet 容器，他包含一个或多个 <code>StandardService</code></li><li><code>StandardService</code> 包含一个或多个 <code>Connector</code>，和一个 <code>Engine</code>，<code>Connector</code> 和 <code>Engine</code> 都是在解析 <code>conf/server.xml</code> 文件时创建的，<code>Engine</code> 在 Tomcat 的标准实现是 <code>StandardEngine</code></li><li><code>MapperListener</code> 实现了 <code>LifecycleListener</code> 和 <code>ContainerListener</code> 接口用于监听容器事件和生命周期事件。该监听器实例监听所有的容器，包括 <code>StandardEngine</code>、<code>StandardHost</code>、<code>StandardContext</code>、<code>StandardWrapper</code>，当容器有变动时，注册容器到 <code>Mapper</code>。</li><li><code>Mapper</code> 维护了 URL 到容器的映射关系。当请求到来时会根据 <code>Mapper</code> 中的映射信息决定将请求映射到哪一个 <code>Host</code>、<code>Context</code>、<code>Wrapper</code>。</li><li><code>Http11NioProtocol</code> 用于处理 HTTP/1.1 的请求</li><li><code>NioEndpoint</code> 是连接的端点，在请求处理流程中该类是核心类，会重点介绍。</li><li><code>CoyoteAdapter</code> 用于将请求从 Connctor 交给 Container 处理。使 Connctor 和 Container 解耦。</li><li><code>StandardEngine</code> 代表的是 Servlet 引擎，用于处理 <code>Connector</code> 接受的 Request。包含一个或多个 <code>Host</code>（虚拟主机）, <code>Host</code> 的标准实现是 <code>StandardHost</code>。</li><li><code>StandardHost</code> 代表的是虚拟主机，用于部署该虚拟主机上的应用程序。通常包含多个 <code>Context</code> (Context 在 Tomcat 中代表应用程序)。<code>Context</code> 在 Tomcat 中的标准实现是 <code>StandardContext</code>。</li><li><code>StandardContext</code> 代表一个独立的应用程序，通常包含多个 <code>Wrapper</code>，一个 <code>Wrapper</code> 容器封装了一个 Servlet，<code>Wrapper</code>的标准实现是 <code>StandardWrapper</code>。</li><li><code>StandardPipeline</code> 组件代表一个流水线，与 <code>Valve</code>（阀）结合，用于处理请求。 <code>StandardPipeline</code> 中含有多个 <code>Valve</code>， 当需要处理请求时，会逐一调用 <code>Valve</code> 的 <code>invoke</code> 方法对 Request 和 Response 进行处理。特别的，其中有一个特殊的 <code>Valve</code> 叫 <code>basicValve</code>,每一个标准容器都有一个指定的 <code>BasicValve</code>，他们做的是最核心的工作。<ul><li><code>StandardEngine</code> 的是 <code>StandardEngineValve</code>，他用来将 Request 映射到指定的 <code>Host</code>;</li><li><code>StandardHost</code> 的是 <code>StandardHostValve</code>, 他用来将 Request 映射到指定的 <code>Context</code>;</li><li><code>StandardContext</code> 的是 <code>StandardContextValve</code>，它用来将 Request 映射到指定的 <code>Wrapper</code>；</li><li><code>StandardWrapper</code> 的是 <code>StandardWrapperValve</code>，他用来加载 Rquest 所指定的 Servlet,并调用 Servlet 的 <code>Service</code> 方法。</li></ul></li></ol><h2 id="Tomcat-init"><a href="#Tomcat-init" class="headerlink" title="Tomcat init"></a><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88%20Tomcat%20%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%5B%E5%90%AB%E9%83%A8%E7%BD%B2%5D.md#tomcat-init" target="_blank" rel="noopener"></a>Tomcat init</h2><p><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/res/tomcat-start.png" target="_blank" rel="noopener"><img src="https://github.com/c-rainstorm/blog/raw/tomcat-request-process/res/tomcat-start.png" alt=""></a></p><ul><li>当通过 <code>./startup.sh</code> 脚本或直接通过 <code>java</code> 命令来启动 <code>Bootstrap</code> 时，Tomcat 的启动过程就正式开始了，启动的入口点就是 <code>Bootstrap</code> 类的 <code>main</code> 方法。</li><li>启动的过程分为两步，分别是 <code>init</code> 和 <code>start</code>，本节主要介绍 <code>init</code>;</li></ul><ol><li>初始化类加载器。[关于 Tomcat 类加载机制，可以参考我之前写的一片文章：<a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.md" target="_blank" rel="noopener">谈谈Java类加载机制</a>]<ol><li>通过从 <code>CatalinaProperties</code> 类中获取 <code>common.loader</code> 等属性，获得类加载器的扫描仓库。<code>CatalinaProperties</code> 类在的静态块中调用了 <code>loadProperties()</code> 方法，从 <code>conf/catalina.properties</code> 文件中加载了属性.(即在类创建的时候属性就已经加载好了)。</li><li>通过 <code>ClassLoaderFactory</code> 创建 <code>URLClassLoader</code> 的实例</li></ol></li><li>通过反射创建 <code>Catalina</code> 的实例并设置 <code>parentClassLoader</code></li><li><code>setAwait(true)</code>。设置 <code>Catalina</code> 的 <code>await</code> 属性为 <code>true</code>。在 Start 阶段尾部，若该属性为 <code>true</code>，Tomcat 会在 main 线程中监听 <code>SHUTDOWN</code> 命令，默认端口是 8005.当收到该命令后执行 <code>Catalina</code> 的 <code>stop()</code> 方法关闭 Tomcat 服务器。</li><li><code>createStartDigester()</code>。<code>Catalina</code> 的该方法用于创建一个 Digester 实例，并添加解析 <code>conf/server.xml</code> 的 <code>RuleSet</code>。Digester 原本是 Apache 的一个开源项目，专门解析 XML 文件的，但我看 Tomcat-9.0.0.M22 中直接将这些类整合到 Tomcat 内部了，而不是引入 jar 文件。Digester 工具的原理不在本文的介绍范围，有兴趣的话可以参考 <a href="http://commons.apache.org/proper/commons-digester/index.html" target="_blank" rel="noopener">The Digester Component - Apache</a> 或 <a href="https://www.amazon.com/How-Tomcat-Works-Budi-Kurniawan/dp/097521280X" target="_blank" rel="noopener">《How Tomcat works》- Digester [推荐]</a> 一章</li><li><code>parse()</code> 方法就是 Digester 处理 <code>conf/server.xml</code> 创建各个组件的过程。值的一提的是这些组件都是使用反射的方式来创建的。特别的，在创建 Digester 的时候，添加了一些特别的 <code>rule Set</code>，用于创建一些十分核心的组件，这些组件在 <code>conf/server.xml</code> 中没有但是其作用都比较大，这里做下简单介绍，当 Start 时用到了再详细说明：<ol><li><code>EngineConfig</code>。<code>LifecycleListener</code> 的实现类,触发 Engine 的生命周期事件后调用，这个监听器没有特别大的作用，就是打印一下日志</li><li><code>HostConfig</code>。<code>LifecycleListener</code> 的实现类，触发 Host 的生命周期事件后调用。这个监听器的作用就是部署应用程序，这包括 <code>conf/&lt;Engine&gt;/&lt;Host&gt;/</code> 目录下所有的 Context xml 文件 和 <code>webapps</code> 目录下的应用程序，不管是 war 文件还是已解压的目录。 另外后台进程对应用程序的热部署也是由该监听器负责的。</li><li><code>ContextConfig</code>。<code>LifecycleListener</code> 的实现类，触发 Context 的生命周期事件时调用。这个监听器的作用是配置应用程序，它会读取并合并 <code>conf/web.xml</code> 和 应用程序的 <code>web.xml</code>，分析 <code>/WEB-INF/classes/</code> 和 <code>/WEB-INF/lib/*.jar</code>中的 Class 文件的注解，将其中所有的 Servlet、ServletMapping、Filter、FilterMapping、Listener 都配置到 <code>StandardContext</code> 中，以备后期使用。当然了 <code>web.xml</code> 中还有一些其他的应用程序参数，最后都会一并配置到 <code>StandardContext</code> 中。</li></ol></li><li><code>reconfigureStartStopExecutor()</code> 用于重新配置启动和停止子容器的 <code>Executor</code>。默认是 1 个线程。我们可以配置 <code>conf/server.xml</code> 中 <code>Engine</code> 的 <code>startStopThreads</code>，来指定用于启动和停止子容器的线程数量，如果配置 0 的话会使用 <code>Runtime.getRuntime().availableProcessors()</code> 作为线程数，若配置为负数的话会使用 <code>Runtime.getRuntime().availableProcessors() + 配置值</code>，若和小与 1 的话，使用 1 作为线程数。当线程数是 1 时，使用 <code>InlineExecutorService</code> 它直接使用当前线程来执行启动停止操作，否则使用 <code>ThreadPoolExecutor</code> 来执行，其最大线程数为我们配置的值。</li><li>需要注意的是 Host 的 <code>init</code> 操作是在 Start 阶段来做的， <code>StardardHost</code> 创建好后其 <code>state</code> 属性的默认值是 <code>LifecycleState.NEW</code>，所以在其调用 <code>startInternal()</code> 之前会进行一次初始化。</li></ol><p><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88%20Tomcat%20%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%5B%E5%90%AB%E9%83%A8%E7%BD%B2%5D.md#tomcat-startdeployment" target="_blank" rel="noopener"></a>Tomcat Start[Deployment]</p><p><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/res/tomcat-start.png" target="_blank" rel="noopener"><img src="https://github.com/c-rainstorm/blog/raw/tomcat-request-process/res/tomcat-start.png" alt=""></a></p><ol><li>图中从 <code>StandardHost</code> Start <code>StandardContext</code> 的这步其实在真正的执行流程中会直接跳过，因为 <code>conf/server.xml</code> 文件中并没有配置任何的 <code>Context</code>，所以在 <code>findChildren()</code> 查找子容器时会返回空数组，所以之后遍历子容器来启动子容器的 <code>for</code> 循环就直接跳过了。</li><li>触发 Host 的 <code>BEFORE_START_EVENT</code> 生命周期事件，<code>HostConfig</code> 调用其 <code>beforeStart()</code> 方法创建 <code>$CATALINA_BASE/webapps</code>&amp; <code>$CATALINA_BASE/conf/&lt;Engine&gt;/&lt;Host&gt;/</code> 目录。</li><li>触发 Host 的 <code>START_EVENT</code> 生命周期事件，<code>HostConfig</code> 调用其 <code>start()</code> 方法开始部署已在 <code>$CATALINA_BASE/webapps</code> &amp; <code>$CATALINA_BASE/conf/&lt;Engine&gt;/&lt;Host&gt;/</code> 目录下的应用程序。<ol><li>解析 <code>$CATALINA_BASE/conf/&lt;Engine&gt;/&lt;Host&gt;/</code> 目录下所有定义 <code>Context</code> 的 XML 文件，并添加到 <code>StandardHost</code>。这些 XML 文件称为应用程序描述符。正因为如此，我们可以配置一个虚拟路径来保存应用程序中用到的图片，详细的配置过程请参考 <a href="https://github.com/c-rainstorm/OnlineShoppingSystem-Documents/blob/master/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E6%8A%80%E6%9C%AF%E8%AF%B4%E6%98%8E/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97.md#63-%E9%85%8D%E7%BD%AE%E5%9B%BE%E7%89%87%E5%AD%98%E6%94%BE%E7%9B%AE%E5%BD%95" target="_blank" rel="noopener">开发环境配置指南 - 6.3. 配置图片存放目录</a></li><li>部署 <code>$CATALINA_BASE/webapps</code> 下所有的 WAR 文件，并添加到 <code>StandardHost</code>。</li><li>部署 <code>$CATALINA_BASE/webapps</code> 下所有已解压的目录，并添加到 <code>StandardHost</code>。</li></ol><ul><li>特别的，添加到 <code>StandardHost</code> 时，会直接调用 <code>StandardContext</code> 的 <code>start()</code> 方法来启动应用程序。启动应用程序步骤请看 Context Start 一节。</li></ul></li><li>在 <code>StandardEngine</code> 和 <code>StandardContext</code> 启动时都会调用各自的 <code>threadStart()</code> 方法，该方法会创建一个新的后台线程来处理该该容器和子容器及容器内各组件的后台事件。<code>StandardEngine</code> 会直接创建一个后台线程，<code>StandardContext</code> 默认是不创建的，和 <code>StandardEngine</code> 共用同一个。后台线程处理机制是周期调用组件的 <code>backgroundProcess()</code> 方法。详情请看 Background process 一节。</li><li><code>MapperListener</code><ul><li><code>addListeners(engine)</code> 方法会将该监听器添加到 <code>StandardEngine</code> 和它的所有子容器中</li><li><code>registerHost()</code> 会注册所有的 <code>Host</code> 和他们的子容器到 <code>Mapper</code> 中，方便后期请求处理时使用。</li><li>当有新的应用(<code>StandardContext</code>)添加进来后，会触发 Host 的容器事件，然后通过 <code>MapperListener</code> 将新应用的映射注册到 <code>Mapper</code> 中。</li></ul></li><li>Start 工作都做完以后 <code>Catalina</code> 会创建一个 <code>CatalinaShutdownHook</code> 并注册到 JVM。<code>CatalinaShutdownHook</code> 继承了 <code>Thread</code>,是 <code>Catalina</code> 的内部类。其 <code>run</code> 方法中直接调用了 <code>Catalina</code> 的 <code>stop()</code> 方法来关闭整个服务器。注册该 Thread 到 JVM 的原因是防止用户非正常终止 Tomcat，比如直接关闭命令窗口之类的。当直接关闭命令窗口时，操作系统会向 JVM 发送一个终止信号，然后 JVM 在退出前会逐一启动已注册的 ShutdownHook 来关闭相应资源。</li></ol><h3 id="Context-Start"><a href="#Context-Start" class="headerlink" title="Context Start"></a><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88%20Tomcat%20%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%5B%E5%90%AB%E9%83%A8%E7%BD%B2%5D.md#context-start" target="_blank" rel="noopener"></a>Context Start</h3><p><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/res/tomcat-context-start.png" target="_blank" rel="noopener"><img src="https://github.com/c-rainstorm/blog/raw/tomcat-request-process/res/tomcat-context-start.png" alt=""></a></p><ol><li><code>StandRoot</code> 类实现了 <code>WebResourceRoot</code> 接口，它容纳了一个应用程序的所有资源，通俗的来说就是部署到 <code>webapps</code> 目录下对应 <code>Context</code> 的目录里的所有资源。因为我对 Tomcat 的资源管理部分暂时不是很感兴趣，所以资源管理相关类只是做了简单了解，并没有深入研究源代码。</li><li><code>resourceStart()</code> 方法会对 <code>StandardRoot</code> 进行初始配置</li><li><code>postWorkDirectory()</code> 用于创建对应的工作目录 <code>$CATALINA_BASE/work/&lt;Engine&gt;/&lt;Host&gt;/&lt;Context&gt;</code>, 该目录用于存放临时文件。</li><li><code>StardardContext</code> 只是一个容器，而 <code>ApplicationContext</code> 则是一个应用程序真正的运行环境，相关类及操作会在请求处理流程看完以后进行补充。</li><li><code>StardardContext</code> 触发 <code>CONFIGURE_START_EVENT</code> 生命周期事件，<code>ContextConfig</code> 开始调用 <code>configureStart()</code> 对应用程序进行配置。<ol><li>这个过程会解析并合并 <code>conf/web.xml</code> &amp; <code>conf/&lt;Engine&gt;/&lt;Host&gt;/web.xml.default</code> &amp; <code>webapps/&lt;Context&gt;/WEB-INF/web.xml</code> 中的配置。</li><li>配置配置文件中的参数到 <code>StandardContext</code>, 其中主要的包括 Servlet、Filter、Listener。</li><li>因为从 Servlet3.0 以后是直接支持注解的，所以服务器必须能够处理加了注解的类。Tomcat 通过分析 <code>WEB-INF/classes/</code> 中的 Class 文件和 <code>WEB-INF/lib/</code> 下的 jar 包将扫描到的 Servlet、Filter、Listerner 注册到 <code>StandardContext</code>。</li><li><code>setConfigured(true)</code>，是非常关键的一个操作，它标识了 Context 的成功配置，若未设置该值为 true 的话，Context 会启动失败。</li></ol></li></ol><h2 id="Background-process"><a href="#Background-process" class="headerlink" title="Background process"></a><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes/%E8%B0%88%E8%B0%88%20Tomcat%20%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%5B%E5%90%AB%E9%83%A8%E7%BD%B2%5D.md#background-process" target="_blank" rel="noopener"></a>Background process</h2><p><a href="https://github.com/c-rainstorm/blog/blob/tomcat-request-process/res/tomcat-background-thread.png" target="_blank" rel="noopener"><img src="https://github.com/c-rainstorm/blog/raw/tomcat-request-process/res/tomcat-background-thread.png" alt=""></a></p><ol><li>后台进程的作用就是处理一下 Servlet 引擎中的周期性事件，处理周期默认是 10s。</li><li>特别的 <code>StandardHost</code> 的 <code>backgroundProcess()</code> 方法会触发 Host 的 <code>PERIODIC_EVENT</code> 生命周期事件。然后 <code>HostConfig</code> 会调用其 <code>check()</code> 方法对已加载并进行过重新部署的应用程序进行 <code>reload</code> 或对新部署的应用程序进行热部署。热部署跟之前介绍的部署步骤一致， <code>reload()</code> 过程只是简单的顺序调用 <code>setPause(true)、stop()、start()、setPause(false)</code>，其中 <code>setPause(true)</code> 的作用是暂时停止接受请求。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/c-rainstorm/blog/blob/tomcat-request-process/reading-notes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java网络编程和NIO &lt;a href=&quot;https://blog.csdn.net/column/details/21963.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21963.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java网络编程与NIO" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO/"/>
    
    
      <category term="Tomcat" scheme="http://h2pl.github.io/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程和NIO详解12：Tomcat中的设计模式</title>
    <link href="http://h2pl.github.io/2018/05/28/Javanet12/"/>
    <id>http://h2pl.github.io/2018/05/28/Javanet12/</id>
    <published>2018-05-28T03:54:17.000Z</published>
    <updated>2018-06-11T12:45:59.770Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java网络编程和NIO <a href="https://blog.csdn.net/column/details/21963.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21963.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><h2 id="门面设计模式"><a href="#门面设计模式" class="headerlink" title="门面设计模式"></a>门面设计模式</h2><p>门面设计模式在 Tomcat 中有多处使用，在 Request 和 Response 对象封装中、Standard Wrapper 到 ServletConfig 封装中、ApplicationContext 到 ServletContext 封装中等都用到了这种设计模式。</p><h3 id="门面设计模式的原理"><a href="#门面设计模式的原理" class="headerlink" title="门面设计模式的原理"></a>门面设计模式的原理</h3><p>这么多场合都用到了这种设计模式，那这种设计模式究竟能有什么作用呢？顾名思义，就是将一个东西封装成一个门面好与人家更容易进行交流，就像一个国家的外交部一样。</p><p>这种设计模式主要用在一个大的系统中有多个子系统组成时，这多个子系统肯定要涉及到相互通信，但是每个子系统又不能将自己的内部数据过多的暴露给其它系统，不然就没有必要划分子系统了。每个子系统都会设计一个门面，把别的系统感兴趣的数据封装起来，通过这个门面来进行访问。这就是门面设计模式存在的意义。</p><p>门面设计模式示意图如下：</p><h5 id="图-1-门面示意图"><a href="#图-1-门面示意图" class="headerlink" title="图 1. 门面示意图"></a>图 1. 门面示意图</h5><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat2/image001.jpg" alt="图 1\. 门面示意图"></p><p>Client 只能访问到 Façade 中提供的数据是门面设计模式的关键，至于 Client 如何访问 Façade 和 Subsystem 如何提供 Façade 门面设计模式并没有规定死。</p><h3 id="Tomcat-的门面设计模式示例"><a href="#Tomcat-的门面设计模式示例" class="headerlink" title="Tomcat 的门面设计模式示例"></a>Tomcat 的门面设计模式示例</h3><p>Tomcat 中门面设计模式使用的很多，因为 Tomcat 中有很多不同组件，每个组件要相互交互数据，用门面模式隔离数据是个很好的方法。</p><p>下面是 Request 上使用的门面设计模式：</p><h5 id="图-2-Request-的门面设计模式类图"><a href="#图-2-Request-的门面设计模式类图" class="headerlink" title="图 2. Request 的门面设计模式类图"></a>图 2. Request 的门面设计模式类图</h5><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat2/image002.png" alt="图 2\. Request 的门面设计模式类图"></p><p>从图中可以看出 HttpRequestFacade 类封装了 HttpRequest 接口能够提供数据，通过 HttpRequestFacade 访问到的数据都被代理到 HttpRequest 中，通常被封装的对象都被设为 Private 或者 Protected 访问修饰，以防止在 Façade 中被直接访问。</p><h2 id="观察者设计模式"><a href="#观察者设计模式" class="headerlink" title="观察者设计模式"></a>观察者设计模式</h2><p>这种设计模式也是常用的设计方法通常也叫发布 - 订阅模式，也就是事件监听机制，通常在某个事件发生的前后会触发一些操作。</p><h3 id="观察者模式的原理"><a href="#观察者模式的原理" class="headerlink" title="观察者模式的原理"></a>观察者模式的原理</h3><p>观察者模式原理也很简单，就是你在做事的时候旁边总有一个人在盯着你，当你做的事情是它感兴趣的时候，它就会跟着做另外一些事情。但是盯着你的人必须要到你那去登记，不然你无法通知它。观察者模式通常包含下面这几个角色：</p><ul><li>Subject 就是抽象主题：它负责管理所有观察者的引用，同时定义主要的事件操作。</li><li>ConcreteSubject 具体主题：它实现了抽象主题的所有定义的接口，当自己发生变化时，会通知所有观察者。</li><li>Observer 观察者：监听主题发生变化相应的操作接口。</li></ul><h3 id="Tomcat-的观察者模式示例"><a href="#Tomcat-的观察者模式示例" class="headerlink" title="Tomcat 的观察者模式示例"></a>Tomcat 的观察者模式示例</h3><p>Tomcat 中观察者模式也有多处使用，前面讲的控制组件生命周期的 Lifecycle 就是这种模式的体现，还有对 Servlet 实例的创建、Session 的管理、Container 等都是同样的原理。下面主要看一下 Lifecycle 的具体实现。</p><p>Lifecycle 的观察者模式结构图：</p><h5 id="图-3-Lifecycle-的观察者模式结构图"><a href="#图-3-Lifecycle-的观察者模式结构图" class="headerlink" title="图 3. Lifecycle 的观察者模式结构图"></a>图 3. Lifecycle 的观察者模式结构图</h5><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat2/image003.png" alt="图 3\. Lifecycle 的观察者模式结构图"></p><p>上面的结构图中，LifecycleListener 代表的是抽象观察者，它定义一个 lifecycleEvent 方法，这个方法就是当主题变化时要执行的方法。 ServerLifecycleListener 代表的是具体的观察者，它实现了 LifecycleListener 接口的方法，就是这个具体的观察者具体的实现方式。Lifecycle 接口代表的是抽象主题，它定义了管理观察者的方法和它要所做的其它方法。而 StandardServer 代表的是具体主题，它实现了抽象主题的所有方法。这里 Tomcat 对观察者做了扩展，增加了另外两个类：LifecycleSupport、LifecycleEvent，它们作为辅助类扩展了观察者的功能。LifecycleEvent 使得可以定义事件类别，不同的事件可区别处理，更加灵活。LifecycleSupport 类代理了主题对多观察者的管理，将这个管理抽出来统一实现，以后如果修改只要修改 LifecycleSupport 类就可以了，不需要去修改所有具体主题，因为所有具体主题的对观察者的操作都被代理给 LifecycleSupport 类了。这可以认为是观察者模式的改进版。</p><p>LifecycleSupport 调用观察者的方法代码如下：</p><h5 id="清单-1-LifecycleSupport-中的-fireLifecycleEvent-方法"><a href="#清单-1-LifecycleSupport-中的-fireLifecycleEvent-方法" class="headerlink" title="清单 1. LifecycleSupport 中的 fireLifecycleEvent 方法"></a>清单 1. LifecycleSupport 中的 fireLifecycleEvent 方法</h5><table><thead><tr><th></th><th><code>public void fireLifecycleEvent(String type, Object data) {`</code>LifecycleEvent event = new LifecycleEvent(lifecycle, type, data);<code>LifecycleListener interested[] = null;</code>synchronized (listeners) {<code>interested = (LifecycleListener[]) listeners.clone();</code>}<code>for (int i = 0; i &lt; interested.length; i++)</code>interested[i].lifecycleEvent(event);<code></code>}`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>主题是怎么通知观察者呢？看下面代码：</p><h5 id="清单-2-容器中的-start-方法"><a href="#清单-2-容器中的-start-方法" class="headerlink" title="清单 2. 容器中的 start 方法"></a>清单 2. 容器中的 start 方法</h5><table><thead><tr><th></th><th><code>public void start() throws LifecycleException {`</code>lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, null);<code>lifecycle.fireLifecycleEvent(START_EVENT, null);</code>started = true;<code>synchronized (services) {</code>for (int i = 0; i &lt; services.length; i++) {<code>if (services[i] instanceof Lifecycle)</code>((Lifecycle) services[i]).start();<code>}</code>}<code>lifecycle.fireLifecycleEvent(AFTER_START_EVENT, null);</code>}`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><h2 id="命令设计模式"><a href="#命令设计模式" class="headerlink" title="命令设计模式"></a>命令设计模式</h2><p>前面把 Tomcat 中两个核心组件 Connector 和 Container，比作一对夫妻。男的将接受过来的请求以命令的方式交给女主人。对应到 Connector 和 Container，Connector 也是通过命令模式调用 Container 的。</p><h3 id="命令模式的原理"><a href="#命令模式的原理" class="headerlink" title="命令模式的原理"></a>命令模式的原理</h3><p>命令模式主要作用就是封装命令，把发出命令的责任和执行命令的责任分开。也是一种功能的分工。不同的模块可以对同一个命令做出不同解释。</p><p>下面是命令模式通常包含下面几个角色：</p><ul><li>Client：创建一个命令，并决定接受者</li><li>Command 命令：命令接口定义一个抽象方法</li><li>ConcreteCommand：具体命令，负责调用接受者的相应操作</li><li>Invoker 请求者：负责调用命令对象执行请求</li><li>Receiver 接受者：负责具体实施和执行一次请求</li></ul><h3 id="Tomcat-中的命令模式的示例"><a href="#Tomcat-中的命令模式的示例" class="headerlink" title="Tomcat 中的命令模式的示例"></a>Tomcat 中的命令模式的示例</h3><p>Tomcat 中命令模式在 Connector 和 Container 组件之间有体现，Tomcat 作为一个应用服务器，无疑会接受到很多请求，如何分配和执行这些请求是必须的功能。</p><p>下面看一下 Tomcat 是如何实现命令模式的，下面是 Tomcat 命令模式的结构图：</p><h5 id="图-4-Tomcat-命令模式的结构图"><a href="#图-4-Tomcat-命令模式的结构图" class="headerlink" title="图 4. Tomcat 命令模式的结构图"></a>图 4. Tomcat 命令模式的结构图</h5><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat2/image004.png" alt="图 4\. Tomcat 命令模式的结构图"></p><p>Connector 作为抽象请求者，HttpConnector 作为具体请求者。HttpProcessor 作为命令。Container 作为命令的抽象接受者，ContainerBase 作为具体的接受者。客户端就是应用服务器 Server 组件了。Server 首先创建命令请求者 HttpConnector 对象，然后创建命令 HttpProcessor 命令对象。再把命令对象交给命令接受者 ContainerBase 容器来处理命令。命令的最终是被 Tomcat 的 Container 执行的。命令可以以队列的方式进来，Container 也可以以不同的方式来处理请求，如 HTTP1.0 协议和 HTTP1.1 的处理方式就会不同。</p><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>Tomcat 中一个最容易发现的设计模式就是责任链模式，这个设计模式也是 Tomcat 中 Container 设计的基础，整个容器的就是通过一个链连接在一起，这个链一直将请求正确的传递给最终处理请求的那个 Servlet。</p><h3 id="责任链模式的原理"><a href="#责任链模式的原理" class="headerlink" title="责任链模式的原理"></a>责任链模式的原理</h3><p>责任链模式，就是很多对象有每个对象对其下家的引用而连接起来形成一条链，请求在这条链上传递，直到链上的某个对象处理此请求，或者每个对象都可以处理请求，并传给下一家，直到最终链上每个对象都处理完。这样可以不影响客户端而能够在链上增加任意的处理节点。</p><p>通常责任链模式包含下面几个角色：</p><ul><li>Handler（抽象处理者）：定义一个处理请求的接口</li><li>ConcreteHandler（具体处理者）：处理请求的具体类，或者传给下家</li></ul><h3 id="Tomcat-中责任链模式示例"><a href="#Tomcat-中责任链模式示例" class="headerlink" title="Tomcat 中责任链模式示例"></a>Tomcat 中责任链模式示例</h3><p>在 tomcat 中这种设计模式几乎被完整的使用，tomcat 的容器设置就是责任链模式，从 Engine 到 Host 再到 Context 一直到 Wrapper 都是通过一个链传递请求。</p><p>Tomcat 中责任链模式的类结构图如下：</p><h5 id="图-5-Tomcat-责任链模式的结构图"><a href="#图-5-Tomcat-责任链模式的结构图" class="headerlink" title="图 5. Tomcat 责任链模式的结构图"></a>图 5. Tomcat 责任链模式的结构图</h5><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat2/image005.jpg" alt="图 5\. Tomcat 责任链模式的结构图"></p><p>上图基本描述了四个子容器使用责任链模式的类结构图，对应的责任链模式的角色，Container 扮演抽象处理者角色，具体处理者由 StandardEngine 等子容器扮演。与标准的责任链不同的是，这里引入了 Pipeline 和 Valve 接口。他们有什么作用呢？</p><p>实际上 Pipeline 和 Valve 是扩展了这个链的功能，使得在链往下传递过程中，能够接受外界的干预。Pipeline 就是连接每个子容器的管子，里面传递的 Request 和 Response 对象好比管子里流的水，而 Valve 就是这个管子上开的一个个小口子，让你有机会能够接触到里面的水，做一些额外的事情。</p><p>为了防止水被引出来而不能流到下一个容器中，每一段管子最后总有一个节点保证它一定能流到下一个子容器，所以每个容器都有一个 StandardXXXValve。只要涉及到这种有链式是处理流程这是一个非常值得借鉴的模式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java网络编程和NIO &lt;a href=&quot;https://blog.csdn.net/column/details/21963.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21963.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java网络编程与NIO" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO/"/>
    
    
      <category term="Tomcat" scheme="http://h2pl.github.io/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程与NIO详解11：Tomcat5总体架构剖析</title>
    <link href="http://h2pl.github.io/2018/05/28/Javanet11/"/>
    <id>http://h2pl.github.io/2018/05/28/Javanet11/</id>
    <published>2018-05-28T03:54:15.000Z</published>
    <updated>2018-06-11T12:46:05.884Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java网络编程和NIO <a href="https://blog.csdn.net/column/details/21963.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21963.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><p>本文以 Tomcat 5 为基础，也兼顾最新的 Tomcat 6 和 Tomcat 4。Tomcat 的基本设计思路和架构是具有一定连续性的。</p><h2 id="Tomcat-总体结构"><a href="#Tomcat-总体结构" class="headerlink" title="Tomcat 总体结构"></a>Tomcat 总体结构</h2><p>Tomcat 的结构很复杂，但是 Tomcat 也非常的模块化，找到了 Tomcat 最核心的模块，您就抓住了 Tomcat 的“七寸”。下面是 Tomcat 的总体结构图：</p><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/image001.gif" alt="图 1.Tomcat 的总体结构"></p><p>从上图中可以看出 Tomcat 的心脏是两个组件：Connector 和 Container，关于这两个组件将在后面详细介绍。Connector 组件是可以被替换，这样可以提供给服务器设计者更多的选择，因为这个组件是如此重要，不仅跟服务器的设计的本身，而且和不同的应用场景也十分相关，所以一个 Container 可以选择对应多个 Connector。多个 Connector 和一个 Container 就形成了一个 Service，Service 的概念大家都很熟悉了，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非 Server 莫属了。所以整个 Tomcat 的生命周期由 Server 控制。</p><h3 id="以-Service-作为“婚姻”"><a href="#以-Service-作为“婚姻”" class="headerlink" title="以 Service 作为“婚姻”"></a>以 Service 作为“婚姻”</h3><p>我们将 Tomcat 中 Connector、Container 作为一个整体比作一对情侣的话，Connector 主要负责对外交流，可以比作为 Boy，Container 主要处理 Connector 接受的请求，主要是处理内部事务，可以比作为 Girl。那么这个 Service 就是连接这对男女的结婚证了。是 Service 将它们连接在一起，共同组成一个家庭。当然要组成一个家庭还要很多其它的元素。</p><p>说白了，Service 只是在 Connector 和 Container 外面多包一层，把它们组装在一起，向外面提供服务，一个 Service 可以设置多个 Connector，但是只能有一个 Container 容器。这个 Service 接口的方法列表如下：</p><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/image002.png" alt="图 2\. Service 接口"></p><p>从 Service 接口中定义的方法中可以看出，它主要是为了关联 Connector 和 Container，同时会初始化它下面的其它组件，注意接口中它并没有规定一定要控制它下面的组件的生命周期。所有组件的生命周期在一个 Lifecycle 的接口中控制，这里用到了一个重要的设计模式，关于这个接口将在后面介绍。</p><p>Tomcat 中 Service 接口的标准实现类是 StandardService 它不仅实现了 Service 借口同时还实现了 Lifecycle 接口，这样它就可以控制它下面的组件的生命周期了。StandardService 类结构图如下：</p><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/image003.png" alt="图 3\. StandardService 的类结构图"></p><p>从上图中可以看出除了 Service 接口的方法的实现以及控制组件生命周期的 Lifecycle 接口的实现，还有几个方法是用于在事件监听的方法的实现，不仅是这个 Service 组件，Tomcat 中其它组件也同样有这几个方法，这也是一个典型的设计模式，将在后面介绍。</p><p>下面看一下 StandardService 中主要的几个方法实现的代码，下面是 setContainer 和 addConnector 方法的源码：</p><pre><code>public void setContainer(Container container) {    Container oldContainer = this.container;    if ((oldContainer != null) &amp;&amp; (oldContainer instanceof Engine))        ((Engine) oldContainer).setService(null);    this.container = container;    if ((this.container != null) &amp;&amp; (this.container instanceof Engine))        ((Engine) this.container).setService(this);    if (started &amp;&amp; (this.container != null) &amp;&amp; (this.container instanceof Lifecycle)) {        try {            ((Lifecycle) this.container).start();        } catch (LifecycleException e) {            ;        }    }    synchronized (connectors) {        for (int i = 0; i &lt; connectors.length; i++)            connectors[i].setContainer(this.container);    }    if (started &amp;&amp; (oldContainer != null) &amp;&amp; (oldContainer instanceof Lifecycle)) {        try {            ((Lifecycle) oldContainer).stop();        } catch (LifecycleException e) {            ;        }    }    support.firePropertyChange(&quot;container&quot;, oldContainer, this.container);}</code></pre><p>这段代码很简单，其实就是先判断当前的这个 Service 有没有已经关联了 Container，如果已经关联了，那么去掉这个关联关系—— oldContainer.setService(null)。如果这个 oldContainer 已经被启动了，结束它的生命周期。然后再替换新的关联、再初始化并开始这个新的 Container 的生命周期。最后将这个过程通知感兴趣的事件监听程序。这里值得注意的地方就是，修改 Container 时要将新的 Container 关联到每个 Connector，还好 Container 和 Connector 没有双向关联，不然这个关联关系将会很难维护。</p><pre><code>public void addConnector(Connector connector) {    synchronized (connectors) {        connector.setContainer(this.container);        connector.setService(this);        Connector results[] = new Connector[connectors.length + 1];        System.arraycopy(connectors, 0, results, 0, connectors.length);        results[connectors.length] = connector;        connectors = results;        if (initialized) {            try {                connector.initialize();            } catch (LifecycleException e) {                e.printStackTrace(System.err);            }        }        if (started &amp;&amp; (connector instanceof Lifecycle)) {            try {                ((Lifecycle) connector).start();            } catch (LifecycleException e) {                ;            }        }        support.firePropertyChange(&quot;connector&quot;, null, connector);    }}</code></pre><p>上面是 addConnector 方法，这个方法也很简单，首先是设置关联关系，然后是初始化工作，开始新的生命周期。这里值得一提的是，注意 Connector 用的是数组而不是 List 集合，这个从性能角度考虑可以理解，有趣的是这里用了数组但是并没有向我们平常那样，一开始就分配一个固定大小的数组，它这里的实现机制是：重新创建一个当前大小的数组对象，然后将原来的数组对象 copy 到新的数组中，这种方式实现了类似的动态数组的功能，这种实现方式，值得我们以后拿来借鉴。</p><p>最新的 Tomcat6 中 StandardService 也基本没有变化，但是从 Tomcat5 开始 Service、Server 和容器类都继承了 MBeanRegistration 接口，Mbeans 的管理更加合理。</p><h3 id="以-Server-为“居”"><a href="#以-Server-为“居”" class="headerlink" title="以 Server 为“居”"></a>以 Server 为“居”</h3><p>前面说一对情侣因为 Service 而成为一对夫妻，有了能够组成一个家庭的基本条件，但是它们还要有个实体的家，这是它们在社会上生存之本，有了家它们就可以安心的为人民服务了，一起为社会创造财富。</p><p>Server 要完成的任务很简单，就是要能够提供一个接口让其它程序能够访问到这个 Service 集合、同时要维护它所包含的所有 Service 的生命周期，包括如何初始化、如何结束服务、如何找到别人要访问的 Service。还有其它的一些次要的任务，如您住在这个地方要向当地政府去登记啊、可能还有要配合当地公安机关日常的安全检查什么的。</p><p>Server 的类结构图如下：</p><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/image004.png" alt="图 4\. Server 的类结构图"></p><p>它的标准实现类 StandardServer 实现了上面这些方法，同时也实现了 Lifecycle、MbeanRegistration 两个接口的所有方法，下面主要看一下 StandardServer 重要的一个方法 addService 的实现：</p><pre><code>public void addService(Service service) {    service.setServer(this);    synchronized (services) {        Service results[] = new Service[services.length + 1];        System.arraycopy(services, 0, results, 0, services.length);        results[services.length] = service;        services = results;        if (initialized) {            try {                service.initialize();            } catch (LifecycleException e) {                e.printStackTrace(System.err);            }        }        if (started &amp;&amp; (service instanceof Lifecycle)) {            try {                ((Lifecycle) service).start();            } catch (LifecycleException e) {                ;            }        }        support.firePropertyChange(&quot;service&quot;, null, service);    }}</code></pre><p>从上面第一句就知道了 Service 和 Server 是相互关联的，Server 也是和 Service 管理 Connector 一样管理它，也是将 Service 放在一个数组中，后面部分的代码也是管理这个新加进来的 Service 的生命周期。Tomcat6 中也是没有什么变化的。</p><h3 id="组件的生命线“Lifecycle”"><a href="#组件的生命线“Lifecycle”" class="headerlink" title="组件的生命线“Lifecycle”"></a>组件的生命线“Lifecycle”</h3><p>前面一直在说 Service 和 Server 管理它下面组件的生命周期，那它们是如何管理的呢？</p><p>Tomcat 中组件的生命周期是通过 Lifecycle 接口来控制的，组件只要继承这个接口并实现其中的方法就可以统一被拥有它的组件控制了，这样一层一层的直到一个最高级的组件就可以控制 Tomcat 中所有组件的生命周期，这个最高的组件就是 Server，而控制 Server 的是 Startup，也就是您启动和关闭 Tomcat。</p><p>下面是 Lifecycle 接口的类结构图：</p><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/image005.png" alt="图 5\. Lifecycle 类结构图"></p><p>除了控制生命周期的 Start 和 Stop 方法外还有一个监听机制，在生命周期开始和结束的时候做一些额外的操作。这个机制在其它的框架中也被使用，如在 Spring 中。关于这个设计模式会在后面介绍。</p><p>Lifecycle 接口的方法的实现都在其它组件中，就像前面中说的，组件的生命周期由包含它的父组件控制，所以它的 Start 方法自然就是调用它下面的组件的 Start 方法，Stop 方法也是一样。如在 Server 中 Start 方法就会调用 Service 组件的 Start 方法，Server 的 Start 方法代码如下：</p><pre><code>public void start() throws LifecycleException {    if (started) {        log.debug(sm.getString(&quot;standardServer.start.started&quot;));        return;    }    lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, null);    lifecycle.fireLifecycleEvent(START_EVENT, null);    started = true;    synchronized (services) {        for (int i = 0; i &lt; services.length; i++) {            if (services[i] instanceof Lifecycle)                ((Lifecycle) services[i]).start();        }    }    lifecycle.fireLifecycleEvent(AFTER_START_EVENT, null);}</code></pre><p>监听的代码会包围 Service 组件的启动过程，就是简单的循环启动所有 Service 组件的 Start 方法，但是所有 Service 必须要实现 Lifecycle 接口，这样做会更加灵活。</p><p>Server 的 Stop 方法代码如下：</p><pre><code>public void stop() throws LifecycleException {    if (!started)        return;    lifecycle.fireLifecycleEvent(BEFORE_STOP_EVENT, null);    lifecycle.fireLifecycleEvent(STOP_EVENT, null);    started = false;    for (int i = 0; i &lt; services.length; i++) {        if (services[i] instanceof Lifecycle)            ((Lifecycle) services[i]).stop();    }    lifecycle.fireLifecycleEvent(AFTER_STOP_EVENT, null);}</code></pre><p>它所要做的事情也和 Start 方法差不多。</p><h2 id="Connector-组件"><a href="#Connector-组件" class="headerlink" title="Connector 组件"></a>Connector 组件</h2><p>Connector 组件是 Tomcat 中两个核心组件之一，它的主要任务是负责接收浏览器的发过来的 tcp 连接请求，创建一个 Request 和 Response 对象分别用于和请求端交换数据，然后会产生一个线程来处理这个请求并把产生的 Request 和 Response 对象传给处理这个请求的线程，处理这个请求的线程就是 Container 组件要做的事了。</p><p>由于这个过程比较复杂，大体的流程可以用下面的顺序图来解释：</p><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/image006.png" alt="图 6\. Connector 处理一次请求顺序图"></p><p>（<a href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/origin_image006.png" target="_blank" rel="noopener">查看清晰大图</a>）</p><p>Tomcat5 中默认的 Connector 是 Coyote，这个 Connector 是可以选择替换的。Connector 最重要的功能就是接收连接请求然后分配线程让 Container 来处理这个请求，所以这必然是多线程的，多线程的处理是 Connector 设计的核心。Tomcat5 将这个过程更加细化，它将 Connector 划分成 Connector、Processor、Protocol, 另外 Coyote 也定义自己的 Request 和 Response 对象。</p><p>下面主要看一下 Tomcat 中如何处理多线程的连接请求，先看一下 Connector 的主要类图：</p><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/image007.png" alt="图 7\. Connector 的主要类图"></p><p>（<a href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/origin_image007.png" target="_blank" rel="noopener">查看清晰大图</a>）</p><p>看一下 HttpConnector 的 Start 方法：</p><pre><code>public void start() throws LifecycleException {    if (started)        throw new LifecycleException            (sm.getString(&quot;httpConnector.alreadyStarted&quot;));    threadName = &quot;HttpConnector[&quot; + port + &quot;]&quot;;    lifecycle.fireLifecycleEvent(START_EVENT, null);    started = true;    threadStart();    while (curProcessors &lt; minProcessors) {        if ((maxProcessors &gt; 0) &amp;&amp; (curProcessors &gt;= maxProcessors))            break;        HttpProcessor processor = newProcessor();        recycle(processor);    }}</code></pre><p>threadStart() 执行就会进入等待请求的状态，直到一个新的请求到来才会激活它继续执行，这个激活是在 HttpProcessor 的 assign 方法中，这个方法是代码如下 <code>：</code></p><pre><code>synchronized void assign(Socket socket) {    while (available) {        try {            wait();        } catch (InterruptedException e) {        }    }    this.socket = socket;    available = true;    notifyAll();    if ((debug &gt;= 1) &amp;&amp; (socket != null))        log(&quot; An incoming request is being assigned&quot;);}</code></pre><p>创建 HttpProcessor 对象是会把 available 设为 false，所以当请求到来时不会进入 while 循环，将请求的 socket 赋给当期处理的 socket，并将 available 设为 true，当 available 设为 true 是 HttpProcessor 的 run 方法将被激活，接下去将会处理这次请求。</p><p>Run 方法代码如下：</p><pre><code>public void run() {    while (!stopped) {        Socket socket = await();        if (socket == null)            continue;        try {            process(socket);        } catch (Throwable t) {            log(&quot;process.invoke&quot;, t);        }        connector.recycle(this);    }    synchronized (threadSync) {        threadSync.notifyAll();    }}</code></pre><p>解析 socket 的过程在 process 方法中，process 方法的代码片段如下：</p><pre><code>private void process(Socket socket) {    boolean ok = true;    boolean finishResponse = true;    SocketInputStream input = null;    OutputStream output = null;    try {        input = new SocketInputStream(socket.getInputStream(),connector.getBufferSize());    } catch (Exception e) {        log(&quot;process.create&quot;, e);        ok = false;    }    keepAlive = true;    while (!stopped &amp;&amp; ok &amp;&amp; keepAlive) {        finishResponse = true;        try {            request.setStream(input);            request.setResponse(response);            output = socket.getOutputStream();            response.setStream(output);            response.setRequest(request);            ((HttpServletResponse) response.getResponse())                .setHeader(&quot;Server&quot;, SERVER_INFO);        } catch (Exception e) {            log(&quot;process.create&quot;, e);            ok = false;        }        try {            if (ok) {                parseConnection(socket);                parseRequest(input, output);                if (!request.getRequest().getProtocol().startsWith(&quot;HTTP/0&quot;))                    parseHeaders(input);                if (http11) {                    ackRequest(output);                    if (connector.isChunkingAllowed())                        response.setAllowChunking(true);                }            }        。。。。。。        try {            ((HttpServletResponse) response).setHeader                (&quot;Date&quot;, FastHttpDateFormat.getCurrentDate());            if (ok) {                connector.getContainer().invoke(request, response);            }            。。。。。。        }        try {            shutdownInput(input);            socket.close();        } catch (IOException e) {            ;        } catch (Throwable e) {            log(&quot;process.invoke&quot;, e);        }    socket = null;}</code></pre><p>当 Connector 将 socket 连接封装成 request 和 response 对象后接下来的事情就交给 Container 来处理了。</p><h2 id="Servlet-容器“Container”"><a href="#Servlet-容器“Container”" class="headerlink" title="Servlet 容器“Container”"></a>Servlet 容器“Container”</h2><p>Container 是容器的父接口，所有子容器都必须实现这个接口，Container 容器的设计用的是典型的责任链的设计模式，它有四个子容器组件构成，分别是：Engine、Host、Context、Wrapper，这四个组件不是平行的，而是父子关系，Engine 包含 Host,Host 包含 Context，Context 包含 Wrapper。通常一个 Servlet class 对应一个 Wrapper，如果有多个 Servlet 就可以定义多个 Wrapper，如果有多个 Wrapper 就要定义一个更高的 Container 了，如 Context，Context 通常就是对应下面这个配置：</p><h5 id="清单-10-Server-xml"><a href="#清单-10-Server-xml" class="headerlink" title="清单 10. Server.xml"></a>清单 10. Server.xml</h5><pre><code>&lt;Context    path=&quot;/library&quot;    docBase=&quot;D:\projects\library\deploy\target\library.war&quot;    reloadable=&quot;true&quot;/&gt;</code></pre><h3 id="容器的总体设计"><a href="#容器的总体设计" class="headerlink" title="容器的总体设计"></a>容器的总体设计</h3><p>Context 还可以定义在父容器 Host 中，Host 不是必须的，但是要运行 war 程序，就必须要 Host，因为 war 中必有 web.xml 文件，这个文件的解析就需要 Host 了，如果要有多个 Host 就要定义一个 top 容器 Engine 了。而 Engine 没有父容器了，一个 Engine 代表一个完整的 Servlet 引擎。</p><p>那么这些容器是如何协同工作的呢？先看一下它们之间的关系图：</p><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/image008.png" alt="图 8\. 四个容器的关系图"></p><p>（<a href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/origin_image008.png" target="_blank" rel="noopener">查看清晰大图</a>）</p><p>当 Connector 接受到一个连接请求时，将请求交给 Container，Container 是如何处理这个请求的？这四个组件是怎么分工的，怎么把请求传给特定的子容器的呢？又是如何将最终的请求交给 Servlet 处理。下面是这个过程的时序图：</p><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/image009.png" alt="图 9\. Engine 和 Host 处理请求的时序图"></p><p>（<a href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/origin_image009.png" target="_blank" rel="noopener">查看清晰大图</a>）</p><p>这里看到了 Valve 是不是很熟悉，没错 Valve 的设计在其他框架中也有用的，同样 Pipeline 的原理也基本是相似的，它是一个管道，Engine 和 Host 都会执行这个 Pipeline，您可以在这个管道上增加任意的 Valve，Tomcat 会挨个执行这些 Valve，而且四个组件都会有自己的一套 Valve 集合。您怎么才能定义自己的 Valve 呢？在 server.xml 文件中可以添加，如给 Engine 和 Host 增加一个 Valve 如下：</p><pre><code>&lt;Engine defaultHost=&quot;localhost&quot; name=&quot;Catalina&quot;&gt;    &lt;Valve className=&quot;org.apache.catalina.valves.RequestDumperValve&quot;/&gt;    ………    &lt;Host appBase=&quot;webapps&quot; autoDeploy=&quot;true&quot; name=&quot;localhost&quot; unpackWARs=&quot;true&quot;        xmlNamespaceAware=&quot;false&quot; xmlValidation=&quot;false&quot;&gt;        &lt;Valve className=&quot;org.apache.catalina.valves.FastCommonAccessLogValve&quot;            directory=&quot;logs&quot;  prefix=&quot;localhost_access_log.&quot; suffix=&quot;.txt&quot;            pattern=&quot;common&quot; resolveHosts=&quot;false&quot;/&gt;        …………    &lt;/Host&gt;&lt;/Engine&gt;</code></pre><p>StandardEngineValve 和 StandardHostValve 是 Engine 和 Host 的默认的 Valve，它们是最后一个 Valve 负责将请求传给它们的子容器，以继续往下执行。</p><p>前面是 Engine 和 Host 容器的请求过程，下面看 Context 和 Wrapper 容器时如何处理请求的。下面是处理请求的时序图：</p><h5 id="图-10-Context-和-wrapper-的处理请求时序图"><a href="#图-10-Context-和-wrapper-的处理请求时序图" class="headerlink" title="图 10. Context 和 wrapper 的处理请求时序图"></a>图 10. Context 和 wrapper 的处理请求时序图</h5><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/image010.png" alt="图 10\. Context 和 wrapper 的处理请求时序图"></p><p>（<a href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/origin_image010.png" target="_blank" rel="noopener">查看清晰大图</a>）</p><p>从 Tomcat5 开始，子容器的路由放在了 request 中，request 中保存了当前请求正在处理的 Host、Context 和 wrapper。</p><h3 id="Engine-容器"><a href="#Engine-容器" class="headerlink" title="Engine 容器"></a>Engine 容器</h3><p>Engine 容器比较简单，它只定义了一些基本的关联关系，接口类图如下：</p><h5 id="图-11-Engine-接口的类结构"><a href="#图-11-Engine-接口的类结构" class="headerlink" title="图 11. Engine 接口的类结构"></a>图 11. Engine 接口的类结构</h5><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/image011.png" alt="图 11\. Engine 接口的类结构"></p><p>它的标准实现类是 StandardEngine，这个类注意一点就是 Engine 没有父容器了，如果调用 setParent 方法时将会报错。添加子容器也只能是 Host 类型的，代码如下：</p><h5 id="清单-12-StandardEngine-addChild"><a href="#清单-12-StandardEngine-addChild" class="headerlink" title="清单 12. StandardEngine. addChild"></a>清单 12. StandardEngine. addChild</h5><pre><code>public void addChild(Container child) {    if (!(child instanceof Host))        throw new IllegalArgumentException            (sm.getString(&quot;standardEngine.notHost&quot;));    super.addChild(child);}public void setParent(Container container) {    throw new IllegalArgumentException        (sm.getString(&quot;standardEngine.notParent&quot;));}</code></pre><p>它的初始化方法也就是初始化和它相关联的组件，以及一些事件的监听。</p><h3 id="Host-容器"><a href="#Host-容器" class="headerlink" title="Host 容器"></a>Host 容器</h3><p>Host 是 Engine 的字容器，一个 Host 在 Engine 中代表一个虚拟主机，这个虚拟主机的作用就是运行多个应用，它负责安装和展开这些应用，并且标识这个应用以便能够区分它们。它的子容器通常是 Context，它除了关联子容器外，还有就是保存一个主机应该有的信息。</p><p>下面是和 Host 相关的类关联图：</p><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/image012.png" alt="图 12\. Host 相关的类图"></p><p>（<a href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/origin_image012.png" target="_blank" rel="noopener">查看清晰大图</a>）</p><p>从上图中可以看出除了所有容器都继承的 ContainerBase 外，StandardHost 还实现了 Deployer 接口，上图清楚的列出了这个接口的主要方法，这些方法都是安装、展开、启动和结束每个 web application。</p><p>Deployer 接口的实现是 StandardHostDeployer，这个类实现了的最要的几个方法，Host 可以调用这些方法完成应用的部署等。</p><h3 id="Context-容器"><a href="#Context-容器" class="headerlink" title="Context 容器"></a>Context 容器</h3><p>Context 代表 Servlet 的 Context，它具备了 Servlet 运行的基本环境，理论上只要有 Context 就能运行 Servlet 了。简单的 Tomcat 可以没有 Engine 和 Host。</p><p>Context 最重要的功能就是管理它里面的 Servlet 实例，Servlet 实例在 Context 中是以 Wrapper 出现的，还有一点就是 Context 如何才能找到正确的 Servlet 来执行它呢？ Tomcat5 以前是通过一个 Mapper 类来管理的，Tomcat5 以后这个功能被移到了 request 中，在前面的时序图中就可以发现获取子容器都是通过 request 来分配的。</p><p>Context 准备 Servlet 的运行环境是在 Start 方法开始的，这个方法的代码片段如下：</p><pre><code>public synchronized void start() throws LifecycleException {    ………    if( !initialized ) {        try {            init();        } catch( Exception ex ) {            throw new LifecycleException(&quot;Error initializaing &quot;, ex);        }    }    ………    lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, null);    setAvailable(false);    setConfigured(false);    boolean ok = true;    File configBase = getConfigBase();    if (configBase != null) {        if (getConfigFile() == null) {            File file = new File(configBase, getDefaultConfigFile());            setConfigFile(file.getPath());            try {                File appBaseFile = new File(getAppBase());                if (!appBaseFile.isAbsolute()) {                    appBaseFile = new File(engineBase(), getAppBase());                }                String appBase = appBaseFile.getCanonicalPath();                String basePath =                    (new File(getBasePath())).getCanonicalPath();                if (!basePath.startsWith(appBase)) {                    Server server = ServerFactory.getServer();                    ((StandardServer) server).storeContext(this);                }            } catch (Exception e) {                log.warn(&quot;Error storing config file&quot;, e);            }        } else {            try {                String canConfigFile =  (new File(getConfigFile())).getCanonicalPath();                if (!canConfigFile.startsWith (configBase.getCanonicalPath())) {                    File file = new File(configBase, getDefaultConfigFile());                    if (copy(new File(canConfigFile), file)) {                        setConfigFile(file.getPath());                    }                }            } catch (Exception e) {                log.warn(&quot;Error setting config file&quot;, e);            }        }    }    ………    Container children[] = findChildren();    for (int i = 0; i &lt; children.length; i++) {        if (children[i] instanceof Lifecycle)            ((Lifecycle) children[i]).start();    }    if (pipeline instanceof Lifecycle)        ((Lifecycle) pipeline).start();    ………}</code></pre><p>它主要是设置各种资源属性和管理组件，还有非常重要的就是启动子容器和 Pipeline。</p><p>我们知道 Context 的配置文件中有个 reloadable 属性，如下面配置：</p><pre><code>&lt;Context    path=&quot;/library&quot;    docBase=&quot;D:\projects\library\deploy\target\library.war&quot;    reloadable=&quot;true&quot;/&gt;</code></pre><p>当这个 reloadable 设为 true 时，war 被修改后 Tomcat 会自动的重新加载这个应用。如何做到这点的呢 ? 这个功能是在 StandardContext 的 backgroundProcess 方法中实现的，这个方法的代码如下：</p><pre><code>public void backgroundProcess() {    if (!started) return;    count = (count + 1) % managerChecksFrequency;    if ((getManager() != null) &amp;&amp; (count == 0)) {        try {            getManager().backgroundProcess();        } catch ( Exception x ) {            log.warn(&quot;Unable to perform background process on manager&quot;,x);        }    }    if (getLoader() != null) {        if (reloadable &amp;&amp; (getLoader().modified())) {            try {                Thread.currentThread().setContextClassLoader                    (StandardContext.class.getClassLoader());                reload();            } finally {                if (getLoader() != null) {                    Thread.currentThread().setContextClassLoader                        (getLoader().getClassLoader());                }            }        }        if (getLoader() instanceof WebappLoader) {            ((WebappLoader) getLoader()).closeJARs(false);        }    }}</code></pre><p>它会调用 reload 方法，而 reload 方法会先调用 stop 方法然后再调用 Start 方法，完成 Context 的一次重新加载。可以看出执行 reload 方法的条件是 reloadable 为 true 和应用被修改，那么这个 backgroundProcess 方法是怎么被调用的呢？</p><p>这个方法是在 ContainerBase 类中定义的内部类 ContainerBackgroundProcessor 被周期调用的，这个类是运行在一个后台线程中，它会周期的执行 run 方法，它的 run 方法会周期调用所有容器的 backgroundProcess 方法，因为所有容器都会继承 ContainerBase 类，所以所有容器都能够在 backgroundProcess 方法中定义周期执行的事件。</p><h3 id="Wrapper-容器"><a href="#Wrapper-容器" class="headerlink" title="Wrapper 容器"></a>Wrapper 容器</h3><p>Wrapper 代表一个 Servlet，它负责管理一个 Servlet，包括的 Servlet 的装载、初始化、执行以及资源回收。Wrapper 是最底层的容器，它没有子容器了，所以调用它的 addChild 将会报错。</p><p>Wrapper 的实现类是 StandardWrapper，StandardWrapper 还实现了拥有一个 Servlet 初始化信息的 ServletConfig，由此看出 StandardWrapper 将直接和 Servlet 的各种信息打交道。</p><p>下面看一下非常重要的一个方法 loadServlet，代码片段如下：</p><pre><code>public synchronized Servlet loadServlet() throws ServletException {    ………    Servlet servlet;    try {        ………        ClassLoader classLoader = loader.getClassLoader();        ………        Class classClass = null;        ………        servlet = (Servlet) classClass.newInstance();        if ((servlet instanceof ContainerServlet) &amp;&amp;            (isContainerProvidedServlet(actualClass) ||            ((Context)getParent()).getPrivileged() )) {                ((ContainerServlet) servlet).setWrapper(this);        }        classLoadTime=(int) (System.currentTimeMillis() -t1);        try {            instanceSupport.fireInstanceEvent(InstanceEvent.BEFORE_INIT_EVENT,servlet);            if( System.getSecurityManager() != null) {                Class[] classType = new Class[]{ServletConfig.class};                Object[] args = new Object[]{((ServletConfig)facade)};                SecurityUtil.doAsPrivilege(&quot;init&quot;,servlet,classType,args);            } else {                servlet.init(facade);            }            if ((loadOnStartup &gt;= 0) &amp;&amp; (jspFile != null)) {                ………                if( System.getSecurityManager() != null) {                    Class[] classType = new Class[]{ServletRequest.class,                        ServletResponse.class};                    Object[] args = new Object[]{req, res};                    SecurityUtil.doAsPrivilege(&quot;service&quot;,servlet,classType,args);                } else {                    servlet.service(req, res);                }            }            instanceSupport.fireInstanceEvent(InstanceEvent.AFTER_INIT_EVENT,servlet);            ………    return servlet;}</code></pre><p>它基本上描述了对 Servlet 的操作，当装载了 Servlet 后就会调用 Servlet 的 init 方法，同时会传一个 StandardWrapperFacade 对象给 Servlet，这个对象包装了 StandardWrapper，ServletConfig 与它们的关系图如下：</p><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/image013.png" alt="图 13\. ServletConfig 与 StandardWrapperFacade、StandardWrapper 的关系"></p><p>Servlet 可以获得的信息都在 StandardWrapperFacade 封装，这些信息又是在 StandardWrapper 对象中拿到的。所以 Servlet 可以通过 ServletConfig 拿到有限的容器的信息。</p><p>当 Servlet 被初始化完成后，就等着 StandardWrapperValve 去调用它的 service 方法了，调用 service 方法之前要调用 Servlet 所有的 filter。</p><h2 id="Tomcat-中其它组件"><a href="#Tomcat-中其它组件" class="headerlink" title="Tomcat 中其它组件"></a>Tomcat 中其它组件</h2><p>Tomcat 还有其它重要的组件，如安全组件 security、logger 日志组件、session、mbeans、naming 等其它组件。这些组件共同为 Connector 和 Container 提供必要的服务。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java网络编程和NIO &lt;a href=&quot;https://blog.csdn.net/column/details/21963.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21963.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java网络编程与NIO" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO/"/>
    
    
      <category term="Tomcat" scheme="http://h2pl.github.io/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程和NIO详解10：初探Tomcat的HTTP请求过程</title>
    <link href="http://h2pl.github.io/2018/05/28/Javanet10/"/>
    <id>http://h2pl.github.io/2018/05/28/Javanet10/</id>
    <published>2018-05-28T03:54:12.000Z</published>
    <updated>2018-06-11T12:46:14.293Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java网络编程和NIO <a href="https://blog.csdn.net/column/details/21963.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21963.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><h2 id="初探Tomcat的HTTP请求过程"><a href="#初探Tomcat的HTTP请求过程" class="headerlink" title="初探Tomcat的HTTP请求过程"></a>初探Tomcat的HTTP请求过程<a href="https://www.cnblogs.com/zhouyuqin/p/5143121.html" target="_blank" rel="noopener"></a></h2><p><img src="https://img.mukewang.com/5a26678e0001e76d03630101.png" alt="图片描述" title="Tomcat架构分析(一)体系结构_"></p><p>前言：<br>1.作为Java开发人员，大多都对Tomcat不陌生，由Apache基金会提供技术支持与维护，因为其免费开源且易用，作为Web服务器深受市场欢迎，所以有必要对其进行深入的研究，本系列皆以Tomcat 8.5为研究课题，下载地址：<a href="https://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">https://tomcat.apache.org/download-80.cgi</a></p><p>2.下图为 apache-tomcat-8.5.23.zip 在windows解压后的目录。</p><p><img src="https://img.mukewang.com/5a26681100015daf10210411.png" alt="图片描述" title="Tomcat架构分析(一)体系结构_"></p><p>下面是解压后的一些关键目录:</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>/bin - 启动和停止服务等批处理文件. ( <span class="strong">*.sh) 文件 (为Unix系统)、 (*</span>.bat) 文件 (for Windows系统)是一个功能性的复制文件. 自从Win32 command-line 开始是一些单一的，缺乏功能的组件, 现在有一些拓展性的功能</span><br><span class="line"><span class="bullet">* </span>/conf - 配置文件和一些相关的DTD文件. 最重要的是 server.xml. 它是这个容器最主要的配置文件.</span><br><span class="line"><span class="bullet">* </span>/logs - 日志文件会打印到这里</span><br><span class="line"><span class="bullet">* </span>/webapps - 这里是你的应用程序部署的地方.</span><br></pre></td></tr></table></figure><p>3.从最本质上讲，tomcat为一个servlet容器，首先研究一下Tomcat的架构，如下图：</p><p><img src="https://img.mukewang.com/5a26687d0001ca2712300718.png" alt="图片描述" title="Tomcat架构分析(一)体系结构_"></p><p>架构诠释：</p><p>1.Server(服务器)是Tomcat构成的顶级构成元素，所有一切均包含在Server中，Server的实现类StandardServer可以包含一个到多个Services,Service的实现类为StandardService调用了容器(Container)接口，其实是调用了Servlet Engine(引擎)，而且StandardService类中也指明了该Service归属的Server;</p><p>2.Container: 引擎(Engine)、主机(Host)、上下文(Context)和Wraper均继承自Container接口，所以它们都是容器。但是，它们是有父子关系的，在主机(Host)、上下文(Context)和引擎(Engine)这三类容器中，引擎是顶级容器，直接包含是主机容器，而主机容器又包含上下文容器，所以引擎、主机和上下文从大小上来说又构成父子关系,虽然它们都继承自Container接口。</p><p>3.连接器(Connector)将Service和Container连接起来，首先它需要注册到一个Service，它的作用就是把来自客户端的请求转发到Container(容器)，这就是它为什么称作连接器的原因。</p><p>从功能的角度将Tomcat源代码分成5个子模块，分别是:</p><p>Jsper模块: 这个子模块负责jsp页面的解析、jsp属性的验证，同时也负责将jsp页面动态转换为java代码并编译成class文件。在Tomcat源代码中，凡是属于org.apache.jasper包及其子包中的源代码都属于这个子模块;</p><p>Servlet和Jsp模块: 这个子模块的源代码属于javax.servlet包及其子包，如我们非常熟悉的javax.servlet.Servlet接口、javax.servet.http.HttpServlet类及javax.servlet.jsp.HttpJspPage就位于这个子模块中;</p><p>Catalina模块: 这个子模块包含了所有以org.apache.catalina开头的java源代码。该子模块的任务是规范了Tomcat的总体架构，定义了Server、Service、Host、Connector、Context、Session及Cluster等关键组件及这些组件的实现，这个子模块大量运用了Composite设计模式。同时也规范了Catalina的启动及停止等事件的执行流程。从代码阅读的角度看，这个子模块应该是我们阅读和学习的重点。</p><p>Connector模块: 如果说上面三个子模块实现了Tomcat应用服务器的话，那么这个子模块就是Web服务器的实现。所谓连接器(Connector)就是一个连接客户和应用服务器的桥梁，它接收用户的请求，并把用户请求包装成标准的Http请求(包含协议名称，请求头Head，请求方法是Get还是Post等等)。同时，这个子模块还按照标准的Http协议，负责给客户端发送响应页面，比如在请求页面未发现时，connector就会给客户端浏览器发送标准的Http 404错误响应页面。</p><p>Resource模块: 这个子模块包含一些资源文件，如Server.xml及Web.xml配置文件。严格说来，这个子模块不包含java源代码，但是它还是Tomcat编译运行所必需的。</p><h2 id="Tomcat的组织结构"><a href="#Tomcat的组织结构" class="headerlink" title="Tomcat的组织结构"></a>Tomcat的组织结构</h2><ul><li>Tomcat是一个基于组件的服务器，它的构成组件都是可配置的，其中最外层的是Catalina servlet容器，其他组件按照一定的格式要求配置在这个顶层容器中。<br>Tomcat的各种组件都是在Tomcat安装目录下的/conf/server.xml文件中配置的。</li></ul><h3 id="由Server-xml的结构看Tomcat的体系结构"><a href="#由Server-xml的结构看Tomcat的体系结构" class="headerlink" title="由Server.xml的结构看Tomcat的体系结构"></a>由Server.xml的结构看Tomcat的体系结构</h3><pre><code>&lt;Server&gt;                                                //顶层类元素，可以包括多个Service       &lt;Service&gt;                                           //顶层类元素，可包含一个Engine，多个Connecter        &lt;Connector&gt;                                     //连接器类元素，代表通信接口                &lt;Engine&gt;                                //容器类元素，为特定的Service组件处理客户请求，要包含多个Host                        &lt;Host&gt;                          //容器类元素，为特定的虚拟主机组件处理客户请求，可包含多个Context                                &lt;Context&gt;               //容器类元素，为特定的Web应用处理所有的客户请求                                &lt;/Context&gt;                        &lt;/Host&gt;                &lt;/Engine&gt;        &lt;/Connector&gt;    &lt;/Service&gt;&lt;/Server&gt;</code></pre><p>实际源码如下：</p><pre><code>&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;  &lt;Listener className=&quot;org.apache.catalina.startup.VersionLoggerListener&quot; /&gt;  &lt;!-- Security listener. Documentation at /docs/config/listeners.html  &lt;Listener className=&quot;org.apache.catalina.security.SecurityListener&quot; /&gt;  --&gt;  &lt;!--APR library loader. Documentation at /docs/apr.html --&gt;  &lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;on&quot; /&gt;  &lt;!--Initialize Jasper prior to webapps are loaded. Documentation at /docs/jasper-howto.html --&gt;  &lt;Listener className=&quot;org.apache.catalina.core.JasperListener&quot; /&gt;  &lt;!-- Prevent memory leaks due to use of particular java/javax APIs--&gt;  &lt;Listener className=&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot; /&gt;  &lt;Listener className=&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot; /&gt;  &lt;Listener className=&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot; /&gt;  &lt;!-- Global JNDI resources       Documentation at /docs/jndi-resources-howto.html  --&gt;  &lt;GlobalNamingResources&gt;    &lt;!-- Editable user database that can also be used by         UserDatabaseRealm to authenticate users    --&gt;    &lt;Resource name=&quot;UserDatabase&quot; auth=&quot;Container&quot;              type=&quot;org.apache.catalina.UserDatabase&quot;              description=&quot;User database that can be updated and saved&quot;              factory=&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;              pathname=&quot;conf/tomcat-users.xml&quot; /&gt;  &lt;/GlobalNamingResources&gt;  &lt;!-- A &quot;Service&quot; is a collection of one or more &quot;Connectors&quot; that share       a single &quot;Container&quot; Note:  A &quot;Service&quot; is not itself a &quot;Container&quot;,       so you may not define subcomponents such as &quot;Valves&quot; at this level.       Documentation at /docs/config/service.html   --&gt;  &lt;Service name=&quot;Catalina&quot;&gt;    &lt;!--The connectors can use a shared executor, you can define one or more named thread pools--&gt;    &lt;!--    &lt;Executor name=&quot;tomcatThreadPool&quot; namePrefix=&quot;catalina-exec-&quot;        maxThreads=&quot;150&quot; minSpareThreads=&quot;4&quot;/&gt;    --&gt;    &lt;!-- A &quot;Connector&quot; represents an endpoint by which requests are received         and responses are returned. Documentation at :         Java HTTP Connector: /docs/config/http.html (blocking &amp; non-blocking)         Java AJP  Connector: /docs/config/ajp.html         APR (HTTP/AJP) Connector: /docs/apr.html         Define a non-SSL HTTP/1.1 Connector on port 8080    --&gt;    &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;               connectionTimeout=&quot;20000&quot;               redirectPort=&quot;8443&quot; /&gt;    &lt;!-- A &quot;Connector&quot; using the shared thread pool--&gt;    &lt;!--    &lt;Connector executor=&quot;tomcatThreadPool&quot;               port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;               connectionTimeout=&quot;20000&quot;               redirectPort=&quot;8443&quot; /&gt;    --&gt;    &lt;!-- Define a SSL HTTP/1.1 Connector on port 8443         This connector uses the BIO implementation that requires the JSSE         style configuration. When using the APR/native implementation, the         OpenSSL style configuration is required as described in the APR/native         documentation --&gt;    &lt;!--    &lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11Protocol&quot;               maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot;               clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; /&gt;    --&gt;    &lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;    &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;    &lt;!-- An Engine represents the entry point (within Catalina) that processes         every request.  The Engine implementation for Tomcat stand alone         analyzes the HTTP headers included with the request, and passes them         on to the appropriate Host (virtual host).         Documentation at /docs/config/engine.html --&gt;    &lt;!-- You should set jvmRoute to support load-balancing via AJP ie :    &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot; jvmRoute=&quot;jvm1&quot;&gt;    --&gt;    &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;      &lt;!--For clustering, please take a look at documentation at:          /docs/cluster-howto.html  (simple how to)          /docs/config/cluster.html (reference documentation) --&gt;      &lt;!--      &lt;Cluster className=&quot;org.apache.catalina.ha.tcp.SimpleTcpCluster&quot;/&gt;      --&gt;      &lt;!-- Use the LockOutRealm to prevent attempts to guess user passwords           via a brute-force attack --&gt;      &lt;Realm className=&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt;        &lt;!-- This Realm uses the UserDatabase configured in the global JNDI             resources under the key &quot;UserDatabase&quot;.  Any edits             that are performed against this UserDatabase are immediately             available for use by the Realm.  --&gt;        &lt;Realm className=&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;               resourceName=&quot;UserDatabase&quot;/&gt;      &lt;/Realm&gt;      &lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;        &lt;!-- SingleSignOn valve, share authentication between web applications             Documentation at: /docs/config/valve.html --&gt;        &lt;!--        &lt;Valve className=&quot;org.apache.catalina.authenticator.SingleSignOn&quot; /&gt;        --&gt;        &lt;!-- Access log processes all example.             Documentation at: /docs/config/valve.html             Note: The pattern used is equivalent to using pattern=&quot;common&quot; --&gt;        &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;               prefix=&quot;localhost_access_log.&quot; suffix=&quot;.txt&quot;               pattern=&quot;%h %l %u %t &quot;%r&quot; %s %b&quot; /&gt;      &lt;/Host&gt;    &lt;/Engine&gt;  &lt;/Service&gt;&lt;/Server&gt;</code></pre><p>由上可得出Tomcat的体系结构：<br><img src="https://images2015.cnblogs.com/blog/665375/201601/665375-20160119185045031-1958903281.jpg" alt=""><br>　　　　　　　　　　　　　图一：Tomcat的体系结构</p><p>由上图可看出Tomca的心脏是两个组件：Connecter和Container。一个Container可以选择多个Connecter，多个Connector和一个Container就形成了一个Service。Service可以对外提供服务，而Server服务器控制整个Tomcat的生命周期。</p><h2 id="Tomcat-Server处理一个HTTP请求的过程"><a href="#Tomcat-Server处理一个HTTP请求的过程" class="headerlink" title="Tomcat Server处理一个HTTP请求的过程"></a>Tomcat Server处理一个HTTP请求的过程</h2><p><img src="https://images2015.cnblogs.com/blog/665375/201601/665375-20160119184923890-1995839223.png" alt=""><br>　　　　　　　　　　　　　　图三：Tomcat Server处理一个HTTP请求的过程</p><blockquote><p>1、用户点击网页内容，请求被发送到本机端口8080，被在那里监听的Coyote HTTP/1.1 Connector获得。 </p></blockquote><blockquote><p>2、Connector把该请求交给它所在的Service的Engine来处理，并等待Engine的回应。 </p></blockquote><blockquote><p>3、Engine获得请求localhost/test/index.jsp，匹配所有的虚拟主机Host。 </p></blockquote><blockquote><p>4、Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机），名为localhost的Host获得请求/test/index.jsp，匹配它所拥有的所有的Context。Host匹配到路径为/test的Context（如果匹配不到就把该请求交给路径名为“ ”的Context去处理）。 </p></blockquote><blockquote><p>5、path=“/test”的Context获得请求/index.jsp，在它的mapping table中寻找出对应的Servlet。Context匹配到URL PATTERN为*.jsp的Servlet,对应于JspServlet类。 </p></blockquote><blockquote><p>6、构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet（）或doPost（）.执行业务逻辑、数据存储等程序。 </p></blockquote><blockquote><p>7、Context把执行完之后的HttpServletResponse对象返回给Host。 </p></blockquote><blockquote><p>8、Host把HttpServletResponse对象返回给Engine。 </p></blockquote><blockquote><p>9、Engine把HttpServletResponse对象返回Connector。 </p></blockquote><blockquote><p>10、Connector把HttpServletResponse对象返回给客户Browser。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java网络编程和NIO &lt;a href=&quot;https://blog.csdn.net/column/details/21963.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21963.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java网络编程与NIO" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO/"/>
    
    
      <category term="Tomcat" scheme="http://h2pl.github.io/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程和NIO详解9：基于NIO的网络编程框架Netty</title>
    <link href="http://h2pl.github.io/2018/05/27/Javanet9/"/>
    <id>http://h2pl.github.io/2018/05/27/Javanet9/</id>
    <published>2018-05-27T03:54:09.000Z</published>
    <updated>2018-06-11T12:46:23.943Z</updated>
    
    <content type="html"><![CDATA[<p>转自<a href="https://sylvanassun.github.io/2017/11/30/2017-11-30-netty_introduction/" target="_blank" rel="noopener">https://sylvanassun.github.io/2017/11/30/2017-11-30-netty_introduction/</a></p><p>netty是基于NIO实现的异步事件驱动的网络编程框架，学完NIO以后，应该看看netty的实现，netty框架涉及的内容特别多，这里只介绍netty的基本使用和实现原理，更多扩展的内容将在以后推出。</p><p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java网络编程和NIO <a href="https://blog.csdn.net/column/details/21963.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21963.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><h1 id="基于NIO的网络编程框架Netty"><a href="#基于NIO的网络编程框架Netty" class="headerlink" title="基于NIO的网络编程框架Netty"></a>基于NIO的网络编程框架Netty</h1><p><a href="https://netty.io/images/components.png" target="_blank" rel="noopener"><img src="https://netty.io/images/components.png" alt=""></a></p><h2 id="Netty概述"><a href="#Netty概述" class="headerlink" title="Netty概述"></a>Netty概述</h2><p>Netty是一个基于异步与事件驱动的网络应用程序框架，它支持快速与简单地开发可维护的高性能的服务器与客户端。</p><p>所谓事件驱动就是由通过各种事件响应来决定程序的流程，在Netty中到处都充满了异步与事件驱动，这种特点使得应用程序可以以任意的顺序响应在任意的时间点产生的事件，它带来了非常高的可伸缩性，让你的应用可以在需要处理的工作不断增长时，通过某种可行的方式或者扩大它的处理能力来适应这种增长。</p><p>Netty提供了高性能与易用性，它具有以下特点：</p><ul><li><p>拥有设计良好且统一的API，支持NIO与OIO（阻塞IO）等多种传输类型，支持真正的无连接UDP Socket。</p></li><li><p>简单而强大的线程模型，可高度定制线程（池）。</p></li><li><p>良好的模块化与解耦，支持可扩展和灵活的事件模型，可以很轻松地分离关注点以复用逻辑组件（可插拔的）。</p></li><li><p>性能高效，拥有比Java核心API更高的吞吐量，通过zero-copy功能以实现最少的内存复制消耗。</p></li><li><p>内置了许多常用的协议编解码器，如HTTP、SSL、WebScoket等常见协议可以通过Netty做到开箱即用。用户也可以利用Netty简单方便地实现自己的应用层协议。</p></li></ul><p>大多数人使用Netty主要还是为了提高应用的性能，而高性能则离不开非阻塞IO。Netty的非阻塞IO是基于Java NIO的，并且对其进行了封装（直接使用Java NIO API在高复杂度下的应用中是一项非常繁琐且容易出错的操作，而Netty帮你封装了这些复杂操作）。</p><p>Netty简介 </p><pre><code>读完这一章，我们基本上可以了解到Netty所有重要的组件，对Netty有一个全面的认识，这对下一步深入学习Netty是十分重要的，而学完这一章，我们其实已经可以用Netty解决一些常规的问题了。</code></pre><h2 id="Netty都有哪些组件？"><a href="#Netty都有哪些组件？" class="headerlink" title="Netty都有哪些组件？"></a>Netty都有哪些组件？</h2><pre><code>为了更好的理解和进一步深入Netty，我们先总体认识一下Netty用到的组件及它们在整个Netty架构中是怎么协调工作的。Netty应用中必不可少的组件：</code></pre><ul><li>Bootstrap or ServerBootstrap</li><li>EventLoop</li><li>EventLoopGroup</li><li>ChannelPipeline</li><li>Channel</li><li>Future or ChannelFuture</li><li>ChannelInitializer</li><li>ChannelHandler</li></ul><pre><code>Bootstrap，一个Netty应用通常由一个Bootstrap开始，它主要作用是配置整个Netty程序，串联起各个组件。Handler，为了支持各种协议和处理数据的方式，便诞生了Handler组件。Handler主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。ChannelInboundHandler，一个最常用的Handler。这个Handler的作用就是处理接收到数据时的事件，也就是说，我们的业务逻辑一般就是写在这个Handler里面的，ChannelInboundHandler就是用来处理我们的核心业务逻辑。ChannelInitializer，当一个链接建立时，我们需要知道怎么来接收或者发送数据，当然，我们有各种各样的Handler实现来处理它，那么ChannelInitializer便是用来配置这些Handler，它会提供一个ChannelPipeline，并把Handler加入到ChannelPipeline。ChannelPipeline，一个Netty应用基于ChannelPipeline机制，这种机制需要依赖于EventLoop和EventLoopGroup，因为它们三个都和事件或者事件处理相关。EventLoops的目的是为Channel处理IO操作，一个EventLoop可以为多个Channel服务。EventLoopGroup会包含多个EventLoop。Channel代表了一个Socket链接，或者其它和IO操作相关的组件，它和EventLoop一起用来参与IO处理。Future，在Netty中所有的IO操作都是异步的，因此，你不能立刻得知消息是否被正确处理，但是我们可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过Future和ChannelFutures,他们可以注册一个监听，当操作执行成功或失败时监听会自动触发。总之，所有的操作都会返回一个ChannelFuture。</code></pre><h2 id="Netty是如何处理连接请求和业务逻辑的呢？"><a href="#Netty是如何处理连接请求和业务逻辑的呢？" class="headerlink" title="Netty是如何处理连接请求和业务逻辑的呢？"></a>Netty是如何处理连接请求和业务逻辑的呢？</h2><p>Channels、Events 和 IO</p><pre><code>Netty是一个非阻塞的、事件驱动的、网络编程框架。当然，我们很容易理解Netty会用线程来处理IO事件，对于熟悉多线程编程的人来说，你或许会想到如何同步你的代码，但是Netty不需要我们考虑这些，具体是这样： 一个Channel会对应一个EventLoop，而一个EventLoop会对应着一个线程，也就是说，仅有一个线程在负责一个Channel的IO操作。关于这些名词之间的关系，可以见下图：![](https://img-blog.csdn.net/20140606104845234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VpZmVuZzMwNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)如图所示：当一个连接到达，Netty会注册一个channel，然后EventLoopGroup会分配一个EventLoop绑定到这个channel,在这个channel的整个生命周期过程中，都会由绑定的这个EventLoop来为它服务，而这个EventLoop就是一个线程。说到这里，那么EventLoops和EventLoopGroups关系是如何的呢？我们前面说过一个EventLoopGroup包含多个Eventloop，但是我们看一下下面这幅图，这幅图是一个继承树，从这幅图中我们可以看出，EventLoop其实继承自EventloopGroup，也就是说，在某些情况下，我们可以把一个EventLoopGroup当做一个EventLoop来用。</code></pre><p><img src="https://img-blog.csdn.net/20140606104919140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VpZmVuZzMwNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>##如何配置一个Netty应用？</p><p>BootsStrapping</p><pre><code>我们利用BootsStrapping来配置netty 应用，它有两种类型，一种用于Client端：BootsStrap，另一种用于Server端：ServerBootstrap，要想区别如何使用它们，你仅需要记住一个用在Client端，一个用在Server端。下面我们来详细介绍一下这两种类型的区别：1.第一个最明显的区别是，ServerBootstrap用于Server端，通过调用bind()方法来绑定到一个端口监听连接；Bootstrap用于Client端，需要调用connect()方法来连接服务器端，但我们也可以通过调用bind()方法返回的ChannelFuture中获取Channel去connect服务器端。2.客户端的Bootstrap一般用一个EventLoopGroup，而服务器端的ServerBootstrap会用到两个（这两个也可以是同一个实例）。为何服务器端要用到两个EventLoopGroup呢？这么设计有明显的好处，如果一个ServerBootstrap有两个EventLoopGroup，那么就可以把第一个EventLoopGroup用来专门负责绑定到端口监听连接事件，而把第二个EventLoopGroup用来处理每个接收到的连接，下面我们用一幅图来展现一下这种模式：![](https://img-blog.csdn.net/20140606104949484?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VpZmVuZzMwNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)  PS: 如果仅由一个EventLoopGroup处理所有请求和连接的话，在并发量很大的情况下，这个EventLoopGroup有可能会忙于处理已经接收到的连接而不能及时处理新的连接请求，用两个的话，会有专门的线程来处理连接请求，不会导致请求超时的情况，大大提高了并发处理能力。 我们知道一个Channel需要由一个EventLoop来绑定，而且两者一旦绑定就不会再改变。一般情况下一个EventLoopGroup中的EventLoop数量会少于Channel数量，那么就很有可能出现一个多个Channel公用一个EventLoop的情况，这就意味着如果一个Channel中的EventLoop很忙的话，会影响到这个Eventloop对其它Channel的处理，这也就是为什么我们不能阻塞EventLoop的原因。当然，我们的Server也可以只用一个EventLoopGroup,由一个实例来处理连接请求和IO事件，请看下面这幅图：![](https://img-blog.csdn.net/20140606105016890?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VpZmVuZzMwNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</code></pre><h2 id="Netty是如何处理数据的？"><a href="#Netty是如何处理数据的？" class="headerlink" title="Netty是如何处理数据的？"></a>Netty是如何处理数据的？</h2><p>Netty核心ChannelHandler</p><pre><code>下面我们来看一下netty中是怎样处理数据的，回想一下我们前面讲到的Handler，对了，就是它。说到Handler我们就不得不提ChannelPipeline，ChannelPipeline负责安排Handler的顺序及其执行，下面我们就来详细介绍一下他们：</code></pre><p> ChannelPipeline and handlers</p><pre><code>我们的应用程序中用到的最多的应该就是ChannelHandler，我们可以这么想象，数据在一个ChannelPipeline中流动，而ChannelHandler便是其中的一个个的小阀门，这些数据都会经过每一个ChannelHandler并且被它处理。这里有一个公共接口ChannelHandler:![](https://img-blog.csdn.net/20140606105045406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VpZmVuZzMwNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)从上图中我们可以看到，ChannelHandler有两个子类ChannelInboundHandler和ChannelOutboundHandler，这两个类对应了两个数据流向，如果数据是从外部流入我们的应用程序，我们就看做是inbound，相反便是outbound。其实ChannelHandler和Servlet有些类似，一个ChannelHandler处理完接收到的数据会传给下一个Handler，或者什么不处理，直接传递给下一个。下面我们看一下ChannelPipeline是如何安排ChannelHandler的：![](https://img-blog.csdn.net/20140606105113171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VpZmVuZzMwNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)从上图中我们可以看到，一个ChannelPipeline可以把两种Handler（ChannelInboundHandler和ChannelOutboundHandler）混合在一起，当一个数据流进入ChannelPipeline时，它会从ChannelPipeline头部开始传给第一个ChannelInboundHandler，当第一个处理完后再传给下一个，一直传递到管道的尾部。与之相对应的是，当数据被写出时，它会从管道的尾部开始，先经过管道尾部的“最后”一个ChannelOutboundHandler，当它处理完成后会传递给前一个ChannelOutboundHandler。</code></pre><p>数据在各个Handler之间传递，这需要调用方法中传递的ChanneHandlerContext来操作， 在netty的API中提供了两个基类分ChannelOutboundHandlerAdapter和ChannelOutboundHandlerAdapter，他们仅仅实现了调用ChanneHandlerContext来把消息传递给下一个Handler，因为我们只关心处理数据，因此我们的程序中可以继承这两个基类来帮助我们做这些，而我们仅需实现处理数据的部分即可。</p><pre><code>我们知道InboundHandler和OutboundHandler在ChannelPipeline中是混合在一起的，那么它们如何区分彼此呢？其实很容易，因为它们各自实现的是不同的接口，对于inbound event，Netty会自动跳过OutboundHandler,相反若是outbound event，ChannelInboundHandler会被忽略掉。当一个ChannelHandler被加入到ChannelPipeline中时，它便会获得一个ChannelHandlerContext的引用，而ChannelHandlerContext可以用来读写Netty中的数据流。因此，现在可以有两种方式来发送数据，一种是把数据直接写入Channel，一种是把数据写入ChannelHandlerContext，它们的区别是写入Channel的话，数据流会从Channel的头开始传递，而如果写入ChannelHandlerContext的话，数据流会流入管道中的下一个Handler。  </code></pre><h2 id="如何处理我们的业务逻辑？"><a href="#如何处理我们的业务逻辑？" class="headerlink" title="如何处理我们的业务逻辑？"></a>如何处理我们的业务逻辑？</h2><p>Encoders, Decoders and Domain Logic</p><pre><code>Netty中会有很多Handler，具体是哪种Handler还要看它们继承的是InboundAdapter还是OutboundAdapter。当然，Netty中还提供了一些列的Adapter来帮助我们简化开发，我们知道在Channelpipeline中每一个Handler都负责把Event传递给下一个Handler，如果有了这些辅助Adapter，这些额外的工作都可自动完成，我们只需覆盖实现我们真正关心的部分即可。此外，还有一些Adapter会提供一些额外的功能，比如编码和解码。那么下面我们就来看一下其中的三种常用的ChannelHandler：</code></pre><p>Encoders和Decoders</p><pre><code>因为我们在网络传输时只能传输字节流，因此，才发送数据之前，我们必须把我们的message型转换为bytes，与之对应，我们在接收数据后，必须把接收到的bytes再转换成message。我们把bytes to message这个过程称作Decode(解码成我们可以理解的)，把message to bytes这个过程成为Encode。Netty中提供了很多现成的编码/解码器，我们一般从他们的名字中便可知道他们的用途，如ByteToMessageDecoder、MessageToByteEncoder，如专门用来处理Google Protobuf协议的ProtobufEncoder、 ProtobufDecoder。我们前面说过，具体是哪种Handler就要看它们继承的是InboundAdapter还是OutboundAdapter，对于Decoders,很容易便可以知道它是继承自ChannelInboundHandlerAdapter或 ChannelInboundHandler，因为解码的意思是把ChannelPipeline传入的bytes解码成我们可以理解的message（即Java Object），而ChannelInboundHandler正是处理Inbound Event，而Inbound Event中传入的正是字节流。Decoder会覆盖其中的“ChannelRead()”方法，在这个方法中来调用具体的decode方法解码传递过来的字节流，然后通过调用ChannelHandlerContext.fireChannelRead(decodedMessage)方法把编码好的Message传递给下一个Handler。与之类似，Encoder就不必多少了。</code></pre><p>Domain Logic</p><pre><code>其实我们最最关心的事情就是如何处理接收到的解码后的数据，我们真正的业务逻辑便是处理接收到的数据。Netty提供了一个最常用的基类SimpleChannelInboundHandler&lt;T&gt;，其中T就是这个Handler处理的数据的类型（上一个Handler已经替我们解码好了），消息到达这个Handler时，Netty会自动调用这个Handler中的channelRead0(ChannelHandlerContext,T)方法，T是传递过来的数据对象，在这个方法中我们便可以任意写我们的业务逻辑了。</code></pre><p>Netty从某方面来说就是一套NIO框架，在Java NIO基础上做了封装，所以要想学好Netty我建议先理解好Java NIO，</p><p>NIO可以称为New IO也可以称为Non-blocking IO，它比Java旧的阻塞IO在性能上要高效许多（如果让每一个连接中的IO操作都单独创建一个线程，那么阻塞IO并不会比NIO在性能上落后，但不可能创建无限多的线程，在连接数非常多的情况下会很糟糕）。</p><ul><li><p>ByteBuffer：NIO的数据传输是基于缓冲区的，ByteBuffer正是NIO数据传输中所使用的缓冲区抽象。ByteBuffer支持在堆外分配内存，并且尝试避免在执行I/O操作中的多余复制。一般的I/O操作都需要进行系统调用，这样会先切换到内核态，内核态要先从文件读取数据到它的缓冲区，只有等数据准备完毕后，才会从内核态把数据写到用户态，所谓的阻塞IO其实就是说的在等待数据准备好的这段时间内进行阻塞。如果想要避免这个额外的内核操作，可以通过使用mmap（虚拟内存映射）的方式来让用户态直接操作文件。</p></li><li><p>Channel：它类似于文件描述符，简单地来说它代表了一个实体（如一个硬件设备、文件、Socket或者一个能够执行一个或多个不同的I/O操作的程序组件）。你可以从一个Channel中读取数据到缓冲区，也可以将一个缓冲区中的数据写入到Channel。</p></li><li><p>Selector：选择器是NIO实现的关键，NIO采用的是I/O多路复用的方式来实现非阻塞，Selector通过在一个线程中监听每个Channel的IO事件来确定有哪些已经准备好进行IO操作的Channel，因此可以在任何时间检查任意的读操作或写操作的完成状态。这种方式避免了等待IO操作准备数据时的阻塞，使用较少的线程便可以处理许多连接，减少了线程切换与维护的开销。</p><p><a href="http://wx2.sinaimg.cn/large/63503acbly1flys7n7hvaj20h90doglj.jpg" target="_blank" rel="noopener"><img src="http://wx2.sinaimg.cn/large/63503acbly1flys7n7hvaj20h90doglj.jpg" alt=""></a></p></li></ul><p>了解了NIO的实现思想之后，我觉得还很有必要了解一下Unix中的I/O模型，Unix中拥有以下5种I/O模型：</p><ul><li><p>阻塞I/O（Blocking I/O）</p></li><li><p>非阻塞I/O（Non-blocking I/O）</p></li><li><p>I/O多路复用（I/O multiplexing (select and poll)）</p></li><li><p>信号驱动I/O（signal driven I/O (SIGIO)）</p></li><li><p>异步I/O（asynchronous I/O (the POSIX aio_functions)）</p></li></ul><p><a href="http://wx3.sinaimg.cn/large/63503acbly1flz1e7kzblj20wb0ftq3l.jpg" target="_blank" rel="noopener"><img src="http://wx3.sinaimg.cn/large/63503acbly1flz1e7kzblj20wb0ftq3l.jpg" alt="阻塞I/O模型"></a></p><p>阻塞I/O模型是最常见的I/O模型，通常我们使用的InputStream/OutputStream都是基于阻塞I/O模型。在上图中，我们使用UDP作为例子，recvfrom()函数是UDP协议用于接收数据的函数，它需要使用系统调用并一直阻塞到内核将数据准备好，之后再由内核缓冲区复制数据到用户态（即是recvfrom()接收到数据），所谓阻塞就是在等待内核准备数据的这段时间内什么也不干。</p><p>举个生活中的例子，阻塞I/O就像是你去餐厅吃饭，在等待饭做好的时间段中，你只能在餐厅中坐着干等（如果你在玩手机那么这就是非阻塞I/O了）。</p><p><a href="http://wx2.sinaimg.cn/large/63503acbly1flz1e8lh7rj20wb0ft0ty.jpg" target="_blank" rel="noopener"><img src="http://wx2.sinaimg.cn/large/63503acbly1flz1e8lh7rj20wb0ft0ty.jpg" alt="非阻塞I/O模型"></a></p><p>在非阻塞I/O模型中，内核在数据尚未准备好的情况下回返回一个错误码<code>EWOULDBLOCK</code>，而recvfrom并没有在失败的情况下选择阻塞休眠，而是不断地向内核询问是否已经准备完毕，在上图中，前三次内核都返回了<code>EWOULDBLOCK</code>，直到第四次询问时，内核数据准备完毕，然后开始将内核中缓存的数据复制到用户态。这种不断询问内核以查看某种状态是否完成的方式被称为<code>polling（轮询）</code>。</p><p>非阻塞I/O就像是你在点外卖，只不过你非常心急，每隔一段时间就要打电话问外卖小哥有没有到。</p><p><a href="http://wx3.sinaimg.cn/large/63503acbly1flz1e989dfj20wh0g80tw.jpg" target="_blank" rel="noopener"><img src="http://wx3.sinaimg.cn/large/63503acbly1flz1e989dfj20wh0g80tw.jpg" alt="I/O多路复用模型"></a></p><p>I/O多路复用的思想跟非阻塞I/O是一样的，只不过在非阻塞I/O中，是在recvfrom的用户态（或一个线程）中去轮询内核，这种方式会消耗大量的CPU时间。而I/O多路复用则是通过select()或poll()系统调用来负责进行轮询，以实现监听I/O读写事件的状态。如上图中，select监听到一个datagram可读时，就交由recvfrom去发送系统调用将内核中的数据复制到用户态。</p><p>这种方式的优点很明显，通过I/O多路复用可以监听多个文件描述符，且在内核中完成监控的任务。但缺点是至少需要两个系统调用（select()与recvfrom()）。</p><p>I/O多路复用同样适用于点外卖这个例子，只不过你在等外卖的期间完全可以做自己的事情，当外卖到的时候会通过外卖APP或者由外卖小哥打电话来通知你。</p><p>Unix中提供了两种I/O多路复用函数，select()和poll()。select()的兼容性更好，但它在单个进程中所能监控的文件描述符是有限的，这个值与<code>FD_SETSIZE</code>相关，32位系统中默认为1024，64位系统中为2048。select()还有一个缺点就是他轮询的方式，它采取了线性扫描的轮询方式，每次都要遍历FD_SETSIZE个文件描述符，不管它们是否活不活跃的。poll()本质上与select()的实现没有区别，不过在数据结构上区别很大，用户必须分配一个pollfd结构数组，该数组维护在内核态中，正因如此，poll()并不像select()那样拥有大小上限的限制，但缺点同样也很明显，大量的fd数组会在用户态与内核态之间不断复制，不管这样的复制是否有意义。</p><p>还有一种比select()与poll()更加高效的实现叫做epoll()，它是由Linux内核2.6推出的可伸缩的I/O多路复用实现，目的是为了替代select()与poll()。epoll()同样没有文件描述符上限的限制，它使用一个文件描述符来管理多个文件描述符，并使用一个红黑树来作为存储结构。同时它还支持边缘触发（edge-triggered）与水平触发（level-triggered）两种模式（poll()只支持水平触发），在边缘触发模式下，<code>epoll_wait</code>仅会在新的事件对象首次被加入到epoll时返回，而在水平触发模式下，<code>epoll_wait</code>会在事件状态未变更前不断地触发。也就是说，边缘触发模式只会在文件描述符变为就绪状态时通知一次，水平触发模式会不断地通知该文件描述符直到被处理。</p><p>关于<code>epoll_wait</code>请参考如下epoll API。</p><pre><code>// 创建一个epoll对象并返回它的文件描述符。// 参数flags允许修改epoll的行为，它只有一个有效值EPOLL_CLOEXEC。int epoll_create1(int flags);// 配置对象，该对象负责描述监控哪些文件描述符和哪些事件。int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);// 等待与epoll_ctl注册的任何事件，直至事件发生一次或超时。// 返回在events中发生的事件，最多同时返回maxevents个。int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</code></pre><p>epoll另一亮点是采用了事件驱动的方式而不是轮询，在<code>epoll_ctl</code>中注册的文件描述符在事件触发的时候会通过一个回调机制来激活该文件描述符，<code>epoll_wait</code>便可以收到通知。这样效率就不会与文件描述符的数量成正比</p><p>在Java NIO2（从JDK1.7开始引入）中，只要Linux内核版本在2.6以上，就会采用epoll，如下源码所示（DefaultSelectorProvider.java）。</p><pre><code>public static SelectorProvider create() {String osname = AccessController.doPrivileged(new GetPropertyAction(&quot;os.name&quot;));if (&quot;SunOS&quot;.equals(osname)) {return new sun.nio.ch.DevPollSelectorProvider();}// use EPollSelectorProvider for Linux kernels &gt;= 2.6if (&quot;Linux&quot;.equals(osname)) {String osversion = AccessController.doPrivileged(new GetPropertyAction(&quot;os.version&quot;));String[] vers = osversion.split(&quot;\\.&quot;, 0);if (vers.length &gt;= 2) {try {int major = Integer.parseInt(vers[0]);int minor = Integer.parseInt(vers[1]);if (major &gt; 2 || (major == 2 &amp;&amp; minor &gt;= 6)) {return new sun.nio.ch.EPollSelectorProvider();}} catch (NumberFormatException x) {// format not recognized}}}return new sun.nio.ch.PollSelectorProvider();}</code></pre><p><a href="http://wx3.sinaimg.cn/large/63503acbly1flz1e9uk8aj20wb0ft3zn.jpg" target="_blank" rel="noopener"><img src="http://wx3.sinaimg.cn/large/63503acbly1flz1e9uk8aj20wb0ft3zn.jpg" alt="信号驱动I/O模型"></a></p><p>信号驱动I/O模型使用到了信号，内核在数据准备就绪时会通过信号来进行通知。我们首先开启了一个信号驱动I/O套接字，并使用sigaction系统调用来安装信号处理程序，内核直接返回，不会阻塞用户态。当datagram准备好时，内核会发送SIGIO信号，recvfrom接收到信号后会发送系统调用开始进行I/O操作。</p><p>这种模型的优点是主进程（线程）不会被阻塞，当数据准备就绪时，通过信号处理程序来通知主进程（线程）准备进行I/O操作与对数据的处理。</p><p><a href="http://wx2.sinaimg.cn/large/63503acbly1flz1eai66rj20wb0g8aau.jpg" target="_blank" rel="noopener"><img src="http://wx2.sinaimg.cn/large/63503acbly1flz1eai66rj20wb0g8aau.jpg" alt="异步I/O模型"></a></p><p>我们之前讨论的各种I/O模型无论是阻塞还是非阻塞，它们所说的阻塞都是指的数据准备阶段。异步I/O模型同样依赖于信号处理程序来进行通知，但与以上I/O模型都不相同的是，异步I/O模型通知的是I/O操作已经完成，而不是数据准备完成。</p><p>可以说异步I/O模型才是真正的非阻塞，主进程只管做自己的事情，然后在I/O操作完成时调用回调函数来完成一些对数据的处理操作即可。</p><p>闲扯了这么多，想必大家已经对I/O模型有了一个深刻的认识。之后，我们将会结合部分源码（Netty4.X）来探讨Netty中的各大核心组件，以及如何使用Netty，你会发现实现一个Netty程序是多么简单（而且还伴随了高性能与可维护性）。</p><blockquote><p>本文作者为<a href="https://github.com/SylvanasSun" target="_blank" rel="noopener">SylvanasSun(sylvanas.sun@gmail.com)</a>，首发于<a href="https://sylvanassun.github.io/" target="_blank" rel="noopener">SylvanasSun’s Blog</a>。<br>原文链接：<a href="https://sylvanassun.github.io/2017/11/30/2017-11-30-netty_introduction/" target="_blank" rel="noopener">https://sylvanassun.github.io/2017/11/30/2017-11-30-netty_introduction/</a><br>（转载请务必保留本段声明，并且保留超链接。）</p></blockquote><h3 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a><a href="https://sylvanassun.github.io/2017/11/30/2017-11-30-netty_introduction/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#ByteBuf" title="ByteBuf" target="_blank" rel="noopener"></a>ByteBuf</h3><hr><p>网络传输的基本单位是字节，在Java NIO中提供了ByteBuffer作为字节缓冲区容器，但该类的API使用起来不太方便，所以Netty实现了ByteBuf作为其替代品，下面是使用ByteBuf的优点：</p><ul><li><p>相比ByteBuffer使用起来更加简单。</p></li><li><p>通过内置的复合缓冲区类型实现了透明的zero-copy。</p></li><li><p>容量可以按需增长。</p></li><li><p>读和写使用了不同的索引指针。</p></li><li><p>支持链式调用。</p></li><li><p>支持引用计数与池化。</p></li><li><p>可以被用户自定义的缓冲区类型扩展。</p></li></ul><p>在讨论ByteBuf之前，我们先需要了解一下ByteBuffer的实现，这样才能比较深刻地明白它们之间的区别。</p><p>ByteBuffer继承于<code>abstract class Buffer</code>（所以还有LongBuffer、IntBuffer等其他类型的实现），本质上它只是一个有限的线性的元素序列，包含了三个重要的属性。</p><ul><li><p>Capacity：缓冲区中元素的容量大小，你只能将capacity个数量的元素写入缓冲区，一旦缓冲区已满就需要清理缓冲区才能继续写数据。</p></li><li><p>Position：指向下一个写入数据位置的索引指针，初始位置为0，最大为capacity-1。当写模式转换为读模式时，position需要被重置为0。</p></li><li><p>Limit：在写模式中，limit是可以写入缓冲区的最大索引，也就是说它在写模式中等价于缓冲区的容量。在读模式中，limit表示可以读取数据的最大索引。</p></li></ul><p><a href="http://tutorials.jenkov.com/images/java-nio/buffers-modes.png" target="_blank" rel="noopener"><img src="http://tutorials.jenkov.com/images/java-nio/buffers-modes.png" alt=""></a></p><p>由于Buffer中只维护了position一个索引指针，所以它在读写模式之间的切换需要调用一个flip()方法来重置指针。使用Buffer的流程一般如下：</p><ul><li><p>写入数据到缓冲区。</p></li><li><p>调用flip()方法。</p></li><li><p>从缓冲区中读取数据</p></li><li><p>调用buffer.clear()或者buffer.compact()清理缓冲区，以便下次写入数据。</p></li></ul><pre><code>RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);FileChannel inChannel = aFile.getChannel();// 分配一个48字节大小的缓冲区ByteBuffer buf = ByteBuffer.allocate(48);int bytesRead = inChannel.read(buf); // 读取数据到缓冲区while (bytesRead != -1) {buf.flip(); // 将position重置为0while(buf.hasRemaining()){System.out.print((char) buf.get()); // 读取数据并输出到控制台}buf.clear(); // 清理缓冲区bytesRead = inChannel.read(buf);}aFile.close();Buffer中核心方法的实现也非常简单，主要就是在操作指针position。</code></pre><p>Buffer中核心方法的实现也非常简单，主要就是在操作指针position。</p><pre><code>/*** Sets this buffer&apos;s mark at its position.** @return This buffer*/public final Buffer mark() {mark = position; // mark属性是用来标记当前索引位置的return this;}// 将当前索引位置重置为mark所标记的位置public final Buffer reset() {int m = mark;if (m &lt; 0)throw new InvalidMarkException();position = m;return this;}// 翻转这个Buffer，将limit设置为当前索引位置，然后再把position重置为0public final Buffer flip() {limit = position;position = 0;mark = -1;return this;}// 清理缓冲区// 说是清理,也只是把postion与limit进行重置,之后再写入数据就会覆盖之前的数据了public final Buffer clear() {position = 0;limit = capacity;mark = -1;return this;}// 返回剩余空间public final int remaining() {return limit - position;}</code></pre><p>Java NIO中的Buffer API操作的麻烦之处就在于读写转换需要手动重置指针。而ByteBuf没有这种繁琐性，它维护了两个不同的索引，一个用于读取，一个用于写入。当你从ByteBuf读取数据时，它的readerIndex将会被递增已经被读取的字节数，同样的，当你写入数据时，writerIndex则会递增。readerIndex的最大范围在writerIndex的所在位置，如果试图移动readerIndex超过该值则会触发异常。</p><p>ByteBuf中名称以read或write开头的方法将会递增它们其对应的索引，而名称以get或set开头的方法则不会。ByteBuf同样可以指定一个最大容量，试图移动writerIndex超过该值则会触发异常。</p><pre><code>public byte readByte() {    this.checkReadableBytes0(1); // 检查readerIndex是否已越界    int i = this.readerIndex;    byte b = this._getByte(i);    this.readerIndex = i + 1; // 递增readerIndex    return b;}private void checkReadableBytes0(int minimumReadableBytes) {    this.ensureAccessible();    if(this.readerIndex &gt; this.writerIndex - minimumReadableBytes) {    throw new IndexOutOfBoundsException(String.format(&quot;readerIndex(%d) + length(%d) exceeds writerIndex(%d): %s&quot;, new Object[]{Integer.valueOf(this.readerIndex), Integer.valueOf(minimumReadableBytes), Integer.valueOf(this.writerIndex), this}));    }}public ByteBuf writeByte(int value) {    this.ensureAccessible();    this.ensureWritable0(1); // 检查writerIndex是否会越过capacity    this._setByte(this.writerIndex++, value);    return this;}private void ensureWritable0(int minWritableBytes) {    if(minWritableBytes &gt; this.writableBytes()) {    if(minWritableBytes &gt; this.maxCapacity - this.writerIndex) {    throw new IndexOutOfBoundsException(String.format(&quot;writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s&quot;, new Object[]{Integer.valueOf(this.writerIndex), Integer.valueOf(minWritableBytes), Integer.valueOf(this.maxCapacity), this}));    } else {    int newCapacity = this.alloc().calculateNewCapacity(this.writerIndex + minWritableBytes, this.maxCapacity);    this.capacity(newCapacity);    }    }}// get与set只对传入的索引进行了检查，然后对其位置进行get或setpublic byte getByte(int index) {    this.checkIndex(index);    return this._getByte(index);}public ByteBuf setByte(int index, int value) {    this.checkIndex(index);    this._setByte(index, value);    return this;}</code></pre><p>ByteBuf同样支持在堆内和堆外进行分配。在堆内分配也被称为支撑数组模式，它能在没有使用池化的情况下提供快速的分配和释放。</p><pre><code>ByteBuf heapBuf = Unpooled.copiedBuffer(bytes);if (heapBuf.hasArray()) { // 判断是否有一个支撑数组byte[] array = heapBuf.array();// 计算第一个字节的偏移量int offset = heapBuf.arrayOffset() + heapBuf.readerIndex();int length = heapBuf.readableBytes(); // 获得可读字节handleArray(array,offset,length); // 调用你的处理方法}</code></pre><p>另一种模式为堆外分配，Java NIO ByteBuffer类在JDK1.4时就已经允许JVM实现通过JNI调用来在堆外分配内存（调用malloc()函数在JVM堆外分配内存），这主要是为了避免额外的缓冲区复制操作。</p><pre><code>ByteBuf directBuf = Unpooled.directBuffer(capacity);if (!directBuf.hasArray()) {int length = directBuf.readableBytes();byte[] array = new byte[length];// 将字节复制到数组中directBuf.getBytes(directBuf.readerIndex(),array);handleArray(array,0,length);}</code></pre><p>ByteBuf还支持第三种模式，它被称为复合缓冲区，为多个ByteBuf提供了一个聚合视图。在这个视图中，你可以根据需要添加或者删除ByteBuf实例，ByteBuf的子类CompositeByteBuf实现了该模式。</p><p>一个适合使用复合缓冲区的场景是HTTP协议，通过HTTP协议传输的消息都会被分成两部分——头部和主体，如果这两部分由应用程序的不同模块产生，将在消息发送时进行组装，并且该应用程序还会为多个消息复用相同的消息主体，这样对于每个消息都将会创建一个新的头部，产生了很多不必要的内存操作。使用CompositeByteBuf是一个很好的选择，它消除了这些额外的复制，以帮助你复用这些消息。</p><pre><code>CompositeByteBuf messageBuf = Unpooled.compositeBuffer();ByteBuf headerBuf = ....;ByteBuf bodyBuf = ....;messageBuf.addComponents(headerBuf,bodyBuf);for (ByteBuf buf : messageBuf) {System.out.println(buf.toString());}</code></pre><p>CompositeByteBuf透明的实现了zero-copy，zero-copy其实就是避免数据在两个内存区域中来回的复制。从操作系统层面上来讲，zero-copy指的是避免在内核态与用户态之间的数据缓冲区复制（通过mmap避免），而Netty中的zero-copy更偏向于在用户态中的数据操作的优化，就像使用CompositeByteBuf来复用多个ByteBuf以避免额外的复制，也可以使用wrap()方法来将一个字节数组包装成ByteBuf，又或者使用ByteBuf的slice()方法把它分割为多个共享同一内存区域的ByteBuf，这些都是为了优化内存的使用率。</p><p>那么如何创建ByteBuf呢？在上面的代码中使用到了Unpooled，它是Netty提供的一个用于创建与分配ByteBuf的工具类，建议都使用这个工具类来创建你的缓冲区，不要自己去调用构造函数。经常使用的是wrappedBuffer()与copiedBuffer()，它们一个是用于将一个字节数组或ByteBuffer包装为一个ByteBuf，一个是根据传入的字节数组与ByteBuffer/ByteBuf来复制出一个新的ByteBuf。</p><pre><code>// 通过array.clone()来复制一个数组进行包装public static ByteBuf copiedBuffer(byte[] array) {return array.length == 0?EMPTY_BUFFER:wrappedBuffer((byte[])array.clone());}// 默认是堆内分配public static ByteBuf wrappedBuffer(byte[] array) {return (ByteBuf)(array.length == 0?EMPTY_BUFFER:new UnpooledHeapByteBuf(ALLOC, array, array.length));}// 也提供了堆外分配的方法private static final ByteBufAllocator ALLOC;public static ByteBuf directBuffer(int initialCapacity) {return ALLOC.directBuffer(initialCapacity);}</code></pre><p>相对底层的分配方法是使用ByteBufAllocator，Netty实现了PooledByteBufAllocator和UnpooledByteBufAllocator，前者使用了<a href="https://github.com/jemalloc/jemalloc" target="_blank" rel="noopener">jemalloc（一种malloc()的实现）</a>来分配内存，并且实现了对ByteBuf的池化以提高性能。后者分配的是未池化的ByteBuf，其分配方式与之前讲的一致。</p><pre><code>Channel channel = ...;ByteBufAllocator allocator = channel.alloc();ByteBuf buffer = allocator.directBuffer();do something.......</code></pre><p>为了优化内存使用率，Netty提供了一套手动的方式来追踪不活跃对象，像UnpooledHeapByteBuf这种分配在堆内的对象得益于JVM的GC管理，无需额外操心，而UnpooledDirectByteBuf是在堆外分配的，它的内部基于DirectByteBuffer，DirectByteBuffer会先向Bits类申请一个额度（Bits还拥有一个全局变量totalCapacity，记录了所有DirectByteBuffer总大小），每次申请前都会查看是否已经超过-XX:MaxDirectMemorySize所设置的上限，如果超限就会尝试调用Sytem.gc()，以试图回收一部分内存，然后休眠100毫秒，如果内存还是不足，则只能抛出OOM异常。堆外内存的回收虽然有了这么一层保障，但为了提高性能与使用率，主动回收也是很有必要的。由于Netty还实现了ByteBuf的池化，像PooledHeapByteBuf和PooledDirectByteBuf就必须依赖于手动的方式来进行回收（放回池中）。</p><p>Netty使用了引用计数器的方式来追踪那些不活跃的对象。引用计数的接口为ReferenceCounted，它的思想很简单，只要ByteBuf对象的引用计数大于0，就保证该对象不会被释放回收，可以通过手动调用release()与retain()方法来操作该对象的引用计数值递减或递增。用户也可以通过自定义一个ReferenceCounted的实现类，以满足自定义的规则。</p><pre><code>package io.netty.buffer;public abstract class AbstractReferenceCountedByteBuf extends AbstractByteBuf {// 由于ByteBuf的实例对象会非常多,所以这里没有将refCnt包装为AtomicInteger// 而是使用一个全局的AtomicIntegerFieldUpdater来负责操作refCntprivate static final AtomicIntegerFieldUpdater&lt;AbstractReferenceCountedByteBuf&gt; refCntUpdater = AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCountedByteBuf.class, &quot;refCnt&quot;);// 每个ByteBuf的初始引用值都为1private volatile int refCnt = 1;public int refCnt() {return this.refCnt;}protected final void setRefCnt(int refCnt) {this.refCnt = refCnt;}public ByteBuf retain() {return this.retain0(1);}// 引用计数值递增increment，increment必须大于0public ByteBuf retain(int increment) {return this.retain0(ObjectUtil.checkPositive(increment, &quot;increment&quot;));}public static int checkPositive(int i, String name) {if(i &lt;= 0) {throw new IllegalArgumentException(name + &quot;: &quot; + i + &quot; (expected: &gt; 0)&quot;);} else {return i;}}// 使用CAS操作不断尝试更新值private ByteBuf retain0(int increment) {int refCnt;int nextCnt;do {refCnt = this.refCnt;nextCnt = refCnt + increment;if(nextCnt &lt;= increment) {throw new IllegalReferenceCountException(refCnt, increment);}} while(!refCntUpdater.compareAndSet(this, refCnt, nextCnt));return this;}public boolean release() {return this.release0(1);}public boolean release(int decrement) {return this.release0(ObjectUtil.checkPositive(decrement, &quot;decrement&quot;));}private boolean release0(int decrement) {int refCnt;do {refCnt = this.refCnt;if(refCnt &lt; decrement) {throw new IllegalReferenceCountException(refCnt, -decrement);}} while(!refCntUpdater.compareAndSet(this, refCnt, refCnt - decrement));if(refCnt == decrement) {this.deallocate();return true;} else {return false;}}protected abstract void deallocate();}</code></pre><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a><a href="https://sylvanassun.github.io/2017/11/30/2017-11-30-netty_introduction/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#Channel" title="Channel" target="_blank" rel="noopener"></a>Channel</h3><hr><p>Netty中的Channel与Java NIO的概念一样，都是对一个实体或连接的抽象，但Netty提供了一套更加通用的API。就以网络套接字为例，在Java中OIO与NIO是截然不同的两套API，假设你之前使用的是OIO而又想更改为NIO实现，那么几乎需要重写所有代码。而在Netty中，只需要更改短短几行代码（更改Channel与EventLoop的实现类，如把OioServerSocketChannel替换为NioServerSocketChannel），就可以完成OIO与NIO（或其他）之间的转换。</p><p><a href="http://wx2.sinaimg.cn/large/63503acbly1fm103i127ej20xe0f074y.jpg" target="_blank" rel="noopener"><img src="http://wx2.sinaimg.cn/large/63503acbly1fm103i127ej20xe0f074y.jpg" alt=""></a></p><p>每个Channel最终都会被分配一个ChannelPipeline和ChannelConfig，前者持有所有负责处理入站与出站数据以及事件的ChannelHandler，后者包含了该Channel的所有配置设置，并且支持热更新，由于不同的传输类型可能具有其特别的配置，所以该类可能会实现为ChannelConfig的不同子类。</p><p>Channel是线程安全的（与之后要讲的线程模型有关），因此你完全可以在多个线程中复用同一个Channel，就像如下代码所示。</p><pre><code>final Channel channel = ...final ByteBuf buffer = Unpooled.copiedBuffer(&quot;Hello,World!&quot;, CharsetUtil.UTF_8).retain();Runnable writer = new Runnable() {@Overridepublic void run() {channel.writeAndFlush(buffer.duplicate());}};Executor executor = Executors.newCachedThreadPool();executor.execute(writer);executor.execute(writer);.......</code></pre><p>Netty除了支持常见的NIO与OIO，还内置了其他的传输类型。</p><table><thead><tr><th>Nmae</th><th>Package</th><th>Description</th></tr></thead><tbody><tr><td>NIO</td><td>io.netty.channel.socket.nio</td><td>以Java NIO为基础实现</td></tr><tr><td>OIO</td><td>io.netty.channel.socket.oio</td><td>以java.net为基础实现，使用阻塞I/O模型</td></tr><tr><td>Epoll</td><td>io.netty.channel.epoll</td><td>由JNI驱动epoll()实现的更高性能的非阻塞I/O，它只能使用在Linux</td></tr><tr><td>Local</td><td>io.netty.channel.local</td><td>本地传输，在JVM内部通过管道进行通信</td></tr><tr><td>Embedded</td><td>io.netty.channel.embedded</td><td>允许在不需要真实网络传输的环境下使用ChannelHandler，主要用于对ChannelHandler进行测试</td></tr></tbody></table><p>NIO、OIO、Epoll我们应该已经很熟悉了，下面主要说说Local与Embedded。</p><p>Local传输用于在同一个JVM中运行的客户端和服务器程序之间的异步通信，与服务器Channel相关联的SocketAddress并没有绑定真正的物理网络地址，它会被存储在注册表中，并在Channel关闭时注销。因此Local传输不会接受真正的网络流量，也就是说它不能与其他传输实现进行互操作。</p><p>Embedded传输主要用于对ChannelHandler进行单元测试，ChannelHandler是用于处理消息的逻辑组件，Netty通过将入站消息与出站消息都写入到EmbeddedChannel中的方式（提供了write/readInbound()与write/readOutbound()来读写入站与出站消息）来实现对ChannelHandler的单元测试。</p><h3 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a><a href="https://sylvanassun.github.io/2017/11/30/2017-11-30-netty_introduction/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#ChannelHandler" title="ChannelHandler" target="_blank" rel="noopener"></a>ChannelHandler</h3><hr><p>ChannelHandler充当了处理入站和出站数据的应用程序逻辑的容器，该类是基于事件驱动的，它会响应相关的事件然后去调用其关联的回调函数，例如当一个新的连接被建立时，ChannelHandler的channelActive()方法将会被调用。</p><p>关于入站消息和出站消息的数据流向定义，如果以客户端为主视角来说的话，那么从客户端流向服务器的数据被称为出站，反之为入站。</p><p>入站事件是可能被入站数据或者相关的状态更改而触发的事件，包括：连接已被激活、连接失活、读取入站数据、用户事件、发生异常等。</p><p>出站事件是未来将会触发的某个动作的结果的事件，这些动作包括：打开或关闭远程节点的连接、将数据写（或冲刷）到套接字。</p><p>ChannelHandler的主要用途包括：</p><ul><li><p>对入站与出站数据的业务逻辑处理</p></li><li><p>记录日志</p></li><li><p>将数据从一种格式转换为另一种格式，实现编解码器。以一次HTTP协议（或者其他应用层协议）的流程为例，数据在网络传输时的单位为字节，当客户端发送请求到服务器时，服务器需要通过解码器（处理入站消息）将字节解码为协议的消息内容，服务器在发送响应的时候（处理出站消息），还需要通过编码器将消息内容编码为字节。</p></li><li><p>捕获异常</p></li><li><p>提供Channel生命周期内的通知，如Channel活动时与非活动时</p></li></ul><p>Netty中到处都充满了异步与事件驱动，而回调函数正是用于响应事件之后的操作。由于异步会直接返回一个结果，所以Netty提供了ChannelFuture（实现了java.util.concurrent.Future）来作为异步调用返回的占位符，真正的结果会在未来的某个时刻完成，到时候就可以通过ChannelFuture对其进行访问，每个Netty的出站I/O操作都将会返回一个ChannelFuture。</p><p>Netty还提供了ChannelFutureListener接口来监听ChannelFuture是否成功，并采取对应的操作。</p><pre><code>Channel channel = ...ChannelFuture future = channel.connect(new InetSocketAddress(&quot;192.168.0.1&quot;,6666));// 注册一个监听器future.addListener(new ChannelFutureListener() {@Overridepublic void operationComplete(ChannelFuture future) {if (future.isSuccess()) {// do something....} else {// 输出错误信息Throwable cause = future.cause();cause.printStackTrace();// do something....}}});</code></pre><p>ChannelFutureListener接口中还提供了几个简单的默认实现，方便我们使用。</p><pre><code>package io.netty.channel;import io.netty.channel.ChannelFuture;import io.netty.util.concurrent.GenericFutureListener;public interface ChannelFutureListener extends GenericFutureListener&lt;ChannelFuture&gt; {// 在Future完成时关闭ChannelFutureListener CLOSE = new ChannelFutureListener() {public void operationComplete(ChannelFuture future) {future.channel().close();}};// 如果失败则关闭ChannelFutureListener CLOSE_ON_FAILURE = new ChannelFutureListener() {public void operationComplete(ChannelFuture future) {if(!future.isSuccess()) {future.channel().close();}}};// 将异常信息传递给下一个ChannelHandlerChannelFutureListener FIRE_EXCEPTION_ON_FAILURE = new ChannelFutureListener() {public void operationComplete(ChannelFuture future) {if(!future.isSuccess()) {future.channel().pipeline().fireExceptionCaught(future.cause());}}};}</code></pre><p>ChannelHandler接口定义了对它生命周期进行监听的回调函数，在ChannelHandler被添加到ChannelPipeline或者被移除时都会调用这些函数。</p><pre><code>package io.netty.channel;public interface ChannelHandler {void handlerAdded(ChannelHandlerContext var1) throws Exception;void handlerRemoved(ChannelHandlerContext var1) throws Exception;/** @deprecated */@Deprecatedvoid exceptionCaught(ChannelHandlerContext var1, Throwable var2) throws Exception;// 该注解表明这个ChannelHandler可被其他线程复用@Inherited@Documented@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)public @interface Sharable {}}入站消息与出站消息由其对应的接口ChannelInboundHandler与ChannelOutboundHandler负责，这两个接口定义了监听Channel的生命周期的状态改变事件的回调函数。</code></pre><p>入站消息与出站消息由其对应的接口ChannelInboundHandler与ChannelOutboundHandler负责，这两个接口定义了监听Channel的生命周期的状态改变事件的回调函数。</p><pre><code>package io.netty.channel;import io.netty.channel.ChannelHandler;import io.netty.channel.ChannelHandlerContext;public interface ChannelInboundHandler extends ChannelHandler {// 当channel被注册到EventLoop时被调用void channelRegistered(ChannelHandlerContext var1) throws Exception;// 当channel已经被创建，但还未注册到EventLoop（或者从EventLoop中注销）被调用void channelUnregistered(ChannelHandlerContext var1) throws Exception;// 当channel处于活动状态（连接到远程节点）被调用void channelActive(ChannelHandlerContext var1) throws Exception;// 当channel处于非活动状态（没有连接到远程节点）被调用void channelInactive(ChannelHandlerContext var1) throws Exception;// 当从channel读取数据时被调用void channelRead(ChannelHandlerContext var1, Object var2) throws Exception;// 当channel的上一个读操作完成时被调用void channelReadComplete(ChannelHandlerContext var1) throws Exception;// 当ChannelInboundHandler.fireUserEventTriggered()方法被调用时被调用void userEventTriggered(ChannelHandlerContext var1, Object var2) throws Exception;// 当channel的可写状态发生改变时被调用void channelWritabilityChanged(ChannelHandlerContext var1) throws Exception;// 当处理过程中发生异常时被调用void exceptionCaught(ChannelHandlerContext var1, Throwable var2) throws Exception;}package io.netty.channel;import io.netty.channel.ChannelHandler;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelPromise;import java.net.SocketAddress;public interface ChannelOutboundHandler extends ChannelHandler {// 当请求将Channel绑定到一个地址时被调用// ChannelPromise是ChannelFuture的一个子接口，定义了如setSuccess(),setFailure()等方法void bind(ChannelHandlerContext var1, SocketAddress var2, ChannelPromise var3) throws Exception;// 当请求将Channel连接到远程节点时被调用void connect(ChannelHandlerContext var1, SocketAddress var2, SocketAddress var3, ChannelPromise var4) throws Exception;// 当请求将Channel从远程节点断开时被调用void disconnect(ChannelHandlerContext var1, ChannelPromise var2) throws Exception;// 当请求关闭Channel时被调用void close(ChannelHandlerContext var1, ChannelPromise var2) throws Exception;// 当请求将Channel从它的EventLoop中注销时被调用void deregister(ChannelHandlerContext var1, ChannelPromise var2) throws Exception;// 当请求从Channel读取数据时被调用void read(ChannelHandlerContext var1) throws Exception;// 当请求通过Channel将数据写到远程节点时被调用void write(ChannelHandlerContext var1, Object var2, ChannelPromise var3) throws Exception;// 当请求通过Channel将缓冲中的数据冲刷到远程节点时被调用void flush(ChannelHandlerContext var1) throws Exception;}</code></pre><p>通过实现ChannelInboundHandler或者ChannelOutboundHandler就可以完成用户自定义的应用逻辑处理程序，不过Netty已经帮你实现了一些基本操作，用户只需要继承并扩展ChannelInboundHandlerAdapter或ChannelOutboundHandlerAdapter来作为自定义实现的起始点。</p><p>通过实现ChannelInboundHandler或者ChannelOutboundHandler就可以完成用户自定义的应用逻辑处理程序，不过Netty已经帮你实现了一些基本操作，用户只需要继承并扩展ChannelInboundHandlerAdapter或ChannelOutboundHandlerAdapter来作为自定义实现的起始点。</p><p>ChannelInboundHandlerAdapter与ChannelOutboundHandlerAdapter都继承于ChannelHandlerAdapter，该抽象类简单实现了ChannelHandler接口。</p><pre><code>public abstract class ChannelHandlerAdapter implements ChannelHandler {boolean added;public ChannelHandlerAdapter() {}// 该方法不允许将此ChannelHandler共享复用protected void ensureNotSharable() {if(this.isSharable()) {throw new IllegalStateException(&quot;ChannelHandler &quot; + this.getClass().getName() + &quot; is not allowed to be shared&quot;);}}// 使用反射判断实现类有没有@Sharable注解，以确认该类是否为可共享复用的public boolean isSharable() {Class clazz = this.getClass();Map cache = InternalThreadLocalMap.get().handlerSharableCache();Boolean sharable = (Boolean)cache.get(clazz);if(sharable == null) {sharable = Boolean.valueOf(clazz.isAnnotationPresent(Sharable.class));cache.put(clazz, sharable);}return sharable.booleanValue();}public void handlerAdded(ChannelHandlerContext ctx) throws Exception {}public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {}public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {ctx.fireExceptionCaught(cause);}}</code></pre><p>ChannelInboundHandlerAdapter与ChannelOutboundHandlerAdapter默认只是简单地将请求传递给ChannelPipeline中的下一个ChannelHandler，源码如下：</p><p>ChannelInboundHandlerAdapter与ChannelOutboundHandlerAdapter默认只是简单地将请求传递给ChannelPipeline中的下一个ChannelHandler，源码如下：</p><pre><code>public class ChannelInboundHandlerAdapter extends ChannelHandlerAdapter implements ChannelInboundHandler {public ChannelInboundHandlerAdapter() {}public void channelRegistered(ChannelHandlerContext ctx) throws Exception {ctx.fireChannelRegistered();}public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {ctx.fireChannelUnregistered();}public void channelActive(ChannelHandlerContext ctx) throws Exception {ctx.fireChannelActive();}public void channelInactive(ChannelHandlerContext ctx) throws Exception {ctx.fireChannelInactive();}public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {ctx.fireChannelRead(msg);}public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {ctx.fireChannelReadComplete();}public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {ctx.fireUserEventTriggered(evt);}public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {ctx.fireChannelWritabilityChanged();}public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {ctx.fireExceptionCaught(cause);}}public class ChannelOutboundHandlerAdapter extends ChannelHandlerAdapter implements ChannelOutboundHandler {public ChannelOutboundHandlerAdapter() {}public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception {ctx.bind(localAddress, promise);}public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) throws Exception {ctx.connect(remoteAddress, localAddress, promise);}public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {ctx.disconnect(promise);}public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {ctx.close(promise);}public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {ctx.deregister(promise);}public void read(ChannelHandlerContext ctx) throws Exception {ctx.read();}public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {ctx.write(msg, promise);}public void flush(ChannelHandlerContext ctx) throws Exception {ctx.flush();}}</code></pre><p>对于处理入站消息，另外一种选择是继承SimpleChannelInboundHandler，它是Netty的一个继承于ChannelInboundHandlerAdapter的抽象类，并在其之上实现了自动释放资源的功能。</p><p>我们在了解ByteBuf时就已经知道了Netty使用了一套自己实现的引用计数算法来主动释放资源，假设你的ChannelHandler继承于ChannelInboundHandlerAdapter或ChannelOutboundHandlerAdapter，那么你就有责任去管理你所分配的ByteBuf，一般来说，一个消息对象（ByteBuf）已经被消费（或丢弃）了，并且不会传递给ChannelHandler链中的下一个处理器（如果该消息到达了实际的传输层，那么当它被写入或Channel关闭时，都会被自动释放），那么你就需要去手动释放它。通过一个简单的工具类ReferenceCountUtil的release方法，就可以做到这一点。</p><pre><code>// 这个泛型为消息对象的类型public abstract class SimpleChannelInboundHandler&lt;I&gt; extends ChannelInboundHandlerAdapter {private final TypeParameterMatcher matcher;private final boolean autoRelease;protected SimpleChannelInboundHandler() {this(true);}protected SimpleChannelInboundHandler(boolean autoRelease) {this.matcher = TypeParameterMatcher.find(this, SimpleChannelInboundHandler.class, &quot;I&quot;);this.autoRelease = autoRelease;}protected SimpleChannelInboundHandler(Class&lt;? extends I&gt; inboundMessageType) {this(inboundMessageType, true);}protected SimpleChannelInboundHandler(Class&lt;? extends I&gt; inboundMessageType, boolean autoRelease) {this.matcher = TypeParameterMatcher.get(inboundMessageType);this.autoRelease = autoRelease;}public boolean acceptInboundMessage(Object msg) throws Exception {return this.matcher.match(msg);}// SimpleChannelInboundHandler只是替你做了ReferenceCountUtil.release()public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {boolean release = true;try {if(this.acceptInboundMessage(msg)) {this.channelRead0(ctx, msg);} else {release = false;ctx.fireChannelRead(msg);}} finally {if(this.autoRelease &amp;&amp; release) {ReferenceCountUtil.release(msg);}}}// 这个方法才是我们需要实现的方法protected abstract void channelRead0(ChannelHandlerContext var1, I var2) throws Exception;}// ReferenceCountUtil中的源码，release方法对消息对象的类型进行判断然后调用它的release()方法public static boolean release(Object msg) {return msg instanceof ReferenceCounted?((ReferenceCounted)msg).release():false;}</code></pre><h3 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a><a href="https://sylvanassun.github.io/2017/11/30/2017-11-30-netty_introduction/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#ChannelPipeline" title="ChannelPipeline" target="_blank" rel="noopener"></a>ChannelPipeline</h3><hr><p>为了模块化与解耦合，不可能由一个ChannelHandler来完成所有应用逻辑，所以Netty采用了拦截器链的设计。ChannelPipeline就是用来管理ChannelHandler实例链的容器，它的职责就是保证实例链的流动。</p><p>每一个新创建的Channel都将会被分配一个新的ChannelPipeline，这种关联关系是永久性的，一个Channel一生只能对应一个ChannelPipeline。</p><p><a href="http://wx3.sinaimg.cn/large/63503acbly1fm1er9l4jfj213h0fcq3d.jpg" target="_blank" rel="noopener"><img src="http://wx3.sinaimg.cn/large/63503acbly1fm1er9l4jfj213h0fcq3d.jpg" alt=""></a></p><p>一个入站事件被触发时，它会先从ChannelPipeline的最左端（头部）开始一直传播到ChannelPipeline的最右端（尾部），而出站事件正好与入站事件顺序相反（从最右端一直传播到最左端）。这个顺序是定死的，Netty总是将ChannelPipeline的入站口作为头部，而将出站口作为尾部。在事件传播的过程中，ChannelPipeline会判断下一个ChannelHandler的类型是否和事件的运动方向相匹配，如果不匹配，就跳过该ChannelHandler并继续检查下一个（保证入站事件只会被ChannelInboundHandler处理），一个ChannelHandler也可以同时实现ChannelInboundHandler与ChannelOutboundHandler，它在入站事件与出站事件中都会被调用。</p><p>在阅读ChannelHandler的源码时，发现很多方法需要一个ChannelHandlerContext类型的参数，该接口是ChannelPipeline与ChannelHandler之间相关联的关键。ChannelHandlerContext可以通知ChannelPipeline中的当前ChannelHandler的下一个ChannelHandler，还可以动态地改变当前ChannelHandler在ChannelPipeline中的位置（通过调用ChannelPipeline中的各种方法来修改）。</p><p>ChannelHandlerContext负责了在同一个ChannelPipeline中的ChannelHandler与其他ChannelHandler之间的交互，每个ChannelHandlerContext都对应了一个ChannelHandler。在DefaultChannelPipeline的源码中，已经表现的很明显了。</p><pre><code>public class DefaultChannelPipeline implements ChannelPipeline {.........// 头部节点和尾部节点的引用变量// ChannelHandlerContext在ChannelPipeline中是以链表的形式组织的final AbstractChannelHandlerContext head;final AbstractChannelHandlerContext tail;.........// 添加一个ChannelHandler到链表尾部public final ChannelPipeline addLast(String name, ChannelHandler handler) {return this.addLast((EventExecutorGroup)null, name, handler);}public final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) {final AbstractChannelHandlerContext newCtx;synchronized(this) {// 检查ChannelHandler是否为一个共享对象(@Sharable)// 如果该ChannelHandler没有@Sharable注解，并且是已被添加过的那么就抛出异常checkMultiplicity(handler);// 返回一个DefaultChannelHandlerContext，注意该对象持有了传入的ChannelHandlernewCtx = this.newContext(group, this.filterName(name, handler), handler);this.addLast0(newCtx);// 如果当前ChannelPipeline没有被注册，那么就先加到未决链表中if(!this.registered) {newCtx.setAddPending();this.callHandlerCallbackLater(newCtx, true);return this;}// 否则就调用ChannelHandler中的handlerAdded()EventExecutor executor = newCtx.executor();if(!executor.inEventLoop()) {newCtx.setAddPending();executor.execute(new Runnable() {public void run() {DefaultChannelPipeline.this.callHandlerAdded0(newCtx);}});return this;}}this.callHandlerAdded0(newCtx);return this;}// 将新的ChannelHandlerContext插入到尾部与尾部之前的节点之间private void addLast0(AbstractChannelHandlerContext newCtx) {AbstractChannelHandlerContext prev = this.tail.prev;newCtx.prev = prev;newCtx.next = this.tail;prev.next = newCtx;this.tail.prev = newCtx;}.....}</code></pre><p>ChannelHandlerContext还定义了许多与Channel和ChannelPipeline重合的方法（像read()、write()、connect()这些用于出站的方法或者如fireChannelXXXX()这样用于入站的方法），不同之处在于调用Channel或者ChannelPipeline上的这些方法，它们将会从头沿着整个ChannelHandler实例链进行传播，而调用位于ChannelHandlerContext上的相同方法，则会从当前所关联的ChannelHandler开始，且只会传播给实例链中的下一个ChannelHandler。而且，事件之间的移动（从一个ChannelHandler到下一个ChannelHandler）也是通过ChannelHandlerContext中的方法调用完成的。</p><pre><code>public class DefaultChannelPipeline implements ChannelPipeline {public final ChannelPipeline fireChannelRead(Object msg) {// 注意这里将头节点传入了进去AbstractChannelHandlerContext.invokeChannelRead(this.head, msg);return this;}}abstract class AbstractChannelHandlerContext extends DefaultAttributeMap implements ChannelHandlerContext, ResourceLeakHint {static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) {final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, &quot;msg&quot;), next);EventExecutor executor = next.executor();if(executor.inEventLoop()) {next.invokeChannelRead(m);} else {executor.execute(new Runnable() {public void run() {next.invokeChannelRead(m);}});}}private void invokeChannelRead(Object msg) {if(this.invokeHandler()) {try {((ChannelInboundHandler)this.handler()).channelRead(this, msg);} catch (Throwable var3) {this.notifyHandlerException(var3);}} else {// 寻找下一个ChannelHandlerthis.fireChannelRead(msg);}}public ChannelHandlerContext fireChannelRead(Object msg) {invokeChannelRead(this.findContextInbound(), msg);return this;}private AbstractChannelHandlerContext findContextInbound() {AbstractChannelHandlerContext ctx = this;do {ctx = ctx.next;} while(!ctx.inbound); // 直到找到一个ChannelInboundHandlerreturn ctx;}}</code></pre><h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a><a href="https://sylvanassun.github.io/2017/11/30/2017-11-30-netty_introduction/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#EventLoop" title="EventLoop" target="_blank" rel="noopener"></a>EventLoop</h3><hr><p>为了最大限度地提供高性能和可维护性，Netty设计了一套强大又易用的线程模型。在一个网络框架中，最重要的能力是能够快速高效地处理在连接的生命周期内发生的各种事件，与之相匹配的程序构造被称为事件循环，Netty定义了接口EventLoop来负责这项工作。</p><p>如果是经常用Java进行多线程开发的童鞋想必经常会使用到线程池，也就是Executor这套API。Netty就是从Executor（java.util.concurrent）之上扩展了自己的EventExecutorGroup（io.netty.util.concurrent），同时为了与Channel的事件进行交互，还扩展了EventLoopGroup接口（io.netty.channel）。在io.netty.util.concurrent包下的EventExecutorXXX负责实现线程并发相关的工作，而在io.netty.channel包下的EventLoopXXX负责实现网络编程相关的工作（处理Channel中的事件）。</p><p><a href="http://wx3.sinaimg.cn/large/63503acbly1fm296hz0p9j20ff0kc3z2.jpg" target="_blank" rel="noopener"><img src="http://wx3.sinaimg.cn/large/63503acbly1fm296hz0p9j20ff0kc3z2.jpg" alt=""></a></p><p>在Netty的线程模型中，一个EventLoop将由一个永远不会改变的Thread驱动，而一个Channel一生只会使用一个EventLoop（但是一个EventLoop可能会被指派用于服务多个Channel），在Channel中的所有I/O操作和事件都由EventLoop中的线程处理，也就是说一个Channel的一生之中都只会使用到一个线程。不过在Netty3，只有入站事件会被EventLoop处理，所有出站事件都会由调用线程处理，这种设计导致了ChannelHandler的线程安全问题。Netty4简化了线程模型，通过在同一个线程处理所有事件，既解决了这个问题，还提供了一个更加简单的架构。</p><pre><code>package io.netty.channel;public abstract class SingleThreadEventLoop extends SingleThreadEventExecutor implements EventLoop {protected static final int DEFAULT_MAX_PENDING_TASKS = Math.max(16, SystemPropertyUtil.getInt(&quot;io.netty.eventLoop.maxPendingTasks&quot;, 2147483647));private final Queue&lt;Runnable&gt; tailTasks;protected SingleThreadEventLoop(EventLoopGroup parent, ThreadFactory threadFactory, boolean addTaskWakesUp) {this(parent, threadFactory, addTaskWakesUp, DEFAULT_MAX_PENDING_TASKS, RejectedExecutionHandlers.reject());}protected SingleThreadEventLoop(EventLoopGroup parent, Executor executor, boolean addTaskWakesUp) {this(parent, executor, addTaskWakesUp, DEFAULT_MAX_PENDING_TASKS, RejectedExecutionHandlers.reject());}protected SingleThreadEventLoop(EventLoopGroup parent, ThreadFactory threadFactory, boolean addTaskWakesUp, int maxPendingTasks, RejectedExecutionHandler rejectedExecutionHandler) {super(parent, threadFactory, addTaskWakesUp, maxPendingTasks, rejectedExecutionHandler);this.tailTasks = this.newTaskQueue(maxPendingTasks);}protected SingleThreadEventLoop(EventLoopGroup parent, Executor executor, boolean addTaskWakesUp, int maxPendingTasks, RejectedExecutionHandler rejectedExecutionHandler) {super(parent, executor, addTaskWakesUp, maxPendingTasks, rejectedExecutionHandler);this.tailTasks = this.newTaskQueue(maxPendingTasks);}// 返回它所在的EventLoopGrouppublic EventLoopGroup parent() {return (EventLoopGroup)super.parent();}public EventLoop next() {return (EventLoop)super.next();}// 注册Channel,这里ChannelPromise和Channel关联到了一起public ChannelFuture register(Channel channel) {return this.register((ChannelPromise)(new DefaultChannelPromise(channel, this)));}public ChannelFuture register(ChannelPromise promise) {ObjectUtil.checkNotNull(promise, &quot;promise&quot;);promise.channel().unsafe().register(this, promise);return promise;}// 剩下这些函数都是用于调度任务public final void executeAfterEventLoopIteration(Runnable task) {ObjectUtil.checkNotNull(task, &quot;task&quot;);if(this.isShutdown()) {reject();}if(!this.tailTasks.offer(task)) {this.reject(task);}if(this.wakesUpForTask(task)) {this.wakeup(this.inEventLoop());}}final boolean removeAfterEventLoopIterationTask(Runnable task) {return this.tailTasks.remove(ObjectUtil.checkNotNull(task, &quot;task&quot;));}protected boolean wakesUpForTask(Runnable task) {return !(task instanceof SingleThreadEventLoop.NonWakeupRunnable);}protected void afterRunningAllTasks() {this.runAllTasksFrom(this.tailTasks);}protected boolean hasTasks() {return super.hasTasks() || !this.tailTasks.isEmpty();}public int pendingTasks() {return super.pendingTasks() + this.tailTasks.size();}interface NonWakeupRunnable extends Runnable {}}</code></pre><p>为了确保一个Channel的整个生命周期中的I/O事件会被一个EventLoop负责，Netty通过inEventLoop()方法来判断当前执行的线程的身份，确定它是否是分配给当前Channel以及它的EventLoop的那一个线程。</p><p>如果当前（调用）线程正是EventLoop中的线程，那么所提交的任务将会被直接执行，否则，EventLoop将调度该任务以便稍后执行，并将它放入内部的任务队列（每个EventLoop都有它自己的任务队列，从SingleThreadEventLoop的源码就能发现很多用于调度内部任务队列的方法），在下次处理它的事件时，将会执行队列中的那些任务。这种设计可以让任何线程与Channel直接交互，而无需在ChannelHandler中进行额外的同步。</p><p>从性能上来考虑，千万不要将一个需要长时间来运行的任务放入到任务队列中，它会影响到该队列中的其他任务的执行。解决方案是使用一个专门的EventExecutor来执行它（ChannelPipeline提供了带有EventExecutorGroup参数的addXXX()方法，该方法可以将传入的ChannelHandler绑定到你传入的EventExecutor之中），这样它就会在另一条线程中执行，与其他任务隔离。</p><pre><code>public abstract class SingleThreadEventExecutor extends AbstractScheduledEventExecutor implements OrderedEventExecutor {.....public void execute(Runnable task) {if(task == null) {throw new NullPointerException(&quot;task&quot;);} else {boolean inEventLoop = this.inEventLoop();if(inEventLoop) {this.addTask(task);} else {this.startThread();this.addTask(task);if(this.isShutdown() &amp;&amp; this.removeTask(task)) {reject();}}if(!this.addTaskWakesUp &amp;&amp; this.wakesUpForTask(task)) {this.wakeup(inEventLoop);}}}public boolean inEventLoop(Thread thread) {return thread == this.thread;}.....}</code></pre><p>EventLoopGroup负责管理和分配EventLoop（创建EventLoop和为每个新创建的Channel分配EventLoop），根据不同的传输类型，EventLoop的创建和分配方式也不同。例如，使用NIO传输类型，EventLoopGroup就会只使用较少的EventLoop（一个EventLoop服务于多个Channel），这是因为NIO基于I/O多路复用，一个线程可以处理多个连接，而如果使用的是OIO，那么新创建一个Channel（连接）就需要分配一个EventLoop（线程）。</p><h3 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a><a href="https://sylvanassun.github.io/2017/11/30/2017-11-30-netty_introduction/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#Bootstrap" title="Bootstrap" target="_blank" rel="noopener"></a>Bootstrap</h3><hr><p>在深入了解地Netty的核心组件之后，发现它们的设计都很模块化，如果想要实现你自己的应用程序，就需要将这些组件组装到一起。Netty通过Bootstrap类，以对一个Netty应用程序进行配置（组装各个组件），并最终使它运行起来。对于客户端程序和服务器程序所使用到的Bootstrap类是不同的，后者需要使用ServerBootstrap，这样设计是因为，在如TCP这样有连接的协议中，服务器程序往往需要一个以上的Channel，通过父Channel来接受来自客户端的连接，然后创建子Channel用于它们之间的通信，而像UDP这样无连接的协议，它不需要每个连接都创建子Channel，只需要一个Channel即可。</p><p>一个比较明显的差异就是Bootstrap与ServerBootstrap的group()方法，后者提供了一个接收2个EventLoopGroup的版本。</p><pre><code>// 该方法在Bootstrap的父类AbstractBootstrap中，泛型B为它当前子类的类型（为了链式调用）public B group(EventLoopGroup group) {if(group == null) {throw new NullPointerException(&quot;group&quot;);} else if(this.group != null) {throw new IllegalStateException(&quot;group set already&quot;);} else {this.group = group;return this;}}// ServerBootstrap中的实现，它也支持只用一个EventLoopGrouppublic ServerBootstrap group(EventLoopGroup group) {return this.group(group, group);}public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) {super.group(parentGroup);if(childGroup == null) {throw new NullPointerException(&quot;childGroup&quot;);} else if(this.childGroup != null) {throw new IllegalStateException(&quot;childGroup set already&quot;);} else {this.childGroup = childGroup;return this;}}</code></pre><p>Bootstrap其实没有什么可以好说的，它就只是一个装配工，将各个组件拼装组合到一起，然后进行一些配置，有关它的详细API请参考<a href="http://netty.io/4.1/api/index.html" target="_blank" rel="noopener">Netty JavaDoc</a>。下面我们将通过一个经典的Echo客户端与服务器的例子，来梳理一遍创建Netty应用的流程。</p><p>首先实现的是服务器，我们先实现一个EchoServerInboundHandler，处理入站消息。</p><pre><code>public class EchoServerInboundHandler extends ChannelInboundHandlerAdapter {@Overridepublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {ByteBuf in = (ByteBuf) msg;System.out.printf(&quot;Server received: %s \n&quot;, in.toString(CharsetUtil.UTF_8));// 由于读事件不是一次性就能把完整消息发送过来的，这里并没有调用writeAndFlushctx.write(in); // 直接把消息写回给客户端(会被出站消息处理器处理,不过我们的应用没有实现任何出站消息处理器)}@Overridepublic void channelReadComplete(ChannelHandlerContext ctx) throws Exception {// 等读事件已经完成时,冲刷之前写数据的缓冲区// 然后添加了一个监听器，它会在Future完成时进行关闭该Channel.ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);}// 处理异常，输出异常信息，然后关闭Channel@Overridepublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {cause.printStackTrace();ctx.close();}}</code></pre><p>服务器的应用逻辑只有这么多，剩下就是用ServerBootstrap进行配置了。</p><pre><code>public class EchoServer {private final int port;public EchoServer(int port) {this.port = port;}public void start() throws Exception {final EchoServerInboundHandler serverHandler = new EchoServerInboundHandler();EventLoopGroup group = new NioEventLoopGroup(); // 传输类型使用NIOtry {ServerBootstrap b = new ServerBootstrap();b.group(group) // 配置EventLoopGroup.channel(NioServerSocketChannel.class) // 配置Channel的类型.localAddress(new InetSocketAddress(port)) // 配置端口号.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {// 实现一个ChannelInitializer，它可以方便地添加多个ChannelHandler@Overrideprotected void initChannel(SocketChannel socketChannel) throws Exception {socketChannel.pipeline().addLast(serverHandler);}});// i绑定地址，同步等待它完成ChannelFuture f = b.bind().sync();// 关闭这个Futuref.channel().closeFuture().sync();} finally {// 关闭应用程序，一般来说Netty应用只需要调用这个方法就够了group.shutdownGracefully().sync();}}public static void main(String[] args) throws Exception {if (args.length != 1) {System.err.printf(&quot;Usage: %s &lt;port&gt; \n&quot;,EchoServer.class.getSimpleName());return;}int port = Integer.parseInt(args[0]);new EchoServer(port).start();}}</code></pre><p>接下来实现客户端，同样需要先实现一个入站消息处理器。</p><pre><code>public class EchoClientInboundHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; {/*** 我们在Channel连接到远程节点直接发送一条消息给服务器*/@Overridepublic void channelActive(ChannelHandlerContext ctx) throws Exception {ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;Hello, Netty!&quot;, CharsetUtil.UTF_8));}@Overrideprotected void channelRead0(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf) throws Exception {// 输出从服务器Echo的消息System.out.printf(&quot;Client received: %s \n&quot;, byteBuf.toString(CharsetUtil.UTF_8));}@Overridepublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {cause.printStackTrace();ctx.close();}}</code></pre><p>然后配置客户端。</p><pre><code>public class EchoClient {private final String host;private final int port;public EchoClient(String host, int port) {this.host = host;this.port = port;}public void start() throws Exception {EventLoopGroup group = new NioEventLoopGroup();try {Bootstrap b = new Bootstrap();b.group(group).channel(NioSocketChannel.class).remoteAddress(new InetSocketAddress(host, port)) // 服务器的地址.handler(new ChannelInitializer&lt;SocketChannel&gt;() {@Overrideprotected void initChannel(SocketChannel socketChannel) throws Exception {socketChannel.pipeline().addLast(new EchoClientInboundHandler());}});ChannelFuture f = b.connect().sync(); // 连接到服务器f.channel().closeFuture().sync();} finally {group.shutdownGracefully().sync();}}public static void main(String[] args) throws Exception {if (args.length != 2) {System.err.printf(&quot;Usage: %s &lt;host&gt; &lt;port&gt; \n&quot;, EchoClient.class.getSimpleName());return;}String host = args[0];int port = Integer.parseInt(args[1]);new EchoClient(host, port).start();}}</code></pre><p>实现一个Netty应用程序就是如此简单，用户大多数都是在编写各种应用逻辑的ChannelHandler（或者使用Netty内置的各种实用ChannelHandler），然后只需要将它们全部添加到ChannelPipeline即可。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><a href="https://sylvanassun.github.io/2017/11/30/2017-11-30-netty_introduction/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE" title="参考文献" target="_blank" rel="noopener"></a>参考文献</h3><hr><ul><li><p><a href="https://netty.io/" target="_blank" rel="noopener">Netty: Home</a></p></li><li><p><a href="https://notes.shichao.io/unp/ch6/#io-multiplexing-model" target="_blank" rel="noopener">Chapter 6. I/O Multiplexing: The select and poll Functions - Shichao’s Notes</a></p></li><li><p><a href="http://man7.org/linux/man-pages/man7/epoll.7.html" target="_blank" rel="noopener">epoll(7) - Linux manual page</a></p></li><li><p><a href="http://tutorials.jenkov.com/java-nio/" target="_blank" rel="noopener">Java NIO</a></p></li></ul><ul><li><p><a href="https://netty.io/" target="_blank" rel="noopener">Netty: Home</a></p></li><li><p><a href="https://notes.shichao.io/unp/ch6/#io-multiplexing-model" target="_blank" rel="noopener">Chapter 6. I/O Multiplexing: The select and poll Functions - Shichao’s Notes</a></p></li><li><p><a href="http://man7.org/linux/man-pages/man7/epoll.7.html" target="_blank" rel="noopener">epoll(7) - Linux manual page</a></p></li><li><p><a href="http://tutorials.jenkov.com/java-nio/" target="_blank" rel="noopener">Java NIO</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自&lt;a href=&quot;https://sylvanassun.github.io/2017/11/30/2017-11-30-netty_introduction/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://sylvanassun.github.io/2017/11/30/2017-11-30-netty_introduction/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;netty是基于NIO实现的异步事件驱动的网络编程框架，学完NIO以后，应该看看netty的实现，netty框架涉及的内容特别多，这里只介绍netty的基本使用和实现原理，更多扩展的内容将在以后推出。&lt;/p&gt;
&lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java网络编程和NIO &lt;a href=&quot;https://blog.csdn.net/column/details/21963.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21963.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java网络编程与NIO" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO/"/>
    
    
      <category term="NIO" scheme="http://h2pl.github.io/tags/NIO/"/>
    
      <category term="netty" scheme="http://h2pl.github.io/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程与NIO详解8：浅析mmap和Direct Buffer</title>
    <link href="http://h2pl.github.io/2018/05/27/Javanet8/"/>
    <id>http://h2pl.github.io/2018/05/27/Javanet8/</id>
    <published>2018-05-27T03:54:07.000Z</published>
    <updated>2018-06-11T12:46:43.094Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java网络编程和NIO <a href="https://blog.csdn.net/column/details/21963.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21963.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><h1 id="Java网络编程与NIO详解8：浅析mmap和Direct-Buffer"><a href="#Java网络编程与NIO详解8：浅析mmap和Direct-Buffer" class="headerlink" title="Java网络编程与NIO详解8：浅析mmap和Direct Buffer"></a>Java网络编程与NIO详解8：浅析mmap和Direct Buffer</h1><p> 之前看到一篇文章说epoll中在维护epoll句柄数据结构时使用到了mmap的技术，但是后来看了其他文章以及epoll源码后发现好像并没有用到这个技术。</p><p>转自知乎：</p><p>epoll_wait的实现~有关从内核态拷贝到用户态代码.可以看到__put_user这个函数就是内核拷贝到用户空间.分析完整个linux 2.6版本的epoll实现没有发现使用了mmap系统调用,根本不存在共享内存在epoll的实现</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (revents) &#123;</span><br><span class="line">            <span class="comment">/* 将当前的事件和用户传入的数据都copy给用户空间,</span></span><br><span class="line"><span class="comment">             * 就是epoll_wait()后应用程序能读到的那一堆数据. */</span></span><br><span class="line">            <span class="function"><span class="title">if</span> (__put_user(revents, &amp;uevent-&gt;</span>events) ||</span><br><span class="line">                __<span class="function"><span class="title">put_user</span>(epi-&gt;</span><span class="function"><span class="title">event</span>.<span class="keyword">data</span>, &amp;uevent-&gt;</span><span class="keyword">data</span>)) &#123;</span><br><span class="line">                <span class="comment">/* 如果copy过程中发生错误, 会中断链表的扫描,</span></span><br><span class="line"><span class="comment">                 * 并把当前发生错误的epitem重新插入到ready list.</span></span><br><span class="line"><span class="comment">                 * 剩下的没处理的epitem也不会丢弃, 在ep_scan_ready_list()</span></span><br><span class="line"><span class="comment">                 * 中它们也会被重新插入到ready list */</span></span><br><span class="line">                <span class="function"><span class="title">list_add</span>(&amp;epi-&gt;</span>rdllink, head);</span><br><span class="line">                return eventcnt ? eventcnt : -EFAULT;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>那么既然提到了，就让我们看看mmap到底是什么吧</p><h1 id="mmap：内存映射文件"><a href="#mmap：内存映射文件" class="headerlink" title="mmap：内存映射文件"></a>mmap：内存映射文件</h1><p>转自：<a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html[](http://projects.spring.io/spring-boot)" target="_blank" rel="noopener">https://www.cnblogs.com/huxiao-tee/p/4660352.html[](http://projects.spring.io/spring-boot)</a></p><h1 id="mmap基础概念"><a href="#mmap基础概念" class="headerlink" title="mmap基础概念"></a>mmap基础概念</h1><p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如下图所示：</p><pre><code>![](https://images0.cnblogs.com/blog2015/571793/201507/200501092691998.png)</code></pre><p>由上图可以看出，进程的虚拟地址空间，由多个虚拟内存区域构成。虚拟内存区域是进程的虚拟地址空间中的一个同质区间，即具有同样特性的连续地址范围。上图中所示的text数据段（代码段）、初始数据段、BSS数据段、堆、栈和内存映射，都是一个独立的虚拟内存区域。而为内存映射服务的地址空间处在堆栈之间的空余部分。</p><p>linux内核使用vm_area_struct结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个vm_area_struct结构来分别表示不同类型的虚拟内存区域。各个vm_area_struct结构使用链表或者树形结构链接，方便进程快速访问，如下图所示：</p><pre><code>![](https://images0.cnblogs.com/blog2015/571793/201507/200501434261629.png)</code></pre><p>vm_area_struct结构中包含区域起始和终止地址以及其他相关信息，同时也包含一个vm_ops指针，其内部可引出所有针对这个区域可以使用的系统调用函数。这样，进程对某一虚拟内存区域的任何操作需要用要的信息，都可以从vm_area_struct中获得。mmap函数就是要创建一个新的vm_area_struct结构，并将其与文件的物理磁盘地址相连。具体步骤请看下一节。</p><p><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p><h1 id="mmap内存映射原理"><a href="#mmap内存映射原理" class="headerlink" title="mmap内存映射原理"></a>mmap内存映射原理</h1><p>mmap内存映射的实现过程，总的来说可以分为三个阶段：</p><p>（一）进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</p><p>1、进程在用户空间调用库函数mmap，原型：void <em>mmap(void </em>start, size_t length, int prot, int flags, int fd, off_t offset);</p><p>2、在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址</p><p>3、为此虚拟区分配一个vm_area_struct结构，接着对这个结构的各个域进行了初始化</p><p>4、将新建的虚拟区结构（vm_area_struct）插入进程的虚拟地址区域链表或树中</p><p>（二）调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系</p><p>5、为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。</p><p>6、通过该文件的文件结构体，链接到file_operations模块，调用内核函数mmap，其原型为：int mmap(struct file <em>filp, struct vm_area_struct </em>vma)，不同于用户空间库函数。</p><p>7、内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。</p><p>8、通过remap_pfn_range函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中。</p><p>（三）进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝</p><p>注：前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时。</p><p>9、进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。</p><p>10、缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。</p><p>11、调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。</p><p>12、之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。</p><p>注：修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用msync()来强制同步, 这样所写的内容就能立即保存到文件里了。</p><p><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p><h1 id="mmap和常规文件操作的区别"><a href="#mmap和常规文件操作的区别" class="headerlink" title="mmap和常规文件操作的区别"></a>mmap和常规文件操作的区别</h1><p>对linux文件系统不了解的朋友，请参阅我之前写的博文《<a href="http://www.cnblogs.com/huxiao-tee/p/4657851.html" target="_blank" rel="noopener">从内核文件系统看文件读写过程</a>》，我们首先简单的回顾一下常规文件系统操作（调用read/fread等类函数）中，函数的调用过程：</p><p>1、进程发起读文件请求。</p><p>2、内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的inode。</p><p>3、inode在address_space上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。</p><p>4、如果不存在，则通过inode定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。</p><p>总结来说，常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要将页缓存中数据页再次拷贝到内存对应的用户空间中。这样，通过了两次数据拷贝过程，才能完成进程对文件内容的获取任务。写操作也是一样，待写入的buffer在内核空间不能直接访问，必须要先拷贝至内核空间对应的主存，再写回磁盘中（延迟写回），也是需要两次数据拷贝。</p><p>而使用mmap操作文件中，创建新的虚拟内存区域和建立文件磁盘地址和虚拟内存区域映射这两步，没有任何文件拷贝操作。而之后访问数据时发现内存中并无数据而发起的缺页异常过程，可以通过已经建立好的映射关系，只使用一次数据拷贝，就从磁盘中将数据传入内存的用户空间中，供进程使用。</p><p>总而言之，常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。说白了，mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程。因此mmap效率更高。</p><p><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p><h1 id="mmap优点总结"><a href="#mmap优点总结" class="headerlink" title="mmap优点总结"></a>mmap优点总结</h1><p>由上文讨论可知，mmap优点共有一下几点：</p><p>1、对文件的读取操作跨过了页缓存，减少了数据的拷贝次数，用内存读写取代I/O读写，提高了文件读取效率。</p><p>2、实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。</p><p>3、提供进程间共享内存及相互通信的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。</p><pre><code>同时，如果进程A和进程B都映射了区域C，当A第一次读取C时通过缺页从磁盘复制文件页到内存中；但当B再读C的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。</code></pre><p>4、可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但是进一步会造成大量的文件I/O操作，极大影响效率。这个问题可以通过mmap映射很好的解决。换句话说，但凡是需要用磁盘空间代替内存的时候，mmap都可以发挥其功效。</p><h1 id="堆外内存之-DirectByteBuffer-详解"><a href="#堆外内存之-DirectByteBuffer-详解" class="headerlink" title="堆外内存之 DirectByteBuffer 详解"></a>堆外内存之 DirectByteBuffer 详解</h1><p>原文出处： <a href="http://www.jianshu.com/p/007052ee3773" target="_blank" rel="noopener">tomas家的小拨浪鼓</a></p><h2 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h2><p>堆外内存是相对于堆内内存的一个概念。堆内内存是由JVM所管控的Java进程内存，我们平时在Java中创建的对象都处于堆内内存中，并且它们遵循JVM的内存管理机制，JVM会采用垃圾回收机制统一管理它们的内存。那么堆外内存就是存在于JVM管控之外的一块内存区域，因此它是不受JVM的管控。</p><p>在讲解DirectByteBuffer之前，需要先简单了解两个知识点。</p><p>java引用类型，因为DirectByteBuffer是通过虚引用(Phantom Reference)来实现堆外内存的释放的。</p><p>PhantomReference 是所有“弱引用”中最弱的引用类型。不同于软引用和弱引用，虚引用无法通过 get() 方法来取得目标对象的强引用从而使用目标对象，观察源码可以发现 get() 被重写为永远返回 null。</p><p>那虚引用到底有什么作用？其实虚引用主要被用来 跟踪对象被垃圾回收的状态，通过查看引用队列中是否包含对象所对应的虚引用来判断它是否 即将被垃圾回收，从而采取行动。它并不被期待用来取得目标对象的引用，而目标对象被回收前，它的引用会被放入一个 ReferenceQueue 对象中，从而达到跟踪对象垃圾回收的作用。</p><p>关于java引用类型的实现和原理可以阅读之前的文章<a href="http://www.importnew.com/26250.html" title="Reference、ReferenceQueue 详解" target="_blank" rel="noopener">Reference 、ReferenceQueue 详解</a> 和 <a href="http://www.importnew.com/26171.html" title="Java 引用类型简述" target="_blank" rel="noopener">Java 引用类型简述</a>。</p><h2 id="关于linux的内核态和用户态"><a href="#关于linux的内核态和用户态" class="headerlink" title="关于linux的内核态和用户态"></a>关于linux的内核态和用户态</h2><p><a href="http://www.importnew.com/?attachment_id=26335" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2017/08/a1c59d418325d59599c29ff2b587c55f.png" alt="" title="4235178-7c5ca2cb236fd2eb"></a></p><ul><li>内核态：控制计算机的硬件资源，并提供上层应用程序运行的环境。比如socket I/0操作或者文件的读写操作等</li><li>用户态：上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源。</li><li>系统调用：为了使上层应用能够访问到这些资源，内核为上层应用提供访问的接口。</li></ul><p><a href="http://www.importnew.com/?attachment_id=26336" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2017/08/e145b5436286bbc2512b97be3860d427.png" alt="" title="4235178-2393d0797135217b"></a></p><p>因此我们可以得知当我们通过JNI调用的native方法实际上就是从用户态切换到了内核态的一种方式。并且通过该系统调用使用操作系统所提供的功能。</p><p>Q：为什么需要用户进程(位于用户态中)要通过系统调用(Java中即使JNI)来调用内核态中的资源，或者说调用操作系统的服务了？<br>A：intel cpu提供Ring0-Ring3四种级别的运行模式，Ring0级别最高，Ring3最低。Linux使用了Ring3级别运行用户态，Ring0作为内核态。Ring3状态不能访问Ring0的地址空间，包括代码和数据。因此用户态是没有权限去操作内核态的资源的，它只能通过系统调用外完成用户态到内核态的切换，然后在完成相关操作后再有内核态切换回用户态。</p><h2 id="DirectByteBuffer-————-直接缓冲"><a href="#DirectByteBuffer-————-直接缓冲" class="headerlink" title="DirectByteBuffer ———— 直接缓冲"></a>DirectByteBuffer ———— 直接缓冲</h2><p>DirectByteBuffer是Java用于实现堆外内存的一个重要类，我们可以通过该类实现堆外内存的创建、使用和销毁。</p><p><a href="http://www.importnew.com/?attachment_id=26337" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2017/08/31d11490d20f02e9ed1f7eea2a318638.png" alt="" title="4235178-fc2ae3eac18813d3"></a></p><p>DirectByteBuffer该类本身还是位于Java内存模型的堆中。堆内内存是JVM可以直接管控、操纵。</p><p>而DirectByteBuffer中的unsafe.allocateMemory(size);是个一个native方法，这个方法分配的是堆外内存，通过C的malloc来进行分配的。分配的内存是系统本地的内存，并不在Java的内存中，也不属于JVM管控范围，所以在DirectByteBuffer一定会存在某种方式来操纵堆外内存。</p><p>在DirectByteBuffer的父类Buffer中有个address属性：</p><pre><code>// Used only by direct buffers// NOTE: hoisted here for speed in JNI GetDirectBufferAddresslong address;</code></pre><p>address只会被直接缓存给使用到。之所以将address属性升级放在Buffer中，是为了在JNI调用GetDirectBufferAddress时提升它调用的速率。<br>address表示分配的堆外内存的地址。</p><p><a href="http://www.importnew.com/?attachment_id=26339" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2017/08/caa35598742279c28d06369760f38323.png" alt="" title="4235178-5e010dc58916b102"></a></p><p>unsafe.allocateMemory(size);分配完堆外内存后就会返回分配的堆外内存基地址，并将这个地址赋值给了address属性。这样我们后面通过JNI对这个堆外内存操作时都是通过这个address来实现的了。</p><p>在前面我们说过，在linux中内核态的权限是最高的，那么在内核态的场景下，操作系统是可以访问任何一个内存区域的，所以操作系统是可以访问到Java堆的这个内存区域的。</p><p>Q：那为什么操作系统不直接访问Java堆内的内存区域了？<br>A：这是因为JNI方法访问的内存区域是一个已经确定了的内存区域地质，那么该内存地址指向的是Java堆内内存的话，那么如果在操作系统正在访问这个内存地址的时候，Java在这个时候进行了GC操作，而GC操作会涉及到数据的移动操作[GC经常会进行先标志在压缩的操作。即，将可回收的空间做标志，然后清空标志位置的内存，然后会进行一个压缩，压缩就会涉及到对象的移动，移动的目的是为了腾出一块更加完整、连续的内存空间，以容纳更大的新对象]，数据的移动会使JNI调用的数据错乱。所以JNI调用的内存是不能进行GC操作的。</p><p>Q：如上面所说，JNI调用的内存是不能进行GC操作的，那该如何解决了？<br>A：①堆内内存与堆外内存之间数据拷贝的方式(并且在将堆内内存拷贝到堆外内存的过程JVM会保证不会进行GC操作)：比如我们要完成一个从文件中读数据到堆内内存的操作，即FileChannelImpl.read(HeapByteBuffer)。这里实际上File I/O会将数据读到堆外内存中，然后堆外内存再讲数据拷贝到堆内内存，这样我们就读到了文件中的内存。</p><p><a href="http://www.importnew.com/?attachment_id=26340" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2017/08/8ef99c738161a15328c8407f0fac3bab.png" alt="" title="4235178-f94db8df14023550"></a></p><pre><code>static int read(FileDescriptor var0, ByteBuffer var1, long var2, NativeDispatcher var4) throws IOException {        if (var1.isReadOnly()) {            throw new IllegalArgumentException(&quot;Read-only buffer&quot;);        } else if (var1 instanceof DirectBuffer) {            return readIntoNativeBuffer(var0, var1, var2, var4);        } else {            // 分配临时的堆外内存            ByteBuffer var5 = Util.getTemporaryDirectBuffer(var1.remaining());            int var7;            try {                // File I/O 操作会将数据读入到堆外内存中                int var6 = readIntoNativeBuffer(var0, var5, var2, var4);                var5.flip();                if (var6 &gt; 0) {                    // 将堆外内存的数据拷贝到堆外内存中                    var1.put(var5);                }                var7 = var6;            } finally {                // 里面会调用DirectBuffer.cleaner().clean()来释放临时的堆外内存                Util.offerFirstTemporaryDirectBuffer(var5);            }            return var7;        }    }</code></pre><p>而写操作则反之，我们会将堆内内存的数据线写到对堆外内存中，然后操作系统会将堆外内存的数据写入到文件中。</p><p>② 直接使用堆外内存，如DirectByteBuffer：这种方式是直接在堆外分配一个内存(即，native memory)来存储数据，程序通过JNI直接将数据读/写到堆外内存中。因为数据直接写入到了堆外内存中，所以这种方式就不会再在JVM管控的堆内再分配内存来存储数据了，也就不存在堆内内存和堆外内存数据拷贝的操作了。这样在进行I/O操作时，只需要将这个堆外内存地址传给JNI的I/O的函数就好了。</p><h2 id="DirectByteBuffer堆外内存的创建和回收的源码解读"><a href="#DirectByteBuffer堆外内存的创建和回收的源码解读" class="headerlink" title="DirectByteBuffer堆外内存的创建和回收的源码解读"></a>DirectByteBuffer堆外内存的创建和回收的源码解读</h2><h3 id="堆外内存分配"><a href="#堆外内存分配" class="headerlink" title="堆外内存分配"></a>堆外内存分配</h3><pre><code>DirectByteBuffer(int cap) {                   // package-private        super(-1, 0, cap, cap);        boolean pa = VM.isDirectMemoryPageAligned();        int ps = Bits.pageSize();        long size = Math.max(1L, (long)cap + (pa ? ps : 0));        // 保留总分配内存(按页分配)的大小和实际内存的大小        Bits.reserveMemory(size, cap);        long base = 0;        try {            // 通过unsafe.allocateMemory分配堆外内存，并返回堆外内存的基地址            base = unsafe.allocateMemory(size);        } catch (OutOfMemoryError x) {            Bits.unreserveMemory(size, cap);            throw x;        }        unsafe.setMemory(base, size, (byte) 0);        if (pa &amp;&amp; (base % ps != 0)) {            // Round up to page boundary            address = base + ps - (base &amp; (ps - 1));        } else {            address = base;        }        // 构建Cleaner对象用于跟踪DirectByteBuffer对象的垃圾回收，以实现当DirectByteBuffer被垃圾回收时，堆外内存也会被释放        cleaner = Cleaner.create(this, new Deallocator(base, size, cap));        att = null;    }</code></pre><h3 id="Bits-reserveMemory-size-cap-方法"><a href="#Bits-reserveMemory-size-cap-方法" class="headerlink" title="Bits.reserveMemory(size, cap) 方法"></a>Bits.reserveMemory(size, cap) 方法</h3><pre><code>static void reserveMemory(long size, int cap) {    if (!memoryLimitSet &amp;&amp; VM.isBooted()) {        maxMemory = VM.maxDirectMemory();        memoryLimitSet = true;    }    // optimist!    if (tryReserveMemory(size, cap)) {        return;    }    final JavaLangRefAccess jlra = SharedSecrets.getJavaLangRefAccess();    // retry while helping enqueue pending Reference objects    // which includes executing pending Cleaner(s) which includes    // Cleaner(s) that free direct buffer memory    while (jlra.tryHandlePendingReference()) {        if (tryReserveMemory(size, cap)) {            return;        }    }    // trigger VM&apos;s Reference processing    System.gc();    // a retry loop with exponential back-off delays    // (this gives VM some time to do it&apos;s job)    boolean interrupted = false;    try {        long sleepTime = 1;        int sleeps = 0;        while (true) {            if (tryReserveMemory(size, cap)) {                return;            }            if (sleeps &gt;= MAX_SLEEPS) {                break;            }            if (!jlra.tryHandlePendingReference()) {                try {                    Thread.sleep(sleepTime);                    sleepTime &lt;&lt;= 1;                    sleeps++;                } catch (InterruptedException e) {                    interrupted = true;                }            }        }        // no luck        throw new OutOfMemoryError(&quot;Direct buffer memory&quot;);    } finally {        if (interrupted) {            // don&apos;t swallow interrupts            Thread.currentThread().interrupt();        }    }}</code></pre><p>该方法用于在系统中保存总分配内存(按页分配)的大小和实际内存的大小。</p><p>其中，如果系统中内存( 即，堆外内存 )不够的话：</p><pre><code>SharedSecrets.setJavaLangRefAccess(new JavaLangRefAccess() {            @Override            public boolean tryHandlePendingReference() {                return tryHandlePending(false);            }        });</code></pre><p>jlra.tryHandlePendingReference()会触发一次非堵塞的Reference#tryHandlePending(false)。该方法会将已经被JVM垃圾回收的DirectBuffer对象的堆外内存释放。<br>因为在Reference的静态代码块中定义了：</p><pre><code>SharedSecrets.setJavaLangRefAccess(new JavaLangRefAccess() {            @Override            public boolean tryHandlePendingReference() {                return tryHandlePending(false);            }        });</code></pre><p>如果在进行一次堆外内存资源回收后，还不够进行本次堆外内存分配的话，则</p><pre><code>// trigger VM&apos;s Reference processingSystem.gc();</code></pre><p>System.gc()会触发一个full gc，当然前提是你没有显示的设置-XX:+DisableExplicitGC来禁用显式GC。并且你需要知道，调用System.gc()并不能够保证full gc马上就能被执行。</p><p>所以在后面打代码中，会进行最多9次尝试，看是否有足够的可用堆外内存来分配堆外内存。并且每次尝试之前，都对延迟等待时间，已给JVM足够的时间去完成full gc操作。如果9次尝试后依旧没有足够的可用堆外内存来分配本次堆外内存，则抛出OutOfMemoryError(“Direct buffer memory”)异常。</p><p><a href="http://www.importnew.com/?attachment_id=26341" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2017/08/8d921b6112fb828be56f64c245b2cc9a.png" alt="" title="4235178-6da0d60191992f59"></a></p><p>注意，这里之所以用使用full gc的很重要的一个原因是：System.gc()会对新生代的老生代都会进行内存回收，这样会比较彻底地回收DirectByteBuffer对象以及他们关联的堆外内存.<br>DirectByteBuffer对象本身其实是很小的，但是它后面可能关联了一个非常大的堆外内存，因此我们通常称之为冰山对象.</p><p>我们做ygc的时候会将新生代里的不可达的DirectByteBuffer对象及其堆外内存回收了，但是无法对old里的DirectByteBuffer对象及其堆外内存进行回收，这也是我们通常碰到的最大的问题。( 并且堆外内存多用于生命期中等或较长的对象 )<br>如果有大量的DirectByteBuffer对象移到了old，但是又一直没有做cms gc或者full gc，而只进行ygc，那么我们的物理内存可能被慢慢耗光，但是我们还不知道发生了什么，因为heap明明剩余的内存还很多(前提是我们禁用了System.gc – JVM参数DisableExplicitGC)。</p><p>总的来说，Bits.reserveMemory(size, cap)方法在可用堆外内存不足以分配给当前要创建的堆外内存大小时，会实现以下的步骤来尝试完成本次堆外内存的创建：</p><p>① 触发一次非堵塞的Reference#tryHandlePending(false)。该方法会将已经被JVM垃圾回收的DirectBuffer对象的堆外内存释放。<br>② 如果进行一次堆外内存资源回收后，还不够进行本次堆外内存分配的话，则进行 System.gc()。System.gc()会触发一个full gc，但你需要知道，调用System.gc()并不能够保证full gc马上就能被执行。所以在后面打代码中，会进行最多9次尝试，看是否有足够的可用堆外内存来分配堆外内存。并且每次尝试之前，都对延迟等待时间，已给JVM足够的时间去完成full gc操作。<br>注意，如果你设置了-XX:+DisableExplicitGC，将会禁用显示GC，这会使System.gc()调用无效。<br>③ 如果9次尝试后依旧没有足够的可用堆外内存来分配本次堆外内存，则抛出OutOfMemoryError(“Direct buffer memory”)异常。</p><p>那么可用堆外内存到底是多少了？，即默认堆外存内存有多大：<br>① 如果我们没有通过-XX:MaxDirectMemorySize来指定最大的堆外内存。则<br>② 如果我们没通过-Dsun.nio.MaxDirectMemorySize指定了这个属性，且它不等于-1。则<br>③ 那么最大堆外内存的值来自于directMemory = Runtime.getRuntime().maxMemory()，这是一个native方法</p><pre><code>JNIEXPORT jlong JNICALLJava_java_lang_Runtime_maxMemory(JNIEnv *env, jobject this){    return JVM_MaxMemory();}JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void))  JVMWrapper(&quot;JVM_MaxMemory&quot;);  size_t n = Universe::heap()-&gt;max_capacity();  return convert_size_t_to_jlong(n);JVM_END</code></pre><p>其中在我们使用CMS GC的情况下也就是我们设置的-Xmx的值里除去一个survivor的大小就是默认的堆外内存的大小了。</p><h3 id="堆外内存回收"><a href="#堆外内存回收" class="headerlink" title="堆外内存回收"></a>堆外内存回收</h3><p>Cleaner是PhantomReference的子类，并通过自身的next和prev字段维护的一个双向链表。PhantomReference的作用在于跟踪垃圾回收过程，并不会对对象的垃圾回收过程造成任何的影响。<br>所以cleaner = Cleaner.create(this, new Deallocator(base, size, cap)); 用于对当前构造的DirectByteBuffer对象的垃圾回收过程进行跟踪。<br>当DirectByteBuffer对象从pending状态 ——&gt; enqueue状态时，会触发Cleaner的clean()，而Cleaner的clean()的方法会实现通过unsafe对堆外内存的释放。</p><p><a href="http://www.importnew.com/?attachment_id=26342" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2017/08/71fb39c74b5e95097d5ce669a911fcb2.png" alt="" title="4235178-792afac32aefd061"></a><a href="http://www.importnew.com/?attachment_id=26343" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2017/08/55becba84de6902babbb03b6bfe17e18.png" alt="" title="4235178-07eaab88f1d02927"></a> </p><p>虽然Cleaner不会调用到Reference.clear()，但Cleaner的clean()方法调用了remove(this)，即将当前Cleaner从Cleaner链表中移除，这样当clean()执行完后，Cleaner就是一个无引用指向的对象了，也就是可被GC回收的对象。</p><p>thunk方法：</p><p><a href="http://www.importnew.com/?attachment_id=26344" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2017/08/f20e391888a9d009aa252b032728e3ad.png" alt="" title="4235178-ebeffa00197df134"></a></p><h3 id="通过配置参数的方式来回收堆外内存"><a href="#通过配置参数的方式来回收堆外内存" class="headerlink" title="通过配置参数的方式来回收堆外内存"></a>通过配置参数的方式来回收堆外内存</h3><p>同时我们可以通过-XX:MaxDirectMemorySize来指定最大的堆外内存大小，当使用达到了阈值的时候将调用System.gc()来做一次full gc，以此来回收掉没有被使用的堆外内存。</p><h2 id="堆外内存那些事"><a href="#堆外内存那些事" class="headerlink" title="堆外内存那些事"></a>堆外内存那些事</h2><h3 id="使用堆外内存的原因"><a href="#使用堆外内存的原因" class="headerlink" title="使用堆外内存的原因"></a>使用堆外内存的原因</h3><ul><li>对垃圾回收停顿的改善</li></ul><p>因为full gc 意味着彻底回收，彻底回收时，垃圾收集器会对所有分配的堆内内存进行完整的扫描，这意味着一个重要的事实——这样一次垃圾收集对Java应用造成的影响，跟堆的大小是成正比的。过大的堆会影响Java应用的性能。如果使用堆外内存的话，堆外内存是直接受操作系统管理( 而不是虚拟机 )。这样做的结果就是能保持一个较小的堆内内存，以减少垃圾收集对应用的影响。</p><ul><li>在某些场景下可以提升程序I/O操纵的性能。少去了将数据从堆内内存拷贝到堆外内存的步骤。</li></ul><h3 id="什么情况下使用堆外内存"><a href="#什么情况下使用堆外内存" class="headerlink" title="什么情况下使用堆外内存"></a>什么情况下使用堆外内存</h3><ul><li>堆外内存适用于生命周期中等或较长的对象。( 如果是生命周期较短的对象，在YGC的时候就被回收了，就不存在大内存且生命周期较长的对象在FGC对应用造成的性能影响 )。</li><li>直接的文件拷贝操作，或者I/O操作。直接使用堆外内存就能少去内存从用户内存拷贝到系统内存的操作，因为I/O操作是系统内核内存和设备间的通信，而不是通过程序直接和外设通信的。</li><li>同时，还可以使用 池+堆外内存 的组合方式，来对生命周期较短，但涉及到I/O操作的对象进行堆外内存的再使用。( Netty中就使用了该方式 )</li></ul><h3 id="堆外内存-VS-内存池"><a href="#堆外内存-VS-内存池" class="headerlink" title="堆外内存 VS 内存池"></a>堆外内存 VS 内存池</h3><ul><li>内存池：主要用于两类对象：①生命周期较短，且结构简单的对象，在内存池中重复利用这些对象能增加CPU缓存的命中率，从而提高性能；②加载含有大量重复对象的大片数据，此时使用内存池能减少垃圾回收的时间。</li><li>堆外内存：它和内存池一样，也能缩短垃圾回收时间，但是它适用的对象和内存池完全相反。内存池往往适用于生命期较短的可变对象，而生命期中等或较长的对象，正是堆外内存要解决的。</li></ul><h3 id="堆外内存的特点"><a href="#堆外内存的特点" class="headerlink" title="堆外内存的特点"></a>堆外内存的特点</h3><ul><li>对于大内存有良好的伸缩性</li><li>对垃圾回收停顿的改善可以明显感觉到</li><li>在进程间可以共享，减少虚拟机间的复制</li></ul><h3 id="堆外内存的一些问题"><a href="#堆外内存的一些问题" class="headerlink" title="堆外内存的一些问题"></a>堆外内存的一些问题</h3><ul><li>堆外内存回收问题，以及堆外内存的泄漏问题。这个在上面的源码解析已经提到了</li><li>堆外内存的数据结构问题：堆外内存最大的问题就是你的数据结构变得不那么直观，如果数据结构比较复杂，就要对它进行串行化（serialization），而串行化本身也会影响性能。另一个问题是由于你可以使用更大的内存，你可能开始担心虚拟内存（即硬盘）的速度对你的影响了。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://lovestblog.cn/blog/2015/05/12/direct-buffer/" target="_blank" rel="noopener">http://lovestblog.cn/blog/2015/05/12/direct-buffer/</a></li><li><a href="http://www.infoq.com/cn/news/2014/12/external-memory-heap-memory" target="_blank" rel="noopener">http://www.infoq.com/cn/news/2014/12/external-memory-heap-memory</a></li><li><a href="http://www.jianshu.com/p/85e931636f27" target="_blank" rel="noopener">http://www.jianshu.com/p/85e931636f27</a></li><li>圣思园《并发与Netty》课程</li></ul><p> 之前看到一篇文章说epoll中在维护epoll句柄数据结构时使用到了mmap的技术，但是后来看了其他文章以及epoll源码后发现好像并没有用到这个技术。</p><p>转自知乎：</p><p>epoll_wait的实现~有关从内核态拷贝到用户态代码.可以看到__put_user这个函数就是内核拷贝到用户空间.分析完整个linux 2.6版本的epoll实现没有发现使用了mmap系统调用,根本不存在共享内存在epoll的实现</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (revents) &#123;</span><br><span class="line"><span class="comment">/* 将当前的事件和用户传入的数据都copy给用户空间,</span></span><br><span class="line"><span class="comment"> * 就是epoll_wait()后应用程序能读到的那一堆数据. */</span></span><br><span class="line"><span class="function"><span class="title">if</span> (__put_user(revents, &amp;uevent-&gt;</span>events) ||</span><br><span class="line">    __<span class="function"><span class="title">put_user</span>(epi-&gt;</span><span class="function"><span class="title">event</span>.<span class="keyword">data</span>, &amp;uevent-&gt;</span><span class="keyword">data</span>)) &#123;</span><br><span class="line"><span class="comment">/* 如果copy过程中发生错误, 会中断链表的扫描,</span></span><br><span class="line"><span class="comment"> * 并把当前发生错误的epitem重新插入到ready list.</span></span><br><span class="line"><span class="comment"> * 剩下的没处理的epitem也不会丢弃, 在ep_scan_ready_list()</span></span><br><span class="line"><span class="comment"> * 中它们也会被重新插入到ready list */</span></span><br><span class="line"><span class="function"><span class="title">list_add</span>(&amp;epi-&gt;</span>rdllink, head);</span><br><span class="line">return eventcnt ? eventcnt : -EFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么既然提到了，就让我们看看mmap到底是什么吧</p><h1 id="mmap：内存映射文件-1"><a href="#mmap：内存映射文件-1" class="headerlink" title="mmap：内存映射文件"></a>mmap：内存映射文件</h1><p>转自：<a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html[](http://projects.spring.io/spring-boot)" target="_blank" rel="noopener">https://www.cnblogs.com/huxiao-tee/p/4660352.html[](http://projects.spring.io/spring-boot)</a></p><ul><li><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html#_label0" target="_blank" rel="noopener">mmap基础概念</a></li><li><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html#_label1" target="_blank" rel="noopener">mmap内存映射原理</a></li><li><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html#_label2" target="_blank" rel="noopener">mmap和常规文件操作的区别</a></li><li><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html#_label3" target="_blank" rel="noopener">mmap优点总结</a></li></ul><p><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p><h1 id="mmap基础概念-1"><a href="#mmap基础概念-1" class="headerlink" title="mmap基础概念"></a>mmap基础概念</h1><p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如下图所示：</p><pre><code>![](https://images0.cnblogs.com/blog2015/571793/201507/200501092691998.png)</code></pre><p>由上图可以看出，进程的虚拟地址空间，由多个虚拟内存区域构成。虚拟内存区域是进程的虚拟地址空间中的一个同质区间，即具有同样特性的连续地址范围。上图中所示的text数据段（代码段）、初始数据段、BSS数据段、堆、栈和内存映射，都是一个独立的虚拟内存区域。而为内存映射服务的地址空间处在堆栈之间的空余部分。</p><p>linux内核使用vm_area_struct结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个vm_area_struct结构来分别表示不同类型的虚拟内存区域。各个vm_area_struct结构使用链表或者树形结构链接，方便进程快速访问，如下图所示：</p><pre><code>![](https://images0.cnblogs.com/blog2015/571793/201507/200501434261629.png)</code></pre><p>vm_area_struct结构中包含区域起始和终止地址以及其他相关信息，同时也包含一个vm_ops指针，其内部可引出所有针对这个区域可以使用的系统调用函数。这样，进程对某一虚拟内存区域的任何操作需要用要的信息，都可以从vm_area_struct中获得。mmap函数就是要创建一个新的vm_area_struct结构，并将其与文件的物理磁盘地址相连。具体步骤请看下一节。</p><p><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p><h1 id="mmap内存映射原理-1"><a href="#mmap内存映射原理-1" class="headerlink" title="mmap内存映射原理"></a>mmap内存映射原理</h1><p>mmap内存映射的实现过程，总的来说可以分为三个阶段：</p><p>（一）进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</p><p>1、进程在用户空间调用库函数mmap，原型：void <em>mmap(void </em>start, size_t length, int prot, int flags, int fd, off_t offset);</p><p>2、在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址</p><p>3、为此虚拟区分配一个vm_area_struct结构，接着对这个结构的各个域进行了初始化</p><p>4、将新建的虚拟区结构（vm_area_struct）插入进程的虚拟地址区域链表或树中</p><p>（二）调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系</p><p>5、为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。</p><p>6、通过该文件的文件结构体，链接到file_operations模块，调用内核函数mmap，其原型为：int mmap(struct file <em>filp, struct vm_area_struct </em>vma)，不同于用户空间库函数。</p><p>7、内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。</p><p>8、通过remap_pfn_range函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中。</p><p>（三）进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝</p><p>注：前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时。</p><p>9、进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。</p><p>10、缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。</p><p>11、调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。</p><p>12、之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。</p><p>注：修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用msync()来强制同步, 这样所写的内容就能立即保存到文件里了。</p><p><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p><h1 id="mmap和常规文件操作的区别-1"><a href="#mmap和常规文件操作的区别-1" class="headerlink" title="mmap和常规文件操作的区别"></a>mmap和常规文件操作的区别</h1><p>对linux文件系统不了解的朋友，请参阅我之前写的博文《<a href="http://www.cnblogs.com/huxiao-tee/p/4657851.html" target="_blank" rel="noopener">从内核文件系统看文件读写过程</a>》，我们首先简单的回顾一下常规文件系统操作（调用read/fread等类函数）中，函数的调用过程：</p><p>1、进程发起读文件请求。</p><p>2、内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的inode。</p><p>3、inode在address_space上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。</p><p>4、如果不存在，则通过inode定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。</p><p>总结来说，常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要将页缓存中数据页再次拷贝到内存对应的用户空间中。这样，通过了两次数据拷贝过程，才能完成进程对文件内容的获取任务。写操作也是一样，待写入的buffer在内核空间不能直接访问，必须要先拷贝至内核空间对应的主存，再写回磁盘中（延迟写回），也是需要两次数据拷贝。</p><p>而使用mmap操作文件中，创建新的虚拟内存区域和建立文件磁盘地址和虚拟内存区域映射这两步，没有任何文件拷贝操作。而之后访问数据时发现内存中并无数据而发起的缺页异常过程，可以通过已经建立好的映射关系，只使用一次数据拷贝，就从磁盘中将数据传入内存的用户空间中，供进程使用。</p><p>总而言之，常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。说白了，mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程。因此mmap效率更高。</p><p><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p><h1 id="mmap优点总结-1"><a href="#mmap优点总结-1" class="headerlink" title="mmap优点总结"></a>mmap优点总结</h1><p>由上文讨论可知，mmap优点共有一下几点：</p><p>1、对文件的读取操作跨过了页缓存，减少了数据的拷贝次数，用内存读写取代I/O读写，提高了文件读取效率。</p><p>2、实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。</p><p>3、提供进程间共享内存及相互通信的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。</p><pre><code>同时，如果进程A和进程B都映射了区域C，当A第一次读取C时通过缺页从磁盘复制文件页到内存中；但当B再读C的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。</code></pre><p>4、可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但是进一步会造成大量的文件I/O操作，极大影响效率。这个问题可以通过mmap映射很好的解决。换句话说，但凡是需要用磁盘空间代替内存的时候，mmap都可以发挥其功效。</p><h1 id="堆外内存之-DirectByteBuffer-详解-1"><a href="#堆外内存之-DirectByteBuffer-详解-1" class="headerlink" title="堆外内存之 DirectByteBuffer 详解"></a>堆外内存之 DirectByteBuffer 详解</h1><p>原文出处： <a href="http://www.jianshu.com/p/007052ee3773" target="_blank" rel="noopener">tomas家的小拨浪鼓</a></p><h2 id="堆外内存-1"><a href="#堆外内存-1" class="headerlink" title="堆外内存"></a>堆外内存</h2><p>堆外内存是相对于堆内内存的一个概念。堆内内存是由JVM所管控的Java进程内存，我们平时在Java中创建的对象都处于堆内内存中，并且它们遵循JVM的内存管理机制，JVM会采用垃圾回收机制统一管理它们的内存。那么堆外内存就是存在于JVM管控之外的一块内存区域，因此它是不受JVM的管控。</p><p>在讲解DirectByteBuffer之前，需要先简单了解两个知识点。</p><p>java引用类型，因为DirectByteBuffer是通过虚引用(Phantom Reference)来实现堆外内存的释放的。</p><p>PhantomReference 是所有“弱引用”中最弱的引用类型。不同于软引用和弱引用，虚引用无法通过 get() 方法来取得目标对象的强引用从而使用目标对象，观察源码可以发现 get() 被重写为永远返回 null。</p><p>那虚引用到底有什么作用？其实虚引用主要被用来 跟踪对象被垃圾回收的状态，通过查看引用队列中是否包含对象所对应的虚引用来判断它是否 即将被垃圾回收，从而采取行动。它并不被期待用来取得目标对象的引用，而目标对象被回收前，它的引用会被放入一个 ReferenceQueue 对象中，从而达到跟踪对象垃圾回收的作用。</p><p>关于java引用类型的实现和原理可以阅读之前的文章<a href="http://www.importnew.com/26250.html" title="Reference、ReferenceQueue 详解" target="_blank" rel="noopener">Reference 、ReferenceQueue 详解</a> 和 <a href="http://www.importnew.com/26171.html" title="Java 引用类型简述" target="_blank" rel="noopener">Java 引用类型简述</a>。</p><h2 id="关于linux的内核态和用户态-1"><a href="#关于linux的内核态和用户态-1" class="headerlink" title="关于linux的内核态和用户态"></a>关于linux的内核态和用户态</h2><p><a href="http://www.importnew.com/?attachment_id=26335" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2017/08/a1c59d418325d59599c29ff2b587c55f.png" alt="" title="4235178-7c5ca2cb236fd2eb"></a></p><ul><li>内核态：控制计算机的硬件资源，并提供上层应用程序运行的环境。比如socket I/0操作或者文件的读写操作等</li><li>用户态：上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源。</li><li>系统调用：为了使上层应用能够访问到这些资源，内核为上层应用提供访问的接口。</li></ul><p><a href="http://www.importnew.com/?attachment_id=26336" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2017/08/e145b5436286bbc2512b97be3860d427.png" alt="" title="4235178-2393d0797135217b"></a></p><p>因此我们可以得知当我们通过JNI调用的native方法实际上就是从用户态切换到了内核态的一种方式。并且通过该系统调用使用操作系统所提供的功能。</p><p>Q：为什么需要用户进程(位于用户态中)要通过系统调用(Java中即使JNI)来调用内核态中的资源，或者说调用操作系统的服务了？<br>A：intel cpu提供Ring0-Ring3四种级别的运行模式，Ring0级别最高，Ring3最低。Linux使用了Ring3级别运行用户态，Ring0作为内核态。Ring3状态不能访问Ring0的地址空间，包括代码和数据。因此用户态是没有权限去操作内核态的资源的，它只能通过系统调用外完成用户态到内核态的切换，然后在完成相关操作后再有内核态切换回用户态。</p><h2 id="DirectByteBuffer-————-直接缓冲-1"><a href="#DirectByteBuffer-————-直接缓冲-1" class="headerlink" title="DirectByteBuffer ———— 直接缓冲"></a>DirectByteBuffer ———— 直接缓冲</h2><p>DirectByteBuffer是Java用于实现堆外内存的一个重要类，我们可以通过该类实现堆外内存的创建、使用和销毁。</p><p><a href="http://www.importnew.com/?attachment_id=26337" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2017/08/31d11490d20f02e9ed1f7eea2a318638.png" alt="" title="4235178-fc2ae3eac18813d3"></a></p><p>DirectByteBuffer该类本身还是位于Java内存模型的堆中。堆内内存是JVM可以直接管控、操纵。</p><p>而DirectByteBuffer中的unsafe.allocateMemory(size);是个一个native方法，这个方法分配的是堆外内存，通过C的malloc来进行分配的。分配的内存是系统本地的内存，并不在Java的内存中，也不属于JVM管控范围，所以在DirectByteBuffer一定会存在某种方式来操纵堆外内存。</p><p>在DirectByteBuffer的父类Buffer中有个address属性：</p><table><thead><tr><th>123</th><th><code>// Used only by direct buffers`</code>// NOTE: hoisted here for speed in JNI GetDirectBufferAddress<code></code>long<code></code>address;`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>address只会被直接缓存给使用到。之所以将address属性升级放在Buffer中，是为了在JNI调用GetDirectBufferAddress时提升它调用的速率。<br>address表示分配的堆外内存的地址。</p><p><a href="http://www.importnew.com/?attachment_id=26339" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2017/08/caa35598742279c28d06369760f38323.png" alt="" title="4235178-5e010dc58916b102"></a></p><p>unsafe.allocateMemory(size);分配完堆外内存后就会返回分配的堆外内存基地址，并将这个地址赋值给了address属性。这样我们后面通过JNI对这个堆外内存操作时都是通过这个address来实现的了。</p><p>在前面我们说过，在linux中内核态的权限是最高的，那么在内核态的场景下，操作系统是可以访问任何一个内存区域的，所以操作系统是可以访问到Java堆的这个内存区域的。</p><p>Q：那为什么操作系统不直接访问Java堆内的内存区域了？<br>A：这是因为JNI方法访问的内存区域是一个已经确定了的内存区域地质，那么该内存地址指向的是Java堆内内存的话，那么如果在操作系统正在访问这个内存地址的时候，Java在这个时候进行了GC操作，而GC操作会涉及到数据的移动操作[GC经常会进行先标志在压缩的操作。即，将可回收的空间做标志，然后清空标志位置的内存，然后会进行一个压缩，压缩就会涉及到对象的移动，移动的目的是为了腾出一块更加完整、连续的内存空间，以容纳更大的新对象]，数据的移动会使JNI调用的数据错乱。所以JNI调用的内存是不能进行GC操作的。</p><p>Q：如上面所说，JNI调用的内存是不能进行GC操作的，那该如何解决了？<br>A：①堆内内存与堆外内存之间数据拷贝的方式(并且在将堆内内存拷贝到堆外内存的过程JVM会保证不会进行GC操作)：比如我们要完成一个从文件中读数据到堆内内存的操作，即FileChannelImpl.read(HeapByteBuffer)。这里实际上File I/O会将数据读到堆外内存中，然后堆外内存再讲数据拷贝到堆内内存，这样我们就读到了文件中的内存。</p><p><a href="http://www.importnew.com/?attachment_id=26340" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2017/08/8ef99c738161a15328c8407f0fac3bab.png" alt="" title="4235178-f94db8df14023550"></a></p><pre><code>static int read(FileDescriptor var0, ByteBuffer var1, long var2, NativeDispatcher var4) throws IOException {        if (var1.isReadOnly()) {            throw new IllegalArgumentException(&quot;Read-only buffer&quot;);        } else if (var1 instanceof DirectBuffer) {            return readIntoNativeBuffer(var0, var1, var2, var4);        } else {            // 分配临时的堆外内存            ByteBuffer var5 = Util.getTemporaryDirectBuffer(var1.remaining());            int var7;            try {                // File I/O 操作会将数据读入到堆外内存中                int var6 = readIntoNativeBuffer(var0, var5, var2, var4);                var5.flip();                if (var6 &gt; 0) {                    // 将堆外内存的数据拷贝到堆外内存中                    var1.put(var5);                }                var7 = var6;            } finally {                // 里面会调用DirectBuffer.cleaner().clean()来释放临时的堆外内存                Util.offerFirstTemporaryDirectBuffer(var5);            }            return var7;        }    }</code></pre><p>而写操作则反之，我们会将堆内内存的数据线写到对堆外内存中，然后操作系统会将堆外内存的数据写入到文件中。</p><p>② 直接使用堆外内存，如DirectByteBuffer：这种方式是直接在堆外分配一个内存(即，native memory)来存储数据，程序通过JNI直接将数据读/写到堆外内存中。因为数据直接写入到了堆外内存中，所以这种方式就不会再在JVM管控的堆内再分配内存来存储数据了，也就不存在堆内内存和堆外内存数据拷贝的操作了。这样在进行I/O操作时，只需要将这个堆外内存地址传给JNI的I/O的函数就好了。</p><h2 id="DirectByteBuffer堆外内存的创建和回收的源码解读-1"><a href="#DirectByteBuffer堆外内存的创建和回收的源码解读-1" class="headerlink" title="DirectByteBuffer堆外内存的创建和回收的源码解读"></a>DirectByteBuffer堆外内存的创建和回收的源码解读</h2><h3 id="堆外内存分配-1"><a href="#堆外内存分配-1" class="headerlink" title="堆外内存分配"></a>堆外内存分配</h3><pre><code>DirectByteBuffer(int cap) {                   // package-private        super(-1, 0, cap, cap);        boolean pa = VM.isDirectMemoryPageAligned();        int ps = Bits.pageSize();        long size = Math.max(1L, (long)cap + (pa ? ps : 0));        // 保留总分配内存(按页分配)的大小和实际内存的大小        Bits.reserveMemory(size, cap);        long base = 0;        try {            // 通过unsafe.allocateMemory分配堆外内存，并返回堆外内存的基地址            base = unsafe.allocateMemory(size);        } catch (OutOfMemoryError x) {            Bits.unreserveMemory(size, cap);            throw x;        }        unsafe.setMemory(base, size, (byte) 0);        if (pa &amp;&amp; (base % ps != 0)) {            // Round up to page boundary            address = base + ps - (base &amp; (ps - 1));        } else {            address = base;        }        // 构建Cleaner对象用于跟踪DirectByteBuffer对象的垃圾回收，以实现当DirectByteBuffer被垃圾回收时，堆外内存也会被释放        cleaner = Cleaner.create(this, new Deallocator(base, size, cap));        att = null;    }</code></pre><h3 id="Bits-reserveMemory-size-cap-方法-1"><a href="#Bits-reserveMemory-size-cap-方法-1" class="headerlink" title="Bits.reserveMemory(size, cap) 方法"></a>Bits.reserveMemory(size, cap) 方法</h3><pre><code>static void reserveMemory(long size, int cap) {    if (!memoryLimitSet &amp;&amp; VM.isBooted()) {        maxMemory = VM.maxDirectMemory();        memoryLimitSet = true;    }    // optimist!    if (tryReserveMemory(size, cap)) {        return;    }    final JavaLangRefAccess jlra = SharedSecrets.getJavaLangRefAccess();    // retry while helping enqueue pending Reference objects    // which includes executing pending Cleaner(s) which includes    // Cleaner(s) that free direct buffer memory    while (jlra.tryHandlePendingReference()) {        if (tryReserveMemory(size, cap)) {            return;        }    }    // trigger VM&apos;s Reference processing    System.gc();    // a retry loop with exponential back-off delays    // (this gives VM some time to do it&apos;s job)    boolean interrupted = false;    try {        long sleepTime = 1;        int sleeps = 0;        while (true) {            if (tryReserveMemory(size, cap)) {                return;            }            if (sleeps &gt;= MAX_SLEEPS) {                break;            }            if (!jlra.tryHandlePendingReference()) {                try {                    Thread.sleep(sleepTime);                    sleepTime &lt;&lt;= 1;                    sleeps++;                } catch (InterruptedException e) {                    interrupted = true;                }            }        }        // no luck        throw new OutOfMemoryError(&quot;Direct buffer memory&quot;);    } finally {        if (interrupted) {            // don&apos;t swallow interrupts            Thread.currentThread().interrupt();        }    }}</code></pre><p>该方法用于在系统中保存总分配内存(按页分配)的大小和实际内存的大小。</p><p>其中，如果系统中内存( 即，堆外内存 )不够的话：</p><pre><code>SharedSecrets.setJavaLangRefAccess(new JavaLangRefAccess() {            @Override            public boolean tryHandlePendingReference() {                return tryHandlePending(false);            }        });</code></pre><p>jlra.tryHandlePendingReference()会触发一次非堵塞的Reference#tryHandlePending(false)。该方法会将已经被JVM垃圾回收的DirectBuffer对象的堆外内存释放。<br>因为在Reference的静态代码块中定义了：</p><pre><code>SharedSecrets.setJavaLangRefAccess(new JavaLangRefAccess() {            @Override            public boolean tryHandlePendingReference() {                return tryHandlePending(false);            }        });</code></pre><p>如果在进行一次堆外内存资源回收后，还不够进行本次堆外内存分配的话，则</p><pre><code>// trigger VM&apos;s Reference processingSystem.gc();</code></pre><p>System.gc()会触发一个full gc，当然前提是你没有显示的设置-XX:+DisableExplicitGC来禁用显式GC。并且你需要知道，调用System.gc()并不能够保证full gc马上就能被执行。</p><p>所以在后面打代码中，会进行最多9次尝试，看是否有足够的可用堆外内存来分配堆外内存。并且每次尝试之前，都对延迟等待时间，已给JVM足够的时间去完成full gc操作。如果9次尝试后依旧没有足够的可用堆外内存来分配本次堆外内存，则抛出OutOfMemoryError(“Direct buffer memory”)异常。</p><p><a href="http://www.importnew.com/?attachment_id=26341" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2017/08/8d921b6112fb828be56f64c245b2cc9a.png" alt="" title="4235178-6da0d60191992f59"></a></p><p>注意，这里之所以用使用full gc的很重要的一个原因是：System.gc()会对新生代的老生代都会进行内存回收，这样会比较彻底地回收DirectByteBuffer对象以及他们关联的堆外内存.<br>DirectByteBuffer对象本身其实是很小的，但是它后面可能关联了一个非常大的堆外内存，因此我们通常称之为冰山对象.</p><p>我们做ygc的时候会将新生代里的不可达的DirectByteBuffer对象及其堆外内存回收了，但是无法对old里的DirectByteBuffer对象及其堆外内存进行回收，这也是我们通常碰到的最大的问题。( 并且堆外内存多用于生命期中等或较长的对象 )<br>如果有大量的DirectByteBuffer对象移到了old，但是又一直没有做cms gc或者full gc，而只进行ygc，那么我们的物理内存可能被慢慢耗光，但是我们还不知道发生了什么，因为heap明明剩余的内存还很多(前提是我们禁用了System.gc – JVM参数DisableExplicitGC)。</p><p>总的来说，Bits.reserveMemory(size, cap)方法在可用堆外内存不足以分配给当前要创建的堆外内存大小时，会实现以下的步骤来尝试完成本次堆外内存的创建：</p><p>① 触发一次非堵塞的Reference#tryHandlePending(false)。该方法会将已经被JVM垃圾回收的DirectBuffer对象的堆外内存释放。<br>② 如果进行一次堆外内存资源回收后，还不够进行本次堆外内存分配的话，则进行 System.gc()。System.gc()会触发一个full gc，但你需要知道，调用System.gc()并不能够保证full gc马上就能被执行。所以在后面打代码中，会进行最多9次尝试，看是否有足够的可用堆外内存来分配堆外内存。并且每次尝试之前，都对延迟等待时间，已给JVM足够的时间去完成full gc操作。<br>注意，如果你设置了-XX:+DisableExplicitGC，将会禁用显示GC，这会使System.gc()调用无效。<br>③ 如果9次尝试后依旧没有足够的可用堆外内存来分配本次堆外内存，则抛出OutOfMemoryError(“Direct buffer memory”)异常。</p><p>那么可用堆外内存到底是多少了？，即默认堆外存内存有多大：<br>① 如果我们没有通过-XX:MaxDirectMemorySize来指定最大的堆外内存。则<br>② 如果我们没通过-Dsun.nio.MaxDirectMemorySize指定了这个属性，且它不等于-1。则<br>③ 那么最大堆外内存的值来自于directMemory = Runtime.getRuntime().maxMemory()，这是一个native方法</p><pre><code>JNIEXPORT jlong JNICALLJava_java_lang_Runtime_maxMemory(JNIEnv *env, jobject this){    return JVM_MaxMemory();}JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void))  JVMWrapper(&quot;JVM_MaxMemory&quot;);  size_t n = Universe::heap()-&gt;max_capacity();  return convert_size_t_to_jlong(n);JVM_END</code></pre><p>其中在我们使用CMS GC的情况下也就是我们设置的-Xmx的值里除去一个survivor的大小就是默认的堆外内存的大小了。</p><h3 id="堆外内存回收-1"><a href="#堆外内存回收-1" class="headerlink" title="堆外内存回收"></a>堆外内存回收</h3><p>Cleaner是PhantomReference的子类，并通过自身的next和prev字段维护的一个双向链表。PhantomReference的作用在于跟踪垃圾回收过程，并不会对对象的垃圾回收过程造成任何的影响。<br>所以cleaner = Cleaner.create(this, new Deallocator(base, size, cap)); 用于对当前构造的DirectByteBuffer对象的垃圾回收过程进行跟踪。<br>当DirectByteBuffer对象从pending状态 ——&gt; enqueue状态时，会触发Cleaner的clean()，而Cleaner的clean()的方法会实现通过unsafe对堆外内存的释放。</p><p><a href="http://www.importnew.com/?attachment_id=26342" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2017/08/71fb39c74b5e95097d5ce669a911fcb2.png" alt="" title="4235178-792afac32aefd061"></a><a href="http://www.importnew.com/?attachment_id=26343" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2017/08/55becba84de6902babbb03b6bfe17e18.png" alt="" title="4235178-07eaab88f1d02927"></a> </p><p>虽然Cleaner不会调用到Reference.clear()，但Cleaner的clean()方法调用了remove(this)，即将当前Cleaner从Cleaner链表中移除，这样当clean()执行完后，Cleaner就是一个无引用指向的对象了，也就是可被GC回收的对象。</p><p>thunk方法：</p><p><a href="http://www.importnew.com/?attachment_id=26344" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2017/08/f20e391888a9d009aa252b032728e3ad.png" alt="" title="4235178-ebeffa00197df134"></a></p><h3 id="通过配置参数的方式来回收堆外内存-1"><a href="#通过配置参数的方式来回收堆外内存-1" class="headerlink" title="通过配置参数的方式来回收堆外内存"></a>通过配置参数的方式来回收堆外内存</h3><p>同时我们可以通过-XX:MaxDirectMemorySize来指定最大的堆外内存大小，当使用达到了阈值的时候将调用System.gc()来做一次full gc，以此来回收掉没有被使用的堆外内存。</p><h2 id="堆外内存那些事-1"><a href="#堆外内存那些事-1" class="headerlink" title="堆外内存那些事"></a>堆外内存那些事</h2><h3 id="使用堆外内存的原因-1"><a href="#使用堆外内存的原因-1" class="headerlink" title="使用堆外内存的原因"></a>使用堆外内存的原因</h3><ul><li>对垃圾回收停顿的改善</li></ul><p>因为full gc 意味着彻底回收，彻底回收时，垃圾收集器会对所有分配的堆内内存进行完整的扫描，这意味着一个重要的事实——这样一次垃圾收集对Java应用造成的影响，跟堆的大小是成正比的。过大的堆会影响Java应用的性能。如果使用堆外内存的话，堆外内存是直接受操作系统管理( 而不是虚拟机 )。这样做的结果就是能保持一个较小的堆内内存，以减少垃圾收集对应用的影响。</p><ul><li>在某些场景下可以提升程序I/O操纵的性能。少去了将数据从堆内内存拷贝到堆外内存的步骤。</li></ul><h3 id="什么情况下使用堆外内存-1"><a href="#什么情况下使用堆外内存-1" class="headerlink" title="什么情况下使用堆外内存"></a>什么情况下使用堆外内存</h3><ul><li>堆外内存适用于生命周期中等或较长的对象。( 如果是生命周期较短的对象，在YGC的时候就被回收了，就不存在大内存且生命周期较长的对象在FGC对应用造成的性能影响 )。</li><li>直接的文件拷贝操作，或者I/O操作。直接使用堆外内存就能少去内存从用户内存拷贝到系统内存的操作，因为I/O操作是系统内核内存和设备间的通信，而不是通过程序直接和外设通信的。</li><li>同时，还可以使用 池+堆外内存 的组合方式，来对生命周期较短，但涉及到I/O操作的对象进行堆外内存的再使用。( Netty中就使用了该方式 )</li></ul><h3 id="堆外内存-VS-内存池-1"><a href="#堆外内存-VS-内存池-1" class="headerlink" title="堆外内存 VS 内存池"></a>堆外内存 VS 内存池</h3><ul><li>内存池：主要用于两类对象：①生命周期较短，且结构简单的对象，在内存池中重复利用这些对象能增加CPU缓存的命中率，从而提高性能；②加载含有大量重复对象的大片数据，此时使用内存池能减少垃圾回收的时间。</li><li>堆外内存：它和内存池一样，也能缩短垃圾回收时间，但是它适用的对象和内存池完全相反。内存池往往适用于生命期较短的可变对象，而生命期中等或较长的对象，正是堆外内存要解决的。</li></ul><h3 id="堆外内存的特点-1"><a href="#堆外内存的特点-1" class="headerlink" title="堆外内存的特点"></a>堆外内存的特点</h3><ul><li>对于大内存有良好的伸缩性</li><li>对垃圾回收停顿的改善可以明显感觉到</li><li>在进程间可以共享，减少虚拟机间的复制</li></ul><h3 id="堆外内存的一些问题-1"><a href="#堆外内存的一些问题-1" class="headerlink" title="堆外内存的一些问题"></a>堆外内存的一些问题</h3><ul><li>堆外内存回收问题，以及堆外内存的泄漏问题。这个在上面的源码解析已经提到了</li><li>堆外内存的数据结构问题：堆外内存最大的问题就是你的数据结构变得不那么直观，如果数据结构比较复杂，就要对它进行串行化（serialization），而串行化本身也会影响性能。另一个问题是由于你可以使用更大的内存，你可能开始担心虚拟内存（即硬盘）的速度对你的影响了。</li></ul><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://lovestblog.cn/blog/2015/05/12/direct-buffer/" target="_blank" rel="noopener">http://lovestblog.cn/blog/2015/05/12/direct-buffer/</a></li><li><a href="http://www.infoq.com/cn/news/2014/12/external-memory-heap-memory" target="_blank" rel="noopener">http://www.infoq.com/cn/news/2014/12/external-memory-heap-memory</a></li><li><a href="http://www.jianshu.com/p/85e931636f27" target="_blank" rel="noopener">http://www.jianshu.com/p/85e931636f27</a></li><li>圣思园《并发与Netty》课程</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java网络编程和NIO &lt;a href=&quot;https://blog.csdn.net/column/details/21963.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21963.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java网络编程与NIO" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO/"/>
    
    
  </entry>
  
  <entry>
    <title>Java网络编程和NIO详解7：浅谈 Linux 中NIO Selector 的实现原理</title>
    <link href="http://h2pl.github.io/2018/05/26/Javanet7/"/>
    <id>http://h2pl.github.io/2018/05/26/Javanet7/</id>
    <published>2018-05-26T03:54:04.000Z</published>
    <updated>2018-06-11T12:50:10.385Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://www.jianshu.com/p/2b71ea919d49" target="_blank" rel="noopener">https://www.jianshu.com/p/2b71ea919d49</a></p><p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java网络编程和NIO <a href="https://blog.csdn.net/column/details/21963.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21963.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><h1 id="浅谈-Linux-中-Selector-的实现原理"><a href="#浅谈-Linux-中-Selector-的实现原理" class="headerlink" title="浅谈 Linux 中 Selector 的实现原理"></a>浅谈 Linux 中 Selector 的实现原理</h1><p>概述</p><p>Selector是NIO中实现I/O多路复用的关键类。Selector实现了通过一个线程管理多个Channel，从而管理多个网络连接的目的。<br>Channel代表这一个网络连接通道，我们可以将Channel注册到Selector中以实现Selector对其的管理。一个Channel可以注册到多个不同的Selector中。<br>当Channel注册到Selector后会返回一个SelectionKey对象，该SelectionKey对象则代表这这个Channel和它注册的Selector间的关系。并且SelectionKey中维护着两个很重要的属性：interestOps、readyOps<br>interestOps是我们希望Selector监听Channel的哪些事件。我们将我们感兴趣的事件设置到该字段，这样在selection操作时，当发现该Channel有我们所感兴趣的事件发生时，就会将我们感兴趣的事件再设置到readyOps中，这样我们就能得知是哪些事件发生了以做相应处理。</p><h2 id="Selector的中的重要属性"><a href="#Selector的中的重要属性" class="headerlink" title="Selector的中的重要属性"></a>Selector的中的重要属性</h2><p>Selector中维护3个特别重要的SelectionKey集合，分别是</p><ul><li>keys：所有注册到Selector的Channel所表示的SelectionKey都会存在于该集合中。keys元素的添加会在Channel注册到Selector时发生。</li><li>selectedKeys：该集合中的每个SelectionKey都是其对应的Channel在上一次操作selection期间被检查到至少有一种SelectionKey中所感兴趣的操作已经准备好被处理。该集合是keys的一个子集。</li><li>cancelledKeys：执行了取消操作的SelectionKey会被放入到该集合中。该集合是keys的一个子集。</li></ul><p>下面的源码解析会说明上面3个集合的用处</p><h2 id="Selector-源码解析"><a href="#Selector-源码解析" class="headerlink" title="Selector 源码解析"></a>Selector 源码解析</h2><p>下面我们通过一段对Selector的使用流程讲解来进一步深入其实现原理。<br>首先先来段Selector最简单的使用片段</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">serverChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">int<span class="built_in"> port </span>= 5566;          </span><br><span class="line">serverChannel.socket().bind(new InetSocketAddress(port));</span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    int n = selector.select();</span><br><span class="line">    <span class="keyword">if</span>(n &gt; 0) &#123;</span><br><span class="line">        Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            SelectionKey selectionKey = iter.next();</span><br><span class="line">            <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">            iter.<span class="builtin-name">remove</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Selector的构建"><a href="#Selector的构建" class="headerlink" title="Selector的构建"></a>Selector的构建</h3><p>SocketChannel、ServerSocketChannel和Selector的实例初始化都通过SelectorProvider类实现。</p><p>ServerSocketChannel.open();</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">ServerSocketChannel <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SelectorProvider.provider().openServerSocketChannel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SocketChannel.open();</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">SocketChannel <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SelectorProvider.provider().openSocketChannel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Selector.open();</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Selector <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SelectorProvider.provider().openSelector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来进一步的了解下SelectorProvider.provider()</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">SelectorProvider <span class="title">provider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (provider != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> provider;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedAction&lt;&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="function">SelectorProvider <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (loadProviderFromProperty())</span><br><span class="line">                            <span class="keyword">return</span> provider;</span><br><span class="line">                        <span class="keyword">if</span> (loadProviderAsService())</span><br><span class="line">                            <span class="keyword">return</span> provider;</span><br><span class="line">                        provider = sun.nio.ch.DefaultSelectorProvider.create();</span><br><span class="line">                        <span class="keyword">return</span> provider;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>① 如果配置了“java.nio.channels.spi.SelectorProvider”属性，则通过该属性值load对应的SelectorProvider对象，如果构建失败则抛异常。</p><p>② 如果provider类已经安装在了对系统类加载程序可见的jar包中，并且该jar包的源码目录META-INF/services包含有一个java.nio.channels.spi.SelectorProvider提供类配置文件，则取文件中第一个类名进行load以构建对应的SelectorProvider对象，如果构建失败则抛异常。</p><p>③ 如果上面两种情况都不存在，则返回系统默认的SelectorProvider，即，sun.nio.ch.DefaultSelectorProvider.create();</p><p>④ 随后在调用该方法，即SelectorProvider.provider()。则返回第一次调用的结果。</p><p>不同系统对应着不同的sun.nio.ch.DefaultSelectorProvider</p><p><img src="https://upload-images.jianshu.io/upload_images/4235178-a02c498e08979aff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><p>这里我们看linux下面的sun.nio.ch.DefaultSelectorProvider</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSelectorProvider</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Prevent instantiation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DefaultSelectorProvider</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the default SelectorProvider.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> sun.nio.ch.EPollSelectorProvider();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见，linux系统下sun.nio.ch.DefaultSelectorProvider.create(); 会生成一个sun.nio.ch.EPollSelectorProvider类型的SelectorProvider，这里对应于linux系统的epoll</p><p>接下来看下 selector.open()：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Opens a selector.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The new selector is created by invoking the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * java.nio.channels.spi.SelectorProvider#openSelector openSelector&#125; method</span></span><br><span class="line"><span class="comment"> * of the system-wide default &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * java.nio.channels.spi.SelectorProvider&#125; object.  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  A new selector</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IOException</span></span><br><span class="line"><span class="comment"> *          If an I/O error occurs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Selector open() throws IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> SelectorProvider.provider().openSelector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在得到sun.nio.ch.EPollSelectorProvider后调用openSelector()方法构建Selector，这里会构建一个EPollSelectorImpl对象。</p><h3 id="EPollSelectorImpl"><a href="#EPollSelectorImpl" class="headerlink" title="EPollSelectorImpl"></a>EPollSelectorImpl</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EPollSelectorImpl</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">SelectorImpl</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// File descriptors used for interrupt</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> fd0;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> fd1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The poll object</span></span><br><span class="line">    EPollArrayWrapper pollWrapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Maps from file descriptors to keys</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,SelectionKeyImpl&gt; fdToKey;</span><br></pre></td></tr></table></figure><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">EPollSelectorImpl(SelectorProvider sp) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">super</span>(sp);</span><br><span class="line">        <span class="keyword">long</span> pipeFds = IOUtil.makePipe(<span class="keyword">false</span>);</span><br><span class="line">        fd0 = (<span class="built_in">int</span>) (pipeFds &gt;&gt;&gt; <span class="number">32</span>);</span><br><span class="line">        fd1 = (<span class="built_in">int</span>) pipeFds;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pollWrapper = <span class="keyword">new</span> EPollArrayWrapper();</span><br><span class="line">            pollWrapper.initInterrupt(fd0, fd1);</span><br><span class="line">            fdToKey = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                FileDispatcherImpl.closeIntFD(fd0);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe0) &#123;</span><br><span class="line">                t.addSuppressed(ioe0);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                FileDispatcherImpl.closeIntFD(fd1);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe1) &#123;</span><br><span class="line">                t.addSuppressed(ioe1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>EPollSelectorImpl构造函数完成：<br>① EPollArrayWrapper的构建，EpollArrayWapper将Linux的epoll相关系统调用封装成了native方法供EpollSelectorImpl使用。</p><p>② 通过EPollArrayWrapper向epoll注册中断事件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initInterrupt</span><span class="params">(<span class="keyword">int</span> fd0, <span class="keyword">int</span> fd1)</span> </span>&#123;</span><br><span class="line">    outgoingInterruptFD = fd1;</span><br><span class="line">    incomingInterruptFD = fd0;</span><br><span class="line">    epollCtl(epfd, EPOLL_CTL_ADD, fd0, EPOLLIN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③ fdToKey：构建文件描述符-SelectionKeyImpl映射表，所有注册到selector的channel对应的SelectionKey和与之对应的文件描述符都会放入到该映射表中。</p><h3 id="EPollArrayWrapper"><a href="#EPollArrayWrapper" class="headerlink" title="EPollArrayWrapper"></a>EPollArrayWrapper</h3><p>EPollArrayWrapper完成了对epoll文件描述符的构建，以及对linux系统的epoll指令操纵的封装。维护每次selection操作的结果，即epoll_wait结果的epoll_event数组。<br>EPollArrayWrapper操纵了一个linux系统下epoll_event结构的本地数组。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* typedef <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">*     void *ptr;</span><br><span class="line">*     int fd;</span><br><span class="line">*     __uint32_t u32;</span><br><span class="line">*     __uint64_t u64;</span><br><span class="line">*  &#125; epoll_data_t;</span><br><span class="line">*</span><br><span class="line">* <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">*     __uint32_t events;</span><br><span class="line">*     epoll_data_t data;</span><br><span class="line">* &#125;;</span><br></pre></td></tr></table></figure><p>epoll_event的数据成员(epoll_data_t data)包含有与通过epoll_ctl将文件描述符注册到epoll时设置的数据相同的数据。这里data.fd为我们注册的文件描述符。这样我们在处理事件的时候持有有效的文件描述符了。</p><p>EPollArrayWrapper将Linux的epoll相关系统调用封装成了native方法供EpollSelectorImpl使用。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="function"><span class="keyword">int</span> <span class="title">epollCreate</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">epollCtl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> opcode, <span class="keyword">int</span> fd, <span class="keyword">int</span> events)</span></span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> epollWait(<span class="keyword">long</span> pollAddress, <span class="keyword">int</span> numfds, <span class="keyword">long</span> timeout,</span><br><span class="line">                             <span class="keyword">int</span> epfd) <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><p>上述三个native方法就对应Linux下epoll相关的三个系统调用</p><p><img src="https://upload-images.jianshu.io/upload_images/4235178-b1f1e91e2394f1fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/643" alt=""></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// The fd of the epoll driver</span><br><span class="line">private<span class="keyword"> final</span><span class="built_in"> int </span>epfd;</span><br><span class="line"></span><br><span class="line"> // The epoll_event<span class="built_in"> array </span>for results from epoll_wait</span><br><span class="line">private<span class="keyword"> final</span> AllocatedNativeObject pollArray;</span><br><span class="line"></span><br><span class="line">// Base address of the epoll_event array</span><br><span class="line">private<span class="keyword"> final</span><span class="built_in"> long </span>pollArrayAddress;</span><br></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于存储已经注册的文件描述符和其注册等待改变的事件的关联关系。在epoll_wait操作就是要检测这里文件描述法注册的事件是否有发生。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] eventsLow = <span class="keyword">new</span> <span class="keyword">byte</span>[MAX_UPDATE_ARRAY_SIZE];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer,<span class="keyword">Byte</span>&gt; eventsHigh = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EPollArrayWrapper() throws IOException &#123;</span><br><span class="line">    // creates the epoll file descriptor</span><br><span class="line">    epfd = epollCreate();</span><br><span class="line"></span><br><span class="line">    // the epoll_event<span class="built_in"> array </span>passed to epoll_wait</span><br><span class="line">   <span class="built_in"> int </span>allocationSize = NUM_EPO<span class="class">LLEVENTS * SIZE_EPOLLEVENT;</span></span><br><span class="line">    pollArray =<span class="built_in"> new </span>AllocatedNativeObject(allocationSize, true);</span><br><span class="line">    pollArrayAddress = pollArray.address();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EPoolArrayWrapper构造函数，创建了epoll文件描述符。构建了一个用于存放epoll_wait返回结果的epoll_event数组。</p><h3 id="ServerSocketChannel的构建"><a href="#ServerSocketChannel的构建" class="headerlink" title="ServerSocketChannel的构建"></a>ServerSocketChannel的构建</h3><p>ServerSocketChannel.open();</p><p>返回ServerSocketChannelImpl对象，构建linux系统下ServerSocket的文件描述符。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Our file descriptor</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FileDescriptor fd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fd value needed for dev/poll. This value will remain valid</span></span><br><span class="line"><span class="comment">// even after the value in the file descriptor object has been set to -1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> fdVal;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannelImpl(SelectorProvider sp) throws IOException &#123;</span><br><span class="line">    <span class="keyword">super</span>(sp);</span><br><span class="line">    <span class="keyword">this</span>.fd =  Net.serverSocket(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">this</span>.fdVal = IOUtil.fdVal(fd);</span><br><span class="line">    <span class="keyword">this</span>.state = ST_INUSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将ServerSocketChannel注册到Selector"><a href="#将ServerSocketChannel注册到Selector" class="headerlink" title="将ServerSocketChannel注册到Selector"></a>将ServerSocketChannel注册到Selector</h3><p> serverChannel.register(selector, SelectionKey.OP_ACCEPT);</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey register(Selector sel, <span class="keyword">int</span> ops,</span><br><span class="line">                                   Object att)</span><br><span class="line">    <span class="keyword">throws</span> ClosedChannelException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (regLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isOpen())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">        <span class="keyword">if</span> ((ops &amp; ~validOps()) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (blocking)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalBlockingModeException();</span><br><span class="line">        SelectionKey k = findKey(sel);</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">            k.interestOps(ops);</span><br><span class="line">            k.attach(att);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// New registration</span></span><br><span class="line">            <span class="keyword">synchronized</span> (keyLock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isOpen())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">                k = ((AbstractSelector)sel).register(<span class="keyword">this</span>, ops, att);</span><br><span class="line">                addKey(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> SelectionKey register(AbstractSelectableChannel ch,</span><br><span class="line">                                      <span class="keyword">int</span> ops,</span><br><span class="line">                                      Object attachment)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(ch <span class="keyword">instanceof</span> SelChImpl))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalSelectorException();</span><br><span class="line">    SelectionKeyImpl k = <span class="keyword">new</span> SelectionKeyImpl((SelChImpl)ch, <span class="keyword">this</span>);</span><br><span class="line">    k.attach(attachment);</span><br><span class="line">    <span class="keyword">synchronized</span> (publicKeys) &#123;</span><br><span class="line">        implRegister(k);</span><br><span class="line">    &#125;</span><br><span class="line">    k.interestOps(ops);</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>① 构建代表channel和selector间关系的SelectionKey对象</p><p>② implRegister(k)将channel注册到epoll中</p><p>③ k.interestOps(int) 完成下面两个操作：</p><p>a) 会将注册的感兴趣的事件和其对应的文件描述存储到EPollArrayWrapper对象的eventsLow或eventsHigh中，这是给底层实现epoll_wait时使用的。</p><p>b) 同时该操作还会将设置SelectionKey的interestOps字段，这是给我们程序员获取使用的。</p><h3 id="EPollSelectorImpl-implRegister"><a href="#EPollSelectorImpl-implRegister" class="headerlink" title="EPollSelectorImpl. implRegister"></a>EPollSelectorImpl. implRegister</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">implRegister</span>(<span class="params">SelectionKeyImpl ski</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</span><br><span class="line">    SelChImpl ch = ski.channel;</span><br><span class="line">    <span class="keyword">int</span> fd = Integer.valueOf(ch.getFDVal());</span><br><span class="line">    fdToKey.put(fd, ski);</span><br><span class="line">    pollWrapper.<span class="keyword">add</span>(fd);</span><br><span class="line">    keys.<span class="keyword">add</span>(ski);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>① 将channel对应的fd(文件描述符)和对应的SelectionKeyImpl放到fdToKey映射表中。</p><p>② 将channel对应的fd(文件描述符)添加到EPollArrayWrapper中，并强制初始化fd的事件为0 ( 强制初始更新事件为0，因为该事件可能存在于之前被取消过的注册中。)</p><p>③ 将selectionKey放入到keys集合中。</p><h4 id="Selection操作"><a href="#Selection操作" class="headerlink" title="Selection操作"></a>Selection操作</h4><p>selection操作有3中类型：<br>① select()：该方法会一直阻塞直到至少一个channel被选择(即，该channel注册的事件发生了)为止，除非当前线程发生中断或者selector的wakeup方法被调用。</p><p>② select(long time)：该方法和select()类似，该方法也会导致阻塞直到至少一个channel被选择(即，该channel注册的事件发生了)为止，除非下面3种情况任意一种发生：a) 设置的超时时间到达；b) 当前线程发生中断；c)<br>selector的wakeup方法被调用</p><p>③ selectNow()：该方法不会发生阻塞，如果没有一个channel被选择也会立即返回。</p><p> 我们主要来看看select()的实现 ：int n = selector.select();</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">select</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会调用到EPollSelectorImpl的doSelect</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</span><br><span class="line">    processDeregisterQueue();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        begin();</span><br><span class="line">        pollWrapper.poll(timeout);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        end();</span><br><span class="line">    &#125;</span><br><span class="line">    processDeregisterQueue();</span><br><span class="line">    <span class="keyword">int</span> numKeysUpdated = updateSelectedKeys();</span><br><span class="line">    <span class="keyword">if</span> (pollWrapper.interrupted()) &#123;</span><br><span class="line">        <span class="comment">// Clear the wakeup pipe</span></span><br><span class="line">        pollWrapper.putEventOps(pollWrapper.interruptedIndex(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (interruptLock) &#123;</span><br><span class="line">            pollWrapper.clearInterrupted();</span><br><span class="line">            IOUtil.drain(fd0);</span><br><span class="line">            interruptTriggered = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numKeysUpdated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>① 先处理注销的selectionKey队列</p><p>② 进行底层的epoll_wait操作</p><p>③ 再次对注销的selectionKey队列进行处理</p><p>④ 更新被选择的selectionKey</p><p>先来看processDeregisterQueue():</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processDeregisterQueue</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Set var1 = <span class="keyword">this</span>.cancelledKeys();</span><br><span class="line">    <span class="keyword">synchronized</span>(var1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!var1.isEmpty()) &#123;</span><br><span class="line">            Iterator var3 = var1.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">                SelectionKeyImpl var4 = (SelectionKeyImpl)var3.next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.implDereg(var4);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SocketException var12) &#123;</span><br><span class="line">                    IOException var6 = <span class="keyword">new</span> IOException(<span class="string">"Error deregistering key"</span>);</span><br><span class="line">                    var6.initCause(var12);</span><br><span class="line">                    <span class="keyword">throw</span> var6;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    var3.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从cancelledKeys集合中依次取出注销的SelectionKey，执行注销操作，将处理后的SelectionKey从cancelledKeys集合中移除。执行processDeregisterQueue()后cancelledKeys集合会为空。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected void implDereg(SelectionKeyImpl ski) throws IOException &#123;</span><br><span class="line">    assert (ski.getIndex() &gt;= <span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">    SelChImpl ch = ski.channel<span class="comment">;</span></span><br><span class="line">    int fd = ch.getFDVal()<span class="comment">;</span></span><br><span class="line">    fdToKey.remove(Integer.valueOf(fd))<span class="comment">;</span></span><br><span class="line">    pollWrapper.remove(fd)<span class="comment">;</span></span><br><span class="line">    ski.setIndex(-<span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">    keys.remove(ski)<span class="comment">;</span></span><br><span class="line">    selectedKeys.remove(ski)<span class="comment">;</span></span><br><span class="line">    deregister((AbstractSelectionKey)ski)<span class="comment">;</span></span><br><span class="line">    SelectableChannel selch = ski.channel()<span class="comment">;</span></span><br><span class="line">    if (!selch.isOpen() &amp;&amp; !selch.isRegistered())</span><br><span class="line">        ((SelChImpl)selch).kill()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注销会完成下面的操作：<br>① 将已经注销的selectionKey从fdToKey( 文件描述与SelectionKeyImpl的映射表 )中移除<br>② 将selectionKey所代表的channel的文件描述符从EPollArrayWrapper中移除<br>③ 将selectionKey从keys集合中移除，这样下次selector.select()就不会再将该selectionKey注册到epoll中监听<br>④ 也会将selectionKey从对应的channel中注销<br>⑤ 最后如果对应的channel已经关闭并且没有注册其他的selector了，则将该channel关闭<br>完成的操作后，注销的SelectionKey就不会出现先在keys、selectedKeys以及cancelKeys这3个集合中的任何一个。</p><p>接着我们来看EPollArrayWrapper.poll(timeout)：</p><pre><code>int poll(long timeout) throws IOException {    updateRegistrations();    updated = epollWait(pollArrayAddress, NUM_EPOLLEVENTS, timeout, epfd);    for (int i=0; i&lt;updated; i++) {        if (getDescriptor(i) == incomingInterruptFD) {            interruptedIndex = i;            interrupted = true;            break;        }    }    return updated;}</code></pre><p>updateRegistrations()方法会将已经注册到该selector的事件(eventsLow或eventsHigh)通过调用epollCtl(epfd, opcode, fd, events); 注册到linux系统中。<br>这里epollWait就会调用linux底层的epoll_wait方法，并返回在epoll_wait期间有事件触发的entry的个数</p><p>再看updateSelectedKeys()：</p><pre><code>private int updateSelectedKeys() {    int entries = pollWrapper.updated;    int numKeysUpdated = 0;    for (int i=0; i&lt;entries; i++) {        int nextFD = pollWrapper.getDescriptor(i);        SelectionKeyImpl ski = fdToKey.get(Integer.valueOf(nextFD));        // ski is null in the case of an interrupt        if (ski != null) {            int rOps = pollWrapper.getEventOps(i);            if (selectedKeys.contains(ski)) {                if (ski.channel.translateAndSetReadyOps(rOps, ski)) {                    numKeysUpdated++;                }            } else {                ski.channel.translateAndSetReadyOps(rOps, ski);                if ((ski.nioReadyOps() &amp; ski.nioInterestOps()) != 0) {                    selectedKeys.add(ski);                    numKeysUpdated++;                }            }        }    }    return numKeysUpdated;}</code></pre><p>该方法会从通过EPollArrayWrapper pollWrapper 以及 fdToKey( 构建文件描述符-SelectorKeyImpl映射表 )来获取有事件触发的SelectionKeyImpl对象，然后将SelectionKeyImpl放到selectedKey集合( 有事件触发的selectionKey集合，可以通过selector.selectedKeys()方法获得 )中，即selectedKeys。并重新设置SelectionKeyImpl中相关的readyOps值。<br>但是，这里要注意两点：</p><p>① 如果SelectionKeyImpl已经存在于selectedKeys集合中，并且发现触发的事件已经存在于readyOps中了，则不会使numKeysUpdated++；这样会使得我们无法得知该事件的变化。这点说明了为什么我们要在每次从selectedKey中获取到Selectionkey后，将其从selectedKey集合移除，就是为了当有事件触发使selectionKey能正确到放入selectedKey集合中，并正确的通知给调用者。</p><p>再者，如果不将已经处理的SelectionKey从selectedKey集合中移除，那么下次有新事件到来时，在遍历selectedKey集合时又会遍历到这个SelectionKey，这个时候就很可能出错了。比如，如果没有在处理完OP_ACCEPT事件后将对应SelectionKey从selectedKey集合移除，那么下次遍历selectedKey集合时，处理到到该SelectionKey，相应的ServerSocketChannel.accept()将返回一个空(null)的SocketChannel。</p><p>② 如果发现channel所发生I/O事件不是当前SelectionKey所感兴趣，则不会将SelectionKeyImpl放入selectedKeys集合中，也不会使numKeysUpdated++</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://www.jianshu.com/p/2b71ea919d49&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/2b71ea919d49&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java网络编程和NIO &lt;a href=&quot;https://blog.csdn.net/column/details/21963.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21963.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java网络编程与NIO" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO/"/>
    
    
      <category term="Linux IO" scheme="http://h2pl.github.io/tags/Linux-IO/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程和NIO详解6：Linux epoll实现原理详解</title>
    <link href="http://h2pl.github.io/2018/05/26/Javanet6/"/>
    <id>http://h2pl.github.io/2018/05/26/Javanet6/</id>
    <published>2018-05-26T03:54:02.000Z</published>
    <updated>2018-06-11T12:50:19.719Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java网络编程和NIO <a href="https://blog.csdn.net/column/details/21963.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21963.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><p> Linux epoll实现原理详解</p><p>在linux 没有实现epoll事件驱动机制之前，我们一般选择用select或者poll等IO多路复用的方法来实现并发服务程序。在大数据、高并发、集群等一些名词唱得火热之年代，select和poll的用武之地越来越有限，风头已经被epoll占尽。</p><p>本文便来介绍epoll的实现机制，并附带讲解一下select和poll。通过对比其不同的实现机制，真正理解为何epoll能实现高并发。</p><p>这部分转自<a href="https://jeff.wtf/2017/02/IO-multiplexing/" target="_blank" rel="noopener">https://jeff.wtf/2017/02/IO-multiplexing/</a></p><h2 id="为什么要-I-O-多路复用"><a href="#为什么要-I-O-多路复用" class="headerlink" title="为什么要 I/O 多路复用"></a>为什么要 I/O 多路复用</h2><p>当需要从一个叫 <code>r_fd</code> 的描述符不停地读取数据，并把读到的数据写入一个叫 <code>w_fd</code> 的描述符时，我们可以用循环使用阻塞 I/O ：</p><pre><code>while((n = read(r_fd, buf, BUF_SIZE)) &gt; 0)if(write(w_fd, buf, n) != n) err_sys(&quot;write error&quot;)</code></pre><p>但是，如果要从两个地方读取数据呢？这时，不能再使用会把程序阻塞住的 <code>read</code> 函数。因为可能在阻塞地等待 <code>r_fd1</code> 的数据时，来不及处理 <code>r_fd2</code>，已经到达的 <code>r_fd2</code> 的数据可能会丢失掉。</p><p>这个情况下需要使用非阻塞 I/O。</p><p>只要做个标记，把文件描述符标记为非阻塞的，以后再对它使用 <code>read</code> 函数：如果它还没有数据可读，函数会立即返回并把 errorno 这个变量的值设置为 35，于是我们知道它没有数据可读，然后可以立马去对其他描述符使用 <code>read</code>；如果它有数据可读，我们就读取它数据。对所有要读的描述符都调用了一遍 <code>read</code> 之后，我们可以等一个较长的时间（比如几秒），然后再从第一个文件描述符开始调用 <code>read</code> 。这种循环就叫做轮询（polling）。</p><p>这样，不会像使用阻塞 I/O 时那样因为一个描述符 <code>read</code> 长时间处于等待数据而使程序阻塞。</p><p>轮询的缺点是浪费太多 CPU 时间。大多数时候我们没有数据可读，但是还是用了 <code>read</code> 这个系统调用，使用系统调用时会从用户态切换到内核态。而大多数情况下我们调用 <code>read</code>，然后陷入内核态，内核发现这个描述符没有准备好，然后切换回用户态并且只得到 EAGAIN （errorno 被设置为 35），做的是无用功。描述符非常多的时候，每次的切换过程就是巨大的浪费。</p><p>所以，需要 I/O 多路复用。I/O 多路复用通过使用一个系统函数，同时等待多个描述符的可读、可写状态。</p><p>为了达到这个目的，我们需要做的是：建立一个描述符列表，以及我们分别关心它们的什么事件（可读还是可写还是发生例外情况）；调用一个系统函数，直到这个描述符列表里有至少一个描述符关联的事件发生时，这个函数才会返回。</p><p>select, poll, epoll 就是这样的系统函数。</p><h2 id="select，poll，epoll-源码分析"><a href="#select，poll，epoll-源码分析" class="headerlink" title="select，poll，epoll 源码分析"></a>select，poll，epoll 源码分析</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a><a href="https://jeff.wtf/2017/02/IO-multiplexing/#select" title="select" target="_blank" rel="noopener"></a>select</h3><p>我们可以在所有 POSIX 兼容的系统里使用 select 函数来进行 I/O 多路复用。我们需要通过 select 函数的参数传递给内核的信息有：</p><ul><li>我们关心哪些描述符</li><li>我们关心它们的什么事件</li><li>我们希望等待多长时间</li></ul><p>select 的返回时，内核会告诉我们：</p><ul><li>可读的描述符的个数</li><li>哪些描述符发生了哪些事件</li></ul><pre><code>include &lt;sys/select.h&gt;int select(int maxfdp1, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout);// 返回值: 已就绪的描述符的个数。超时时为 0 ，错误时为 -1</code></pre><p><code>maxfdp1</code> 意思是 “max file descriptor plus 1” ，就是把你要监视的所有文件描述符里最大的那个加上 1 。（它实际上决定了内核要遍历文件描述符的次数，比如你监视了文件描述符 5 和 20 并把 <code>maxfdp1</code> 设置为 21 ，内核每次都会从描述符 0 依次检查到 20。）</p><p>中间的三个参数是你想监视的文件描述符的集合。可以把 fd_set 类型视为 1024 位的二进制数，这意味着 select 只能监视小于 1024 的文件描述符（1024 是由 Linux 的 sys/select.h 里 <code>FD_SETSIZE</code> 宏设置的值）。在 select 返回后我们通过 <code>FD_ISSET</code> 来判断代表该位的描述符是否是已准备好的状态。</p><p>最后一个参数是等待超时的时长：到达这个时长但是没有任一描述符可用时，函数会返回 0 。</p><p>用一个代码片段来展示 select 的用法：</p><pre>// 这个例子要监控文件描述符 3, 4 的可读状态，以及 4, 5 的可写状态// 初始化两个 fd_set 以及 timevalfd_set read_set, write_set;FD_ZERO(read_set);FD_ZERO(write_set);timeval t;t.tv_sec = 5;   // 超时为 5 秒t.tv_usec = 0;  // 加 0 微秒// 设置好两个 fd_setint fd1 = 3;int fd2 = 4;int fd3 = 5;int maxfdp1 = 5 + 1;FD_SET(fd1, &read_set);FD_SET(fd2, &read_set);FD_SET(fd2, &write_set);FD_SET(fd3, &write_set);// 准备备用的 fd_setfd_set r_temp = read_set;fd_set w_temp = write_set;while(true){ // 每次都要重新设置放入 select 的 fd_set read_set = r_temp; write_set = w_temp; // 使用 select int n = select(maxfdp1, &read_set, &write_set, NULL, &t); // 上面的 select 函数会一直阻塞，直到 // 3, 4 可读以及 4, 5 可写这四件事中至少一项发生 // 或者等待时间到达 5 秒，返回 0 for(int i=0; i<maxfdp1 &&="" n="">0; i++){ if(FD_ISSET(i, &read_set)){ n--; if(i==fd1) prinf("描述符 3 可读"); if(i==fd2) prinf("描述符 4 可读"); } if(FD_ISSET(i, &write_set)){ n--; if(i==fd2) prinf("描述符 3 可写"); if(i==fd3) prinf("描述符 4 可写"); } } // 上面的 printf 语句换成对应的 read 或者 write 函数就 // 可以立即读取或者写入相应的描述符而不用等待}</maxfdp1></pre><p>可以看到，select 的缺点有：</p><ul><li>默认能监视的文件描述符不能大于 1024，也代表监视的总数不超过1024。即使你因为需要监视的描述符大于 1024 而改动内核的 <code>FD_SETSIZE</code> 值，但由于 select 是每次都会线性扫描整个fd_set，集合越大速度越慢，所以性能会比较差。</li><li>select 函数返回时只能看见已准备好的描述符数量，至于是哪个描述符准备好了需要循环用 <code>FD_ISSET</code> 来检查，当未准备好的描述符很多而准备好的很少时，效率比较低。</li><li>select 函数每次执行的时候，都把参数里传入的三个 fd_set 从用户空间复制到内核空间。而每次 fd_set 里要监视的描述符变化不大时，全部重新复制一遍并不划算。同样在每次都是未准备好的描述符很多而准备好的很少时，调用 select 会很频繁，用户/内核间的的数据复制就成了一个大的开销。</li></ul><p>还有一个问题是在代码的写法上给我一些困扰的，就是每次调用 select 前必须重新设置三个 fd_set。 fd_set 类型只是 1024 位的二进制数（实际上结构体里是几个 long 变量的数组；比如 64 位机器上 long 是 64 bit，那么 fd_set 里就是 16 个 long 变量的数组），由一位的 1 和 0 代表一个文件描述符的状态，但是其实调用 select 前后位的 1/0 状态意义是不一样的。</p><p>先讲一下几个对 fd_set 操作的函数的作用：<code>FD_ZERO</code> 把 fd_set 所有位设置为 0 ；<code>FD_SET</code> 把一个位设置为 1 ；<code>FD_ISSET</code> 判断一个位是否为 1 。</p><p>调用 select 前：我们用 <code>FD_ZERO</code> 把 fd_set 先全部初始化，然后用 <code>FD_SET</code> 把我们关心的代表描述符的位设置为 1 。我们这时可以用 <code>FD_ISSET</code> 判断这个位是否被我们设置，这时的含义是我们想要监视的描述符是否被设置为被监视的状态。</p><p>调用 select 时：内核判断 fd_set 里的位并把各个 fd_set 里所有值为 1 的位记录下来，然后把 fd_set 全部设置成 0 ；一个描述符上有对应的事件发生时，把对应 fd_set 里代表这个描述符的位设置为 1 。</p><p>在 select 返回之后：我们同样用 <code>FD_ISSET</code> 判断各个我们关心的位是 0 还是 1 ，这时的含义是，这个位是否是发生了我们关心的事件。</p><p>所以，在下一次调用 select 前，我们不得不把已经被内核改掉的 fd_set 全部重新设置一下。</p><p>select 在监视大量描述符尤其是更多的描述符未准备好的情况时性能很差。《Unix 高级编程》里写，用 select 的程序通常只使用 3 到 10 个描述符。</p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a><a href="https://jeff.wtf/2017/02/IO-multiplexing/#poll" title="poll" target="_blank" rel="noopener"></a>poll</h3><p>poll 和 select 是相似的，只是给的接口不同。</p><pre><code>#include &lt;poll.h&gt;int poll(struct pollfd fdarray[], nfds_t nfds, int timeout);</code></pre><p>返回值: 已就绪的描述符的个数。超时时为 0 ，错误时为 -1</p><p><code>fdarray</code> 是 <code>pollfd</code> 的数组。<code>pollfd</code> 结构体是这样的：</p><pre><code>struct pollfd {     int fd; // 文件描述符     short events;   // 我期待的事件     short revents;  // 实际发生的事件：我期待的事件中发生的；或者异常情况};</code></pre><p><code>nfds</code> 是 <code>fdarray</code> 的长度，也就是 pollfd 的个数。</p><p><code>timeout</code> 代表等待超时的毫秒数。</p><p>相比 select ，poll 有这些优点：由于 poll 在 pollfd 里用 <code>int fd</code> 来表示文件描述符而不像 select 里用的 fd_set 来分别表示描述符，所以没有必须小于 1024 的限制，也没有数量限制；由于 poll 用 <code>events</code> 表示期待的事件，通过修改 <code>revents</code> 来表示发生的事件，所以不需要像 select 在每次调用前重新设置描述符和期待的事件。</p><p>除此之外，poll 和 select 几乎相同。在 poll 返回后，需要遍历 <code>fdarray</code> 来检查各个 <code>pollfd</code> 里的 <code>revents</code> 是否发生了期待的事件；每次调用 poll 时，把 <code>fdarray</code> 复制到内核空间。在描述符太多而每次准备好的较少时，poll 有同样的性能问题。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a><a href="https://jeff.wtf/2017/02/IO-multiplexing/#epoll" title="epoll" target="_blank" rel="noopener"></a>epoll</h3><p>epoll 是在 Linux 2.5.44 中首度登场的。不像 select 和 poll ，它提供了三个系统函数而不是一个。</p><h4 id="epoll-create-用来创建一个-epoll-描述符："><a href="#epoll-create-用来创建一个-epoll-描述符：" class="headerlink" title="epoll_create 用来创建一个 epoll 描述符："></a><a href="https://jeff.wtf/2017/02/IO-multiplexing/#epoll-create-%E7%94%A8%E6%9D%A5%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-epoll-%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%9A" title="epoll_create 用来创建一个 epoll 描述符：" target="_blank" rel="noopener"></a>epoll_create 用来创建一个 epoll 描述符：</h4><pre><code>#include &lt;sys/epoll.h&gt;int epoll_create(int size);// 返回值：epoll 描述符</code></pre><p><code>size</code> 用来告诉内核你想监视的文件描述符的数目，但是它并不是限制了能监视的描述符的最大个数，而是给内核最初分配的空间一个建议。然后系统会在内核中分配一个空间来存放事件表，并返回一个 epoll 描述符，用来操作这个事件表。</p><h4 id="epoll-ctl-用来增-删-改内核中的事件表："><a href="#epoll-ctl-用来增-删-改内核中的事件表：" class="headerlink" title="epoll_ctl 用来增/删/改内核中的事件表："></a><a href="https://jeff.wtf/2017/02/IO-multiplexing/#epoll-ctl-%E7%94%A8%E6%9D%A5%E5%A2%9E-%E5%88%A0-%E6%94%B9%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E8%A1%A8%EF%BC%9A" title="epoll_ctl 用来增/删/改内核中的事件表：" target="_blank" rel="noopener"></a>epoll_ctl 用来增/删/改内核中的事件表：</h4><pre><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);// 返回值：成功时返回 0 ，失败时返回 -1</code></pre><p><code>epfd</code> 是 epoll 描述符。</p><p><code>op</code> 是操作类型（增加/删除/修改）。</p><p><code>fd</code> 是希望监视的文件描述符。</p><p><code>event</code> 是一个 epoll_event 结构体的指针。epoll_event 的定义是这样的：</p><pre><code>typedef union epoll_data {   void        *ptr;   int          fd;   uint32_t     u32;   uint64_t     u64;} epoll_data_t;struct epoll_event {   uint32_t     events;      // 我期待的事件   epoll_data_t data;        // 用户数据变量};</code></pre><p>这个结构体里，除了期待的事件外，还有一个 <code>data</code> ，是一个 union，它是用来让我们在得到下面第三个函数的返回值以后方便的定位文件描述符的。</p><h4 id="epoll-wait-用来等待事件"><a href="#epoll-wait-用来等待事件" class="headerlink" title="epoll_wait 用来等待事件"></a><a href="https://jeff.wtf/2017/02/IO-multiplexing/#epoll-wait-%E7%94%A8%E6%9D%A5%E7%AD%89%E5%BE%85%E4%BA%8B%E4%BB%B6" title="epoll_wait 用来等待事件" target="_blank" rel="noopener"></a>epoll_wait 用来等待事件</h4><pre><code>int epoll_wait(int epfd, struct epoll_event *result_events,              int maxevents, int timeout);</code></pre><p>// 返回值：已就绪的描述符个数。超时时为 0 ，错误时为 -1</p><p><code>epfd</code> 是 epoll 描述符。</p><p><code>result_events</code> 是 epoll_event 结构体的指针，它将指向的是所有已经准备好的事件描述符相关联的 epoll_event（在上个步骤里调用 epoll_ctl 时关联起来的）。下面的例子可以让你知道这个参数的意义。</p><p><code>maxevents</code> 是返回的最大事件个数，也就是你能通过 result_events 指针遍历到的最大的次数。</p><p><code>timeout</code> 是等待超时的毫秒数。</p><p>用一个代码片段来展示 epoll 的用法：</p><pre><code>// 这个例子要监控文件描述符 3, 4 的可读状态，以及 4, 5 的可写状态/* 通过 epoll_create 创建 epoll 描述符 */int epfd = epoll_create(4);int fd1 = 3;int fd2 = 4;int fd3 = 5;/* 通过 epoll_ctl 注册好四个事件 */struct epoll_event ev1;ev1.events = EPOLLIN;      // 期待它的可读事件发生ev1.data   = fd1;          // 我们通常就把 data 设置为 fd ，方便以后查看epoll_ctl(epfd, EPOLL_CTL_ADD, fd1, &amp;ev1);  // 添加到事件表struct epoll_event ev2;ev2.events = EPOLLIN;ev2.data   = fd2;epoll_ctl(epfd, EPOLL_CTL_ADD, fd2, &amp;ev2);struct epoll_event ev3;ev3.events = EPOLLOUT;     // 期待它的可写事件发生ev3.data   = fd2;epoll_ctl(epfd, EPOLL_CTL_ADD, fd2, &amp;ev3);struct epoll_event ev4;ev4.events = EPOLLOUT;ev4.data   = fd3;epoll_ctl(epfd, EPOLL_CTL_ADD, fd3, &amp;ev4);/* 通过 epoll_wait 等待事件 */# DEFINE MAXEVENTS 4struct epoll_event result_events[MAXEVENTS];while(true){    int n = epoll_wait(epfd, &amp;result_events, MAXEVENTS, 5000);    for(int i=0; i&lt;n; n--){        // result_events[i] 一定是 ev1 到 ev4 中的一个        if(result_events[i].events&amp;EPOLLIN)            printf(&quot;描述符 %d 可读&quot;, result_events[i].fd);        else if(result_events[i].events&amp;EPOLLOUT)            printf(&quot;描述符 %d 可写&quot;, result_events[i].fd)    }}</code></pre><p>所以 epoll 解决了 poll 和 select 的问题：</p><ul><li><p>只在 epoll_ctl 的时候把数据复制到内核空间，这保证了每个描述符和事件一定只会被复制到内核空间一次；每次调用 epoll_wait 都不会复制新数据到内核空间。相比之下，select 每次调用都会把三个 fd_set 复制一遍；poll 每次调用都会把 <code>fdarray</code> 复制一遍。</p></li><li><p>epoll_wait 返回 n ，那么只需要做 n 次循环，可以保证遍历的每一次都是有意义的。相比之下，select 需要做至少 n 次至多 <code>maxfdp1</code> 次循环；poll 需要遍历完 fdarray 即做 <code>nfds</code> 次循环。</p></li><li><p>在内部实现上，epoll 使用了回调的方法。调用 epoll_ctl 时，就是注册了一个事件：在集合中放入文件描述符以及事件数据，并且加上一个回调函数。一旦文件描述符上的对应事件发生，就会调用回调函数，这个函数会把这个文件描述符加入到就绪队列上。当你调用 epoll_wait 时，它只是在查看就绪队列上是否有内容，有的话就返回给你的程序。<code>select()</code> <code>poll()`</code>epoll_wait()` 三个函数在操作系统看来，都是睡眠一会儿然后判断一会儿的循环，但是 select 和 poll 在醒着的时候要遍历整个文件描述符集合，而 epoll_wait 只是看看就绪队列是否为空而已。这是 epoll 高性能的理由，使得其 I/O 的效率不会像使用轮询的 select/poll 随着描述符增加而大大降低。</p></li></ul><blockquote><p>注 1 ：select/poll/epoll_wait 三个函数的等待超时时间都有一样的特性：等待时间设置为 0 时函数不阻塞而是立即返回，不论是否有文件描述符已准备好；poll/epoll_wait 中的 timeout 为 -1，select 中的 timeout 为 NULL 时，则无限等待，直到有描述符已准备好才会返回。</p><p>注 2 ：有的新手会把文件描述符是否标记为阻塞 I/O 等同于 I/O 多路复用函数是否阻塞。其实文件描述符是否标记为阻塞，决定了你 <code>read</code> 或 <code>write</code> 它时如果它未准备好是阻塞等待，还是立即返回 EAGAIN ；而 I/O 多路复用函数除非你把 timeout 设置为 0 ，否则它总是会阻塞住你的程序。</p><p>注 3 ：上面的例子只是入门，可能是不准确或不全面的：一是数据要立即处理防止丢失；二是 EPOLLIN/EPOLLOUT 不完全等同于可读可写事件，具体要去搜索 poll/epoll 的事件具体有哪些；三是大多数实际例子里，比如一个 tcp server ，都会在运行中不断增加/删除的文件描述符而不是记住固定的 3 4 5 几个描述符（用这种例子更能看出 epoll 的优势）；四是 epoll 的优势更多的体现在处理大量闲连接的情况，如果场景是处理少量短连接，用 select 反而更好，而且用 select 的代码能运行在所有平台上。</p></blockquote><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h2 id="Epoll数据结构："><a href="#Epoll数据结构：" class="headerlink" title="Epoll数据结构："></a>Epoll数据结构：</h2><h2 id="select-和poll-IO多路复用模型"><a href="#select-和poll-IO多路复用模型" class="headerlink" title="select()和poll() IO多路复用模型"></a>select()和poll() IO多路复用模型</h2><p>select的缺点：</p><ol><li>单个进程能够监视的文件描述符的数量存在最大限制，通常是1024，当然可以更改数量，但由于select采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差；(在linux内核头文件中，有这样的定义：#define __FD_SETSIZE    1024)</li><li>内核 / 用户空间内存拷贝问题，select需要复制大量的句柄数据结构，产生巨大的开销；</li><li>select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件；</li><li>select的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程。</li></ol><p>相比select模型，poll使用链表保存文件描述符，因此没有了监视文件数量的限制，但其他三个缺点依然存在。</p><p>拿select模型为例，假设我们的服务器需要支持100万的并发连接，则在__FD_SETSIZE 为1024的情况下，则我们至少需要开辟1k个进程才能实现100万的并发连接。除了进程间上下文切换的时间消耗外，从内核/用户空间大量的无脑内存拷贝、数组轮询等，是系统难以承受的。因此，基于select模型的服务器程序，要达到10万级别的并发访问，是一个很难完成的任务。</p><p>因此，该epoll上场了。</p><h2 id="epoll-IO多路复用模型实现机制"><a href="#epoll-IO多路复用模型实现机制" class="headerlink" title="epoll IO多路复用模型实现机制"></a>epoll IO多路复用模型实现机制</h2><p>由于epoll的实现机制与select/poll机制完全不同，上面所说的 select的缺点在epoll上不复存在。</p><p>设想一下如下场景：有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？</p><p>在select/poll时代，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般只能处理几千的并发连接。</p><p>epoll的设计和实现与select完全不同。epoll通过在Linux内核中申请一个简易的文件系统(文件系统一般用什么数据结构实现？B+树)。把原先的select/poll调用分成了3个部分：</p><p>1）调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)</p><p>2）调用epoll_ctl向epoll对象中添加这100万个连接的套接字</p><p>3）调用epoll_wait收集发生的事件的连接</p><p>如此一来，要实现上面说是的场景，只需要在进程启动时建立一个epoll对象，然后在需要的时候向这个epoll对象中添加或者删除连接。同时，epoll_wait的效率也非常高，因为调用epoll_wait时，并没有一股脑的向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接。</p><p>下面来看看Linux内核具体的epoll机制实现思路。</p><p>当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关。eventpoll结构体如下所示：</p><pre><code>1.  struct eventpoll{  2.      ....  3.      /*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/  4.      struct rb_root  rbr;  5.      /*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/  6.      struct list_head rdlist;  7.      ....  8.  };  </code></pre><p>每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是lgn，其中n为树的高度)。</p><p>而所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。</p><p>在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示：</p><pre><code>1.  struct epitem{  2.      struct rb_node  rbn;//红黑树节点  3.      struct list_head    rdllink;//双向链表节点  4.      struct epoll_filefd  ffd;  //事件句柄信息  5.      struct eventpoll *ep;    //指向其所属的eventpoll对象  6.      struct epoll_event event; //期待发生的事件类型  7.  }  </code></pre><p>当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。</p><p><img src="http://static.open-open.com/lib/uploadImg/20140911/20140911103834_133.jpg" alt="epoll.jpg" title="epoll.jpg"></p><p>epoll数据结构示意图</p><p>从上面的讲解可知：通过红黑树和双链表数据结构，并结合回调机制，造就了epoll的高效。</p><p>OK，讲解完了Epoll的机理，我们便能很容易掌握epoll的用法了。一句话描述就是：三步曲。</p><p>第一步：epoll_create()系统调用。此调用返回一个句柄，之后所有的使用都依靠这个句柄来标识。</p><p>第二步：epoll_ctl()系统调用。通过此调用向epoll对象中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败。</p><p>第三部：epoll_wait()系统调用。通过此调用收集收集在epoll监控中已经发生的事件。</p><h2 id="epoll实例"><a href="#epoll实例" class="headerlink" title="epoll实例"></a>epoll实例</h2><p>最后，附上一个epoll编程实例。</p><p>几乎所有的epoll程序都使用下面的框架：</p><pre><code>1.  for( ; ; )  2.     {  3.         nfds = epoll_wait(epfd,events,20,500);  4.         for(i=0;i&lt;nfds;++i)  &lt; span=&quot;&quot; &gt;5.         {  6.             if(events[i].data.fd==listenfd) //有新的连接  7.             {  8.                 connfd = accept(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen); //accept这个连接  9.                 ev.data.fd=connfd;  10.                 ev.events=EPOLLIN|EPOLLET;  11.                 epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;ev); //将新的fd添加到epoll的监听队列中  12.             }  13.    14.             else if( events[i].events&amp;EPOLLIN ) //接收到数据，读socket  15.             {  16.                 n = read(sockfd, line, MAXLINE)) &lt; 0    //读  17.                 ev.data.ptr = md;     //md为自定义类型，添加数据  18.                 ev.events=EPOLLOUT|EPOLLET;  19.                 epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);//修改标识符，等待下一个循环时发送数据，异步处理的精髓  20.             }  21.             else if(events[i].events&amp;EPOLLOUT) //有数据待发送，写socket  22.             {  23.                 struct myepoll_data* md = (myepoll_data*)events[i].data.ptr;    //取数据  24.                 sockfd = md-&gt;fd;  25.                 send( sockfd, md-&gt;ptr, strlen((char*)md-&gt;ptr), 0 );        //发送数据  26.                 ev.data.fd=sockfd;  27.                 ev.events=EPOLLIN|EPOLLET;  28.                 epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev); //修改标识符，等待下一个循环时接收数据  29.             }  30.             else  31.             {  32.                 //其他的处理  33.             }  34.         }  35.     }  </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java网络编程和NIO &lt;a href=&quot;https://blog.csdn.net/column/details/21963.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21963.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java网络编程与NIO" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO/"/>
    
    
      <category term="Linux IO" scheme="http://h2pl.github.io/tags/Linux-IO/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程和NIO详解5：Java 非阻塞 IO 和异步 IO</title>
    <link href="http://h2pl.github.io/2018/05/26/Javanet5/"/>
    <id>http://h2pl.github.io/2018/05/26/Javanet5/</id>
    <published>2018-05-26T03:53:59.000Z</published>
    <updated>2018-06-02T14:18:07.359Z</updated>
    
    <content type="html"><![CDATA[<p>Java 非阻塞 IO 和异步 IO</p><p>转自<a href="https://www.javadoop.com/post/nio-and-aio" target="_blank" rel="noopener">https://www.javadoop.com/post/nio-and-aio</a></p><p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java网络编程和NIO <a href="https://blog.csdn.net/column/details/21963.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21963.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><p>上一篇文章介绍了 Java NIO 中 Buffer、Channel 和 Selector 的基本操作，主要是一些接口操作，比较简单。</p><p>本文将介绍非阻塞 IO 和异步 IO，也就是大家耳熟能详的 NIO 和 AIO。很多初学者可能分不清楚异步和非阻塞的区别，只是在各种场合能听到异步非阻塞这个词。</p><p>本文会先介绍并演示阻塞模式，然后引入非阻塞模式来对阻塞模式进行优化，最后再介绍 JDK7 引入的异步 IO，由于网上关于异步 IO 的介绍相对较少，所以这部分内容我会介绍得具体一些。</p><p>希望看完本文，读者可以对非阻塞 IO 和异步 IO 的迷雾看得更清晰些，或者为初学者解开一丝丝疑惑也是好的。</p><ul><li><a href="https://www.javadoop.com/post/nio-and-aio#%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%20IO" target="_blank" rel="noopener">阻塞模式 IO</a></li><li><a href="https://www.javadoop.com/post/nio-and-aio#%E9%9D%9E%E9%98%BB%E5%A1%9E%20IO" target="_blank" rel="noopener">非阻塞 IO</a></li><li><a href="https://www.javadoop.com/post/nio-and-aio#NIO.2%20%E5%BC%82%E6%AD%A5%20IO" target="_blank" rel="noopener">NIO.2 异步 IO</a><ul><li><a href="https://www.javadoop.com/post/nio-and-aio#1%E3%80%81%E8%BF%94%E5%9B%9E%20Future%20%E5%AE%9E%E4%BE%8B" target="_blank" rel="noopener">1、返回 Future 实例</a></li><li><a href="https://www.javadoop.com/post/nio-and-aio#2%E3%80%81%E6%8F%90%E4%BE%9B%20CompletionHandler%20%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">2、提供 CompletionHandler 回调函数</a></li><li><a href="https://www.javadoop.com/post/nio-and-aio#AsynchronousFileChannel" target="_blank" rel="noopener">AsynchronousFileChannel</a></li><li><a href="https://www.javadoop.com/post/nio-and-aio#AsynchronousServerSocketChannel" target="_blank" rel="noopener">AsynchronousServerSocketChannel</a></li><li><a href="https://www.javadoop.com/post/nio-and-aio#AsynchronousSocketChannel" target="_blank" rel="noopener">AsynchronousSocketChannel</a></li><li><a href="https://www.javadoop.com/post/nio-and-aio#Asynchronous%20Channel%20Groups" target="_blank" rel="noopener">Asynchronous Channel Groups</a></li></ul></li><li><a href="https://www.javadoop.com/post/nio-and-aio#%E5%B0%8F%E7%BB%93" target="_blank" rel="noopener">小结</a></li></ul><h2 id="阻塞模式-IO"><a href="#阻塞模式-IO" class="headerlink" title="阻塞模式 IO"></a>阻塞模式 IO</h2><p>我们已经介绍过使用 Java NIO 包组成一个简单的客户端-服务端网络通讯所需要的 ServerSocketChannel、SocketChannel 和 Buffer，我们这里整合一下它们，给出一个完整的可运行的例子：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监听 8080 端口进来的 TCP 链接</span></span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里会阻塞，直到有一个请求的连接进来</span></span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开启一个新的线程来处理这个请求，然后在 while 循环中继续监听 8080 端口</span></span><br><span class="line">            SocketHandler <span class="keyword">handler</span> = <span class="keyword">new</span> SocketHandler(socketChannel);</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">handler</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看一下新的线程需要做什么，SocketHandler：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class SocketHandler implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SocketHandler(SocketChannel socketChannel) &#123;</span><br><span class="line">        <span class="keyword">this</span>.socketChannel = socketChannel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span><br><span class="line"></span><br><span class="line">        ByteBuffer <span class="built_in">buffer</span> = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="built_in">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将请求数据读入 Buffer 中</span></span><br><span class="line">            <span class="keyword">int</span> num;</span><br><span class="line">            <span class="built_in">while</span> ((num = socketChannel.<span class="built_in">read</span>(<span class="built_in">buffer</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 读取 Buffer 内容之前先 flip 一下</span></span><br><span class="line">                <span class="built_in">buffer</span>.flip();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 提取 Buffer 中的数据</span></span><br><span class="line">                <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[num];</span><br><span class="line">                <span class="built_in">buffer</span>.<span class="built_in">get</span>(bytes);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">String</span> re = <span class="keyword">new</span> <span class="keyword">String</span>(bytes, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">"收到请求："</span> + re);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 回应客户端</span></span><br><span class="line">                ByteBuffer writeBuffer = ByteBuffer.wrap((<span class="string">"我已经收到你的请求，你的请求内容是："</span> + re).getBytes());</span><br><span class="line">                socketChannel.<span class="built_in">write</span>(writeBuffer);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">buffer</span>.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in">catch</span> (IOException e) &#123;</span><br><span class="line">            IOUtils.closeQuietly(socketChannel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，贴一下客户端 SocketChannel 的使用，客户端比较简单：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class SocketChannelTest &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) throws IOException &#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.<span class="built_in">open</span>();</span><br><span class="line">        socketChannel.<span class="built_in">connect</span>(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送请求</span></span><br><span class="line">        ByteBuffer <span class="built_in">buffer</span> = ByteBuffer.wrap(<span class="string">"1234567890"</span>.getBytes());</span><br><span class="line">        socketChannel.<span class="built_in">write</span>(<span class="built_in">buffer</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取响应</span></span><br><span class="line">        ByteBuffer readBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="built_in">if</span> ((num = socketChannel.<span class="built_in">read</span>(readBuffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            readBuffer.flip();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] re = <span class="keyword">new</span> <span class="keyword">byte</span>[num];</span><br><span class="line">            readBuffer.<span class="built_in">get</span>(re);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">String</span> result = <span class="keyword">new</span> <span class="keyword">String</span>(re, <span class="string">"UTF-8"</span>);</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"返回值: "</span> + result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面介绍的阻塞模式的代码应该很好理解：来一个新的连接，我们就新开一个线程来处理这个连接，之后的操作全部由那个线程来完成。</p><p>那么，这个模式下的性能瓶颈在哪里呢？</p><ol><li>首先，每次来一个连接都开一个新的线程这肯定是不合适的。当活跃连接数在几十几百的时候当然是可以这样做的，但如果活跃连接数是几万几十万的时候，这么多线程明显就不行了。每个线程都需要一部分内存，内存会被迅速消耗，同时，线程切换的开销非常大。</li><li>其次，阻塞操作在这里也是一个问题。首先，accept() 是一个阻塞操作，当 accept() 返回的时候，代表有一个连接可以使用了，我们这里是马上就新建线程来处理这个 SocketChannel 了，但是，但是这里不代表对方就将数据传输过来了。所以，SocketChannel#read 方法将阻塞，等待数据，明显这个等待是不值得的。同理，write 方法也需要等待通道可写才能执行写入操作，这边的阻塞等待也是不值得的。</li></ol><h2 id="非阻塞-IO"><a href="#非阻塞-IO" class="headerlink" title="非阻塞 IO"></a>非阻塞 IO</h2><p>说完了阻塞模式的使用及其缺点以后，我们这里就可以介绍非阻塞 IO 了。</p><p>非阻塞 IO 的核心在于使用一个 Selector 来管理多个通道，可以是 SocketChannel，也可以是 ServerSocketChannel，将各个通道注册到 Selector 上，指定监听的事件。</p><p>之后可以只用一个线程来轮询这个 Selector，看看上面是否有通道是准备好的，当通道准备好可读或可写，然后才去开始真正的读写，这样速度就很快了。我们就完全没有必要给每个通道都起一个线程。</p><p>NIO 中 Selector 是对底层操作系统实现的一个抽象，管理通道状态其实都是底层系统实现的，这里简单介绍下在不同系统下的实现。</p><p>select：上世纪 80 年代就实现了，它支持注册 FD_SETSIZE(1024) 个 socket，在那个年代肯定是够用的，不过现在嘛，肯定是不行了。</p><p>poll：1997 年，出现了 poll 作为 select 的替代者，最大的区别就是，poll 不再限制 socket 数量。</p><p>select 和 poll 都有一个共同的问题，那就是它们都只会告诉你有几个通道准备好了，但是不会告诉你具体是哪几个通道。所以，一旦知道有通道准备好以后，自己还是需要进行一次扫描，显然这个不太好，通道少的时候还行，一旦通道的数量是几十万个以上的时候，扫描一次的时间都很可观了，时间复杂度 O(n)。所以，后来才催生了以下实现。</p><p>epoll：2002 年随 Linux 内核 2.5.44 发布，epoll 能直接返回具体的准备好的通道，时间复杂度 O(1)。</p><p>除了 Linux 中的 epoll，2000 年 FreeBSD 出现了 Kqueue，还有就是，Solaris 中有 /dev/poll。</p><blockquote><p>前面说了那么多实现，但是没有出现 Windows，Windows 平台的非阻塞 IO 使用 select，我们也不必觉得 Windows 很落后，在 Windows 中 IOCP 提供的异步 IO 是比较强大的。</p></blockquote><p>我们回到 Selector，毕竟 JVM 就是这么一个屏蔽底层实现的平台，我们面向 Selector 编程就可以了。</p><p>之前在介绍 Selector 的时候已经了解过了它的基本用法，这边来一个可运行的实例代码，大家不妨看看：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class SelectorServer &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) throws IOException &#123;</span><br><span class="line">        Selector selector = Selector.<span class="built_in">open</span>();</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel server = ServerSocketChannel.<span class="built_in">open</span>();</span><br><span class="line">        server.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将其注册到 Selector 中，监听 OP_ACCEPT 事件</span></span><br><span class="line">        server.configureBlocking(false);</span><br><span class="line">        server.<span class="keyword">register</span>(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">while</span> (true) &#123;</span><br><span class="line">            <span class="keyword">int</span> readyChannels = selector.select();</span><br><span class="line">            <span class="built_in">if</span> (readyChannels == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;SelectionKey&gt; readyKeys = selector.selectedKeys();</span><br><span class="line">            <span class="comment">// 遍历</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = readyKeys.iterator();</span><br><span class="line">            <span class="built_in">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                iterator.<span class="built_in">remove</span>();</span><br><span class="line"></span><br><span class="line">                <span class="built_in">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">// 有已经接受的新的到服务端的连接</span></span><br><span class="line">                    SocketChannel socketChannel = server.accept();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 有新的连接并不代表这个通道就有数据，</span></span><br><span class="line">                    <span class="comment">// 这里将这个新的 SocketChannel 注册到 Selector，监听 OP_READ 事件，等待数据</span></span><br><span class="line">                    socketChannel.configureBlocking(false);</span><br><span class="line">                    socketChannel.<span class="keyword">register</span>(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="built_in">else</span> <span class="built_in">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">// 有数据可读</span></span><br><span class="line">                    <span class="comment">// 上面一个 if 分支中注册了监听 OP_READ 事件的 SocketChannel</span></span><br><span class="line">                    SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">                    ByteBuffer readBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="keyword">int</span> num = socketChannel.<span class="built_in">read</span>(readBuffer);</span><br><span class="line">                    <span class="built_in">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 处理进来的数据...</span></span><br><span class="line">                        System.out.<span class="built_in">println</span>(<span class="string">"收到数据："</span> + <span class="keyword">new</span> <span class="keyword">String</span>(readBuffer.<span class="keyword">array</span>()).trim());</span><br><span class="line">                        ByteBuffer <span class="built_in">buffer</span> = ByteBuffer.wrap(<span class="string">"返回给客户端的数据..."</span>.getBytes());</span><br><span class="line">                        socketChannel.<span class="built_in">write</span>(<span class="built_in">buffer</span>);</span><br><span class="line">                    &#125; <span class="built_in">else</span> <span class="built_in">if</span> (num == <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="comment">// -1 代表连接已经关闭</span></span><br><span class="line">                        socketChannel.<span class="built_in">close</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于客户端，大家可以继续使用上一节介绍阻塞模式时的客户端进行测试。</p><h2 id="NIO-2-异步-IO"><a href="#NIO-2-异步-IO" class="headerlink" title="NIO.2 异步 IO"></a>NIO.2 异步 IO</h2><p>More New IO，或称 NIO.2，随 JDK 1.7 发布，包括了引入异步 IO 接口和 Paths 等文件访问接口。</p><p>异步这个词，我想对于绝大多数开发者来说都很熟悉，很多场景下我们都会使用异步。</p><p>通常，我们会有一个线程池用于执行异步任务，提交任务的线程将任务提交到线程池就可以立马返回，不必等到任务真正完成。如果想要知道任务的执行结果，通常是通过传递一个回调函数的方式，任务结束后去调用这个函数。</p><p>同样的原理，Java 中的异步 IO 也是一样的，都是由一个线程池来负责执行任务，然后使用回调或自己去查询结果。</p><p>大部分开发者都知道为什么要这么设计了，这里再啰嗦一下。异步 IO 主要是为了控制线程数量，减少过多的线程带来的内存消耗和 CPU 在线程调度上的开销。</p><p>在 Unix/Linux 等系统中，JDK 使用了并发包中的线程池来管理任务，具体可以查看 AsynchronousChannelGroup 的源码。</p><p>在 Windows 操作系统中，提供了一个叫做 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365198.aspx" target="_blank" rel="noopener">I/O Completion Ports</a> 的方案，通常简称为 IOCP，操作系统负责管理线程池，其性能非常优异，所以在 Windows 中 JDK 直接采用了 IOCP 的支持，使用系统支持，把更多的操作信息暴露给操作系统，也使得操作系统能够对我们的 IO 进行一定程度的优化。</p><blockquote><p>在 Linux 中其实也是有异步 IO 系统实现的，但是限制比较多，性能也一般，所以 JDK 采用了自建线程池的方式。</p></blockquote><p>本文还是以实用为主，想要了解更多信息请自行查找其他资料，下面对 Java 异步 IO 进行实践性的介绍。</p><p>总共有三个类需要我们关注，分别是 AsynchronousSocketChannel，AsynchronousServerSocketChannel 和 AsynchronousFileChannel，只不过是在之前介绍的 FileChannel、SocketChannel 和 ServerSocketChannel 的类名上加了个前缀 Asynchronous。</p><p>Java 异步 IO 提供了两种使用方式，分别是返回 Future 实例和使用回调函数。</p><h3 id="1、返回-Future-实例"><a href="#1、返回-Future-实例" class="headerlink" title="1、返回 Future 实例"></a>1、返回 Future 实例</h3><p>返回 java.util.concurrent.Future 实例的方式我们应该很熟悉，JDK 线程池就是这么使用的。Future 接口的几个方法语义在这里也是通用的，这里先做简单介绍。</p><ul><li><p>future.isDone();</p><p>判断操作是否已经完成，包括了正常完成、异常抛出、取消</p></li><li><p>future.cancel(true);</p><p>取消操作，方式是中断。参数 true 说的是，即使这个任务正在执行，也会进行中断。</p></li><li><p>future.isCancelled();</p><p>是否被取消，只有在任务正常结束之前被取消，这个方法才会返回 true</p></li><li><p>future.get();</p><p>这是我们的老朋友，获取执行结果，阻塞。</p></li><li><p>future.get(10, TimeUnit.SECONDS);</p><p>如果上面的 get() 方法的阻塞你不满意，那就设置个超时时间。</p></li></ul><h3 id="2、提供-CompletionHandler-回调函数"><a href="#2、提供-CompletionHandler-回调函数" class="headerlink" title="2、提供 CompletionHandler 回调函数"></a>2、提供 CompletionHandler 回调函数</h3><p>java.nio.channels.CompletionHandler 接口定义：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>CompletionHandler&lt;V,A&gt; &#123;</span><br><span class="line"></span><br><span class="line">    void completed(V result, A attachment);</span><br><span class="line"></span><br><span class="line">    void failed(Throwable exc, A attachment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，参数上有个 attachment，虽然不常用，我们可以在各个支持的方法中传递这个参数值</p></blockquote><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AsynchronousServerSocketChannel listener = AsynchronousServerSocketChannel.<span class="built_in">open</span>().bind(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// accept 方法的第一个参数可以传递 attachment</span></span><br><span class="line">listener.accept(attachment, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, <span class="keyword">Object</span>&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> completed(</span><br><span class="line">      AsynchronousSocketChannel client, <span class="keyword">Object</span> attachment) &#123;</span><br><span class="line">          <span class="comment">//</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> failed(Throwable exc, <span class="keyword">Object</span> attachment) &#123;</span><br><span class="line">          <span class="comment">//</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="AsynchronousFileChannel"><a href="#AsynchronousFileChannel" class="headerlink" title="AsynchronousFileChannel"></a>AsynchronousFileChannel</h3><p>网上关于 Non-Blocking IO 的介绍文章很多，但是 Asynchronous IO 的文章相对就少得多了，所以我这边会多介绍一些相关内容。</p><p>首先，我们就来关注异步的文件 IO，前面我们说了，文件 IO 在所有的操作系统中都不支持非阻塞模式，但是我们可以对文件 IO 采用异步的方式来提高性能。</p><p>下面，我会介绍 AsynchronousFileChannel 里面的一些重要的接口，都很简单，读者要是觉得无趣，直接滑到下一个标题就可以了。</p><p>实例化：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AsynchronousFileChannel channel = AsynchronousFileChannel.<span class="built_in">open</span>(Paths.<span class="built_in">get</span>(<span class="string">"/Users/hongjie/test.txt"</span>));</span><br></pre></td></tr></table></figure><p>一旦实例化完成，我们就可以着手准备将数据读入到 Buffer 中：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ByteBuffer </span><span class="keyword">buffer </span>= <span class="keyword">ByteBuffer.allocate(1024);</span></span><br><span class="line"><span class="keyword">Future&lt;Integer&gt; </span>result = channel.read(<span class="keyword">buffer, </span><span class="number">0</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><blockquote><p>异步文件通道的读操作和写操作都需要提供一个文件的开始位置，文件开始位置为 0</p></blockquote><p>除了使用返回 Future 实例的方式，也可以采用回调函数进行操作，接口如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> &lt;A&gt; <span class="keyword">void</span> read(ByteBuffer dst,</span><br><span class="line">                              <span class="keyword">long</span> position,</span><br><span class="line">                              A attachment,</span><br><span class="line">                              CompletionHandler&lt;Integer,? <span class="keyword">super</span> A&gt; <span class="keyword">handler</span>);</span><br></pre></td></tr></table></figure><p>顺便也贴一下写操作的两个版本的接口：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Future&lt;Integer&gt; write(ByteBuffer src, <span class="keyword">long</span> position);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> &lt;A&gt; <span class="keyword">void</span> write(ByteBuffer src,</span><br><span class="line">                               <span class="keyword">long</span> position,</span><br><span class="line">                               A attachment,</span><br><span class="line">                               CompletionHandler&lt;Integer,? <span class="keyword">super</span> A&gt; <span class="keyword">handler</span>);</span><br></pre></td></tr></table></figure><p>我们可以看到，AIO 的读写主要也还是与 Buffer 打交道，这个与 NIO 是一脉相承的。</p><p>另外，还提供了用于将内存中的数据刷入到磁盘的方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">void</span> <span class="title">force</span><span class="params">(<span class="keyword">boolean</span> metaData)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><blockquote><p>因为我们对文件的写操作，操作系统并不会直接针对文件操作，系统会缓存，然后周期性地刷入到磁盘。如果希望将数据及时写入到磁盘中，以免断电引发部分数据丢失，可以调用此方法。参数如果设置为 true，意味着同时也将文件属性信息更新到磁盘。</p></blockquote><p>还有，还提供了对文件的锁定功能，我们可以锁定文件的部分数据，这样可以进行排他性的操作。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> abstract Future&lt;FileLock&gt; lock(<span class="keyword">long</span> <span class="built_in">position</span>, <span class="keyword">long</span> <span class="built_in">size</span>, <span class="keyword">boolean</span> shared);</span><br></pre></td></tr></table></figure><blockquote><p>position 是要锁定内容的开始位置，size 指示了要锁定的区域大小，shared 指示需要的是共享锁还是排他锁</p></blockquote><p>当然，也可以使用回调函数的版本：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> &lt;A&gt; <span class="keyword">void</span> lock(<span class="keyword">long</span> position,</span><br><span class="line">                              <span class="keyword">long</span> size,</span><br><span class="line">                              <span class="keyword">boolean</span> shared,</span><br><span class="line">                              A attachment,</span><br><span class="line">                              CompletionHandler&lt;FileLock,? <span class="keyword">super</span> A&gt; <span class="keyword">handler</span>);</span><br></pre></td></tr></table></figure><p>文件锁定功能上还提供了 tryLock 方法，此方法会快速返回结果：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> FileLock tryLock(<span class="keyword">long</span> position, <span class="keyword">long</span> size, <span class="keyword">boolean</span> shared)</span><br><span class="line">    <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><blockquote><p>这个方法很简单，就是尝试去获取锁，如果该区域已被其他线程或其他应用锁住，那么立刻返回 null，否则返回 FileLock 对象。</p></blockquote><p>AsynchronousFileChannel 操作大体上也就以上介绍的这些接口，还是比较简单的，这里就少一些废话早点结束好了。</p><h3 id="AsynchronousServerSocketChannel"><a href="#AsynchronousServerSocketChannel" class="headerlink" title="AsynchronousServerSocketChannel"></a>AsynchronousServerSocketChannel</h3><p>这个类对应的是非阻塞 IO 的 ServerSocketChannel，大家可以类比下使用方式。</p><p>我们就废话少说，用代码说事吧：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javadoop.aio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 实例化，并监听端口</span></span><br><span class="line">        AsynchronousServerSocketChannel server =</span><br><span class="line">                AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> <span class="type">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己定义一个 Attachment 类，用于传递一些信息</span></span><br><span class="line">        Attachment att = <span class="keyword">new</span> <span class="type">Attachment</span>();</span><br><span class="line">        att.setServer(server);</span><br><span class="line"></span><br><span class="line">        server.accept(att, <span class="keyword">new</span> <span class="type">CompletionHandler</span>&lt;AsynchronousSocketChannel, Attachment&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> void completed(AsynchronousSocketChannel client, Attachment att) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SocketAddress clientAddr = client.getRemoteAddress();</span><br><span class="line">                    System.out.println(<span class="string">"收到新的连接："</span> + clientAddr);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 收到新的连接后，server 应该重新调用 accept 方法等待新的连接进来</span></span><br><span class="line">                    att.getServer().accept(att, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">                    Attachment <span class="keyword">new</span><span class="type">Att</span> = <span class="keyword">new</span> <span class="type">Attachment</span>();</span><br><span class="line">                    <span class="keyword">new</span><span class="type">Att</span>.setServer(server);</span><br><span class="line">                    <span class="keyword">new</span><span class="type">Att</span>.setClient(client);</span><br><span class="line">                    <span class="keyword">new</span><span class="type">Att</span>.setReadMode(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">new</span><span class="type">Att</span>.setBuffer(ByteBuffer.allocate(<span class="number">2048</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 这里也可以继续使用匿名实现类，不过代码不好看，所以这里专门定义一个类</span></span><br><span class="line">                    client.read(<span class="keyword">new</span><span class="type">Att</span>.getBuffer(), <span class="keyword">new</span><span class="type">Att</span>, <span class="keyword">new</span> <span class="type">ChannelHandler</span>());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> void failed(Throwable t, Attachment att) &#123;</span><br><span class="line">                System.out.println(<span class="string">"accept failed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 为了防止 main 线程退出</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下 ChannelHandler 类：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package com.javadoop.aio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class ChannelHandler implements CompletionHandler&lt;Integer, Attachment&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> completed(Integer result, Attachment att) &#123;</span><br><span class="line">        <span class="built_in">if</span> (att.isReadMode()) &#123;</span><br><span class="line">            <span class="comment">// 读取来自客户端的数据</span></span><br><span class="line">            ByteBuffer <span class="built_in">buffer</span> = att.getBuffer();</span><br><span class="line">            <span class="built_in">buffer</span>.flip();</span><br><span class="line">            <span class="keyword">byte</span> bytes[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="built_in">buffer</span>.limit()];</span><br><span class="line">            <span class="built_in">buffer</span>.<span class="built_in">get</span>(bytes);</span><br><span class="line">            <span class="keyword">String</span> msg = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="built_in">buffer</span>.<span class="keyword">array</span>()).toString().trim();</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"收到来自客户端的数据: "</span> + msg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 响应客户端请求，返回数据</span></span><br><span class="line">            <span class="built_in">buffer</span>.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="built_in">buffer</span>.<span class="built_in">put</span>(<span class="string">"Response from server!"</span>.getBytes(Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">            att.setReadMode(false);</span><br><span class="line">            <span class="built_in">buffer</span>.flip();</span><br><span class="line">            <span class="comment">// 写数据到客户端也是异步</span></span><br><span class="line">            att.getClient().<span class="built_in">write</span>(<span class="built_in">buffer</span>, att, <span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="built_in">else</span> &#123;</span><br><span class="line">            <span class="comment">// 到这里，说明往客户端写数据也结束了，有以下两种选择:</span></span><br><span class="line">            <span class="comment">// 1\. 继续等待客户端发送新的数据过来</span></span><br><span class="line"><span class="comment">//            att.setReadMode(true);</span></span><br><span class="line"><span class="comment">//            att.getBuffer().clear();</span></span><br><span class="line"><span class="comment">//            att.getClient().read(att.getBuffer(), att, this);</span></span><br><span class="line">            <span class="comment">// 2\. 既然服务端已经返回数据给客户端，断开这次的连接</span></span><br><span class="line">            <span class="built_in">try</span> &#123;</span><br><span class="line">                att.getClient().<span class="built_in">close</span>();</span><br><span class="line">            &#125; <span class="built_in">catch</span> (IOException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> failed(Throwable t, Attachment att) &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"连接断开"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便再贴一下自定义的 Attachment 类：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Attachment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousServerSocketChannel <span class="keyword">server</span>;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousSocketChannel <span class="keyword">client</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isReadMode;</span><br><span class="line">    <span class="keyword">private</span> ByteBuffer buffer;</span><br><span class="line">    <span class="comment">// getter &amp; setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，一个简单的服务端就写好了，接下来可以接收客户端请求了。上面我们用的都是回调函数的方式，读者要是感兴趣，可以试试写个使用 Future 的。</p><h3 id="AsynchronousSocketChannel"><a href="#AsynchronousSocketChannel" class="headerlink" title="AsynchronousSocketChannel"></a>AsynchronousSocketChannel</h3><p>其实，说完上面的 AsynchronousServerSocketChannel，基本上读者也就知道怎么使用 AsynchronousSocketChannel 了，和非阻塞 IO 基本类似。</p><p>这边做个简单演示，这样读者就可以配合之前介绍的 Server 进行测试使用了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.javadoop.aio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="type">String</span>[] args) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        <span class="type">AsynchronousSocketChannel</span> client = <span class="type">AsynchronousSocketChannel</span>.<span class="keyword">open</span>();</span><br><span class="line">          <span class="comment">// 来个 Future 形式的</span></span><br><span class="line">        <span class="type">Future</span>&lt;?&gt; future = client.connect(new <span class="type">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">// 阻塞一下，等待连接成功</span></span><br><span class="line">        future.<span class="keyword">get</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Attachment</span> att = new <span class="type">Attachment</span>();</span><br><span class="line">        att.setClient(client);</span><br><span class="line">        att.setReadMode(<span class="literal">false</span>);</span><br><span class="line">        att.setBuffer(<span class="type">ByteBuffer</span>.allocate(<span class="number">2048</span>));</span><br><span class="line">        byte[] data = <span class="string">"I am obot!"</span>.getBytes();</span><br><span class="line">        att.getBuffer().put(data);</span><br><span class="line">        att.getBuffer().flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步发送数据到服务端</span></span><br><span class="line">        client.write(att.getBuffer(), att, new <span class="type">ClientChannelHandler</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里休息一下再退出，给出足够的时间处理数据</span></span><br><span class="line">        <span class="type">Thread</span>.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>往里面看下 ClientChannelHandler 类：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package com.javadoop.aio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class ClientChannelHandler implements CompletionHandler&lt;Integer, Attachment&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> completed(Integer result, Attachment att) &#123;</span><br><span class="line">        ByteBuffer <span class="built_in">buffer</span> = att.getBuffer();</span><br><span class="line">        <span class="built_in">if</span> (att.isReadMode()) &#123;</span><br><span class="line">            <span class="comment">// 读取来自服务端的数据</span></span><br><span class="line">            <span class="built_in">buffer</span>.flip();</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="built_in">buffer</span>.limit()];</span><br><span class="line">            <span class="built_in">buffer</span>.<span class="built_in">get</span>(bytes);</span><br><span class="line">            <span class="keyword">String</span> msg = <span class="keyword">new</span> <span class="keyword">String</span>(bytes, Charset.forName(<span class="string">"UTF-8"</span>));</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"收到来自服务端的响应数据: "</span> + msg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接下来，有以下两种选择:</span></span><br><span class="line">            <span class="comment">// 1\. 向服务端发送新的数据</span></span><br><span class="line"><span class="comment">//            att.setReadMode(false);</span></span><br><span class="line"><span class="comment">//            buffer.clear();</span></span><br><span class="line"><span class="comment">//            String newMsg = "new message from client";</span></span><br><span class="line"><span class="comment">//            byte[] data = newMsg.getBytes(Charset.forName("UTF-8"));</span></span><br><span class="line"><span class="comment">//            buffer.put(data);</span></span><br><span class="line"><span class="comment">//            buffer.flip();</span></span><br><span class="line"><span class="comment">//            att.getClient().write(buffer, att, this);</span></span><br><span class="line">            <span class="comment">// 2\. 关闭连接</span></span><br><span class="line">            <span class="built_in">try</span> &#123;</span><br><span class="line">                att.getClient().<span class="built_in">close</span>();</span><br><span class="line">            &#125; <span class="built_in">catch</span> (IOException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in">else</span> &#123;</span><br><span class="line">            <span class="comment">// 写操作完成后，会进到这里</span></span><br><span class="line">            att.setReadMode(true);</span><br><span class="line">            <span class="built_in">buffer</span>.<span class="built_in">clear</span>();</span><br><span class="line">            att.getClient().<span class="built_in">read</span>(<span class="built_in">buffer</span>, att, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> failed(Throwable t, Attachment att) &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"服务器无响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码都是可以运行调试的，如果读者碰到问题，请在评论区留言。</p><h3 id="Asynchronous-Channel-Groups"><a href="#Asynchronous-Channel-Groups" class="headerlink" title="Asynchronous Channel Groups"></a>Asynchronous Channel Groups</h3><p>为了知识的完整性，有必要对 group 进行介绍，其实也就是介绍 AsynchronousChannelGroup 这个类。之前我们说过，异步 IO 一定存在一个线程池，这个线程池负责接收任务、处理 IO 事件、回调等。这个线程池就在 group 内部，group 一旦关闭，那么相应的线程池就会关闭。</p><p>AsynchronousServerSocketChannels 和 AsynchronousSocketChannels 是属于 group 的，当我们调用 AsynchronousServerSocketChannel 或 AsynchronousSocketChannel 的 open() 方法的时候，相应的 channel 就属于默认的 group，这个 group 由 JVM 自动构造并管理。</p><p>如果我们想要配置这个默认的 group，可以在 JVM 启动参数中指定以下系统变量：</p><ul><li><p>java.nio.channels.DefaultThreadPool.threadFactory</p><p>此系统变量用于设置 ThreadFactory，它应该是 java.util.concurrent.ThreadFactory 实现类的全限定类名。一旦我们指定了这个 ThreadFactory 以后，group 中的线程就会使用该类产生。</p></li><li><p>java.nio.channels.DefaultThreadPool.initialSize</p><p>此系统变量也很好理解，用于设置线程池的初始大小。</p></li></ul><p>可能你会想要使用自己定义的 group，这样可以对其中的线程进行更多的控制，使用以下几个方法即可：</p><ul><li>AsynchronousChannelGroup.withCachedThreadPool(ExecutorService executor, int initialSize)</li><li>AsynchronousChannelGroup.withFixedThreadPool(int nThreads, ThreadFactory threadFactory)</li><li>AsynchronousChannelGroup.withThreadPool(ExecutorService executor)</li></ul><p>熟悉线程池的读者对这些方法应该很好理解，它们都是 AsynchronousChannelGroup 中的静态方法。</p><p>至于 group 的使用就很简单了，代码一看就懂：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AsynchronousChannelGroup<span class="built_in"> group </span>= AsynchronousChannelGroup</span><br><span class="line">        .withFixedThreadPool(10, Executors.defaultThreadFactory());</span><br><span class="line">AsynchronousServerSocketChannel<span class="built_in"> server </span>= AsynchronousServerSocketChannel.open(group);</span><br><span class="line">AsynchronousSocketChannel<span class="built_in"> client </span>= AsynchronousSocketChannel.open(group);</span><br></pre></td></tr></table></figure><p>AsynchronousFileChannels 不属于 group。但是它们也是关联到一个线程池的，如果不指定，会使用系统默认的线程池，如果想要使用指定的线程池，可以在实例化的时候使用以下方法：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AsynchronousFileChannel open(Path <span class="keyword">file</span>,</span><br><span class="line">                                           Set&lt;? <span class="keyword">extends</span> OpenOption&gt; <span class="keyword">options</span>,</span><br><span class="line">                                           ExecutorService executor,</span><br><span class="line">                                           FileAttribute&lt;?&gt;... attrs) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，异步 IO 就算介绍完成了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我想，本文应该是说清楚了非阻塞 IO 和异步 IO 了，对于异步 IO，由于网上的资料比较少，所以不免篇幅多了些。</p><p>我们也要知道，看懂了这些，确实可以学到一些东西，多了解一些知识，但是我们还是很少在工作中将这些知识变成工程代码。一般而言，我们需要在网络应用中使用 NIO 或 AIO 来提升性能，但是，在工程上，绝不是了解了一些概念，知道了一些接口就可以的，需要处理的细节还非常多。</p><p>这也是为什么 Netty/Mina 如此盛行的原因，因为它们帮助封装好了很多细节，提供给我们用户友好的接口，后面有时间我也会对 Netty 进行介绍。</p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 非阻塞 IO 和异步 IO&lt;/p&gt;
&lt;p&gt;转自&lt;a href=&quot;https://www.javadoop.com/post/nio-and-aio&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.javadoop.com/post/nio-and-aio&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java网络编程和NIO &lt;a href=&quot;https://blog.csdn.net/column/details/21963.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21963.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java网络编程与NIO" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO/"/>
    
    
      <category term="Java网络编程" scheme="http://h2pl.github.io/tags/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="NIO" scheme="http://h2pl.github.io/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程与NIO详解4：浅析NIO包中的Buffer、Channel 和 Selector</title>
    <link href="http://h2pl.github.io/2018/05/25/Javanet4/"/>
    <id>http://h2pl.github.io/2018/05/25/Javanet4/</id>
    <published>2018-05-25T03:53:43.000Z</published>
    <updated>2018-06-02T14:21:39.401Z</updated>
    
    <content type="html"><![CDATA[<p>转自<a href="https://www.javadoop.com/post/nio-and-aio" target="_blank" rel="noopener">https://www.javadoop.com/post/nio-and-aio</a></p><p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java网络编程和NIO <a href="https://blog.csdn.net/column/details/21963.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21963.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><p>Java NIO：Buffer、Channel 和 Selector</p><p>本文将介绍 Java NIO 中三大组件 Buffer、Channel、Selector 的使用。</p><p>本来要一起介绍非阻塞 IO 和 JDK7 的异步 IO 的，不过因为之前的文章真的太长了，有点影响读者阅读，所以这里将它们放到另一篇文章中进行介绍。</p><ul><li><a href="https://www.javadoop.com/post/java-nio?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#Buffer" target="_blank" rel="noopener">Buffer</a><ul><li><a href="https://www.javadoop.com/post/java-nio?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#position%E3%80%81limit%E3%80%81capacity" target="_blank" rel="noopener">position、limit、capacity</a></li><li><a href="https://www.javadoop.com/post/java-nio?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E5%88%9D%E5%A7%8B%E5%8C%96%20Buffer" target="_blank" rel="noopener">初始化 Buffer</a></li><li><a href="https://www.javadoop.com/post/java-nio?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E5%A1%AB%E5%85%85%20Buffer" target="_blank" rel="noopener">填充 Buffer</a></li><li><a href="https://www.javadoop.com/post/java-nio?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E6%8F%90%E5%8F%96%20Buffer%20%E4%B8%AD%E7%9A%84%E5%80%BC" target="_blank" rel="noopener">提取 Buffer 中的值</a></li><li><a href="https://www.javadoop.com/post/java-nio?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#mark(" target="_blank" rel="noopener">mark() &amp; reset()</a>%20%26%20reset())</li><li><a href="https://www.javadoop.com/post/java-nio?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#rewind(" target="_blank" rel="noopener">rewind() &amp; clear() &amp; compact()</a>%20%26%20clear()%20%26%20compact())</li></ul></li><li><a href="https://www.javadoop.com/post/java-nio?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#Channel" target="_blank" rel="noopener">Channel</a><ul><li><a href="https://www.javadoop.com/post/java-nio?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#FileChannel" target="_blank" rel="noopener">FileChannel</a></li><li><a href="https://www.javadoop.com/post/java-nio?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#SocketChannel" target="_blank" rel="noopener">SocketChannel</a></li><li><a href="https://www.javadoop.com/post/java-nio?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#ServerSocketChannel" target="_blank" rel="noopener">ServerSocketChannel</a></li><li><a href="https://www.javadoop.com/post/java-nio?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#DatagramChannel" target="_blank" rel="noopener">DatagramChannel</a></li></ul></li><li><a href="https://www.javadoop.com/post/java-nio?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#Selector" target="_blank" rel="noopener">Selector</a></li><li><a href="https://www.javadoop.com/post/java-nio?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E5%B0%8F%E7%BB%93" target="_blank" rel="noopener">小结</a></li></ul><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>一个 Buffer 本质上是内存中的一块，我们可以将数据写入这块内存，之后从这块内存获取数据。</p><p>java.nio 定义了以下几个 Buffer 的实现，这个图读者应该也在不少地方见过了吧。</p><p><img src="https://www.javadoop.com/blogimages/nio/6.png" alt="6"></p><p>其实核心是最后的 ByteBuffer，前面的一大串类只是包装了一下它而已，我们使用最多的通常也是 ByteBuffer。</p><p>我们应该将 Buffer 理解为一个数组，IntBuffer、CharBuffer、DoubleBuffer 等分别对应 int[]、char[]、double[] 等。</p><p>MappedByteBuffer 用于实现内存映射文件，也不是本文关注的重点。</p><p>我觉得操作 Buffer 和操作数组、类集差不多，只不过大部分时候我们都把它放到了 NIO 的场景里面来使用而已。下面介绍 Buffer 中的几个重要属性和几个重要方法。</p><h3 id="position、limit、capacity"><a href="#position、limit、capacity" class="headerlink" title="position、limit、capacity"></a>position、limit、capacity</h3><p>就像数组有数组容量，每次访问元素要指定下标，Buffer 中也有几个重要属性：position、limit、capacity。</p><p><img src="https://www.javadoop.com/blogimages/nio/5.png" alt="5"></p><p>最好理解的当然是 capacity，它代表这个缓冲区的容量，一旦设定就不可以更改。比如 capacity 为 1024 的 IntBuffer，代表其一次可以存放 1024 个 int 类型的值。一旦 Buffer 的容量达到 capacity，需要清空 Buffer，才能重新写入值。</p><p>position 和 limit 是变化的，我们分别看下读和写操作下，它们是如何变化的。</p><p>position 的初始值是 0，每往 Buffer 中写入一个值，position 就自动加 1，代表下一次的写入位置。读操作的时候也是类似的，每读一个值，position 就自动加 1。</p><p>从写操作模式到读操作模式切换的时候（flip），position 都会归零，这样就可以从头开始读写了。</p><p>Limit：写操作模式下，limit 代表的是最大能写入的数据，这个时候 limit 等于 capacity。写结束后，切换到读模式，此时的 limit 等于 Buffer 中实际的数据大小，因为 Buffer 不一定被写满了。</p><p><img src="https://www.javadoop.com/blogimages/nio/7.png" alt="7"></p><h3 id="初始化-Buffer"><a href="#初始化-Buffer" class="headerlink" title="初始化 Buffer"></a>初始化 Buffer</h3><p>每个 Buffer 实现类都提供了一个静态方法 <code>allocate(int capacity)</code> 帮助我们快速实例化一个 Buffer。如：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBuf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">IntBuffer intBuf = IntBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">LongBuffer longBuf = LongBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>另外，我们经常使用 wrap 方法来初始化一个 Buffer。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(byte[] <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="填充-Buffer"><a href="#填充-Buffer" class="headerlink" title="填充 Buffer"></a>填充 Buffer</h3><p>各个 Buffer 类都提供了一些 put 方法用于将数据填充到 Buffer 中，如 ByteBuffer 中的几个 put 方法：</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 填充一个 byte 值</span><br><span class="line">public abstract <span class="type">ByteBuffer</span> put(byte b);</span><br><span class="line">// 在指定位置填充一个 <span class="built_in">int</span> 值</span><br><span class="line">public abstract <span class="type">ByteBuffer</span> put(<span class="built_in">int</span> index, byte b);</span><br><span class="line">// 将一个数组中的值填充进去</span><br><span class="line">public final <span class="type">ByteBuffer</span> put(byte[] src) <span class="meta">&#123;...&#125;</span></span><br><span class="line">public <span class="type">ByteBuffer</span> put(byte[] src, <span class="built_in">int</span> offset, <span class="built_in">int</span> length) <span class="meta">&#123;...&#125;</span></span><br></pre></td></tr></table></figure><p>上述这些方法需要自己控制 Buffer 大小，不能超过 capacity，超过会抛 java.nio.BufferOverflowException 异常。</p><p>对于 Buffer 来说，另一个常见的操作中就是，我们要将来自 Channel 的数据填充到 Buffer 中，在系统层面上，这个操作我们称为读操作，因为数据是从外部（文件或网络等）读到内存中。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = channel.<span class="built_in">read</span>(buf);</span><br></pre></td></tr></table></figure><p>上述方法会返回从 Channel 中读入到 Buffer 的数据大小。</p><h3 id="提取-Buffer-中的值"><a href="#提取-Buffer-中的值" class="headerlink" title="提取 Buffer 中的值"></a>提取 Buffer 中的值</h3><p>前面介绍了写操作，每写入一个值，position 的值都需要加 1，所以 position 最后会指向最后一次写入的位置的后面一个，如果 Buffer 写满了，那么 position 等于 capacity（position 从 0 开始）。</p><p>如果要读 Buffer 中的值，需要切换模式，从写入模式切换到读出模式。注意，通常在说 NIO 的读操作的时候，我们说的是从 Channel 中读数据到 Buffer 中，对应的是对 Buffer 的写入操作，初学者需要理清楚这个。</p><p>调用 Buffer 的 flip() 方法，可以从写入模式切换到读取模式。其实这个方法也就是设置了一下 position 和 limit 值罢了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer flip() &#123;</span><br><span class="line">    limit = position; <span class="comment">// 将 limit 设置为实际写入的数据数量</span></span><br><span class="line">    position = <span class="number">0</span>; <span class="comment">// 重置 position 为 0</span></span><br><span class="line">    mark = <span class="number">-1</span>; <span class="comment">// mark 之后再说</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应写入操作的一系列 put 方法，读操作提供了一系列的 get 方法：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 position 来获取数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">byte</span> <span class="built_in">get</span>();</span><br><span class="line"><span class="comment">// 获取指定位置的数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">byte</span> <span class="built_in">get</span>(<span class="built_in">int</span> index);</span><br><span class="line"><span class="comment">// 将 Buffer 中的数据写入到数组中</span></span><br><span class="line"><span class="keyword">public</span> ByteBuffer <span class="built_in">get</span>(<span class="built_in">byte</span>[] dst)</span><br></pre></td></tr></table></figure><p>附一个经常使用的方法：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="keyword">String</span>(<span class="built_in">buffer</span>.<span class="keyword">array</span>()).trim();</span><br></pre></td></tr></table></figure><p>当然了，除了将数据从 Buffer 取出来使用，更常见的操作是将我们写入的数据传输到 Channel 中，如通过 FileChannel 将数据写入到文件中，通过 SocketChannel 将数据写入网络发送到远程机器等。对应的，这种操作，我们称之为写操作。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = channel.<span class="built_in">write</span>(buf);</span><br></pre></td></tr></table></figure><h3 id="mark-amp-reset"><a href="#mark-amp-reset" class="headerlink" title="mark() &amp; reset()"></a>mark() &amp; reset()</h3><p>除了 position、limit、capacity 这三个基本的属性外，还有一个常用的属性就是 mark。</p><p>mark 用于临时保存 position 的值，每次调用 mark() 方法都会将 mark 设值为当前的 position，便于后续需要的时候使用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer mark() &#123;</span><br><span class="line">    mark = position;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那到底什么时候用呢？考虑以下场景，我们在 position 为 5 的时候，先 mark() 一下，然后继续往下读，读到第 10 的时候，我想重新回到 position 为 5 的地方重新来一遍，那只要调一下 reset() 方法，position 就回到 5 了。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function">Buffer <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = mark;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">    position = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rewind-amp-clear-amp-compact"><a href="#rewind-amp-clear-amp-compact" class="headerlink" title="rewind() &amp; clear() &amp; compact()"></a>rewind() &amp; clear() &amp; compact()</h3><p>rewind()：会重置 position 为 0，通常用于重新从头读写 Buffer。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer rewind() &#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clear()：有点重置 Buffer 的意思，相当于重新实例化了一样。</p><p>通常，我们会先填充 Buffer，然后从 Buffer 读取数据，之后我们再重新往里填充新的数据，我们一般在重新填充之前先调用 clear()。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer clear() &#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compact()：和 clear() 一样的是，它们都是在准备往 Buffer 填充新的数据之前调用。</p><p>前面说的 clear() 方法会重置几个属性，但是我们要看到，clear() 方法并不会将 Buffer 中的数据清空，只不过后续的写入会覆盖掉原来的数据，也就相当于清空了数据了。</p><p>而 compact() 方法有点不一样，调用这个方法以后，会先处理还没有读取的数据，也就是 position 到 limit 之间的数据（还没有读过的数据），先将这些数据移到左边，然后在这个基础上再开始写入。很明显，此时 limit 还是等于 capacity，position 指向原来数据的右边。</p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>所有的 NIO 操作始于通道，通道是数据来源或数据写入的目的地，主要地，我们将关心 java.nio 包中实现的以下几个 Channel：</p><p><img src="https://www.javadoop.com/blogimages/nio/8.png" alt="8"></p><ul><li>FileChannel：文件通道，用于文件的读和写</li><li>DatagramChannel：用于 UDP 连接的接收和发送</li><li>SocketChannel：把它理解为 TCP 连接通道，简单理解就是 TCP 客户端</li><li>ServerSocketChannel：TCP 对应的服务端，用于监听某个端口进来的请求</li></ul><p>这里不是很理解这些也没关系，后面介绍了代码之后就清晰了。还有，我们最应该关注，也是后面将会重点介绍的是 SocketChannel 和 ServerSocketChannel。</p><p>Channel 经常翻译为通道，类似 IO 中的流，用于读取和写入。它与前面介绍的 Buffer 打交道，读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。</p><p><img src="https://www.javadoop.com/blogimages/nio/9.png" alt="9"></p><p><img src="https://www.javadoop.com/blogimages/nio/10.png" alt="10"></p><p>至少读者应该记住一点，这两个方法都是 channel 实例的方法。</p><h3 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h3><p>我想文件操作对于大家来说应该是最熟悉的，不过我们在说 NIO 的时候，其实 FileChannel 并不是关注的重点。而且后面我们说非阻塞的时候会看到，FileChannel 是不支持非阻塞的。</p><p>这里算是简单介绍下常用的操作吧，感兴趣的读者瞄一眼就是了。</p><p>初始化：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">FileInputStream inputStream</span> = new FileInputStream(new File(<span class="string">"/data.txt"</span>));</span><br><span class="line"><span class="attribute">FileChannel fileChannel</span> = inputStream.getChannel();</span><br></pre></td></tr></table></figure><p>当然了，我们也可以从 RandomAccessFile#getChannel 来得到 FileChannel。</p><p>读取文件内容：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer <span class="built_in">buffer</span> = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = fileChannel.<span class="built_in">read</span>(<span class="built_in">buffer</span>);</span><br></pre></td></tr></table></figure><p>前面我们也说了，所有的 Channel 都是和 Buffer 打交道的。</p><p>写入文件内容：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer <span class="built_in">buffer</span> = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="built_in">buffer</span>.<span class="built_in">put</span>(<span class="string">"随机写入一些内容到 Buffer 中"</span>.getBytes());</span><br><span class="line"><span class="comment">// Buffer 切换为读模式</span></span><br><span class="line"><span class="built_in">buffer</span>.flip();</span><br><span class="line"><span class="built_in">while</span>(<span class="built_in">buffer</span>.hasRemaining()) &#123;</span><br><span class="line">    <span class="comment">// 将 Buffer 中的内容写入文件</span></span><br><span class="line">    fileChannel.<span class="built_in">write</span>(<span class="built_in">buffer</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h3><p>我们前面说了，我们可以将 SocketChannel 理解成一个 TCP 客户端。虽然这么理解有点狭隘，因为我们在介绍 ServerSocketChannel 的时候会看到另一种使用方式。</p><p>打开一个 TCP 连接：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.<span class="built_in">open</span>(<span class="keyword">new</span> InetSocketAddress(<span class="string">"https://www.javadoop.com"</span>, <span class="number">80</span>));</span><br></pre></td></tr></table></figure><p>当然了，上面的这行代码等价于下面的两行：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开一个通道</span></span><br><span class="line">SocketChannel socketChannel = SocketChannel.<span class="built_in">open</span>();</span><br><span class="line"><span class="comment">// 发起连接</span></span><br><span class="line">socketChannel.<span class="built_in">connect</span>(<span class="keyword">new</span> InetSocketAddress(<span class="string">"https://www.javadoop.com"</span>, <span class="number">80</span>));</span><br></pre></td></tr></table></figure><p>SocketChannel 的读写和 FileChannel 没什么区别，就是操作缓冲区。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line">socketChannel.<span class="built_in">read</span>(<span class="built_in">buffer</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入数据到网络连接中</span></span><br><span class="line"><span class="built_in">while</span>(<span class="built_in">buffer</span>.hasRemaining()) &#123;</span><br><span class="line">    socketChannel.<span class="built_in">write</span>(<span class="built_in">buffer</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要在这里停留太久，先继续往下走。</p><h3 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h3><p>之前说 SocketChannel 是 TCP 客户端，这里说的 ServerSocketChannel 就是对应的服务端。</p><p>ServerSocketChannel 用于监听机器端口，管理从这个端口进来的 TCP 连接。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化</span></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.<span class="keyword">open</span>();</span><br><span class="line"><span class="comment">// 监听 8080 端口</span></span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 一旦有一个 TCP 连接进来，就对应创建一个 SocketChannel 进行处理</span></span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里我们可以看到 SocketChannel 的第二个实例化方式</p></blockquote><p>到这里，我们应该能理解 SocketChannel 了，它不仅仅是 TCP 客户端，它代表的是一个网络通道，可读可写。</p><p>ServerSocketChannel 不和 Buffer 打交道了，因为它并不实际处理数据，它一旦接收到请求后，实例化 SocketChannel，之后在这个连接通道上的数据传递它就不管了，因为它需要继续监听端口，等待下一个连接。</p><h3 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h3><p>UDP 和 TCP 不一样，DatagramChannel 一个类处理了服务端和客户端。</p><blockquote><p>科普一下，UDP 是面向无连接的，不需要和对方握手，不需要通知对方，就可以直接将数据包投出去，至于能不能送达，它是不知道的</p></blockquote><p>监听端口：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DatagramChannel channel = DatagramChannel.open()<span class="comment">;</span></span><br><span class="line">channel.socket().<span class="keyword">bind(new </span>InetSocketAddress(<span class="number">9090</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ByteBuffer </span><span class="keyword">buf </span>= <span class="keyword">ByteBuffer.allocate(48);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">channel.receive(buf);</span></span><br></pre></td></tr></table></figure><p>发送数据：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String newData = <span class="string">"New String to write to file..."</span></span><br><span class="line">                    + System.currentTimeMillis()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ByteBuffer </span><span class="keyword">buf </span>= <span class="keyword">ByteBuffer.allocate(48);</span></span><br><span class="line"><span class="keyword">buf.put(newData.getBytes());</span></span><br><span class="line"><span class="keyword">buf.flip();</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">int </span><span class="keyword">bytesSent </span>= channel.send(<span class="keyword">buf, </span>new InetSocketAddress(<span class="string">"jenkov.com"</span>, <span class="number">80</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>NIO 三大组件就剩 Selector 了，Selector 建立在非阻塞的基础之上，大家经常听到的 多路复用 在 Java 世界中指的就是它，用于实现一个线程管理多个 Channel。</p><p>读者在这一节不能消化 Selector 也没关系，因为后续在介绍非阻塞 IO 的时候还得说到这个，这里先介绍一些基本的接口操作。</p><ol><li><p>首先，我们开启一个 Selector。你们爱翻译成选择器也好，多路复用器也好。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Selector</span> <span class="keyword">selector</span> = <span class="keyword">Selector</span>.open();</span><br></pre></td></tr></table></figure></li><li><p>将 Channel 注册到 Selector 上。前面我们说了，Selector 建立在非阻塞模式之上，所以注册到 Selector 的 Channel 必须要支持非阻塞模式，FileChannel 不支持非阻塞，我们这里讨论最常见的 SocketChannel 和 ServerSocketChannel。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将通道设置为非阻塞模式，因为默认都是阻塞模式的</span></span><br><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line">SelectionKey key = channel.<span class="keyword">register</span>(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure><p>register 方法的第二个 int 型参数（使用二进制的标记位）用于表明需要监听哪些感兴趣的事件，共以下四种事件：</p><ul><li><p>SelectionKey.OP_READ</p><blockquote><p>对应 00000001，通道中有数据可以进行读取</p></blockquote></li><li><p>SelectionKey.OP_WRITE</p><blockquote><p>对应 00000100，可以往通道中写入数据</p></blockquote></li><li><p>SelectionKey.OP_CONNECT</p><blockquote><p>对应 00001000，成功建立 TCP 连接</p></blockquote></li><li><p>SelectionKey.OP_ACCEPT</p><blockquote><p>对应 00010000，接受 TCP 连接</p></blockquote></li></ul><p>我们可以同时监听一个 Channel 中的发生的多个事件，比如我们要监听 ACCEPT 和 READ 事件，那么指定参数为二进制的 00010001 即十进制数值 17 即可。</p><p>注册方法返回值是 SelectionKey 实例，它包含了 Channel 和 Selector 信息，也包括了一个叫做 Interest Set 的信息，即我们设置的我们感兴趣的正在监听的事件集合。</p></li><li><p>调用 select() 方法获取通道信息。用于判断是否有我们感兴趣的事件已经发生了。</p></li></ol><p>Selector 的操作就是以上 3 步，这里来一个简单的示例，大家看一下就好了。之后在介绍非阻塞 IO 的时候，会演示一份可执行的示例代码。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.<span class="built_in">open</span>();</span><br><span class="line"></span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">SelectionKey <span class="built_in">key</span> = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断是否有事件准备好</span></span><br><span class="line">  <span class="built_in">int</span> readyChannels = selector.select();</span><br><span class="line">  <span class="keyword">if</span>(readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历</span></span><br><span class="line">  Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">  Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line">  <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey <span class="built_in">key</span> = keyIterator.next();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">key</span>.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">key</span>.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">key</span>.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">key</span>.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyIterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Selector，我们还需要非常熟悉以下几个方法：</p><ol><li><p>select()</p><p>调用此方法，会将上次 select 之后的准备好的 channel 对应的 SelectionKey 复制到 selected set 中。如果没有任何通道准备好，这个方法会阻塞，直到至少有一个通道准备好。</p></li><li><p>selectNow()</p><p>功能和 select 一样，区别在于如果没有准备好的通道，那么此方法会立即返回 0。</p></li><li><p>select(long timeout)</p><p>看了前面两个，这个应该很好理解了，如果没有通道准备好，此方法会等待一会</p></li><li><p>wakeup()</p><p>这个方法是用来唤醒等待在 select() 和 select(timeout) 上的线程的。如果 wakeup() 先被调用，此时没有线程在 select 上阻塞，那么之后的一个 select() 或 select(timeout) 会立即返回，而不会阻塞，当然，它只会作用一次。</p></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到此为止，介绍了 Buffer、Channel 和 Selector 的常见接口。</p><p>Buffer 和数组差不多，它有 position、limit、capacity 几个重要属性。put() 一下数据、flip() 切换到读模式、然后用 get() 获取数据、clear() 一下清空数据、重新回到 put() 写入数据。</p><p>Channel 基本上只和 Buffer 打交道，最重要的接口就是 channel.read(buffer) 和 channel.write(buffer)。</p><p>Selector 用于实现非阻塞 IO，这里仅仅介绍接口使用，后续请关注非阻塞 IO 的介绍。</p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自&lt;a href=&quot;https://www.javadoop.com/post/nio-and-aio&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.javadoop.com/post/nio-and-aio&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java网络编程和NIO &lt;a href=&quot;https://blog.csdn.net/column/details/21963.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21963.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java网络编程与NIO" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO/"/>
    
    
      <category term="Java网络编程" scheme="http://h2pl.github.io/tags/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="NIO" scheme="http://h2pl.github.io/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程和NIO详解3：IO模型与Java网络编程模型</title>
    <link href="http://h2pl.github.io/2018/05/25/Javanet3/"/>
    <id>http://h2pl.github.io/2018/05/25/Javanet3/</id>
    <published>2018-05-25T03:53:40.000Z</published>
    <updated>2018-06-02T14:21:44.650Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java网络编程和NIO <a href="https://blog.csdn.net/column/details/21963.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21963.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><h2 id="基本概念说明"><a href="#基本概念说明" class="headerlink" title="基本概念说明"></a>基本概念说明</h2><p>用户空间与内核空间</p><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p><p>进程切换</p><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p><p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p><ul><li>保存处理机上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。 选择另一个进程执行，并更新其PCB。</li><li>更新内存管理的数据结构。</li><li>恢复处理机上下文。</li></ul><p>进程的阻塞</p><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。</p><p>文件描述符</p><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p><p>缓存 IO</p><p>缓存 IO 又被称作标准 IO，大多数文件系统的默认 IO 操作都是缓存 IO。在 Linux 的缓存 IO 机制中，操作系统会将 IO 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p><p>缓存 IO 的缺点：</p><p>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p><h2 id="IO模型介绍"><a href="#IO模型介绍" class="headerlink" title="IO模型介绍"></a>IO模型介绍</h2><p>作者：cooffeelis<br>链接：<a href="https://www.jianshu.com/p/511b9cffbdac" target="_blank" rel="noopener">https://www.jianshu.com/p/511b9cffbdac</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>常用的5种IO模型:<br>blocking IO<br>nonblocking IO<br>IO multiplexing<br>signal driven IO<br>asynchronous IO</p><p>再说一下IO发生时涉及的对象和步骤:</p><p><strong><em>对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象：</em></strong></p><ul><li>一个是调用这个IO的process (or thread)</li><li>一个就是系统内核(kernel)</li></ul><p><strong><em>当一个read操作发生时，它会经历两个阶段：</em></strong></p><ul><li>等待数据准备,比如accept(), recv()等待数据 <code>(Waiting for the data to be ready)</code></li><li>将数据从内核拷贝到进程中, 比如 accept()接受到请求,recv()接收连接发送的数据后需要复制到内核,再从内核复制到进程用户空间<code>(Copying the data from the kernel to the process)</code></li></ul><p><strong><em>对于socket流而言,数据的流向经历两个阶段：</em></strong></p><ul><li>第一步通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。</li><li>第二步把数据从内核缓冲区复制到应用进程缓冲区。</li></ul><p>记住这两点很重要，因为这些IO Model的区别就是在两个阶段上各有不同的情况。</p><h3 id="阻塞-I-O（blocking-IO）"><a href="#阻塞-I-O（blocking-IO）" class="headerlink" title="阻塞 I/O（blocking IO）"></a>阻塞 I/O（blocking IO）</h3><hr><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</p><p><img src="https://upload-images.jianshu.io/upload_images/1446087-9522cafa9e14abd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/552" alt=""></p><p>阻塞IO流程</p><p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到<strong>操作系统内核的缓冲区</strong>中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会<strong>将数据从kernel中拷贝到用户内存</strong>，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p><blockquote><p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p></blockquote><h3 id="非阻塞-I-O（nonblocking-IO）"><a href="#非阻塞-I-O（nonblocking-IO）" class="headerlink" title="非阻塞 I/O（nonblocking IO）"></a>非阻塞 I/O（nonblocking IO）</h3><hr><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p><p><img src="https://upload-images.jianshu.io/upload_images/1446087-0c604ff4a2d8dc5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/603" alt=""></p><p>非阻塞 I/O 流程</p><p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，<strong>那么它并不会block用户进程，而是立刻返回一个error</strong>。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p><blockquote><p>所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。</p></blockquote><p><strong><em>值得注意的是,此时的非阻塞IO只是应用到等待数据上,当真正有数据到达执行recvfrom的时候,还是同步阻塞IO来的, 从图中的copy data from kernel to user可以看出 </em></strong></p><h3 id="I-O-多路复用（-IO-multiplexing）"><a href="#I-O-多路复用（-IO-multiplexing）" class="headerlink" title="I/O 多路复用（ IO multiplexing）"></a>I/O 多路复用（ IO multiplexing）</h3><hr><p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p><p><img src="https://upload-images.jianshu.io/upload_images/1446087-3b0399b077daf0a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/609" alt=""></p><p>I/O 多路复用流程</p><p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p><blockquote><p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p></blockquote><p>IO复用的实现方式目前主要有select、poll和epoll。</p><p>select和poll的原理基本相同：</p><ul><li>注册待侦听的fd(这里的fd创建时最好使用非阻塞)</li><li>每次调用都去检查这些fd的状态，当有一个或者多个fd就绪的时候返回</li><li>返回结果中包括已就绪和未就绪的fd</li></ul><p>相比select，poll解决了单个进程能够打开的文件描述符数量有限制这个问题：select受限于FD_SIZE的限制，如果修改则需要修改这个宏重新编译内核；而poll通过一个pollfd数组向内核传递需要关注的事件，避开了文件描述符数量限制。</p><p>此外，select和poll共同具有的一个很大的缺点就是包含大量fd的数组被整体复制于用户态和内核态地址空间之间，开销会随着fd数量增多而线性增大。</p><p>select和poll就类似于上面说的就餐方式。但当你每次都去询问时，老板会把所有你点的饭菜都轮询一遍再告诉你情况，当大量饭菜很长时间都不能准备好的情况下是很低效的。于是，老板有些不耐烦了，就让厨师每做好一个菜就通知他。这样每次你再去问的时候，他会直接把已经准备好的菜告诉你，你再去端。这就是事件驱动IO就绪通知的方式-epoll。</p><p>epoll的出现，解决了select、poll的缺点：</p><ul><li>基于事件驱动的方式，避免了每次都要把所有fd都扫描一遍。</li><li>epoll_wait只返回就绪的fd。</li><li>epoll使用nmap内存映射技术避免了内存复制的开销。</li><li>epoll的fd数量上限是操作系统的最大文件句柄数目,这个数目一般和内存有关，通常远大于1024。</li></ul><p>目前，epoll是Linux2.6下最高效的IO复用方式，也是Nginx、Node的IO实现方式。而在freeBSD下，kqueue是另一种类似于epoll的IO复用方式。</p><p>此外，对于IO复用还有一个水平触发和边缘触发的概念：</p><ul><li>水平触发：当就绪的fd未被用户进程处理后，下一次查询依旧会返回，这是select和poll的触发方式。</li><li>边缘触发：无论就绪的fd是否被处理，下一次不再返回。理论上性能更高，但是实现相当复杂，并且任何意外的丢失事件都会造成请求处理错误。epoll默认使用水平触发，通过相应选项可以使用边缘触发。</li></ul><blockquote><p>点评：<br><strong><em>I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，</em></strong>而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。<br><strong><em>所以, IO多路复用，本质上不会有并发的功能，因为任何时候还是只有一个进程或线程进行工作，它之所以能提高效率是因为select\epoll 把进来的socket放到他们的 ‘监视’ 列表里面，当任何socket有可读可写数据立马处理，那如果select\epoll 手里同时检测着很多socket， 一有动静马上返回给进程处理，总比一个一个socket过来,阻塞等待,处理高效率。</em></strong><br>当然也可以多线程/多进程方式，一个连接过来开一个进程/线程处理，这样消耗的内存和进程切换页会耗掉更多的系统资源。<br>所以我们可以结合IO多路复用和多进程/多线程 来高性能并发，IO复用负责提高接受socket的通知效率，收到请求后，交给进程池/线程池来处理逻辑。</p><h3 id="信号驱动"><a href="#信号驱动" class="headerlink" title="信号驱动"></a>信号驱动</h3><p>上文的就餐方式还是需要你每次都去问一下饭菜状况。于是，你再次不耐烦了，就跟老板说，哪个饭菜好了就通知我一声吧。然后就自己坐在桌子那里干自己的事情。更甚者，你可以把手机号留给老板，自己出门，等饭菜好了直接发条短信给你。这就类似信号驱动的IO模型。</p><p><img src="http://www.rowkey.me/images/blog_images/io/sigio.png" alt="bio"></p><p>流程如下：</p><ul><li>开启套接字信号驱动IO功能</li><li>系统调用sigaction执行信号处理函数（非阻塞，立刻返回）</li><li>数据就绪，生成sigio信号，通过信号回调通知应用来读取数据。</li></ul><p>此种io方式存在的一个很大的问题：Linux中信号队列是有限制的，如果超过这个数字问题就无法读取数据。</p><h3 id="异步非阻塞"><a href="#异步非阻塞" class="headerlink" title="异步非阻塞"></a>异步非阻塞</h3></blockquote><h3 id="异步-I-O（asynchronous-IO）"><a href="#异步-I-O（asynchronous-IO）" class="headerlink" title="异步 I/O（asynchronous IO）"></a>异步 I/O（asynchronous IO）</h3><hr><p>linux下的asynchronous IO其实用得很少。先看一下它的流程：</p><p><img src="https://upload-images.jianshu.io/upload_images/1446087-e707464b299104e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/572" alt=""></p><p>异步IO 流程</p><p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p><h2 id="阻塞IO-非阻塞IO-与-同步IO-异步IO的区别和联系"><a href="#阻塞IO-非阻塞IO-与-同步IO-异步IO的区别和联系" class="headerlink" title="阻塞IO,非阻塞IO 与 同步IO, 异步IO的区别和联系"></a>阻塞IO,非阻塞IO 与 同步IO, 异步IO的区别和联系</h2><h5 id="阻塞IO-VS-非阻塞IO："><a href="#阻塞IO-VS-非阻塞IO：" class="headerlink" title="阻塞IO VS 非阻塞IO："></a>阻塞IO VS 非阻塞IO：</h5><p>概念：<br>阻塞和非阻塞关注的是<strong>程序在等待调用结果（消息，返回值）时的状态.</strong><br>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><p>例子：你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p><hr><p>分析：<br>阻塞IO会一直block住对应的进程直到操作完成，而非阻塞IO在kernel还准备数据的情况下会立刻返回。</p><h5 id="同步IO-VS-异步IO："><a href="#同步IO-VS-异步IO：" class="headerlink" title="同步IO VS 异步IO："></a>同步IO VS 异步IO：</h5><p>概念：<br>同步与异步同步和异步关注的是<strong>_消息通信机制 _</strong>(synchronous communication/ asynchronous communication)所谓同步，就是在发出一个_调用<em>时，在没有得到结果之前，该</em>调用<em>就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由</em>调用者<em>主动等待这个</em>调用<em>的结果。而异步则是相反，</em>调用<em>在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在</em>调用<em>发出后，</em>被调用者_通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p><p>典型的异步编程模型比如Node.js举个通俗的例子：你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p><hr><p>分析：<br>在说明同步IO和异步IO的区别之前，需要先给出两者的定义。Stevens给出的定义（其实是POSIX的定义）是这样子的：</p><blockquote><p>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;<br>An asynchronous I/O operation does not cause the requesting process to be blocked;</p></blockquote><p>两者的区别就在于同步IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的<strong><em>阻塞IO,非阻塞IO ，IO复用都属于同步IO。</em></strong><br>有人可能会说，非阻塞IO 并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。非阻塞IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p><p>而异步IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p><h3 id="IO模型的形象举例"><a href="#IO模型的形象举例" class="headerlink" title="IO模型的形象举例"></a>IO模型的形象举例</h3><p>最后，再举几个不是很恰当的例子来说明这四个IO Model:<br>有A，B，C，D四个人在钓鱼：<br>A用的是最老式的鱼竿，所以呢，得一直守着，等到鱼上钩了再拉杆；<br>B的鱼竿有个功能，能够显示是否有鱼上钩，所以呢，B就和旁边的MM聊天，隔会再看看有没有鱼上钩，有的话就迅速拉杆；<br>C用的鱼竿和B差不多，但他想了一个好办法，就是同时放好几根鱼竿，然后守在旁边，一旦有显示说鱼上钩了，它就将对应的鱼竿拉起来；<br>D是个有钱人，干脆雇了一个人帮他钓鱼，一旦那个人把鱼钓上来了，就给D发个短信。</p><h3 id="Select-Poll-Epoll-轮询机制"><a href="#Select-Poll-Epoll-轮询机制" class="headerlink" title="Select/Poll/Epoll 轮询机制"></a>Select/Poll/Epoll 轮询机制</h3><p><strong><em>select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的</em></strong><br>Select/Poll/Epoll 都是IO复用的实现方式， 上面说了使用IO复用，会把socket设置成non-blocking，然后放进Select/Poll/Epoll 各自的监视列表里面，那么，他们的对socket是否有数据到达的监视机制分别是怎样的？效率又如何？我们应该使用哪种方式实现IO复用比较好？下面列出他们各自的实现方式，效率，优缺点：</p><p>（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p><p>（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p><h2 id="Java网络编程模型"><a href="#Java网络编程模型" class="headerlink" title="Java网络编程模型"></a>Java网络编程模型</h2><p>上文讲述了UNIX环境的五种IO模型。基于这五种模型，在Java中，随着NIO和NIO2.0(AIO)的引入，一般具有以下几种网络编程模型：</p><ul><li>BIO</li><li>NIO</li><li>AIO</li></ul><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>BIO是一个典型的网络编程模型，是通常我们实现一个服务端程序的过程，步骤如下：</p><ul><li>主线程accept请求阻塞</li><li>请求到达，创建新的线程来处理这个套接字，完成对客户端的响应。</li><li>主线程继续accept下一个请求</li></ul><p>这种模型有一个很大的问题是：当客户端连接增多时，服务端创建的线程也会暴涨，系统性能会急剧下降。因此，在此模型的基础上，类似于 tomcat的bio connector，采用的是线程池来避免对于每一个客户端都创建一个线程。有些地方把这种方式叫做伪异步IO(把请求抛到线程池中异步等待处理)。</p><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>JDK1.4开始引入了NIO类库，这里的NIO指的是New IO，主要是使用Selector多路复用器来实现。Selector在Linux等主流操作系统上是通过epoll实现的。</p><p>NIO的实现流程，类似于select：</p><ul><li>创建ServerSocketChannel监听客户端连接并绑定监听端口，设置为非阻塞模式。</li><li>创建Reactor线程，创建多路复用器(Selector)并启动线程。</li><li>将ServerSocketChannel注册到Reactor线程的Selector上。监听accept事件。</li><li>Selector在线程run方法中无线循环轮询准备就绪的Key。</li><li>Selector监听到新的客户端接入，处理新的请求，完成tcp三次握手，建立物理连接。</li><li>将新的客户端连接注册到Selector上，监听读操作。读取客户端发送的网络消息。</li><li>客户端发送的数据就绪则读取客户端请求，进行处理。</li></ul><p>相比BIO，NIO的编程非常复杂。</p><h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><p>JDK1.7引入NIO2.0，提供了异步文件通道和异步套接字通道的实现。其底层在windows上是通过IOCP，在Linux上是通过epoll来实现的(LinuxAsynchronousChannelProvider.java,UnixAsynchronousServerSocketChannelImpl.java)。</p><ul><li>创建AsynchronousServerSocketChannel，绑定监听端口</li><li>调用AsynchronousServerSocketChannel的accpet方法，传入自己实现的CompletionHandler。包括上一步，都是非阻塞的</li><li>连接传入，回调CompletionHandler的completed方法，在里面，调用AsynchronousSocketChannel的read方法，传入负责处理数据的CompletionHandler。</li><li>数据就绪，触发负责处理数据的CompletionHandler的completed方法。继续做下一步处理即可。</li><li>写入操作类似，也需要传入CompletionHandler。</li></ul><p>其编程模型相比NIO有了不少的简化。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table><thead><tr><th>.</th><th>同步阻塞IO</th><th>伪异步IO</th><th>NIO</th><th>AIO</th></tr></thead><tbody><tr><td>客户端数目 ：IO线程</td><td>1 : 1</td><td>m : n</td><td>m : 1</td><td>m : 0</td></tr><tr><td>IO模型</td><td>同步阻塞IO</td><td>同步阻塞IO</td><td>同步非阻塞IO</td><td>异步非阻塞IO</td></tr><tr><td>吞吐量</td><td>低</td><td>中</td><td>高</td><td>高</td></tr><tr><td>编程复杂度</td><td>简单</td><td>简单</td><td>非常复杂</td><td>复杂</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java网络编程和NIO &lt;a href=&quot;https://blog.csdn.net/column/details/21963.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21963.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java网络编程与NIO" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO/"/>
    
    
      <category term="Java网络编程" scheme="http://h2pl.github.io/tags/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="NIO" scheme="http://h2pl.github.io/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程与NIO详解2：JAVA NIO一步步构建IO多路复用的请求模型</title>
    <link href="http://h2pl.github.io/2018/05/25/Javanet2/"/>
    <id>http://h2pl.github.io/2018/05/25/Javanet2/</id>
    <published>2018-05-25T03:53:36.000Z</published>
    <updated>2018-06-02T14:21:58.209Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://github.com/jasonGeng88/blog" target="_blank" rel="noopener">https://github.com/jasonGeng88/blog</a></p><p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java网络编程和NIO <a href="https://blog.csdn.net/column/details/21963.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21963.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><blockquote><p>摘要：本文属于原创，欢迎转载，转载请保留出处：<a href="https://github.com/jasonGeng88/blog" target="_blank" rel="noopener">https://github.com/jasonGeng88/blog</a></p></blockquote><ul><li>文章一：<a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md" target="_blank" rel="noopener">JAVA 中原生的 socket 通信机制</a></li></ul><h2 id="当前环境"><a href="#当前环境" class="headerlink" title="当前环境"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83" target="_blank" rel="noopener"></a>当前环境</h2><ol><li>jdk == 1.8</li></ol><h2 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E4%BB%A3%E7%A0%81%E5%9C%B0%E5%9D%80" target="_blank" rel="noopener"></a>代码地址</h2><p>git 地址：<a href="https://github.com/jasonGeng88/java-network-programming" target="_blank" rel="noopener">https://github.com/jasonGeng88/java-network-programming</a></p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E7%9F%A5%E8%AF%86%E7%82%B9" target="_blank" rel="noopener"></a>知识点</h2><ul><li>nio 下 I/O 阻塞与非阻塞实现</li><li>SocketChannel 介绍</li><li>I/O 多路复用的原理</li><li>事件选择器与 SocketChannel 的关系</li><li>事件监听类型</li><li>字节缓冲 ByteBuffer 数据结构</li></ul><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E5%9C%BA%E6%99%AF" target="_blank" rel="noopener"></a>场景</h2><p>接着上一篇中的站点访问问题，如果我们需要并发访问10个不同的网站，我们该如何处理？</p><p>在上一篇中，我们使用了<code>java.net.socket</code>类来实现了这样的需求，以一线程处理一连接的方式，并配以线程池的控制，貌似得到了当前的最优解。可是这里也存在一个问题，连接处理是同步的，也就是并发数量增大后，大量请求会在队列中等待，或直接异常抛出。</p><p>为解决这问题，我们发现元凶处在“一线程一请求”上，如果一个线程能同时处理多个请求，那么在高并发下性能上会大大改善。这里就借住 JAVA 中的 nio 技术来实现这一模型。</p><h2 id="nio-的阻塞实现"><a href="#nio-的阻塞实现" class="headerlink" title="nio 的阻塞实现"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#nio-%E7%9A%84%E9%98%BB%E5%A1%9E%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener"></a>nio 的阻塞实现</h2><p>关于什么是 nio，从字面上理解为 New IO，就是为了弥补原本 I/O 上的不足，而在 JDK 1.4 中引入的一种新的 I/O 实现方式。简单理解，就是它提供了 I/O 的阻塞与非阻塞的两种实现方式（<em>当然，默认实现方式是阻塞的。</em>）。</p><p>下面，我们先来看下 nio 以阻塞方式是如何处理的。</p><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener"></a>建立连接</h3><p>有了上一篇 socket 的经验，我们的第一步一定也是建立 socket 连接。只不过，这里不是采用 <code>new socket()</code> 的方式，而是引入了一个新的概念 <code>SocketChannel</code>。它可以看作是 socket 的一个完善类，除了提供 Socket 的相关功能外，还提供了许多其他特性，如后面要讲到的向选择器注册的功能。</p><p>类图如下： <a href="https://github.com/jasonGeng88/blog/blob/master/201708/assets/java-nio-01.jpg" target="_blank" rel="noopener"><img src="https://github.com/jasonGeng88/blog/raw/master/201708/assets/java-nio-01.jpg" alt=""></a></p><p>建立连接代码实现：</p><pre>// 初始化 socket，建立 socket 与 channel 的绑定关系SocketChannel socketChannel = SocketChannel.open();// 初始化远程连接地址SocketAddress remote = new InetSocketAddress(this.host, port);// I/O 处理设置阻塞，这也是默认的方式，可不设置socketChannel.configureBlocking(true);// 建立连接socketChannel.connect(remote);</pre><h3 id="获取-socket-连接"><a href="#获取-socket-连接" class="headerlink" title="获取 socket 连接"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E8%8E%B7%E5%8F%96-socket-%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener"></a>获取 socket 连接</h3><p>因为是同样是 I/O 阻塞的实现，所以后面的关于 socket 输入输出流的处理，和上一篇的基本相同。唯一差别是，这里需要通过 channel 来获取 socket 连接。</p><ul><li>获取 socket 连接</li></ul><pre>Socket socket = socketChannel.socket();</pre><ul><li>处理输入输出流</li></ul><pre>PrintWriter pw = getWriter(socketChannel.socket());BufferedReader br = getReader(socketChannel.socket());</pre><h3 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B" target="_blank" rel="noopener"></a>完整示例</h3><pre>package com.jason.network.mode.nio;import com.jason.network.constant.HttpConstant;import com.jason.network.util.HttpUtil;import java.io.*;import java.net.InetSocketAddress;import java.net.Socket;import java.net.SocketAddress;import java.nio.channels.SocketChannel;public class NioBlockingHttpClient {    private SocketChannel socketChannel;    private String host;    public static void main(String[] args) throws IOException {        for (String host: HttpConstant.HOSTS) {            NioBlockingHttpClient client = new NioBlockingHttpClient(host, HttpConstant.PORT);            client.request();        }    }    public NioBlockingHttpClient(String host, int port) throws IOException {        this.host = host;        socketChannel = SocketChannel.open();        socketChannel.socket().setSoTimeout(5000);        SocketAddress remote = new InetSocketAddress(this.host, port);        this.socketChannel.connect(remote);    }    public void request() throws IOException {        PrintWriter pw = getWriter(socketChannel.socket());        BufferedReader br = getReader(socketChannel.socket());        pw.write(HttpUtil.compositeRequest(host));        pw.flush();        String msg;        while ((msg = br.readLine()) != null){            System.out.println(msg);        }    }    private PrintWriter getWriter(Socket socket) throws IOException {        OutputStream out = socket.getOutputStream();        return new PrintWriter(out);    }    private BufferedReader getReader(Socket socket) throws IOException {        InputStream in = socket.getInputStream();        return new BufferedReader(new InputStreamReader(in));    }}</pre><h2 id="nio-的非阻塞实现"><a href="#nio-的非阻塞实现" class="headerlink" title="nio 的非阻塞实现"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#nio-%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener"></a>nio 的非阻塞实现</h2><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90" target="_blank" rel="noopener"></a>原理分析</h3><p>nio 的阻塞实现，基本与使用原生的 socket 类似，没有什么特别大的差别。</p><p>下面我们来看看它真正强大的地方。到目前为止，我们将的都是阻塞 I/O。何为阻塞 I/O，看下图：</p><p><a href="https://github.com/jasonGeng88/blog/blob/master/201708/assets/java-nio-02.jpg" target="_blank" rel="noopener"><img src="https://github.com/jasonGeng88/blog/raw/master/201708/assets/java-nio-02.jpg" alt=""></a></p><p><em>我们主要观察图中的前三种 I/O 模型，关于异步 I/O，一般需要依靠操作系统的支持，这里不讨论。</em></p><p>从图中可以发现，阻塞过程主要发生在两个阶段上：</p><ul><li>第一阶段：等待数据就绪；</li><li>第二阶段：将已就绪的数据从内核缓冲区拷贝到用户空间；</li></ul><p>这里产生了一个从内核到用户空间的拷贝，主要是为了系统的性能优化考虑。假设，从网卡读到的数据直接返回给用户空间，那势必会造成频繁的系统中断，因为从网卡读到的数据不一定是完整的，可能断断续续的过来。通过内核缓冲区作为缓冲，等待缓冲区有足够的数据，或者读取完结后，进行一次的系统中断，将数据返回给用户，这样就能避免频繁的中断产生。</p><p>了解了 I/O 阻塞的两个阶段，下面我们进入正题。看看一个线程是如何实现同时处理多个 I/O 调用的。从上图中的非阻塞 I/O 可以看出，仅仅只有第二阶段需要阻塞，第一阶段的数据等待过程，我们是不需要关心的。不过该模型是频繁地去检查是否就绪，造成了 CPU 无效的处理，反而效果不好。如果有一种类似的好莱坞原则— “不要给我们打电话，我们会打给你” 。这样一个线程可以同时发起多个 I/O 调用，并且不需要同步等待数据就绪。在数据就绪完成的时候，会以事件的机制，来通知我们。这样不就实现了单线程同时处理多个 IO 调用的问题了吗？即所说的“I/O 多路复用模型”。</p><hr><p>废话讲了一大堆，下面就来实际操刀一下。</p><h3 id="创建选择器"><a href="#创建选择器" class="headerlink" title="创建选择器"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E5%88%9B%E5%BB%BA%E9%80%89%E6%8B%A9%E5%99%A8" target="_blank" rel="noopener"></a>创建选择器</h3><p>由上面分析可以，我们得有一个选择器，它能监听所有的 I/O 操作，并且以事件的方式通知我们哪些 I/O 已经就绪了。</p><p>代码如下：</p><pre>import java.nio.channels.Selector;...private static Selector selector;static {    try {        selector = Selector.open();    } catch (IOException e) {        e.printStackTrace();    }}</pre><h3 id="创建非阻塞-I-O"><a href="#创建非阻塞-I-O" class="headerlink" title="创建非阻塞 I/O"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E5%88%9B%E5%BB%BA%E9%9D%9E%E9%98%BB%E5%A1%9E-io" target="_blank" rel="noopener"></a>创建非阻塞 I/O</h3><p>下面，我们来创建一个非阻塞的 <code>SocketChannel</code>，代码与阻塞实现类型，唯一不同是<code>socketChannel.configureBlocking(false)</code>。</p><p><em>注意：只有在<code>socketChannel.configureBlocking(false)</code>之后的代码，才是非阻塞的，如果<code>socketChannel.connect()</code>在设置非阻塞模式之前，那么连接操作依旧是阻塞调用的。</em></p><pre>SocketChannel socketChannel = SocketChannel.open();SocketAddress remote = new InetSocketAddress(host, port);// 设置非阻塞模式socketChannel.configureBlocking(false);socketChannel.connect(remote);</pre><h3 id="建立选择器与-socket-的关联"><a href="#建立选择器与-socket-的关联" class="headerlink" title="建立选择器与 socket 的关联"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E5%BB%BA%E7%AB%8B%E9%80%89%E6%8B%A9%E5%99%A8%E4%B8%8E-socket-%E7%9A%84%E5%85%B3%E8%81%94" target="_blank" rel="noopener"></a>建立选择器与 socket 的关联</h3><p>选择器与 socket 都创建好了，下一步就是将两者进行关联，好让选择器和监听到 Socket 的变化。这里采用了以 <code>SocketChannel</code> 主动注册到选择器的方式进行关联绑定，这也就解释了，为什么不直接<code>new Socket()</code>，而是以<code>SocketChannel</code>的方式来创建 socket。</p><p>代码如下：</p><pre>socketChannel.register(selector,                        SelectionKey.OP_CONNECT                        | SelectionKey.OP_READ                        | SelectionKey.OP_WRITE);</pre><p>上面代码，我们将 socketChannel 注册到了选择器中，并且对它的连接、可读、可写事件进行了监听。</p><p>具体的事件监听类型如下：</p><table><thead><tr><th>操作类型</th><th>值</th><th>描述</th><th>所属对象</th></tr></thead><tbody><tr><td>OP_READ</td><td>1 &lt;&lt; 0</td><td>读操作</td><td>SocketChannel</td></tr><tr><td>OP_WRITE</td><td>1 &lt;&lt; 2</td><td>写操作</td><td>SocketChannel</td></tr><tr><td>OP_CONNECT</td><td>1 &lt;&lt; 3</td><td>连接socket操作</td><td>SocketChannel</td></tr><tr><td>OP_ACCEPT</td><td>1 &lt;&lt; 4</td><td>接受socket操作</td><td>ServerSocketChannel</td></tr></tbody></table><h3 id="选择器监听-socket-变化"><a href="#选择器监听-socket-变化" class="headerlink" title="选择器监听 socket 变化"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E9%80%89%E6%8B%A9%E5%99%A8%E7%9B%91%E5%90%AC-socket-%E5%8F%98%E5%8C%96" target="_blank" rel="noopener"></a>选择器监听 socket 变化</h3><p>现在，选择器已经与我们关心的 socket 进行了关联。下面就是感知事件的变化，然后调用相应的处理机制。</p><p>这里与 Linux 下的 selector 有点不同，nio 下的 selecotr 不会去遍历所有关联的 socket。我们在注册时设置了我们关心的事件类型，每次从选择器中获取的，只会是那些符合事件类型，并且完成就绪操作的 socket，减少了大量无效的遍历操作。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> select() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">// 获取就绪的 socket 个数</span></span><br><span class="line">    <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取符合的 socket 在选择器中对应的事件句柄 key</span></span><br><span class="line">        Set keys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有的key</span></span><br><span class="line">        Iterator it = keys.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取对应的 key，并从已选择的集合中移除</span></span><br><span class="line">            SelectionKey <span class="built_in">key</span> = (SelectionKey)it.next();</span><br><span class="line">            it.remove();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">key</span>.isConnectable())&#123;</span><br><span class="line">            <span class="comment">// 进行连接操作</span></span><br><span class="line">                connect(<span class="built_in">key</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">key</span>.isWritable())&#123;</span><br><span class="line">            <span class="comment">// 进行写操作</span></span><br><span class="line">                write(<span class="built_in">key</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">key</span>.isReadable())&#123;</span><br><span class="line">            <span class="comment">// 进行读操作</span></span><br><span class="line">                receive(<span class="built_in">key</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注意：这里的<code>selector.select()</code>是同步阻塞的，等待有事件发生后，才会被唤醒。这就防止了 CPU 空转的产生。当然，我们也可以给它设置超时时间，<code>selector.select(long timeout)</code>来结束阻塞过程。</em></p><h3 id="处理连接就绪事件"><a href="#处理连接就绪事件" class="headerlink" title="处理连接就绪事件"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E5%A4%84%E7%90%86%E8%BF%9E%E6%8E%A5%E5%B0%B1%E7%BB%AA%E4%BA%8B%E4%BB%B6" target="_blank" rel="noopener"></a>处理连接就绪事件</h3><p>下面，我们分别来看下，一个 socket 是如何来处理连接、写入数据和读取数据的（<em>这些操作都是阻塞的过程，只是我们将等待就绪的过程变成了非阻塞的了</em>）。</p><p>处理连接代码：</p><pre>// SelectionKey 代表 SocketChannel 在选择器中注册的事件句柄private void connect(SelectionKey key) throws IOException {    // 获取事件句柄对应的 SocketChannel    SocketChannel channel = (SocketChannel) key.channel();   // 真正的完成 socket 连接    channel.finishConnect();   // 打印连接信息    InetSocketAddress remote = (InetSocketAddress) channel.socket().getRemoteSocketAddress();    String host = remote.getHostName();    int port = remote.getPort();    System.out.println(String.format("访问地址: %s:%s 连接成功!", host, port));}</pre><h3 id="处理写入就绪事件"><a href="#处理写入就绪事件" class="headerlink" title="处理写入就绪事件"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E5%A4%84%E7%90%86%E5%86%99%E5%85%A5%E5%B0%B1%E7%BB%AA%E4%BA%8B%E4%BB%B6" target="_blank" rel="noopener"></a>处理写入就绪事件</h3><pre>// 字符集处理类private Charset charset = Charset.forName("utf8");private void write(SelectionKey key) throws IOException {    SocketChannel channel = (SocketChannel) key.channel();    InetSocketAddress remote = (InetSocketAddress) channel.socket().getRemoteSocketAddress();    String host = remote.getHostName();    // 获取 HTTP 请求，同上一篇    String request = HttpUtil.compositeRequest(host);    // 向 SocketChannel 写入事件     channel.write(charset.encode(request));    // 修改 SocketChannel 所关心的事件    key.interestOps(SelectionKey.OP_READ);}</pre><p>这里有两个地方需要注意：</p><ul><li>第一个是使用 <code>channel.write(charset.encode(request));</code> 进行数据写入。有人会说，为什么不能像上面同步阻塞那样，通过<code>PrintWriter</code>包装类进行操作。因为<code>PrintWriter</code>的 <code>write()</code> 方法是阻塞的，也就是说要等数据真正从 socket 发送出去后才返回。</li></ul><p>这与我们这里所讲的阻塞是不一致的，这里的操作虽然也是阻塞的，但它发生的过程是在数据从用户空间到内核缓冲区拷贝过程。至于系统将缓冲区的数据通过 socket 发送出去，这不在阻塞范围内。也解释了为什么要用 <code>Charset</code> 对写入内容进行编码了，因为缓冲区接收的格式是<code>ByteBuffer</code>。</p><ul><li><p>第二，选择器用来监听事件变化的两个参数是 <code>interestOps</code> 与 <code>readyOps</code>。</p><ul><li><p>interestOps：表示 <code>SocketChannel</code> 所关心的事件类型，也就是告诉选择器，当有这几种事件发生时，才来通知我。这里通过<code>key.interestOps(SelectionKey.OP_READ);</code>告诉选择器，之后我只关心“读就绪”事件，其他的不用通知我了。</p></li><li><p>readyOps：表示 <code>SocketChannel</code> 当前就绪的事件类型。以<code>key.isReadable()</code>为例，判断依据就是：<code>return (readyOps() &amp; OP_READ) != 0;</code></p></li></ul></li></ul><h3 id="处理读取就绪事件"><a href="#处理读取就绪事件" class="headerlink" title="处理读取就绪事件"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E5%A4%84%E7%90%86%E8%AF%BB%E5%8F%96%E5%B0%B1%E7%BB%AA%E4%BA%8B%E4%BB%B6" target="_blank" rel="noopener"></a>处理读取就绪事件</h3><pre>private void receive(SelectionKey key) throws IOException {    SocketChannel channel = (SocketChannel) key.channel();    ByteBuffer buffer = ByteBuffer.allocate(1024);    channel.read(buffer);    buffer.flip();    String receiveData = charset.decode(buffer).toString();    // 当再没有数据可读时，取消在选择器中的关联，并关闭 socket 连接    if ("".equals(receiveData)) {        key.cancel();        channel.close();        return;    }    System.out.println(receiveData);}</pre><p>这里的处理基本与写入一致，唯一要注意的是，这里我们需要自行处理去缓冲区读取数据的操作。首先会分配一个固定大小的缓冲区，然后从内核缓冲区中，拷贝数据至我们刚分配固定缓冲区上。这里存在两种情况：</p><ul><li>我们分配的缓冲区过大，那多余的部分以0补充（<em>初始化时，其实会自动补0</em>）。</li><li>我们分配的缓冲去过小，因为选择器会不停的遍历。只要 <code>SocketChannel</code> 处理读就绪状态，那下一次会继续读取。当然，分配过小，会增加遍历次数。</li></ul><p>最后，将一下 <code>ByteBuffer</code> 的结构，它主要有 position, limit,capacity 以及 mark 属性。以 <code>buffer.flip();</code> 为例，讲下各属性的作用（<em>mark 主要是用来标记之前 position 的位置，是在当前 postion 无法满足的情况下使用的，这里不作讨论</em>）。</p><p><a href="https://github.com/jasonGeng88/blog/blob/master/201708/assets/java-nio-03.png" target="_blank" rel="noopener"><img src="https://github.com/jasonGeng88/blog/raw/master/201708/assets/java-nio-03.png" alt=""></a></p><p>从图中看出，</p><ul><li>容量（capacity）：表示缓冲区可以保存的数据容量；</li><li>极限（limit）：表示缓冲区的当前终点，即写入、读取都不可超过该重点；</li><li>位置（position）：表示缓冲区下一个读写单元的位置；</li></ul><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" target="_blank" rel="noopener"></a>完整代码</h3><pre>package com.jason.network.mode.nio;import com.jason.network.constant.HttpConstant;import com.jason.network.util.HttpUtil;import java.io.IOException;import java.net.InetSocketAddress;import java.net.SocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.SocketChannel;import java.nio.charset.Charset;import java.util.Iterator;import java.util.Set;public class NioNonBlockingHttpClient {    private static Selector selector;    private Charset charset = Charset.forName("utf8");    static {        try {            selector = Selector.open();        } catch (IOException e) {            e.printStackTrace();        }    }    public static void main(String[] args) throws IOException {        NioNonBlockingHttpClient client = new NioNonBlockingHttpClient();        for (String host: HttpConstant.HOSTS) {            client.request(host, HttpConstant.PORT);        }        client.select();    }    public void request(String host, int port) throws IOException {        SocketChannel socketChannel = SocketChannel.open();        socketChannel.socket().setSoTimeout(5000);        SocketAddress remote = new InetSocketAddress(host, port);        socketChannel.configureBlocking(false);        socketChannel.connect(remote);        socketChannel.register(selector,                        SelectionKey.OP_CONNECT                        | SelectionKey.OP_READ                        | SelectionKey.OP_WRITE);    }    public void select() throws IOException {        while (selector.select(500) > 0){            Set keys = selector.selectedKeys();            Iterator it = keys.iterator();            while (it.hasNext()){                SelectionKey key = (SelectionKey)it.next();                it.remove();                if (key.isConnectable()){                    connect(key);                }                else if (key.isWritable()){                    write(key);                }                else if (key.isReadable()){                    receive(key);                }            }        }    }    private void connect(SelectionKey key) throws IOException {        SocketChannel channel = (SocketChannel) key.channel();        channel.finishConnect();        InetSocketAddress remote = (InetSocketAddress) channel.socket().getRemoteSocketAddress();        String host = remote.getHostName();        int port = remote.getPort();        System.out.println(String.format("访问地址: %s:%s 连接成功!", host, port));    }    private void write(SelectionKey key) throws IOException {        SocketChannel channel = (SocketChannel) key.channel();        InetSocketAddress remote = (InetSocketAddress) channel.socket().getRemoteSocketAddress();        String host = remote.getHostName();        String request = HttpUtil.compositeRequest(host);        System.out.println(request);        channel.write(charset.encode(request));        key.interestOps(SelectionKey.OP_READ);    }    private void receive(SelectionKey key) throws IOException {        SocketChannel channel = (SocketChannel) key.channel();        ByteBuffer buffer = ByteBuffer.allocate(1024);        channel.read(buffer);        buffer.flip();        String receiveData = charset.decode(buffer).toString();        if ("".equals(receiveData)) {            key.cancel();            channel.close();            return;        }        System.out.println(receiveData);    }}</pre><h3 id="示例效果"><a href="#示例效果" class="headerlink" title="示例效果"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E7%A4%BA%E4%BE%8B%E6%95%88%E6%9E%9C" target="_blank" rel="noopener"></a>示例效果</h3><p><a href="https://github.com/jasonGeng88/blog/blob/master/201708/assets/java-nio-04.png" target="_blank" rel="noopener"><img src="https://github.com/jasonGeng88/blog/raw/master/201708/assets/java-nio-04.png" alt=""></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener"></a>总结</h2><p>本文从 nio 的阻塞方式讲起，介绍了阻塞 I/O 与非阻塞 I/O 的区别，以及在 nio 下是如何一步步构建一个 IO 多路复用的模型的客户端。文中需要理解的内容比较多，如果有理解错误的地方，欢迎指正~</p><h2 id="补充1：基于NIO的多路复用客户端（线程池版）"><a href="#补充1：基于NIO的多路复用客户端（线程池版）" class="headerlink" title="补充1：基于NIO的多路复用客户端（线程池版）"></a>补充1：基于NIO的多路复用客户端（线程池版）</h2><pre>public static void main(String[] args) {    基于线程池的伪异步NIO模型 a = new 基于线程池的伪异步NIO模型();  a.startServer(); }private Charset charset = Charset.forName("utf8");   class WriteThread implements Runnable {    private SelectionKey key; public WriteThread(SelectionKey key) {        this.key = key;  }    @Override  public void run() {        SocketChannel socketChannel = (SocketChannel) key.channel();  Socket socket = socketChannel.socket(); try {            socketChannel.finishConnect();  } catch (IOException e) {            e.printStackTrace();  }        InetSocketAddress remote = (InetSocketAddress) socketChannel.socket().getRemoteSocketAddress();  String host = remote.getHostName(); int port = remote.getPort();  System._out_.println(String.format("访问地址: %s:%s 连接成功!", host, port));    }}class ReadThread implements Runnable {    private SelectionKey key; public ReadThread(SelectionKey key) {        this.key = key;  }    @Override  public void run() {        SocketChannel socketChannel = (SocketChannel) key.channel();  ByteBuffer buffer = ByteBuffer.allocate(1024); try {            socketChannel.read(buffer);  } catch (IOException e) {            e.printStackTrace();  }        buffer.flip();  String receiveData = null; try {            receiveData = new String(buffer.array(), "utf8");  } catch (UnsupportedEncodingException e) {            e.printStackTrace();  }        if ("".equals(receiveData)) {            key.cancel(); try {                socketChannel.close();  } catch (IOException e) {                e.printStackTrace();  }            return;  }        System._out_.println(receiveData);  }}class ConnectThread implements Runnable {    private SelectionKey key; public ConnectThread(SelectionKey key) {        this.key = key;  }    @Override  public void run() {        SocketChannel socketChannel = (SocketChannel) key.channel();  ByteBuffer byteBuffer = charset.encode("hello world"); try {            socketChannel.write(byteBuffer);  System._out_.println("hello world");  } catch (IOException e) {            e.printStackTrace();  }        key.interestOps(SelectionKey._OP_READ_);  }}public void startServer() {    ExecutorService executorService = Executors.newFixedThreadPool(10); try {        SocketChannel socketChannel = SocketChannel.open();  Selector selector = Selector.open();    socketChannel.configureBlocking(false);  InetSocketAddress inetAddress = new InetSocketAddress(1234);    socketChannel.connect(inetAddress);  socketChannel.register(selector, SelectionKey._OP_CONNECT_ |                SelectionKey._OP_READ_ |                SelectionKey._OP_WRITE_);   while (selector.select(500) > 0) {            Iterator<selectionkey> keys = selector.selectedKeys().iterator(); while (keys.hasNext()) {                SelectionKey key = keys.next(); if (key.isConnectable()) {                    executorService.submit(new ConnectThread(key));  }else if(key.isReadable()) {                    executorService.submit(new ReadThread(key));  }else {                    executorService.submit(new WriteThread(key));  }            }        }    } catch (IOException e) {        e.printStackTrace();  }}</selectionkey></pre><h2 id="补充2：基于NIO的多路复用服务端"><a href="#补充2：基于NIO的多路复用服务端" class="headerlink" title="补充2：基于NIO的多路复用服务端"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E5%90%8E%E7%BB%AD" target="_blank" rel="noopener"></a>补充2：基于NIO的多路复用服务端</h2><pre>class NioNonBlockingHttpServer {    private static Selector _selector_; private Charset charset = Charset.forName("utf8");   static {        try {            _selector_ = Selector.open();  } catch (IOException e) {            e.printStackTrace();  }    }    public static void main(String[] args) throws IOException {        NioNonBlockingHttpServer httpServer = new NioNonBlockingHttpServer();  httpServer.select();    }    public void request(int port) throws IOException {        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();  serverSocketChannel.socket().setSoTimeout(5000);  serverSocketChannel.configureBlocking(false);  serverSocketChannel.socket().bind(new InetSocketAddress(8383)); //        serverSocketChannel.register(selector, //                SelectionKey.OP_CONNECT //                        | SelectionKey.OP_READ //                        | SelectionKey.OP_WRITE);  }    public void select() throws IOException {        while (_selector_.select(500) > 0) {            Set keys = _selector_.selectedKeys();    Iterator it = keys.iterator();   while (it.hasNext()) {                SelectionKey key = (SelectionKey) it.next();  it.remove();   if (key.isAcceptable()) {                    accept(key);  } else if (key.isWritable()) {                    write(key);  } else if (key.isReadable()) {                    receive(key);  }            }        }    }    private void accept(SelectionKey key) throws IOException {        SocketChannel socketChannel;  ServerSocketChannel channel = (ServerSocketChannel) key.channel();  socketChannel = channel.accept();//接受连接请求  socketChannel.configureBlocking(false);    socketChannel.register(_selector_, SelectionKey._OP_READ_ | SelectionKey._OP_WRITE_);    InetSocketAddress local = (InetSocketAddress) channel.socket().getLocalSocketAddress();  String host = local.getHostName(); int port = local.getPort();  System._out_.println(String.format("请求地址: %s:%s 接收成功!", host, port));      }    private void write(SelectionKey key) throws IOException {        SocketChannel channel = (SocketChannel) key.channel();    InetSocketAddress local = (InetSocketAddress) channel.socket().getRemoteSocketAddress();  String host = local.getHostName();  String msg = "hello Client";  channel.write(charset.encode(msg));    System._out_.println(msg);  key.interestOps(SelectionKey._OP_READ_);  }    private void receive(SelectionKey key) throws IOException {        SocketChannel channel = (SocketChannel) key.channel();  ByteBuffer buffer = ByteBuffer.allocate(1024);  channel.read(buffer);  buffer.flip();  String receiveData = charset.decode(buffer).toString();   if ("".equals(receiveData)) {            key.cancel();  channel.close(); return;  }        System._out_.println(receiveData);  }}</pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://github.com/jasonGeng88/blog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/jasonGeng88/blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java网络编程和NIO &lt;a href=&quot;https://blog.csdn.net/column/details/21963.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21963.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java网络编程与NIO" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO/"/>
    
    
      <category term="Java网络编程" scheme="http://h2pl.github.io/tags/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="NIO" scheme="http://h2pl.github.io/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程和NIO详解1：JAVA 中原生的 socket 通信机制</title>
    <link href="http://h2pl.github.io/2018/05/25/Javanet1/"/>
    <id>http://h2pl.github.io/2018/05/25/Javanet1/</id>
    <published>2018-05-25T03:53:32.000Z</published>
    <updated>2018-06-11T12:50:54.192Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://github.com/jasonGeng88/blog" target="_blank" rel="noopener">https://github.com/jasonGeng88/blog</a></p><p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java网络编程和NIO <a href="https://blog.csdn.net/column/details/21963.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21963.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><h1 id="JAVA-中原生的-socket-通信机制"><a href="#JAVA-中原生的-socket-通信机制" class="headerlink" title="JAVA 中原生的 socket 通信机制"></a>JAVA 中原生的 socket 通信机制</h1><blockquote><p>摘要：本文属于原创，欢迎转载，转载请保留出处：<a href="https://github.com/jasonGeng88/blog" target="_blank" rel="noopener">https://github.com/jasonGeng88/blog</a></p></blockquote><h2 id="当前环境"><a href="#当前环境" class="headerlink" title="当前环境"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83" target="_blank" rel="noopener"></a>当前环境</h2><ol><li>jdk == 1.8</li></ol><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md#%E7%9F%A5%E8%AF%86%E7%82%B9" target="_blank" rel="noopener"></a>知识点</h2><ul><li>socket 的连接处理</li><li>IO 输入、输出流的处理</li><li>请求数据格式处理</li><li>请求模型优化</li></ul><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md#%E5%9C%BA%E6%99%AF" target="_blank" rel="noopener"></a>场景</h2><p>今天，和大家聊一下 JAVA 中的 socket 通信问题。这里采用最简单的一请求一响应模型为例，假设我们现在需要向 baidu 站点进行通信。我们用 JAVA 原生的 socket 该如何实现。</p><h3 id="建立-socket-连接"><a href="#建立-socket-连接" class="headerlink" title="建立 socket 连接"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md#%E5%BB%BA%E7%AB%8B-socket-%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener"></a>建立 socket 连接</h3><p>首先，我们需要建立 socket 连接（<em>核心代码</em>）</p><pre>import java.net.InetSocketAddress;import java.net.Socket;import java.net.SocketAddress;// 初始化 socketSocket socket = new Socket();// 初始化远程连接地址SocketAddress remote = new InetSocketAddress(host, port);// 建立连接socket.connect(remote);</pre><h3 id="处理-socket-输入输出流"><a href="#处理-socket-输入输出流" class="headerlink" title="处理 socket 输入输出流"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md#%E5%A4%84%E7%90%86-socket-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81" target="_blank" rel="noopener"></a>处理 socket 输入输出流</h3><p>成功建立 socket 连接后，我们就能获得它的输入输出流，通信的本质是对输入输出流的处理。通过输入流，读取网络连接上传来的数据，通过输出流，将本地的数据传出给远端。</p><p><em>socket 连接实际与处理文件流有点类似，都是在进行 IO 操作。</em></p><p>获取输入、输出流代码如下：</p><pre>// 输入流InputStream in = socket.getInputStream();// 输出流OutputStream out = socket.getOutputStream();</pre><p>关于 IO 流的处理，我们一般会用相应的包装类来处理 IO 流，如果直接处理的话，我们需要对 <code>byte[]</code> 进行操作，而这是相对比较繁琐的。如果采用包装类，我们可以直接以<code>string</code>、<code>int</code>等类型进行处理，简化了 IO 字节操作。</p><p>下面以 <code>BufferedReader</code> 与 <code>PrintWriter</code> 作为输入输出的包装类进行处理。</p><pre>// 获取 socket 输入流private BufferedReader getReader(Socket socket) throws IOException {    InputStream in = socket.getInputStream();    return new BufferedReader(new InputStreamReader(in));}// 获取 socket 输出流private PrintWriter getWriter(Socket socket) throws IOException {    OutputStream out = socket.getOutputStream();    return new PrintWriter(new OutputStreamWriter(out));}</pre><h3 id="数据请求与响应"><a href="#数据请求与响应" class="headerlink" title="数据请求与响应"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md#%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94" target="_blank" rel="noopener"></a>数据请求与响应</h3><p>有了 socket 连接、IO 输入输出流，下面就该向发送请求数据，以及获取请求的响应结果。</p><p>因为有了 IO 包装类的支持，我们可以直接以字符串的格式进行传输，由包装类帮我们将数据装换成相应的字节流。</p><p>因为我们与 baidu 站点进行的是 HTTP 访问，所有我们不需要额外定义输出格式。采用标准的 HTTP 传输格式，就能进行请求响应了（<em>某些特定的 RPC 框架，可能会有自定义的通信格式</em>）。</p><p>请求的数据内容处理如下：</p><pre>public class HttpUtil {    public static String compositeRequest(String host){        return "GET / HTTP/1.1\r\n" +                "Host: " + host + "\r\n" +                "User-Agent: curl/7.43.0\r\n" +                "Accept: */*\r\n\r\n";    }}</pre><p>发送请求数据代码如下：</p><pre>// 发起请求PrintWriter writer = getWriter(socket);writer.write(HttpUtil.compositeRequest(host));writer.flush();</pre><p>接收响应数据代码如下：</p><pre>// 读取响应String msg;BufferedReader reader = getReader(socket);while ((msg = reader.readLine()) != null){    System.out.println(msg);}</pre><h3 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md#%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA" target="_blank" rel="noopener"></a>结果展示</h3><p>至此，讲完了原生 socket 下的创建连接、发送请求与接收响应的所有核心代码。</p><p>完整代码如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> com.test.network.util.HttpUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketHttpClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void start(<span class="keyword">String</span> host, int port) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 socket</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> <span class="type">Socket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置 socket 连接</span></span><br><span class="line">            SocketAddress remote = <span class="keyword">new</span> <span class="type">InetSocketAddress</span>(host, port);</span><br><span class="line">            socket.setSoTimeout(<span class="number">5000</span>);</span><br><span class="line">            socket.connect(remote);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发起请求</span></span><br><span class="line">            PrintWriter writer = getWriter(socket);</span><br><span class="line">            System.out.println(HttpUtil.compositeRequest(host));</span><br><span class="line">            writer.write(HttpUtil.compositeRequest(host));</span><br><span class="line">            writer.flush();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取响应</span></span><br><span class="line">            <span class="keyword">String</span> msg;</span><br><span class="line">            BufferedReader reader = getReader(socket);</span><br><span class="line">            <span class="keyword">while</span> ((msg = reader.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BufferedReader getReader(Socket socket) throws IOException &#123;</span><br><span class="line">        InputStream <span class="keyword">in</span> = socket.getInputStream();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">BufferedReader</span>(<span class="keyword">new</span> <span class="type">InputStreamReader</span>(<span class="keyword">in</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PrintWriter getWriter(Socket socket) throws IOException &#123;</span><br><span class="line">        OutputStream out = socket.getOutputStream();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">PrintWriter</span>(<span class="keyword">new</span> <span class="type">OutputStreamWriter</span>(out));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们通过实例化一个客户端，来展示 socket 通信的结果。</p><pre>public class Application {    public static void main(String[] args) {        new SocketHttpClient().start("www.baidu.com", 80);    }}</pre><p>结果输出：</p><p><a href="https://github.com/jasonGeng88/blog/blob/master/201708/assets/java-socket-01.png" target="_blank" rel="noopener"><img src="https://github.com/jasonGeng88/blog/raw/master/201708/assets/java-socket-01.png" alt=""></a></p><h2 id="请求模型优化"><a href="#请求模型优化" class="headerlink" title="请求模型优化"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md#%E8%AF%B7%E6%B1%82%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96" target="_blank" rel="noopener"></a>请求模型优化</h2><p>这种方式，虽然实现功能没什么问题。但是我们细看，发现在 IO 写入与读取过程，是发生了 IO 阻塞的情况。即：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会发生 IO 阻塞</span></span><br><span class="line"><span class="selector-tag">writer</span><span class="selector-class">.write</span>(HttpUtil.compositeRequest(host));</span><br><span class="line"><span class="selector-tag">reader</span><span class="selector-class">.readLine</span>();</span><br></pre></td></tr></table></figure><p>所以如果要同时请求10个不同的站点，如下：</p><pre>public class SingleThreadApplication {    public static void main(String[] args) {        // HttpConstant.HOSTS 为 站点集合        for (String host: HttpConstant.HOSTS) {            new SocketHttpClient().start(host, HttpConstant.PORT);        }    }}</pre><p>它一定是第一个请求响应结束后，才会发起下一个站点处理。</p><p><em>这在服务端更明显，虽然这里的代码是客户端连接，但是具体的操作和服务端是差不多的。请求只能一个个串行处理，这在响应时间上肯定不能达标。</em></p><ul><li>多线程处理</li></ul><p>有人觉得这根本不是问题，JAVA 是多线程的编程语言。对于这种情况，采用多线程的模型再合适不过。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (final <span class="keyword">String</span> host: <span class="type">HttpConstant</span>.HOSTS) &#123;</span><br><span class="line"></span><br><span class="line">            Thread t = <span class="keyword">new</span> <span class="type">Thread</span>(<span class="keyword">new</span> <span class="type">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> void run() &#123;</span><br><span class="line">                    <span class="keyword">new</span> <span class="type">SocketHttpClient</span>().start(host, HttpConstant.PORT);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            t.start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式起初看起来挺有用的，但并发量一大，应用会起很多的线程。都知道，在服务器上，每一个线程实际都会占据一个文件句柄。而服务器上的句柄数是有限的，而且大量的线程，造成的线程间切换的消耗也会相当的大。所以这种方式在并发量大的场景下，一定是承载不住的。</p><ul><li>多线程 + 线程池 处理</li></ul><p>既然线程太多不行，那我们控制一下线程创建的数目不就行了。只启动固定的线程数来进行 socket 处理，既利用了多线程的处理，又控制了系统的资源消耗。</p><pre>public class ThreadPoolApplication {    public static void main(String[] args) {        ExecutorService executorService = Executors.newFixedThreadPool(8);        for (final String host: HttpConstant.HOSTS) {            Thread t = new Thread(new Runnable() {                public void run() {                    new SocketHttpClient().start(host, HttpConstant.PORT);                }            });            executorService.submit(t);            new SocketHttpClient().start(host, HttpConstant.PORT);        }    }}</pre><p><em>关于启动的线程数，一般 CPU 密集型会设置在 N+1（N为CPU核数），IO 密集型设置在 2N + 1。</em></p><p>这种方式，看起来是最优的了。那有没有更好的呢，如果一个线程能同时处理多个 socket 连接，并且在每个 socket 输入输出数据没有准备好的情况下，不进行阻塞，那是不是更优呢。这种技术叫做“IO多路复用”。在 JAVA 的 nio 包中，提供了相应的实现。</p><h2 id="补充1：TCP客户端与服务端"><a href="#补充1：TCP客户端与服务端" class="headerlink" title="补充1：TCP客户端与服务端"></a>补充1：TCP客户端与服务端</h2><pre>public class TCP客户端 {    public static void main(String[] args) {        new Thread(new Runnable() {            @Override  public void run() {                try {                    Socket s = new Socket("127.0.0.1",1234);    //构建IO  InputStream is = s.getInputStream();  OutputStream os = s.getOutputStream();    BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(os));  //向服务器端发送一条消息  bw.write("测试客户端和服务器通信，服务器接收到消息返回到客户端\n");  bw.flush();    //读取服务器返回的消息  BufferedReader br = new BufferedReader(new InputStreamReader(is));  String mess = br.readLine();  System._out_.println("服务器："+mess);  } catch (UnknownHostException e) {                    e.printStackTrace();  } catch (IOException e) {                    e.printStackTrace();  }            }        }).start();  }}</pre><pre>public class TCP服务端 {    public static void main(String[] args) {        new Thread(new Runnable() {            @Override  public void run() {                try {                    ServerSocket ss = new ServerSocket(1234); while (true) {                        System._out_.println("启动服务器....");  Socket s = ss.accept();  System._out_.println("客户端:" + s.getInetAddress().getLocalHost() + "已连接到服务器");  BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));  //读取客户端发送来的消息  String mess = br.readLine();  System._out_.println("客户端：" + mess);  BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));  bw.write(mess + "\n");  bw.flush();  }                } catch (IOException e) {                    e.printStackTrace();  }            }        }).start();  }}</pre><h2 id="补充2：UDP客户端和服务端"><a href="#补充2：UDP客户端和服务端" class="headerlink" title="补充2：UDP客户端和服务端"></a>补充2：UDP客户端和服务端</h2><pre>public class UDP客户端 {    public static void main(String[] args) {        new Thread(new Runnable() {            @Override  public void run() {                byte []arr = "Hello Server".getBytes(); try {                    InetAddress inetAddress = InetAddress.getLocalHost();  DatagramSocket datagramSocket = new DatagramSocket();  DatagramPacket datagramPacket = new DatagramPacket(arr, arr.length, inetAddress, 1234);  datagramSocket.send(datagramPacket);  System._out_.println("send end");  } catch (UnknownHostException e) {                    e.printStackTrace();  } catch (SocketException e) {                    e.printStackTrace();  } catch (IOException e) {                    e.printStackTrace();  }            }        }).start();  }}</pre><pre>public class UDP服务端 {    public static void main(String[] args) {        new Thread(new Runnable() {            @Override  public void run() {                try {                    DatagramSocket datagramSocket = new DatagramSocket(1234); byte[] buffer = new byte[1024];  DatagramPacket packet = new DatagramPacket(buffer, buffer.length);  datagramSocket.receive(packet);  System._out_.println("server recv");  String msg = new String(packet.getData(), "utf-8");  System._out_.println(msg);  } catch (SocketException e) {                    e.printStackTrace();  } catch (IOException e) {                    e.printStackTrace();  }            }        }).start();  }}</pre><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md#%E5%90%8E%E7%BB%AD" target="_blank" rel="noopener"></a>后续</h2><ul><li>JAVA 中是如何实现 IO多路复用</li><li>Netty 下的实现异步请求的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://github.com/jasonGeng88/blog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/jasonGeng88/blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java网络编程和NIO &lt;a href=&quot;https://blog.csdn.net/column/details/21963.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21963.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java网络编程与NIO" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO/"/>
    
    
      <category term="Java网络编程" scheme="http://h2pl.github.io/tags/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程和NIO详解开篇：Java网络编程基础</title>
    <link href="http://h2pl.github.io/2018/05/25/Javanet/"/>
    <id>http://h2pl.github.io/2018/05/25/Javanet/</id>
    <published>2018-05-25T03:53:28.000Z</published>
    <updated>2018-06-02T14:22:30.193Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java网络编程和NIO <a href="https://blog.csdn.net/column/details/21963.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21963.html</a></p><p>部分代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><h1 id="计算机网络编程基础"><a href="#计算机网络编程基础" class="headerlink" title="计算机网络编程基础"></a>计算机网络编程基础</h1><p>转自：<a href="https://mp.weixin.qq.com/s/XXMz5uAFSsPdg38bth2jAA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/XXMz5uAFSsPdg38bth2jAA</a></p><p>我们是幸运的，因为我们拥有网络。网络是一个神奇的东西，它改变了你和我的生活方式，改变了整个世界。 然而，网络的无标度和小世界特性使得它又是复杂的，无所不在，无所不能，以致于我们无法区分甚至无法描述。</p><p>对于一个码农而言，了解网络的基础知识可能还是从了解定义开始，认识OSI的七层协议模型，深入Socket内部，进而熟练地进行网络编程。</p><p>关于网络</p><p>关于网络，在词典中的定义是这样的：</p><p>在电的系统中，由若干元件组成的用来使电信号按一定要求传输的电路或这种电路的部分，叫网络。</p><p>作为一名从事过TMN开发的通信专业毕业生，固执地认为网络是从通信系统中诞生的。通信是人与人之间通过某种媒介进行的信息交流与传递。传统的通信网络（即电话网络）是由传输、交换和终端三大部分组成，通信网络是指将各个孤立的设备进行物理连接，实现信息交换的链路，从而达到资源共享和通信的目的。通信网络可以从覆盖范围，拓扑结构，交换方式等诸多视角进行分类…… 满满的回忆，还是留在书架上吧。</p><p>网络的概念外延被不断的放大着，抽象的思维能力是人们创新乃至创造的根源。网络用来表示诸多对象及其相互联系，数学上的图，物理学上的模型,交通网络，人际网络，城市网络等等，总之，网络被总结成从同类问题中抽象出来用数学中的图论科学来表达并研究的一种模型。</p><p>很多伙伴认为，了解这些之后呢，然并卵。我们关心的只是计算机网络，算机网络是用通信线路和设备将分布在不同地点的多台计算机系统互相连接起来，按照网络协议，分享软硬件功能，最终实现资源共享的系统。特别的，我们谈到的网络只是互联网——Internet，或者移动互联网，需要的是写互连网应用程序。但是，一位工作了五六年的编程高手曾对我说，现在终于了解到基础知识有多重要，技术在不断演进，而相对不变的就是那些原理和编程模型了。</p><p>老码农深以为然，编程实践就是从具体到抽象，再到具体，循环往复，螺旋式上升的过程。了解前世今生，只是为了可能触摸到“势”。基础越扎实，建筑就会越有想象的空间。 对于网络编程的基础，大概要从OSI的七层协议模型开始了。</p><h2 id="七层模型"><a href="#七层模型" class="headerlink" title="七层模型"></a>七层模型</h2><p>七层模型（OSI，Open System Interconnection参考模型），是参考是国际标准化组织制定的一个用于计算机或通信系统间互联的标准体系。它是一个七层抽象的模型，不仅包括一系列抽象的术语和概念，也包括具体的协议。 经典的描述如下：</p><p>简述每一层的含义：</p><ol><li><p>物理层（Physical Layer）：建立、维护、断开物理连接。</p></li><li><p>数据链路层 (Link)：逻辑连接、进行硬件地址寻址、差错校验等。</p></li><li><p>网络层 (Network)：进行逻辑寻址，实现不同网络之间的路径选择。</p></li><li><p>传输层 (Transport)：定义传输数据的协议端口号，及流控和差错校验。</p></li><li><p>会话层（Session Layer）：建立、管理、终止会话。</p></li><li><p>表示层（Presentation Layer）：数据的表示、安全、压缩。</p></li><li><p>应用层 (Application)：网络服务与最终用户的一个接口</p></li></ol><p>每一层利用下一层提供的服务与对等层通信，每一层使用自己的协议。了解了这些，然并卵。但是，这一模型确实是绝大多数网络编程的基础，作为抽象类存在的，而TCP／IP协议栈只是这一模型的一个具体实现。</p><h3 id="TCP-IP-协议模型"><a href="#TCP-IP-协议模型" class="headerlink" title="TCP/IP 协议模型"></a>TCP/IP 协议模型</h3><p>TCP/IP是Internet的基础，是一组协议的代名词，包括许多协议，组成了TCP/IP协议栈。TCP／IP 有四层模型和五层模型之说，区别在于数据链路层是否作为独立的一层存在。个人倾向于5层模型，这样2层和3层的交换设备更容易弄明白。当谈到网络的2层或3层交换机的时候，就知道指的是那些协议。</p><p>数据是如何传递呢？这就要了解网络层和传输层的协议，我们熟知的IP包结构是这样的： </p><p><img src="https://img-blog.csdn.net/20180601221723141?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3MjQ4ODg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>IP协议和IP地址是两个不同的概念，这里没有涉及IPV6的。不关注网络安全的话，对这些结构不必耳熟能详的。传输层使用这样的数据包进行传输，传输层又分为面向连接的可靠传输TCP和数据报UDP。TCP的包结构： </p><p><img src="https://img-blog.csdn.net/20180601221803983?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3MjQ4ODg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>TCP 连接建立的三次握手肯定是必知必会，在系统调优的时候，内核中关于网络的相关参数与这个图息息相关。UDP是一种无连接的传输层协议，提供的是简单不可靠的信息传输。协议结构相对简单，包括源和目标的端口号，长度以及校验和。基于TCP和UDP的数据封装及解析示例如下： </p><p><img src="https://img-blog.csdn.net/20180601221848793?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3MjQ4ODg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>还是然并卵么？一个数据包的大小了解了，会发现什么呢？PayLoad到底是多少？在设计协议通信的时候，这些都为我们提供了粒度定义的依据。进一步，通过一个例子看看吧。</p><h3 id="模型解读示例"><a href="#模型解读示例" class="headerlink" title="模型解读示例"></a>模型解读示例</h3><p>FTP是一个比较好的例子。为了方便起见，假设两条计算机分别是A 和 B，将使用FTP 将A上的一个文件X传输到B上。</p><p>首先，计算机A和B之间要有物理层的连接，可以是有线比如同轴电缆或者双绞线通过RJ-45的电路接口连接，也可以是无线连接例如WIFI。先简化一下，考虑局域网，暂不讨论路由器和交换机以及WIFI热点。这些物理层的连接建立了比特流的原始传输通路。</p><p>接下来，数据链路层登场，建立两台计算机的数据链路。如果A和B所在的网络上同时连接着计算机C，D，E等等，A和B之间如何建立的数据链路呢？这一过程就是物理寻址，A要在众多的物理连接中找到B，依赖的是计算机的物理地址即MAC地址，对就是网卡上的MAC地址。以太网采用CSMA/CD方式来传输数据，数据在以太网的局域网中都是以广播方式传输的，整个局域网中的所有节点都会收到该帧，只有目标MAC地址与自己的MAC地址相同的帧才会被接收。A通过差错控制和接入控制找到了B的网卡，建立可靠的数据通路。</p><p>那IP地址呢？ 数据链路建立起来了，还需要IP地址么？我们FTP 命令中制定的是IP地址而不是MAC地址呀？IP地址是逻辑地址，包括网络地址和主机地址。如果A和B在不同的局域网中，中间有着多个路由器，A需要对B进行逻辑寻址才可以的。物理地址用于底层的硬件的通信，逻辑地址用于上层的协议间的通信。在以太网中：逻辑地址就是IP地址，物理地址就是MAC 地址。在使用中，两种地址是用一定的算法将他们两个联系起来的。所以，IP是用来在网络上选择路由的，在FTP的命令中，IP中的原地址就是A的IP地址，目标地址就是B的IP地址。这应该就是网络层，负责将分组数据从源端传输到目的端。</p><p>A向B传输一个文件时，如果文件中有部分数据丢失，就可能会造成在B上无法正常阅读或使用。所以需要一个可靠的连接，能够确保传输过程的完整性，这就是传输层的TCP协议，FTP就是建立在TCP之上的。TCP的三次握手确定了双方数据包的序号、最大接受数据的大小(window)以及MSS(Maximum Segment Size)。TCP利用IP完成寻址，TCP中的提供了端口号，FTP中目的端口号一般是21。传输层的端口号对应主机进程，指本地主机与远程主机正在进行的会话。</p><p>会话层用来建立、维护、管理应用程序之间的会话，主要功能是对话控制和同步，编程中所涉及的session是会话层的具体体现。表示层完成数据的解编码，加解密，压缩解压缩等，例如FTP中bin命令，代表了二进制传输，即所传输层数据的格式。 HTTP协议里body中的Json，XML等都可以认为是表示层。应用层就是具体应用的本身了，FTP中的PUT，GET等命令都是应用的具体功能特性。</p><p>简单地，物理层到电缆连接，数据链路层到网卡，网络层路由到主机，传输层到端口，会话层维持会话，表示层表达数据格式，应用层就是具体FTP中的各种命令功能了。</p><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>了解了7层模型就可以编程了么，拿起编程语言就可以耍了么？刚开始上手尝试还是可以的，如果要进一步，老码农觉得还是看看底层实现的好，因为一切归根到底都会归结为系统调用。到了操作系统层面如何看网络呢？Socket登场了。</p><p>在Linux世界，“一切皆文件”，操作系统把网络读写作为IO操作，就像读写文件那样，对外提供出来的编程接口就是Socket。所以，socket（套接字）是通信的基石，是支持TCP/IP协议网络通信的基本操作单元。socket实质上提供了进程通信的端点。进程通信之前，双方首先必须各自创建一个端点，否则是没有办法建立联系并相互通信的。一个完整的socket有一个本地唯一的socket号，这是由操作系统分配的。</p><p>从设计模式的角度看， Socket其实是一个外观模式，它把复杂的TCP/IP协议栈隐藏在Socket接口后面，对用户来说，一组简单的Socket接口就是全部。当应用程序创建一个socket时，操作系统就返回一个整数作为描述符（descriptor）来标识这个套接字。然后，应用程序以该描述符为传递参数，通过调用函数来完成某种操作（例如通过网络传送数据或接收输入的数据）。</p><p>在许多操作系统中，Socket描述符和其他I/O描述符是集成在一起的，操作系统把socket描述符实现为一个指针数组，这些指针指向内部数据结构。进一步看，操作系统为每个运行的进程维护一张单独的文件描述符表。当进程打开一个文件时，系统把一个指向此文件内部数据结构的指针写入文件描述符表，并把该表的索引值返回给调用者 。</p><p>既然Socket和操作系统的IO操作相关，那么各操作系统IO实现上的差异会导致Socket编程上的些许不同。看看我Mac上的Socket.so 会发现和CentOS上的还是些不同的。 </p><p>进程进行Socket操作时，也有着多种处理方式，如阻塞式IO，非阻塞式IO，多路复用(select/poll/epoll)，AIO等等。</p><p>多路复用往往在提升性能方面有着重要的作用。select系统调用的功能是对多个文件描述符进行监视，当有文件描述符的文件读写操作完成以及发生异常或者超时，该调用会返回这些文件描述符。select 需要遍历所有的文件描述符，就遍历操作而言，复杂度是 O(N)。</p><p>epoll相关系统调用是在Linux 2.5 后的某个版本开始引入的。该系统调用针对传统的select/poll不足，设计上作了很大的改动。select/poll 的缺点在于: </p><ol><li><p>每次调用时要重复地从用户模式读入参数，并重复地扫描文件描述符。</p></li><li><p>每次在调用开始时，要把当前进程放入各个文件描述符的等待队列。在调用结束后，又把进程从各个等待队列中删除。</p></li></ol><p>epoll 是把 select/poll 单个的操作拆分为 1 个 epollcreate，多个 epollctrl和一个 wait。此外，操作系统内核针对 epoll 操作添加了一个文件系统，每一个或者多个要监视的文件描述符都有一个对应的inode 节点，主要信息保存在 eventpoll 结构中。而被监视的文件的重要信息则保存在 epitem 结构中，是一对多的关系。由于在执行 epollcreate 和 epollctrl 时，已经把用户模式的信息保存到内核了， 所以之后即便反复地调用 epoll_wait，也不会重复地拷贝参数，不会重复扫描文件描述符，也不反复地把当前进程放入/拿出等待队列。</p><p>所以，当前主流的Server侧Socket实现大都采用了epoll的方式，例如Nginx， 在配置文件可以显式地看到 <code>use epoll</code>。</p><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p>了解了7层协议模型和操作系统层面的Socket实现，可以方便我们理解网络编程。</p><p>在系统架构的时候，有重要的一环就是拓扑架构，这里涉及了网络等基础设施，那么7层协议下四层就会有助于我们对业务系统网络结构的观察和判断。在系统设计的时候，往往采用面向接口的设计，而接口也往往是基于HTTP协议的Restful API。 那接口的粒度就可以将data segment作为一个约束了，同时可以关注到移动互联网中的弱网环境。</p><p>不同的编程语言，有着不同的框架和库，真正的编写网络程序代码并不复杂，例如，用Erlang 中 gen_tcp 用于编写一个简单的Echo服务器： </p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Start_echo_server<span class="function"><span class="params">()</span>-&gt;</span></span><br><span class="line">         &#123;ok,Listen&#125;= gen_tcp:listen(<span class="number">1234</span>,[binary,&#123;packet,<span class="number">4</span>&#125;,&#123;reuseaddr,<span class="literal">true</span>&#125;,&#123;active,<span class="literal">true</span>&#125;]),</span><br><span class="line">         &#123;ok,socket&#125;=get_tcp:accept(Listen),</span><br><span class="line">         gen_tcp:close(Listen),</span><br><span class="line">         <span class="keyword">loop</span>(Socket).</span><br><span class="line"></span><br><span class="line"><span class="keyword">loop</span><span class="function"><span class="params">(Socket)</span> -&gt;</span></span><br><span class="line">         receive</span><br><span class="line">                  &#123;tcp,Socket,Bin&#125;<span class="function"> -&gt;</span></span><br><span class="line">                            io:format(“serverreceived binary = ~p~n”,[Bin])</span><br><span class="line">                            Str= binary_to_term(Bin),</span><br><span class="line">                            io:format(“server  (unpacked) ~p~n”,[Str]),</span><br><span class="line">                            Reply= lib_misc:string2value(Str),</span><br><span class="line">                            io:format(“serverreplying = ~p~n”,[Reply]),</span><br><span class="line">                            gen_tcp:send(Socket,term_to_binary(Reply)),</span><br><span class="line">                            <span class="keyword">loop</span>(Socket);</span><br><span class="line">                   &#123;tcp_closed,Socket&#125;<span class="function"> -&gt;</span></span><br><span class="line">                            Io:format(“ServerSocket closed ~n”)</span><br><span class="line">         end.</span><br></pre></td></tr></table></figure><p>然而，写出漂亮的服务器程序仍然是一件非常吃功夫的事情，例如，个人非常喜欢的python Tornado 代码, 在ioloop.py 中有对多路复用的选择：</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@classmethod</span><br><span class="line">def configurable_default(cls):</span><br><span class="line">        <span class="keyword">if</span> hasattr(<span class="built_in">select</span>, <span class="string">"epoll"</span>):</span><br><span class="line">            <span class="keyword">from</span> tornado.platform.epoll <span class="keyword">import</span> EPollIOLoop</span><br><span class="line">            <span class="keyword">return</span> EPollIOLoop</span><br><span class="line">        <span class="keyword">if</span> hasattr(<span class="built_in">select</span>, <span class="string">"kqueue"</span>):</span><br><span class="line">            # Python <span class="number">2.6</span>+ on BSD <span class="keyword">or</span> Mac</span><br><span class="line">            <span class="keyword">from</span> tornado.platform.kqueue <span class="keyword">import</span> KQueueIOLoop</span><br><span class="line">            <span class="keyword">return</span> KQueueIOLoop</span><br><span class="line">        <span class="keyword">from</span> tornado.platform.<span class="built_in">select</span> <span class="keyword">import</span> SelectIOLoop</span><br><span class="line">        <span class="keyword">return</span> SelectIOLoop</span><br></pre></td></tr></table></figure><p>在HTTPServer.py 中同样继承了TCPServer，进而实现了HTTP协议，代码片段如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class HTTPServer(TCPServer, Configurable,</span><br><span class="line">                httputil.HTTPServerConnectionDelegate):</span><br><span class="line">                <span class="built_in">..</span>.</span><br><span class="line">    def initialize(self, request_callback, <span class="attribute">no_keep_alive</span>=<span class="literal">False</span>, <span class="attribute">io_loop</span>=None,</span><br><span class="line">                   <span class="attribute">xheaders</span>=<span class="literal">False</span>, <span class="attribute">ssl_options</span>=None, <span class="attribute">protocol</span>=None,</span><br><span class="line">                   <span class="attribute">decompress_request</span>=<span class="literal">False</span>,</span><br><span class="line">                   <span class="attribute">chunk_size</span>=None, <span class="attribute">max_header_size</span>=None,</span><br><span class="line">                   <span class="attribute">idle_connection_timeout</span>=None, <span class="attribute">body_timeout</span>=None,</span><br><span class="line">                   <span class="attribute">max_body_size</span>=None, <span class="attribute">max_buffer_size</span>=None):</span><br><span class="line">        self.request_callback = request_callback</span><br><span class="line">        self.no_keep_alive = no_keep_alive</span><br><span class="line">        self.xheaders = xheaders</span><br><span class="line">        self.protocol = protocol</span><br><span class="line">        self.conn_params = HTTP1ConnectionParameters(</span><br><span class="line">            <span class="attribute">decompress</span>=decompress_request,</span><br><span class="line">            <span class="attribute">chunk_size</span>=chunk_size,</span><br><span class="line">            <span class="attribute">max_header_size</span>=max_header_size,</span><br><span class="line">            <span class="attribute">header_timeout</span>=idle_connection_timeout <span class="keyword">or</span> 3600,</span><br><span class="line">            <span class="attribute">max_body_size</span>=max_body_size,</span><br><span class="line">            <span class="attribute">body_timeout</span>=body_timeout)</span><br><span class="line">        TCPServer.__init__(self, <span class="attribute">io_loop</span>=io_loop, <span class="attribute">ssl_options</span>=ssl_options,</span><br><span class="line">                           <span class="attribute">max_buffer_size</span>=max_buffer_size,</span><br><span class="line">                           <span class="attribute">read_chunk_size</span>=chunk_size)</span><br><span class="line">        self._connections = <span class="builtin-name">set</span>()</span><br><span class="line">        <span class="built_in">..</span>.</span><br></pre></td></tr></table></figure><h1 id="Java网络编程基础"><a href="#Java网络编程基础" class="headerlink" title="Java网络编程基础"></a>Java网络编程基础</h1><p>Java网络编程基础<br>转自并发编程网<a href="https://ifeve.com/" target="_blank" rel="noopener">https://ifeve.com/</a></p><p>Java 网络教程: 基础</p><p>Java提供了非常易用的网络API，调用这些API我们可以很方便的通过建立TCP/IP或UDP套接字，在网络之间进行相互通信，其中TCP要比UDP更加常用，但在本教程中我们对这两种方式都有说明。</p><p>尽管Java网络API允许我们通过套接字（Socket）打开或关闭网络连接，但所有的网络通信均是基于Java IO类 InputStream和OutputStream实现的。</p><p>此外，我们还可以使用Java NIO API中相关的网络类，用法与Java网络API基本类似，Java NIO API可以以非阻塞模式工作，在某些特定的场景中使用非阻塞模式可以获得较大的性能提升。</p><p>Java TCP网络基础</p><p>通常情况下，客户端打开一个连接到服务器端的TCP/IP连接，然后客户端开始与服务器之间通信，当通信结束后客户端关闭连接，过程如下图所示：</p><p>ClientServerOpen ConnectionSend RequestReceive ResponseClose Connection</p><p>​客户端通过一个已打开的连接可以发送不止一个请求。事实上在服务器处于接收状态下，客户端可以发送尽可能多的数据，服务器也可以主动关闭连接。</p><p>Java中Socket类和ServerSocket类</p><p>当客户端想要打开一个连接到服务器的TCP/IP连接时，就要使用到Java Socket类。socket类只需要被告知连接的IP地址和TCP端口，其余的都有Java实现。</p><p>假如我们想要打开一个监听服务，来监听客户端连接某些指定TCP端口的连接，那就需要使用Java ServerSocket类。当客户端通过Socket连接服务器端的ServerSocket监听时，服务器端会指定这个连接的一个Socket，此时客户端与服务器端间的通信就变成Socket与Socket之间的通信。</p><p>关于Socket类和ServerSocket类会在后面的文章中有详细的介绍。</p><p>Java UDP网络基础</p><p>UDP的工作方式与TCP相比略有不同。使用UDP通信时，在客户端与服务器之间并没有建立连接的概念，客户端发送到服务器的数据，服务器可能（也可能并没有）收到这些数据，而且客户端也并不知道这些数据是否被服务器成功接收。当服务器向客户端发送数据时也是如此。</p><p>正因为是不可靠的数据传输，UDP相比与TCP来说少了很多的协议开销。</p><p>在某些场景中，使用无连接的UDP要优于TCP，这些在文章Java UDP DatagramSocket类介绍中会有更多介绍。</p><p>当我们想要在Java中使用TCP/IP通过网络连接到服务器时，就需要创建java.net.Socket对象并连接到服务器。假如希望使用Java NIO，也可以创建Java NIO中的SocketChannel对象。</p><h2 id="Socket-1"><a href="#Socket-1" class="headerlink" title="Socket"></a>Socket</h2><p>创建Socket</p><p>下面的示例代码是连接到IP地址为78.64.84.171服务器上的80端口，这台服务器就是我们的Web服务器（<a href="http://www.jenkov.com），而80端口就是Web服务端口。" target="_blank" rel="noopener">www.jenkov.com），而80端口就是Web服务端口。</a></p><p>Socket socket = new Socket(“78.46.84.171”, 80);<br>我们也可以像如下示例中使用域名代替IP地址：</p><p>Socket socket = new Socket(“jenkov.com”, 80);</p><p>Socket发送数据</p><p>要通过Socket发送数据，我们需要获取Socket的输出流（OutputStream），示例代码如下：</p><p>Socket socket = new Socket(“jenkov.com”, 80);<br>OutputStream out = socket.getOutputStream(); </p><p>out.write(“some data”.getBytes());<br>out.flush();<br>out.close(); </p><p>socket.close();<br>代码非常简单，但是想要通过网络将数据发送到服务器端，一定不要忘记调用flush()方法。操作系统底层的TCP/IP实现会先将数据放入一个更大的数据缓存块中，而缓存块的大小是与TCP/IP的数据包大小相适应的。（译者注：调用flush()方法只是将数据写入操作系统缓存中，并不保证数据会立即发送）</p><p>Socket读取数据</p><p>从Socket中读取数据，我们就需要获取Socket的输入流（InputStream），代码如下：</p><p>Socket socket = new Socket(“jenkov.com”, 80);<br>InputStream in = socket.getInputStream(); </p><p>int data = in.read();<br>//… read more data… </p><p>in.close();<br>socket.close();<br>代码也并不复杂，但需要注意的是，从Socket的输入流中读取数据并不能读取文件那样，一直调用read()方法直到返回-1为止，因为对Socket而言，只有当服务端关闭连接时，Socket的输入流才会返回-1，而是事实上服务器并不会不停地关闭连接。假设我们想要通过一个连接发送多个请求，那么在这种情况下关闭连接就显得非常愚蠢。</p><p>因此，从Socket的输入流中读取数据时我们必须要知道需要读取的字节数，这可以通过让服务器在数据中告知发送了多少字节来实现，也可以采用在数据末尾设置特殊字符标记的方式连实现。</p><p>关闭Socket</p><p>当使用完Socket后我们必须将Socket关闭，断开与服务器之间的连接。关闭Socket只需要调用Socket.close()方法即可，代码如下：</p><p>Socket socket = new Socket(“jenkov.com”, 80); </p><p>socket.close();<br>Java 网络教程: ServerSocket<br>用java.net.ServerSocket实现java服务通过TCP/IP监听客户端连接，你也可以用Java NIO 来代替java网络标准API，这时候需要用到 ServerSocketChannel。</p><p>创建一个 ServerSocket连接<br>以下是一个创建ServerSocket类来监听9000端口的一个简单的代码</p><p>ServerSocket serverSocket = new ServerSocket(9000);</p><p>监听请求的连接<br>要获取请求的连接需要用ServerSocket.accept()方法。该方法返回一个Socket类，该类具有普通java Socket类的所有特性。代码如下：</p><p>ServerSocket serverSocket = new ServerSocket(9000); boolean isStopped = false;while(!isStopped){   Socket clientSocket = serverSocket.accept();    //do something with clientSocket}</p><p>对每个调用了accept()方法的类都只获得一个请求的连接。</p><p>另外，请求的连接也只能在线程运行的server中调用了accept()方法之后才能够接受请求。线程运行在server中其它所有的方法上的时候都不能接受客户端的连接请求。所以”接受”请求的线程通常都会把Socket的请求连接放入一个工作线程池中，然后再和客户端连接。更多关于多线程服务端设计的文档请参考 java多线程服务</p><p>关闭客户端Socket<br>客户端请求执行完毕，并且不会再有该客户端的其它请求发送过来的时候，就需要关闭Socket连接，这和关闭一个普通的客户端Socket连接一样。如下代码来执行关闭：</p><p>socket.close();</p><p>关闭服务端Sockets<br>要关闭服务的时候需要关掉 ServerSocket连接。通过执行如下代码：</p><p>serverSocket.close();</p><h2 id="UDP-DatagramSocket"><a href="#UDP-DatagramSocket" class="headerlink" title="UDP DatagramSocket"></a>UDP DatagramSocket</h2><p>DatagramSocket类是java通过UDP通信的途径。UDP仍位于IP层的上面。 你可以用DatagramSocket类发送和接收UDP数据包。</p><p>UDP 和TCP</p><p>UDP工作方式和TCP有点不同。当你通过TCP发送数据时，你先要创建连接。一旦TCP连接建立了，TCP会保证你的数据传递到对端，否则它将告诉你已发生的错误。</p><p>仅仅用UDP来发送数据包（datagrams）到网络间的某个IP地址。你不能保证数据会不会到达。你也不能保证UDP数据包到达接收方的指令。这意味着UDP比TCP有更少的协议开销（无完整检查流）。</p><p>当数据传输过程中不在乎数据包是否丢失时，UDP就比较适合这样的数据传输。比如，网上的电视信号的传输。你希望信号到达客户端时尽可能地接近直播。因此，如果丢失一两个画面，你一点都不在乎。你不希望直播延迟，值想确保所有的画面显示在客户端。你宁可跳过丢失的画面，希望一直看到最新的画面。</p><p>这种情况也会发生在网上摄像机直播节目中。谁会关心过去发生的什么，你只想显示当前的画面。你不希望比实际情况慢30s结束，只因为你想看到摄像机显示给观众的所有画面。这跟摄像机录像有点不同。从摄像机录制画面到磁盘，你不希望丢失一个画面。你可能还希望有点延迟，如果有重大的情况发生，就不需要倒回去检查画面。</p><p>通过DatagramSocket发送数据<br>通过Java的DatagramSocket类发送数据，首先需要创建DatagramPacket。如下：</p><p>1    buffer = new byte[65508];<br>2<br>3    InetAddress address = new DatagramPacket(buffer, buffer.length, address,9000);<br>字节缓冲块（字节数组）就是UDP数据包中用来发送的数据。缓冲块上限长度为65508字节，是单一UDP数据包发送的最大的数据量。</p><p>数据包构造函数的长度就是缓存块中用于发送的数据的长度。所有多于最大容量的数据都会被忽略。</p><p>包含节点（例如服务器）地址的InetAddress实例携带节点（如服务器）的地址发送的UDP数据包。InetAddress类表示一个ip地址（网络地址）。getByName()方法返回带有一个InetAddress实例，该实例带有匹配主机名的ip地址。</p><p>端口参数是UDP端口服务器用来接收正在监听的数据。UDP端口和TCP端口是不一样的。一台电脑同时有不同的进程监听UDP和TCP 80端口。</p><p>为了发送数据包，你需要创建DatagramSocket来发送数据。如下：</p><pre><code>1    DatagramSocketdatagramSocket = new DatagramSocket();</code></pre><p>调用send()方法发送数据，像这样：</p><pre><code>1    datagramSocket.send(packet);完整示例：1    DatagramSocket datagramSocket = new DatagramSocket();2     3    byte[] buffer = &quot;0123456789&quot;.getBytes();4     5    InetAddress receiverAddress = InetAddress.getLocalHost();6     7    DataframPacket packet = new DatagramPacket( buffer, buffer.length, receiverAddress,80);8    datagramSocket.send(packet);</code></pre><p>从DatagramSocket获取数据<br>从DataframSocket获取数据时，首先创建DataframPacket ,然后通过DatagramSocket类的receive()方法接收数据。例如：</p><pre><code>1    DatagramSocket datagramSocket = new DatagramSocket(80);2     3    byte[] buffer = new byte[10];4     5    DatagramPacket packet = new DatagramPacket(buffer, buffer.length);6     7    datagramSocket.receive(packet);</code></pre><p>注意DatagramSocket是如何通过传递参数80到它的构造器初始化的。这个参数是UDP端口的DatagramSocket用来接收UDP数据包的。像之前提到的，TCP和UDP端口是不一样的，也不重叠。你可以有俩个不同的进程同时在端口80监听TCP和UDP，没有任何冲突。</p><p>第二，字节缓存块和DatagramPacket创建了。注意DatagramPacket是没有关于节点如何发送数据的信息的，当创建一个方数据的DatagramPacket时，它会直到这个信息。这就是为什么我们会用DatagramPacket接收数据而不是发送数据。因此没有目标地址是必须的。</p><p>最后，调用DatagramSocket的receive()方法。直到数据包接收到为止，这个方法都是阻塞的。</p><p>接收的数据位于DatagramPacket的字节缓冲块。缓冲块可以通过调用getData()获得：</p><p>1    byte[] buffer = packet.getData();<br>缓冲块接收了多少的数据需要你去找出来。你用的协议应该定义每个UDP包发多少数据，活着定义一个你能找到的数据结束标记。<br>一个真正的服务端程序可能会在一个loop中调用receive()方法，传送所有接收到的DatagramPacket到工作的线程池中，就像TCP服务器处理请求连接一样（查看Java Multithreaded Servers获取更多详情）</p><h2 id="URL-URLConnection"><a href="#URL-URLConnection" class="headerlink" title="URL + URLConnection"></a>URL + URLConnection</h2><p>HTTP GET和POST<br>从URLs到本地文件<br>在java.net包中包含两个有趣的类：URL类和URLConnection类。这两个类可以用来创建客户端到web服务器（HTTP服务器）的连接。下面是一个简单的代码例子：</p><pre><code>1    URL url = new URL(&quot;http://jenkov.com&quot;);2    URLConnection urlConnection = url.openConnection();3    InputStream input = urlConnection.getInputStream();4    int data = input.read();5    while(data != -1){6    System.out.print((char) data);7    data = input.read();8    }9    input.close();</code></pre><p>HTTP GET和POST<br>默认情况下URLConnection发送一个HTTP GET请求到web服务器。如果你想发送一个HTTP POST请求，要调用URLConnection.setDoOutput(true)方法，如下：</p><pre><code>1    URL url = new URL(&quot;http://jenkov.com&quot;);2    URLConnection urlConnection = url.openConnection();3    urlConnection.setDoOutput(true);</code></pre><p>一旦你调用了setDoOutput(true)，你就可以打开URLConnection的OutputStream，如下：</p><pre><code>1    OutputStream output = urlConnection.getOutputStream();</code></pre><p>你可以使用这个OutputStream向相应的HTTP请求中写任何数据，但你要记得将其转换成URL编码（关于URL编码的解释，自行Google）（译者注：具体名字是：application/x-www-form-urlencoded MIME 格式编码）。<br>当你写完数据的时候要记得关闭OutputStream。</p><p>从URLs到本地文件<br>URL也被叫做统一资源定位符。如果你的代码不关心文件是来自网络还是来自本地文件系统，URL类是另外一种打开文件的方式。<br>下面是一个如何使用URL类打开一个本地文件系统文件的例子：</p><pre><code>1    URL url = new URL(&quot;file:/c:/data/test.txt&quot;);2    URLConnection urlConnection = url.openConnection();3    InputStream input = urlConnection.getInputStream();4    int data = input.read();5    while(data != -1){6    System.out.print((char) data);7    data = input.read();8    }9    input.close();</code></pre><p>注意：这和通过HTTP访问一个web服务器上的文件的唯一不同处就是URL：”file:/c:/data/test.txt”。</p><h2 id="JarURLConnection"><a href="#JarURLConnection" class="headerlink" title="JarURLConnection"></a>JarURLConnection</h2><p>Java的JarURLConnection类用来连接Java Jar文件。一旦连接上，你可以获取Jar文件的信息。一个简单的例子如下：</p><pre><code>01    String urlString = &quot;http://butterfly.jenkov.com/&quot;02                     + &quot;container/download/&quot;03                     + &quot;jenkov-butterfly-container-2.9.9-beta.jar&quot;;04     05    URL jarUrl = new URL(urlString);06    JarURLConnection connection = new JarURLConnection(jarUrl);07     08    Manifest manifest = connection.getManifest();09     10    JarFile jarFile = connection.getJarFile();11    //do something with Jar file...</code></pre><h2 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h2><p>创建一个 InetAddress 实例<br>InetAddress 的内部方法<br>InetAddress 是 Java 对 IP 地址的封装。这个类的实例经常和 UDP DatagramSockets 和 Socket，ServerSocket 类一起使用。</p><p>创建一个 InetAddress 实例<br>InetAddress 没有公开的构造方法，因此你必须通过一系列静态方法中的某一个来获取它的实例。<br>&lt;!–more–&gt;</p><p>下面是为一个域名实例化 InetAddres 类的例子：</p><pre><code>InetAddress address = InetAddress.getByName(&quot;jenkov.com&quot;);</code></pre><p>当然也会有为匹配某个 IP 地址来实例化一个 InetAddress:</p><pre><code>InetAddress address = InetAddress.getByName(&quot;78.46.84.171&quot;);</code></pre><p>另外，它还有通过获取本地 IP 地址的来获取 InetAddress 的方法（正在运行程序的那台机器）</p><pre><code>InetAddress address = InetAddress.getLocalHost();</code></pre><p>InetAddress 内部方法<br>InetAddress 类还拥有大量你可以调用的其它方法。例如：你可以通过调用getAddress()方法来获取 IP 地址的 byte 数组。如果要了解更多的方法，最简单的方式就是读 JavaDoc 文档中关于 InetAddress 类的部分。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java网络编程和NIO &lt;a href=&quot;https://blog.csdn.net/column/details/21963.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21963.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java网络编程与NIO" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO/"/>
    
    
      <category term="Java网络编程" scheme="http://h2pl.github.io/tags/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="NIO" scheme="http://h2pl.github.io/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Java并发指南15：Fork join并发框架与工作窃取算法剖析</title>
    <link href="http://h2pl.github.io/2018/05/24/concurrent15/"/>
    <id>http://h2pl.github.io/2018/05/24/concurrent15/</id>
    <published>2018-05-24T14:47:05.000Z</published>
    <updated>2018-06-11T13:00:45.832Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java并发指南<br><a href="https://blog.csdn.net/column/details/21961.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21961.html</a></p><p>相关代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><p>转载自_<a href="http://ifeve.com/" target="_blank" rel="noopener">并发编程网 – ifeve.com</a></p><h2 id="什么是Fork-Join框架"><a href="#什么是Fork-Join框架" class="headerlink" title="什么是Fork/Join框架"></a>什么是Fork/Join框架</h2><p>Fork/Join框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p><p>我们再通过Fork和Join这两个单词来理解下Fork/Join框架，Fork就是把一个大任务切分为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果。比如计算1+2+。。＋10000，可以分割成10个子任务，每个子任务分别对1000个数进行求和，最终汇总这10个子任务的结果。Fork/Join的运行流程图如下：</p><p><img src="http://infoqstatic.com/resource/articles/fork-join-introduction/zh/resources/21.png" alt=""></p><h2 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h2><p>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程图如下：</p><p><img src="http://ifeve.com/wp-content/uploads/2013/12/fj.png" alt="fj"></p><p>那么为什么需要使用工作窃取算法呢？假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p><p>工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p><h2 id="Fork-Join框架的介绍"><a href="#Fork-Join框架的介绍" class="headerlink" title="Fork/Join框架的介绍"></a>Fork/Join框架的介绍</h2><p>我们已经很清楚Fork/Join框架的需求了，那么我们可以思考一下，如果让我们来设计一个Fork/Join框架，该如何设计？这个思考有助于你理解Fork/Join框架的设计。</p><p>第一步分割任务。首先我们需要有一个fork类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停的分割，直到分割出的子任务足够小。</p><p>第二步执行任务并合并结果。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</p><p>Fork/Join使用两个类来完成以上两件事情：</p><ul><li>ForkJoinTask：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制，通常情况下我们不需要直接继承ForkJoinTask类，而只需要继承它的子类，Fork/Join框架提供了以下两个子类：<ul><li>RecursiveAction：用于没有返回结果的任务。</li><li>RecursiveTask ：用于有返回结果的任务。</li></ul></li><li>ForkJoinPool ：ForkJoinTask需要通过ForkJoinPool来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</li></ul><h2 id="使用Fork-Join框架"><a href="#使用Fork-Join框架" class="headerlink" title="使用Fork/Join框架"></a>使用Fork/Join框架</h2><p>让我们通过一个简单的需求来使用下Fork／Join框架，需求是：计算1+2+3+4的结果。</p><p>使用Fork／Join框架首先要考虑到的是如何分割任务，如果我们希望每个子任务最多执行两个数的相加，那么我们设置分割的阈值是2，由于是4个数字相加，所以Fork／Join框架会把这个任务fork成两个子任务，子任务一负责计算1+2，子任务二负责计算3+4，然后再join两个子任务的结果。</p><p>因为是有结果的任务，所以必须继承RecursiveTask，实现代码如下：</p><pre><code>001    packagefj;002     003    importjava.util.concurrent.ExecutionException;004     005    importjava.util.concurrent.ForkJoinPool;006     007    importjava.util.concurrent.Future;008     009    importjava.util.concurrent.RecursiveTask;010     011    publicclassCountTaskextendsRecursiveTask {012     013           privatestaticfinalintTHRESHOLD= 2;//阈值014     015           privateintstart;016     017           privateintend;018     019           publicCountTask(intstart,intend) {020     021                       this.start= start;022     023                       this.end= end;024     025            }026     027           @Override028     029           protectedInteger compute() {030     031                       intsum = 0;032     033                       //如果任务足够小就计算任务034     035                       booleancanCompute = (end-start) &lt;=THRESHOLD;036     037                       if(canCompute) {038     039                                  for(inti =start; i &lt;=end; i++) {040     041                                               sum += i;042     043                                   }044     045                        }else{046     047                                  //如果任务大于阀值，就分裂成两个子任务计算048     049                                  intmiddle = (start+end) / 2;050     051                                   CountTask leftTask =newCountTask(start, middle);052     053                                   CountTask rightTask =newCountTask(middle + 1,end);054     055                                  //执行子任务056     057                                   leftTask.fork();058     059                                   rightTask.fork();060     061                                  //等待子任务执行完，并得到其结果062     063                                  intleftResult=leftTask.join();064     065                                  intrightResult=rightTask.join();066     067                                  //合并子任务068     069                                   sum = leftResult  + rightResult;070     071                        }072     073                       returnsum;074     075            }076     077           publicstaticvoidmain(String[] args) {078     079                        ForkJoinPool forkJoinPool =newForkJoinPool();080     081                       //生成一个计算任务，负责计算1+2+3+4082     083                        CountTask task =newCountTask(1, 4);084     085                       //执行一个任务086     087                        Future result = forkJoinPool.submit(task);088     089                       try{090     091                                   System.out.println(result.get());092     093                        }catch(InterruptedException e) {094     095                        }catch(ExecutionException e) {096     097                        }098     099            }100     101    }</code></pre><p>通过这个例子让我们再来进一步了解ForkJoinTask，ForkJoinTask与一般的任务的主要区别在于它需要实现compute方法，在这个方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果不足够小，就必须分割成两个子任务，每个子任务在调用fork方法时，又会进入compute方法，看看当前子任务是否需要继续分割成孙任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会等待子任务执行完并得到其结果。</p><h2 id="Fork-Join框架的异常处理"><a href="#Fork-Join框架的异常处理" class="headerlink" title="Fork/Join框架的异常处理"></a>Fork/Join框架的异常处理</h2><p>ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常。使用如下代码：</p><pre>if(task.isCompletedAbnormally()){    System.out.println(task.getException());}</pre><p>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。</p><h2 id="Fork-Join框架的实现原理"><a href="#Fork-Join框架的实现原理" class="headerlink" title="Fork/Join框架的实现原理"></a>Fork/Join框架的实现原理</h2><p>ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，ForkJoinTask数组负责存放程序提交给ForkJoinPool的任务，而ForkJoinWorkerThread数组负责执行这些任务。</p><p>ForkJoinTask的fork方法实现原理。当我们调用ForkJoinTask的fork方法时，程序会调用ForkJoinWorkerThread的pushTask方法异步的执行这个任务，然后立即返回结果。代码如下：</p><pre><code>1    public final ForkJoinTask fork() {2            ((ForkJoinWorkerThread) Thread.currentThread())3                .pushTask(this);4            return this;5    }</code></pre><p>pushTask方法把当前任务存放在ForkJoinTask 数组queue里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。代码如下：</p><pre><code>01    final void pushTask(ForkJoinTask t) {02            ForkJoinTask[] q; int s, m;03            if ((q = queue) != null) {    // ignore if queue removed04                long u = (((s = queueTop) &amp; (m = q.length - 1)) &lt;&lt; ASHIFT) + ABASE;05                UNSAFE.putOrderedObject(q, u, t);06                queueTop = s + 1;         // or use putOrderedInt07                if ((s -= queueBase) &lt;= 2)08                    pool.signalWork();09        else if (s == m)10                    growQueue();11            }12        }</code></pre><p>ForkJoinTask的join方法实现原理。Join方法的主要作用是阻塞当前线程并等待获取结果。让我们一起看看ForkJoinTask的join方法的实现，代码如下：</p><pre><code>public final V join() {02            if (doJoin() != NORMAL)03                return reportResult();04            else05                return getRawResult();06    }07    private V reportResult() {08            int s; Throwable ex;09            if ((s = status) == CANCELLED)10                throw new CancellationException();11    if (s == EXCEPTIONAL &amp;&amp; (ex = getThrowableException()) != null)12                UNSAFE.throwException(ex);13            return getRawResult();14    }</code></pre><p>首先，它调用了doJoin()方法，通过doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有四种：已完成（NORMAL），被取消（CANCELLED），信号（SIGNAL）和出现异常（EXCEPTIONAL）。</p><ul><li>如果任务状态是已完成，则直接返回任务结果。</li><li>如果任务状态是被取消，则直接抛出CancellationException。</li><li>如果任务状态是抛出异常，则直接抛出对应的异常。</li></ul><p>让我们再来分析下doJoin()方法的实现代码：</p><p>01    private int doJoin() {<br>02            Thread t; ForkJoinWorkerThread w; int s; booleancompleted;<br>03            if ((t = Thread.currentThread()) instanceofForkJoinWorkerThread) {<br>04                if ((s = status) &lt; 0)<br>05     return s;<br>06                if ((w = (ForkJoinWorkerThread)t).unpushTask(this)) {<br>07                    try {<br>08                        completed = exec();<br>09                    } catch (Throwable rex) {<br>10                        return setExceptionalCompletion(rex);<br>11                    }<br>12                    if (completed)<br>13                        return setCompletion(NORMAL);<br>14                }<br>15                return w.joinTask(this);<br>16            }<br>17            else<br>18                return externalAwaitDone();<br>19        }</p><p>在doJoin()方法里，首先通过查看任务的状态，看任务是否已经执行完了，如果执行完了，则直接返回任务状态，如果没有执行完，则从任务数组里取出任务并执行。如果任务顺利执行完成了，则设置任务状态为NORMAL，如果出现异常，则纪录异常，并将任务状态设置为EXCEPTIONAL。</p><h2 id="Fork-Join源码剖析与算法解析"><a href="#Fork-Join源码剖析与算法解析" class="headerlink" title="Fork/Join源码剖析与算法解析"></a>Fork/Join源码剖析与算法解析</h2><p>我们在大学算法课本上，学过的一种基本算法就是：分治。其基本思路就是：把一个大的任务分成若干个子任务，这些子任务分别计算，最后再Merge出最终结果。这个过程通常都会用到递归。</p><p>而Fork/Join其实就是一种利用多线程来实现“分治算法”的并行框架。</p><p>另外一方面，可以把Fori/Join看作一个单机版的Map/Reduce，只不过这里的并行不是多台机器并行计算，而是多个线程并行计算。</p><p>下面看2个简单例子：</p><p>例子1： 快排<br>我们都知道，快排有2个步骤：<br>第1步，拿数组的第1个元素，把元素划分成2半，左边的比该元素小，右边的比该元素大；<br>第2步，对左右的2个子数组，分别排序。</p><p>可以看出，这里左右2个子数组，可以相互独立的，并行计算。因此可以利用ForkJoin框架， 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个Task，基础自RecursiveAction，实现其compute方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortTask</span> <span class="title">extends</span> <span class="title">RecursiveAction</span> &#123;</span></span><br><span class="line">    final <span class="keyword">long</span>[] <span class="built_in">array</span>;</span><br><span class="line">    final <span class="keyword">int</span> lo;</span><br><span class="line">    final <span class="keyword">int</span> hi;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> THRESHOLD = <span class="number">0</span>; <span class="comment">//For demo only</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SortTask</span><span class="params">(<span class="keyword">long</span>[] <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">array</span> = <span class="built_in">array</span>;</span><br><span class="line">        <span class="keyword">this</span>.lo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.hi = <span class="built_in">array</span>.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SortTask</span><span class="params">(<span class="keyword">long</span>[] <span class="built_in">array</span>, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">array</span> = <span class="built_in">array</span>;</span><br><span class="line">        <span class="keyword">this</span>.lo = lo;</span><br><span class="line">        <span class="keyword">this</span>.hi = hi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hi - lo &lt; THRESHOLD)</span><br><span class="line">            sequentiallySort(<span class="built_in">array</span>, lo, hi);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> pivot = partition(<span class="built_in">array</span>, lo, hi);  <span class="comment">//划分</span></span><br><span class="line">            coInvoke(<span class="keyword">new</span> SortTask(<span class="built_in">array</span>, lo, pivot - <span class="number">1</span>), <span class="keyword">new</span> SortTask(<span class="built_in">array</span>,</span><br><span class="line">                    pivot + <span class="number">1</span>, hi));  <span class="comment">//递归调，左右2个子数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">long</span>[] <span class="built_in">array</span>, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> x = <span class="built_in">array</span>[hi];</span><br><span class="line">        <span class="keyword">int</span> i = lo - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = lo; j &lt; hi; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt;= x) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                swap(<span class="built_in">array</span>, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(<span class="built_in">array</span>, i + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">long</span>[] <span class="built_in">array</span>, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">            <span class="keyword">long</span> temp = <span class="built_in">array</span>[i];</span><br><span class="line">            <span class="built_in">array</span>[i] = <span class="built_in">array</span>[j];</span><br><span class="line">            <span class="built_in">array</span>[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sequentiallySort</span><span class="params">(<span class="keyword">long</span>[] <span class="built_in">array</span>, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(<span class="built_in">array</span>, lo, hi + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSort</span><span class="params">()</span> throws Exception </span>&#123;</span><br><span class="line">        ForkJoinTask sort = <span class="keyword">new</span> SortTask(<span class="built_in">array</span>);   <span class="comment">//1个任务</span></span><br><span class="line">        ForkJoinPool fjpool = <span class="keyword">new</span> ForkJoinPool();  <span class="comment">//1个ForkJoinPool</span></span><br><span class="line">        fjpool.submit(sort); <span class="comment">//提交任务</span></span><br><span class="line">        fjpool.shutdown(); <span class="comment">//结束。ForkJoinPool内部会开多个线程，并行上面的子任务</span></span><br><span class="line"></span><br><span class="line">        fjpool.awaitTermination(<span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>例子2： 求1到n个数的和</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个Task，基础自RecursiveTask，实现其commpute方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt;</span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">10</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> end;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SumTask(<span class="keyword">long</span> n) &#123;  </span><br><span class="line">        <span class="keyword">this</span>(<span class="number">1</span>,n);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SumTask(<span class="keyword">long</span> start, <span class="keyword">long</span> end) &#123;  </span><br><span class="line">        <span class="keyword">this</span>.start = start;  </span><br><span class="line">        <span class="keyword">this</span>.end = end;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    @Override  <span class="comment">//有返回值</span></span><br><span class="line">    <span class="keyword">protected</span> Long compute() &#123;  </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">sum</span> = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">if</span>((end - start) &lt;= THRESHOLD)&#123;  </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">long</span> l = start; l &lt;= end; l++)&#123;  </span><br><span class="line">                <span class="keyword">sum</span> += l;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="keyword">long</span> mid = (start + end) &gt;&gt;&gt; <span class="number">1</span>;  </span><br><span class="line">            SumTask left = <span class="keyword">new</span> SumTask(start, mid);   <span class="comment">//分治，递归</span></span><br><span class="line">            SumTask right = <span class="keyword">new</span> SumTask(mid + <span class="number">1</span>, end);  </span><br><span class="line">            left.fork();  </span><br><span class="line">            right.fork();  </span><br><span class="line">            <span class="keyword">sum</span> = left.join() + right.join();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">sum</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1</span>L;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//测试函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> testSum() throws Exception &#123;</span><br><span class="line">        SumTask <span class="keyword">sum</span> = <span class="keyword">new</span> SumTask(<span class="number">100</span>);   <span class="comment">//1个任务</span></span><br><span class="line">        ForkJoinPool fjpool = <span class="keyword">new</span> ForkJoinPool();  <span class="comment">//1个ForkJoinPool</span></span><br><span class="line">        Future&lt;Long&gt; future = fjpool.submit(<span class="keyword">sum</span>); <span class="comment">//提交任务</span></span><br><span class="line">        Long r = future.get(); <span class="comment">//获取返回值</span></span><br><span class="line">        fjpool.shutdown(); </span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>与ThreadPool的区别</p><p>通过上面例子，我们可以看出，它在使用上，和ThreadPool有共同的地方，也有区别点：<br>（1） ThreadPool只有“外部任务”，也就是调用者放到队列里的任务。 ForkJoinPool有“外部任务”，还有“内部任务”，也就是任务自身在执行过程中，分裂出”子任务“，递归，再次放入队列。<br>（2）ForkJoinPool里面的任务通常有2类，RecusiveAction/RecusiveTask，这2个都是继承自FutureTask。在使用的时候，重写其compute算法。</p><p>工作窃取算法</p><p>上面提到，ForkJoinPool里有”外部任务“，也有“内部任务”。其中外部任务，是放在ForkJoinPool的全局队列里面，而每个Worker线程，也有一个自己的队列，用于存放内部任务。</p><p>窃取的基本思路就是：当worker自己的任务队列里面没有任务时，就去scan别的线程的队列，把别人的任务拿过来执行。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ForkJoinPool的成员变量</span></span><br><span class="line">ForkJoinWorkerThread[] workers;  <span class="comment">//worker thread集合</span></span><br><span class="line"><span class="keyword">private</span> ForkJoinTask&lt;?&gt;[] submissionQueue; <span class="comment">//外部任务队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock submissionLock; </span><br><span class="line"></span><br><span class="line"><span class="comment">//ForkJoinWorkerThread的成员变量</span></span><br><span class="line">ForkJoinTask&lt;?&gt;[] queue;   <span class="comment">//每个worker线程自己的内部任务队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提交任务</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; ForkJoinTask&lt;T&gt; submit(ForkJoinTask&lt;T&gt; <span class="keyword">task</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">task</span> == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">    forkOrSubmit(<span class="keyword">task</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">task</span>;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> forkOrSubmit(ForkJoinTask&lt;T&gt; <span class="keyword">task</span>) &#123;  </span><br><span class="line">    ForkJoinWorkerThread w;  </span><br><span class="line">    Thread t = Thread.currentThread();  </span><br><span class="line">    <span class="keyword">if</span> (shutdown)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException();  </span><br><span class="line">    <span class="keyword">if</span> ((t <span class="keyword">instanceof</span> ForkJoinWorkerThread) &amp;&amp;   <span class="comment">//如果当前是worker线程提交的任务，也就是worker执行过程中，分裂出来的子任务，放入worker自己的内部任务队列</span></span><br><span class="line">        (w = (ForkJoinWorkerThread)t).pool == <span class="keyword">this</span>)  </span><br><span class="line">        w.pushTask(<span class="keyword">task</span>);  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        addSubmission(<span class="keyword">task</span>);  <span class="comment">//外部任务，放入pool的全局队列</span></span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//worker的run方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> run() &#123;  </span><br><span class="line">    Throwable exception = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        onStart();  </span><br><span class="line">        pool.work(<span class="keyword">this</span>);  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;  </span><br><span class="line">        exception = ex;  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        onTermination(exception);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> work(ForkJoinWorkerThread w) &#123;  </span><br><span class="line">    <span class="keyword">boolean</span> swept = <span class="keyword">false</span>;                <span class="comment">// true on empty scans  </span></span><br><span class="line">    <span class="keyword">long</span> c;  </span><br><span class="line">    <span class="keyword">while</span> (!w.terminate &amp;&amp; (<span class="keyword">int</span>)(c = ctl) &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">int</span> a;                            <span class="comment">// active count  </span></span><br><span class="line">        <span class="keyword">if</span> (!swept &amp;&amp; (a = (<span class="keyword">int</span>)(c &gt;&gt; AC_SHIFT)) &lt;= <span class="number">0</span>)  </span><br><span class="line">            swept = scan(w, a);   <span class="comment">//核心代码都在这个scan函数里面</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tryAwaitWork(w, c))  </span><br><span class="line">            swept = <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//scan的基本思路：从别人的任务队列里面抢，没有，再到pool的全局的任务队列里面去取。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> scan(ForkJoinWorkerThread w, <span class="keyword">int</span> a) &#123;  </span><br><span class="line">    <span class="keyword">int</span> g = scanGuard;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = (parallelism == <span class="number">1</span> - a &amp;&amp; blockedCount == <span class="number">0</span>) ? <span class="number">0</span> : g &amp; SMASK;  </span><br><span class="line">    ForkJoinWorkerThread[] ws = workers;  </span><br><span class="line">    <span class="keyword">if</span> (ws == <span class="keyword">null</span> || ws.length &lt;= m)         <span class="comment">// 过期检测  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = w.seed, k = r, j = -(m + m); j &lt;= m + m; ++j) &#123;  </span><br><span class="line">        ForkJoinTask&lt;?&gt; t; ForkJoinTask&lt;?&gt;[] q; <span class="keyword">int</span> b, i;  </span><br><span class="line">        <span class="comment">//随机选出一个牺牲者(工作线程)。  </span></span><br><span class="line">        ForkJoinWorkerThread v = ws[k &amp; m];  </span><br><span class="line">        <span class="comment">//一系列检查...  </span></span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span> &amp;&amp; (b = v.queueBase) != v.queueTop &amp;&amp;  </span><br><span class="line">            (q = v.queue) != <span class="keyword">null</span> &amp;&amp; (i = (q.length - <span class="number">1</span>) &amp; b) &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="comment">//如果这个牺牲者的任务队列中还有任务，尝试窃取这个任务。  </span></span><br><span class="line">            <span class="keyword">long</span> u = (i &lt;&lt; ASHIFT) + ABASE;  </span><br><span class="line">            <span class="keyword">if</span> ((t = q[i]) != <span class="keyword">null</span> &amp;&amp; v.queueBase == b &amp;&amp;  </span><br><span class="line">                UNSAFE.compareAndSwapObject(q, u, t, <span class="keyword">null</span>)) &#123;  </span><br><span class="line">                <span class="comment">//窃取成功后，调整queueBase  </span></span><br><span class="line">                <span class="keyword">int</span> d = (v.queueBase = b + <span class="number">1</span>) - v.queueTop;  </span><br><span class="line">                <span class="comment">//将牺牲者的stealHint设置为当前工作线程在pool中的下标。  </span></span><br><span class="line">                v.stealHint = w.poolIndex;  </span><br><span class="line">                <span class="keyword">if</span> (d != <span class="number">0</span>)  </span><br><span class="line">                    signalWork();             <span class="comment">// 如果牺牲者的任务队列还有任务，继续唤醒(或创建)线程。  </span></span><br><span class="line">                w.execTask(t); <span class="comment">//执行窃取的任务。  </span></span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">//计算出下一个随机种子。  </span></span><br><span class="line">            r ^= r &lt;&lt; <span class="number">13</span>; r ^= r &gt;&gt;&gt; <span class="number">17</span>; w.seed = r ^ (r &lt;&lt; <span class="number">5</span>);  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;                     <span class="comment">// 返回false，表示不是一个空扫描。  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//前2*m次，随机扫描。  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;                     <span class="comment">// xorshift  </span></span><br><span class="line">            r ^= r &lt;&lt; <span class="number">13</span>; r ^= r &gt;&gt;&gt; <span class="number">17</span>; k = r ^= r &lt;&lt; <span class="number">5</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//后2*m次，顺序扫描。  </span></span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            ++k;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (scanGuard != g)                       <span class="comment">// staleness check  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    <span class="keyword">else</span> &#123;                                     </span><br><span class="line">        <span class="comment">//如果扫描完毕后没找到可窃取的任务，那么从Pool的提交任务队列中取一个任务来执行。  </span></span><br><span class="line">        ForkJoinTask&lt;?&gt; t; ForkJoinTask&lt;?&gt;[] q; <span class="keyword">int</span> b, i;  </span><br><span class="line">        <span class="keyword">if</span> ((b = queueBase) != queueTop &amp;&amp;  </span><br><span class="line">            (q = submissionQueue) != <span class="keyword">null</span> &amp;&amp;  </span><br><span class="line">            (i = (q.length - <span class="number">1</span>) &amp; b) &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">long</span> u = (i &lt;&lt; ASHIFT) + ABASE;  </span><br><span class="line">            <span class="keyword">if</span> ((t = q[i]) != <span class="keyword">null</span> &amp;&amp; queueBase == b &amp;&amp;  </span><br><span class="line">                UNSAFE.compareAndSwapObject(q, u, t, <span class="keyword">null</span>)) &#123;  </span><br><span class="line">                queueBase = b + <span class="number">1</span>;  </span><br><span class="line">                w.execTask(t);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;                         <span class="comment">// 如果所有的队列(工作线程的任务队列和pool的任务队列)都是空的，返回true。  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于ForkJoinPool/FutureTask，本文只是分析了其基本使用原理。还有很多实现细节，留待读者自己去分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java并发指南&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/21961.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21961.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java并发" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://h2pl.github.io/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java并发指南14：Java并发容器ConcurrentSkipListMap与CopyOnWriteArrayList</title>
    <link href="http://h2pl.github.io/2018/05/24/concurrent14/"/>
    <id>http://h2pl.github.io/2018/05/24/concurrent14/</id>
    <published>2018-05-24T14:47:00.000Z</published>
    <updated>2018-06-11T12:51:51.344Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java并发指南<br><a href="https://blog.csdn.net/column/details/21961.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21961.html</a></p><p>相关代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a><br><a id="more"></a></p><blockquote><p>原文出处<a href="http://cmsblogs.com/" target="_blank" rel="noopener">http://cmsblogs.com/</a> 『chenssy』</p></blockquote><p>到目前为止，我们在Java世界里看到了两种实现key-value的数据结构：Hash、TreeMap，这两种数据结构各自都有着优缺点。</p><ol><li>Hash表：插入、查找最快，为O(1)；如使用链表实现则可实现无锁；数据有序化需要显式的排序操作。</li><li>红黑树：插入、查找为O(logn)，但常数项较小；无锁实现的复杂性很高，一般需要加锁；数据天然有序。</li></ol><p>然而，这次介绍第三种实现key-value的数据结构：SkipList。SkipList有着不低于红黑树的效率，但是其原理和实现的复杂度要比红黑树简单多了。</p><h2 id="SkipList"><a href="#SkipList" class="headerlink" title="SkipList"></a>SkipList</h2><p>什么是SkipList？Skip List ，称之为跳表，它是一种可以替代平衡树的数据结构，其数据元素默认按照key值升序，天然有序。Skip list让已排序的数据分布在多层链表中，以0-1随机数决定一个数据的向上攀升与否，通过“空间来换取时间”的一个算法，在每个节点中增加了向前的指针，在插入、删除、查找时可以忽略一些不可能涉及到的结点，从而提高了效率。</p><p>我们先看一个简单的链表，如下：</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/1499585893174201707090001.png" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/1499585893174201707090001_thumb.png" alt="1499585893174201707090001" title="1499585893174201707090001"></a></p><p>如果我们需要查询9、21、30，则需要比较次数为3 + 6 + 8 = 17 次，那么有没有优化方案呢？有！我们将该链表中的某些元素提炼出来作为一个比较“索引”，如下：</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/1499586063109201707090002.png" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/1499586063109201707090002_thumb.png" alt="1499586063109201707090002" title="1499586063109201707090002"></a></p><p>我们先与这些索引进行比较来决定下一个元素是往右还是下走，由于存在“索引”的缘故，导致在检索的时候会大大减少比较的次数。当然元素不是很多，很难体现出优势，当元素足够多的时候，这种索引结构就会大显身手。</p><h3 id="SkipList的特性"><a href="#SkipList的特性" class="headerlink" title="SkipList的特性"></a>SkipList的特性</h3><p>SkipList具备如下特性：</p><ol><li>由很多层结构组成，level是通过一定的概率随机产生的</li><li>每一层都是一个有序的链表，默认是升序，也可以根据创建映射时所提供的Comparator进行排序，具体取决于使用的构造方法</li><li>最底层(Level 1)的链表包含所有元素</li><li>如果一个元素出现在Level i 的链表中，则它在Level i 之下的链表也都会出现</li><li>每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素</li></ol><p>我们将上图再做一些扩展就可以变成一个典型的SkipList结构了</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/1499590828559201707090003.png" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/1499590828559201707090003_thumb.png" alt="1499590828559201707090003" title="1499590828559201707090003"></a></p><h3 id="SkipList的查找"><a href="#SkipList的查找" class="headerlink" title="SkipList的查找"></a>SkipList的查找</h3><p>SkipListd的查找算法较为简单，对于上面我们我们要查找元素21，其过程如下：</p><ol><li>比较3，大于，往后找（9），</li><li>比9大，继续往后找（25），但是比25小，则从9的下一层开始找（16）</li><li>16的后面节点依然为25，则继续从16的下一层找</li><li>找到21</li></ol><p>如图</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201707090004.png" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201707090004_thumb.png" alt="201707090004" title="201707090004"></a></p><p>红色虚线代表路径。</p><h3 id="SkipList的插入"><a href="#SkipList的插入" class="headerlink" title="SkipList的插入"></a>SkipList的插入</h3><p>SkipList的插入操作主要包括：</p><ol><li>查找合适的位置。这里需要明确一点就是在确认新节点要占据的层次K时，采用丢硬币的方式，完全随机。如果占据的层次K大于链表的层次，则重新申请新的层，否则插入指定层次</li><li>申请新的节点</li><li>调整指针</li></ol><p>假定我们要插入的元素为23，经过查找可以确认她是位于25后，9、16、21前。当然需要考虑申请的层次K。</p><p>如果层次K &gt; 3</p><p>需要申请新层次（Level 4）</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201707090005.png" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201707090005_thumb.png" alt="201707090005" title="201707090005"></a></p><p>如果层次 K = 2</p><p>直接在Level 2 层插入即可</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201707090006.png" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201707090006_thumb.png" alt="201707090006" title="201707090006"></a></p><p>这里会涉及到以个算法：通过丢硬币决定层次K，该算法我们通过后面ConcurrentSkipListMap源码来分析。还有一个需要注意的地方就是，在K层插入元素后，需要确保所有小于K层的层次都应该出现新节点。</p><h3 id="SkipList的删除"><a href="#SkipList的删除" class="headerlink" title="SkipList的删除"></a>SkipList的删除</h3><p>删除节点和插入节点思路基本一致：找到节点，删除节点，调整指针。</p><p>比如删除节点9，如下：</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201707090007.png" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201707090007_thumb.png" alt="201707090007" title="201707090007"></a></p><h2 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h2><p>通过上面我们知道SkipList采用空间换时间的算法，其插入和查找的效率O(logn)，其效率不低于红黑树，但是其原理和实现的复杂度要比红黑树简单多了。一般来说会操作链表List，就会对SkipList毫无压力。</p><p>ConcurrentSkipListMap其内部采用SkipLis数据结构实现。为了实现SkipList，ConcurrentSkipListMap提供了三个内部类来构建这样的链表结构：Node、Index、HeadIndex。其中Node表示最底层的单链表有序节点、Index表示为基于Node的索引层，HeadIndex用来维护索引层次。到这里我们可以这样说ConcurrentSkipListMap是通过HeadIndex维护索引层次，通过Index从最上层开始往下层查找，一步一步缩小查询范围，最后到达最底层Node时，就只需要比较很小一部分数据了。在JDK中的关系如下图：</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201707090008.png" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201707090008_thumb.png" alt="201707090008" title="201707090008"></a></p><p><strong> Node </strong></p><pre name="code">  static  final  class  Node<k,v>  {  final K key;  volatile  Object value;  volatile  ConcurrentSkipListMap.Node<k, v="">  next;  /** 省略些许代码 */  }</k,></k,v></pre><p>Node的结构和一般的单链表毫无区别，key-value和一个指向下一个节点的next。</p><p>Index</p><pre name="code">  static  class  Index<k,v>  {  final  ConcurrentSkipListMap.Node<k,v> node;  final  ConcurrentSkipListMap.Index<k,v> down;  volatile  ConcurrentSkipListMap.Index<k,v> right;  /** 省略些许代码 */  }</k,v></k,v></k,v></k,v></pre><p>Index提供了一个基于Node节点的索引Node，一个指向下一个Index的right，一个指向下层的down节点。</p><p>HeadIndex</p><pre name="code">  static  final  class  HeadIndex<k,v>  extends  Index<k,v>  {  final  int level;  //索引层，从1开始，Node单链表层为0  HeadIndex(Node<k,v> node,  Index<k,v> down,  Index<k,v> right,  int level)  {  super(node, down, right);  this.level = level;  }  }</k,v></k,v></k,v></k,v></k,v></pre><p>HeadIndex内部就一个level来定义层级。</p><p>ConcurrentSkipListMap提供了四个构造函数，每个构造函数都会调用initialize()方法进行初始化工作。</p><pre name="code">  final  void initialize()  { keySet =  null; entrySet =  null; values =  null; descendingMap =  null; randomSeed = seedGenerator.nextInt()  |  0x0100;  // ensure nonzero head =  new  ConcurrentSkipListMap.HeadIndex<k,v>(new  ConcurrentSkipListMap.Node<k,v>(null, BASE_HEADER,  null),  null,  null,  1);  }</k,v></k,v></pre><p>注意，initialize()方法不仅仅只在构造函数中被调用，如clone，clear、readObject时都会调用该方法进行初始化步骤。这里需要注意randomSeed的初始化。</p><pre name="code">  private  transient  int randomSeed; randomSeed = seedGenerator.nextInt()  |  0x0100;  // ensure nonzero</pre><p>randomSeed一个简单的随机数生成器（在后面介绍）。</p><h3 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h3><p>CoucurrentSkipListMap提供了put()方法用于将指定值与此映射中的指定键关联。源码如下：</p><pre name="code">  public V put(K key, V value)  {  if  (value ==  null)  throw  new  NullPointerException();  return doPut(key, value,  false);  }</pre><p>首先判断value如果为null，则抛出NullPointerException，否则调用doPut方法，其实如果各位看过JDK的源码的话，应该对这样的操作很熟悉了，JDK源码里面很多方法都是先做一些必要性的验证后，然后通过调用do**()方法进行真正的操作。</p><p>doPut()方法内容较多，我们分步分析。</p><pre name="code">  private V doPut(K key, V value,  boolean onlyIfAbsent)  {  Node<k,v> z;  // added node  if  (key ==  null)  throw  new  NullPointerException();  // 比较器  Comparator<?  super K> cmp = comparator; outer:  for  (;;)  {  for  (Node<k, v=""> b = findPredecessor(key, cmp), n = b.next;  ;  )  {  /** 省略代码 */</k,></k,v></pre><p>doPut()方法有三个参数，除了key,value外还有一个boolean类型的onlyIfAbsent，该参数作用与如果存在当前key时，该做何动作。当onlyIfAbsent为false时，替换value，为true时，则返回该value。用代码解释为：</p><pre name="code">  if  (!map.containsKey(key))  return map.put(key, value);  else  return map.get(key);</pre><p>首先判断key是否为null，如果为null，则抛出NullPointerException，从这里我们可以确认ConcurrentSkipList是不支持key或者value为null的。然后调用findPredecessor()方法，传入key来确认位置。findPredecessor()方法其实就是确认key要插入的位置。</p><pre name="code">  private  Node<k,v> findPredecessor(Object key,  Comparator<?  super K> cmp)  {  if  (key ==  null)  throw  new  NullPointerException();  // don't postpone errors  for  (;;)  {  // 从head节点开始，head是level最高级别的headIndex  for  (Index<k,v> q = head, r = q.right, d;;)  {  // r != null，表示该节点右边还有节点，需要比较  if  (r !=  null)  {  Node<k,v> n = r.node; K k = n.key;  // value == null，表示该节点已经被删除了  // 通过unlink()方法过滤掉该节点  if  (n.value ==  null)  {  //删掉r节点  if  (!q.unlink(r))  break;  // restart r = q.right;  // reread r  continue;  }  // value != null，节点存在  // 如果key 大于r节点的key 则往前进一步  if  (cpr(cmp, key, k)  >  0)  { q = r; r = r.right;  continue;  }  }  // 到达最右边，如果dowm == null，表示指针已经达到最下层了，直接返回该节点  if  ((d = q.down)  ==  null)  return q.node; q = d; r = d.right;  }  }  }</k,v></k,v></k,v></pre><p>findPredecessor()方法意思非常明确：寻找前辈。从最高层的headIndex开始向右一步一步比较，直到right为null或者右边节点的Node的key大于当前key为止，然后再向下寻找，依次重复该过程，直到down为null为止，即找到了前辈，看返回的结果注意是Node，不是Item，所以插入的位置应该是最底层的Node链表。</p><p>在这个过程中ConcurrentSkipListMap赋予了该方法一个其他的功能，就是通过判断节点的value是否为null，如果为null，表示该节点已经被删除了，通过调用unlink()方法删除该节点。</p><pre name="code">  final  boolean unlink(Index<k,v> succ)  {  return node.value !=  null  && casRight(succ, succ.right);  }</k,v></pre><p>删除节点过程非常简单，更改下right指针即可。</p><p>通过findPredecessor()找到前辈节点后，做什么呢？看下面：</p><pre name="code">  for  (Node<k,v> b = findPredecessor(key, cmp), n = b.next;;)  {  // 前辈节点的next != null  if  (n !=  null)  {  Object v;  int c;  Node<k,v> f = n.next;  // 不一致读，主要原因是并发，有节点捷足先登  if  (n != b.next)  // inconsistent read  break;  // n.value == null，该节点已经被删除了  if  ((v = n.value)  ==  null)  {  // n is deleted n.helpDelete(b, f);  break;  }  // 前辈节点b已经被删除  if  (b.value ==  null  || v == n)  // b is deleted  break;  // 节点大于，往前移  if  ((c = cpr(cmp, key, n.key))  >  0)  { b = n; n = f;  continue;  }  // c == 0 表示，找到一个key相等的节点，根据onlyIfAbsent参数来做判断  // onlyIfAbsent ==false，则通过casValue，替换value  // onlyIfAbsent == true，返回该value  if  (c ==  0)  {  if  (onlyIfAbsent || n.casValue(v, value))  {  @SuppressWarnings("unchecked") V vv =  (V)v;  return vv;  }  break;  // restart if lost race to replace value  }  // else c < 0; fall through  }  // 将key-value包装成一个node，插入 z =  new  Node<k,v>(key, value, n);  if  (!b.casNext(n, z))  break;  // restart if lost race to append to b  break outer;  }</k,v></k,v></k,v></pre><p>找到合适的位置后，就是在该位置插入节点咯。插入节点的过程比较简单，就是将key-value包装成一个Node，然后通过casNext()方法加入到链表当中。当然是插入之前需要进行一系列的校验工作。</p><p>在最下层插入节点后，下一步工作是什么？新建索引。前面博主提过，在插入节点的时候，会根据采用抛硬币的方式来决定新节点所插入的层次，由于存在并发的可能，ConcurrentSkipListMap采用ThreadLocalRandom来生成随机数。如下：</p><pre name="code">int rnd =  ThreadLocalRandom.nextSecondarySeed();</pre><p>抛硬币决定层次的思想很简单，就是通过抛硬币如果硬币为正面则层次level + 1 ，否则停止，如下：</p><pre name="code">  // 抛硬币决定层次  while  (((rnd >>>=  1)  &  1)  !=  0)  ++level;</pre><p>在阐述SkipList插入节点的时候说明了，决定的层次level会分为两种情况进行处理，一是如果层次level大于最大的层次话则需要新增一层，否则就在相应层次以及小于该level的层次进行节点新增处理。</p><p>level &lt;= headIndex.level</p><pre name="code">  // 如果决定的层次level比最高层次head.level小，直接生成最高层次的index  // 由于需要确认每一层次的down，所以需要从最下层依次往上生成  if  (level <= (max="h.level))" {="" for="" (int="" i="1;" <="level;" ++i)="" idx="new" concurrentskiplistmap.index<k,v="">(z, idx,  null);  }</=></pre><p>从底层开始，小于level的每一层都初始化一个index，每次的node都指向新加入的node，down指向下一层的item，右侧next全部为null。整个处理过程非常简单：为小于level的每一层初始化一个index，然后加入到原来的index链条中去。</p><p>level &gt; headIndex.level</p><pre name="code">  // leve > head.level 则新增一层  else  {  // try to grow by one level  // 新增一层 level = max +  1;  // 初始化 level个item节点  @SuppressWarnings("unchecked")  ConcurrentSkipListMap.Index<k,v>[] idxs =  (ConcurrentSkipListMap.Index<k,v>[])new  ConcurrentSkipListMap.Index<?,?>[level+1];  for  (int i =  1; i <= level;="" ++i)="" idxs[i]="idx" =="" new="" concurrentskiplistmap.index<k,v="">(z, idx,  null);  //  for  (;;)  { h = head;  int oldLevel = h.level;  // 层次扩大了，需要重新开始（有新线程节点加入）  if  (level <= oldlevel)="" lost="" race="" to="" add="" level="" break;="" 新的头结点headindex="" concurrentskiplistmap.headindex<k,v=""> newh = h;  ConcurrentSkipListMap.Node<k,v> oldbase = h.node;  // 生成新的HeadIndex节点，该HeadIndex指向新增层次  for  (int j = oldLevel+1; j <= level;="" ++j)="" newh="new" concurrentskiplistmap.headindex<k,v="">(oldbase, newh, idxs[j], j);  // HeadIndex CAS替换  if  (casHead(h, newh))  { h = newh; idx = idxs[level = oldLevel];  break;  }  }</=></k,v></=></=></k,v></k,v></pre><p>当抛硬币决定的level大于最大层次level时，需要新增一层进行处理。处理逻辑如下：</p><ol><li>初始化一个对应的index数组，大小为level + 1，然后为每个单位都创建一个index，个中参数为：Node为新增的Z，down为下一层index，right为null</li><li>通过for循环来进行扩容操作。从最高层进行处理，新增一个HeadIndex，个中参数：节点Node，down都为最高层的Node和HeadIndex，right为刚刚创建的对应层次的index，level为相对应的层次level。最后通过CAS把当前的head与新加入层的head进行替换。</li></ol><p>通过上面步骤我们发现，尽管已经找到了前辈节点，也将node插入了，也确定确定了层次并生成了相应的Index，但是并没有将这些Index插入到相应的层次当中，所以下面的代码就是将index插入到相对应的层当中。</p><pre name="code">  // 从插入的层次level开始 splice:  for  (int insertionLevel = level;;)  {  int j = h.level;  //  从headIndex开始  for  (ConcurrentSkipListMap.Index<k,v> q = h, r = q.right, t = idx;;)  {  if  (q ==  null  || t ==  null)  break splice;  // r != null；这里是找到相应层次的插入节点位置，注意这里只横向找  if  (r !=  null)  {  ConcurrentSkipListMap.Node<k,v> n = r.node;  int c = cpr(cmp, key, n.key);  // n.value == null ，解除关系，r右移  if  (n.value ==  null)  {  if  (!q.unlink(r))  break; r = q.right;  continue;  }  // key > n.key 右移  if  (c >  0)  { q = r; r = r.right;  continue;  }  }  // 上面找到节点要插入的位置，这里就插入  // 当前层是最顶层  if  (j == insertionLevel)  {  // 建立联系  if  (!q.link(r, t))  break;  // restart  if  (t.node.value ==  null)  { findNode(key);  break splice;  }  // 标志的插入层 -- ，如果== 0 ，表示已经到底了，插入完毕，退出循环  if  (--insertionLevel ==  0)  break splice;  }  // 上面节点已经插入完毕了，插入下一个节点  if  (--j >= insertionLevel && j < level) t = t.down; q = q.down; r = q.right;  }  }</k,v></k,v></pre><p>这段代码分为两部分看，一部分是找到相应层次的该节点插入的位置，第二部分在该位置插入，然后下移。</p><p>至此，ConcurrentSkipListMap的put操作到此就结束了。代码量有点儿多，这里总结下：</p><ol><li>首先通过findPredecessor()方法找到前辈节点Node</li><li>根据返回的前辈节点以及key-value，新建Node节点，同时通过CAS设置next</li><li>设置节点Node，再设置索引节点。采取抛硬币方式决定层次，如果所决定的层次大于现存的最大层次，则新增一层，然后新建一个Item链表。</li><li>最后，将新建的Item链表插入到SkipList结构中。</li></ol><h3 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h3><p>相比于put操作 ，get操作会简单很多，其过程其实就只相当于put操作的第一步：</p><pre name="code">  private V doGet(Object key)  {  if  (key ==  null)  throw  new  NullPointerException();  Comparator<?  super K> cmp = comparator; outer:  for  (;;)  {  for  (ConcurrentSkipListMap.Node<k,v> b = findPredecessor(key, cmp), n = b.next;;)  {  Object v;  int c;  if  (n ==  null)  break outer;  ConcurrentSkipListMap.Node<k,v> f = n.next;  if  (n != b.next)  // inconsistent read  break;  if  ((v = n.value)  ==  null)  {  // n is deleted n.helpDelete(b, f);  break;  }  if  (b.value ==  null  || v == n)  // b is deleted  break;  if  ((c = cpr(cmp, key, n.key))  ==  0)  {  @SuppressWarnings("unchecked") V vv =  (V)v;  return vv;  }  if  (c <  0)  break outer; b = n; n = f;  }  }  return  null;  }</k,v></k,v></pre><p>与put操作第一步相似，首先调用findPredecessor()方法找到前辈节点，然后顺着right一直往右找即可，同时在这个过程中同样承担了一个删除value为null的节点的职责。</p><h3 id="remove操作"><a href="#remove操作" class="headerlink" title="remove操作"></a>remove操作</h3><p>remove操作为删除指定key节点，如下：</p><pre name="code">  public V remove(Object key)  {  return doRemove(key,  null);  }</pre><p>直接调用doRemove()方法，这里remove有两个参数，一个是key，另外一个是value，所以doRemove方法即提供remove key，也提供同时满足key-value。</p><pre name="code">  final V doRemove(Object key,  Object value)  {  if  (key ==  null)  throw  new  NullPointerException();  Comparator<?  super K> cmp = comparator; outer:  for  (;;)  {  for  (ConcurrentSkipListMap.Node<k,v> b = findPredecessor(key, cmp), n = b.next;;)  {  Object v;  int c;  if  (n ==  null)  break outer;  ConcurrentSkipListMap.Node<k,v> f = n.next;  // 不一致读，重新开始  if  (n != b.next)  // inconsistent read  break;  // n节点已删除  if  ((v = n.value)  ==  null)  {  // n is deleted n.helpDelete(b, f);  break;  }  // b节点已删除  if  (b.value ==  null  || v == n)  // b is deleted  break;  if  ((c = cpr(cmp, key, n.key))  <  0)  break outer;  // 右移  if  (c >  0)  { b = n; n = f;  continue;  }  /*                 * 找到节点                 */  // value != null 表示需要同时校验key-value值  if  (value !=  null  &&  !value.equals(v))  break outer;  // CAS替换value  if  (!n.casValue(v,  null))  break;  if  (!n.appendMarker(f)  ||  !b.casNext(n, f)) findNode(key);  // retry via findNode  else  {  // 清理节点 findPredecessor(key, cmp);  // clean index  // head.right == null表示该层已经没有节点，删掉该层  if  (head.right ==  null) tryReduceLevel();  }  @SuppressWarnings("unchecked") V vv =  (V)v;  return vv;  }  }  return  null;  }</k,v></k,v></pre><p>调用findPredecessor()方法找到前辈节点，然后通过右移，然后比较，找到后利用CAS把value替换为null，然后判断该节点是不是这层唯一的index，如果是的话，调用tryReduceLevel()方法把这层干掉，完成删除。</p><p>其实从这里可以看出，remove方法仅仅是把Node的value设置null，并没有真正删除该节点Node，其实从上面的put操作、get操作我们可以看出，他们在寻找节点的时候都会判断节点的value是否为null，如果为null，则调用unLink()方法取消关联关系，如下：</p><pre name="code">  if  (n.value ==  null)  {  if  (!q.unlink(r))  break;  // restart r = q.right;  // reread r  continue;  }</pre><h3 id="size操作"><a href="#size操作" class="headerlink" title="size操作"></a>size操作</h3><p>ConcurrentSkipListMap的size()操作和ConcurrentHashMap不同，它并没有维护一个全局变量来统计元素的个数，所以每次调用该方法的时候都需要去遍历。</p><pre name="code">  public  int size()  {  long count =  0;  for  (Node<k,v> n = findFirst(); n !=  null; n = n.next)  {  if  (n.getValidValue()  !=  null)  ++count;  }  return  (count >=  Integer.MAX_VALUE)  ?  Integer.MAX_VALUE :  (int) count;  }</k,v></pre><p>调用findFirst()方法找到第一个Node，然后利用node的next去统计。最后返回统计数据，最多能返回Integer.MAX_VALUE。注意这里在线程并发下是安全的。</p><p>ConcurrentSkipListMap过程其实不复杂，相比于ConcurrentHashMap而言，是简单的不能再简单了。对跳表SkipList熟悉的话，ConcurrentSkipListMap 应该是盘中餐了。</p><h3 id="Java并发编程：并发容器之CopyOnWriteArrayList（转载）"><a href="#Java并发编程：并发容器之CopyOnWriteArrayList（转载）" class="headerlink" title="Java并发编程：并发容器之CopyOnWriteArrayList（转载）"></a>Java并发编程：并发容器之CopyOnWriteArrayList（转载）</h3><p>　　原文链接：</p><p>　　<a href="http://ifeve.com/java-copy-on-write/" target="_blank" rel="noopener">http://ifeve.com/java-copy-on-write/</a></p><p>　　Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p><h2 id="什么是CopyOnWrite容器"><a href="#什么是CopyOnWrite容器" class="headerlink" title="什么是CopyOnWrite容器"></a>什么是CopyOnWrite容器</h2><p>　　CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p><h2 id="CopyOnWriteArrayList的实现原理"><a href="#CopyOnWriteArrayList的实现原理" class="headerlink" title="CopyOnWriteArrayList的实现原理"></a>CopyOnWriteArrayList的实现原理</h2><p>　　在使用CopyOnWriteArrayList之前，我们先阅读其源码了解下它是如何实现的。以下代码是向CopyOnWriteArrayList中add方法的实现（向CopyOnWriteArrayList里添加元素），可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。</p><pre><code>/**     * Appends the specified element to the end of this list.     *     * @param e element to be appended to this list     * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by {@link Collection#add})     */    public boolean add(E e) {    final ReentrantLock lock = this.lock;    lock.lock();    try {        Object[] elements = getArray();        int len = elements.length;        Object[] newElements = Arrays.copyOf(elements, len + 1);        newElements[len] = e;        setArray(newElements);        return true;    } finally {        lock.unlock();    }    }</code></pre><p> 　　读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的CopyOnWriteArrayList。</p><pre><code>public E get(int index) {    return get(getArray(), index);}</code></pre><p> 　　JDK中并没有提供CopyOnWriteMap，我们可以参考CopyOnWriteArrayList来实现一个，基本代码如下：</p><pre><code>import java.util.Collection;import java.util.Map;import java.util.Set;public class CopyOnWriteMap&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable {    private volatile Map&lt;K, V&gt; internalMap;    public CopyOnWriteMap() {        internalMap = new HashMap&lt;K, V&gt;();    }    public V put(K key, V value) {        synchronized (this) {            Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap);            V val = newMap.put(key, value);            internalMap = newMap;            return val;        }    }    public V get(Object key) {        return internalMap.get(key);    }    public void putAll(Map&lt;? extends K, ? extends V&gt; newData) {        synchronized (this) {            Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap);            newMap.putAll(newData);            internalMap = newMap;        }    }}</code></pre><p> 　　实现很简单，只要了解了CopyOnWrite机制，我们可以实现各种CopyOnWrite容器，并且在不同的应用场景中使用。</p><h2 id="CopyOnWrite的应用场景"><a href="#CopyOnWrite的应用场景" class="headerlink" title="CopyOnWrite的应用场景"></a>CopyOnWrite的应用场景</h2><p>　　CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。实现代码如下：</p><p>package com.ifeve.book;</p><p>import java.util.Map;</p><p>import com.ifeve.book.forkjoin.CopyOnWriteMap;</p><pre><code>/** * 黑名单服务 * * @author fangtengfei * */public class BlackListServiceImpl {    private static CopyOnWriteMap&lt;String, Boolean&gt; blackListMap = new CopyOnWriteMap&lt;String, Boolean&gt;(            1000);    public static boolean isBlackList(String id) {        return blackListMap.get(id) == null ? false : true;    }    public static void addBlackList(String id) {        blackListMap.put(id, Boolean.TRUE);    }    /**     * 批量添加黑名单     *     * @param ids     */    public static void addBlackList(Map&lt;String,Boolean&gt; ids) {        blackListMap.putAll(ids);    }}</code></pre><p> 　　代码很简单，但是使用CopyOnWriteMap需要注意两件事情：</p><p>　　1. 减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。</p><p>　　2. 使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。如使用上面代码里的addBlackList方法。</p><h2 id="CopyOnWrite的缺点"><a href="#CopyOnWrite的缺点" class="headerlink" title="CopyOnWrite的缺点"></a>CopyOnWrite的缺点</h2><p>　　CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p><p>　　内存占用问题。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</p><p>　　针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如<a href="http://ifeve.com/concurrenthashmap/" target="_blank" rel="noopener">ConcurrentHashMap</a>。</p><p>　　数据一致性问题。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p><p>　　下面这篇文章验证了CopyOnWriteArrayList和同步容器的性能：</p><p>　　<a href="http://blog.csdn.net/wind5shy/article/details/5396887" target="_blank" rel="noopener">http://blog.csdn.net/wind5shy/article/details/5396887</a></p><p>　　下面这篇文章简单描述了CopyOnWriteArrayList的使用：</p><p>　　<a href="http://blog.csdn.net/imzoer/article/details/9751591" target="_blank" rel="noopener">http://blog.csdn.net/imzoer/article/details/9751591</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java并发指南&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/21961.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21961.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java并发" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="JUC" scheme="http://h2pl.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java并发指南13：Java7和8 中的 HashMap 和 ConcurrentHashMap 全解析</title>
    <link href="http://h2pl.github.io/2018/05/23/concurrent13/"/>
    <id>http://h2pl.github.io/2018/05/23/concurrent13/</id>
    <published>2018-05-23T14:46:56.000Z</published>
    <updated>2018-06-11T13:43:21.509Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java并发指南<br><a href="https://blog.csdn.net/column/details/21961.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21961.html</a></p><p>相关代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a><br><a id="more"></a></p><p>Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析</p><p>转自<a href="https://www.javadoop.com/post/hashmap#toc7" target="_blank" rel="noopener">https://www.javadoop.com/post/hashmap#toc7</a></p><p>部分内容转自</p><p><a href="http://www.jasongj.com/java/concurrenthashmap" target="_blank" rel="noopener">http://www.jasongj.com/java/concurrenthashmap</a></p><p>今天发一篇”水文”，可能很多读者都会表示不理解，不过我想把它作为并发序列文章中不可缺少的一块来介绍。本来以为花不了多少时间的，不过最终还是投入了挺多时间来完成这篇文章的。</p><p>网上关于 HashMap 和 ConcurrentHashMap 的文章确实不少，不过缺斤少两的文章比较多，所以才想自己也写一篇，把细节说清楚说透，尤其像 Java8 中的 ConcurrentHashMap，大部分文章都说不清楚。终归是希望能降低大家学习的成本，不希望大家到处找各种不是很靠谱的文章，看完一篇又一篇，可是还是模模糊糊。</p><p>阅读建议：四节基本上可以进行独立阅读，建议初学者可按照 Java7 HashMap -&gt; Java7 ConcurrentHashMap -&gt; Java8 HashMap -&gt; Java8 ConcurrentHashMap 顺序进行阅读，可适当降低阅读门槛。</p><p>阅读前提：本文分析的是源码，所以至少读者要熟悉它们的接口使用，同时，对于并发，读者至少要知道 CAS、ReentrantLock、UNSAFE 操作这几个基本的知识，文中不会对这些知识进行介绍。Java8 用到了红黑树，不过本文不会进行展开，感兴趣的读者请自行查找相关资料。</p><ul><li><a href="https://www.javadoop.com/post/hashmap#Java7%20HashMap" target="_blank" rel="noopener">Java7 HashMap</a><ul><li><a href="https://www.javadoop.com/post/hashmap#put%20%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90" target="_blank" rel="noopener">put 过程分析</a><ul><li><a href="https://www.javadoop.com/post/hashmap#%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96" target="_blank" rel="noopener">数组初始化</a></li><li><a href="https://www.javadoop.com/post/hashmap#%E8%AE%A1%E7%AE%97%E5%85%B7%E4%BD%93%E6%95%B0%E7%BB%84%E4%BD%8D%E7%BD%AE" target="_blank" rel="noopener">计算具体数组位置</a></li><li><a href="https://www.javadoop.com/post/hashmap#%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%E5%88%B0%E9%93%BE%E8%A1%A8%E4%B8%AD" target="_blank" rel="noopener">添加节点到链表中</a></li><li><a href="https://www.javadoop.com/post/hashmap#%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9" target="_blank" rel="noopener">数组扩容</a></li></ul></li><li><a href="https://www.javadoop.com/post/hashmap#get%20%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90" target="_blank" rel="noopener">get 过程分析</a></li></ul></li><li><a href="https://www.javadoop.com/post/hashmap#Java7%20ConcurrentHashMap" target="_blank" rel="noopener">Java7 ConcurrentHashMap</a><ul><li><a href="https://www.javadoop.com/post/hashmap#%E5%88%9D%E5%A7%8B%E5%8C%96" target="_blank" rel="noopener">初始化</a></li><li><a href="https://www.javadoop.com/post/hashmap#put%20%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90" target="_blank" rel="noopener">put 过程分析</a><ul><li><a href="https://www.javadoop.com/post/hashmap#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A7%BD%3A%20ensureSegment" target="_blank" rel="noopener">初始化槽: ensureSegment</a></li><li><a href="https://www.javadoop.com/post/hashmap#%E8%8E%B7%E5%8F%96%E5%86%99%E5%85%A5%E9%94%81%3A%20scanAndLockForPut" target="_blank" rel="noopener">获取写入锁: scanAndLockForPut</a></li><li><a href="https://www.javadoop.com/post/hashmap#%E6%89%A9%E5%AE%B9%3A%20rehash" target="_blank" rel="noopener">扩容: rehash</a></li></ul></li><li><a href="https://www.javadoop.com/post/hashmap#get%20%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90" target="_blank" rel="noopener">get 过程分析</a></li><li><a href="https://www.javadoop.com/post/hashmap#%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90" target="_blank" rel="noopener">并发问题分析</a></li></ul></li><li><a href="https://www.javadoop.com/post/hashmap#Java8%20HashMap" target="_blank" rel="noopener">Java8 HashMap</a><ul><li><a href="https://www.javadoop.com/post/hashmap#put%20%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90" target="_blank" rel="noopener">put 过程分析</a><ul><li><a href="https://www.javadoop.com/post/hashmap#%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9" target="_blank" rel="noopener">数组扩容</a></li></ul></li><li><a href="https://www.javadoop.com/post/hashmap#get%20%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90" target="_blank" rel="noopener">get 过程分析</a></li></ul></li><li><a href="https://www.javadoop.com/post/hashmap#Java8%20ConcurrentHashMap" target="_blank" rel="noopener">Java8 ConcurrentHashMap</a><ul><li><a href="https://www.javadoop.com/post/hashmap#%E5%88%9D%E5%A7%8B%E5%8C%96" target="_blank" rel="noopener">初始化</a></li><li><a href="https://www.javadoop.com/post/hashmap#put%20%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90" target="_blank" rel="noopener">put 过程分析</a><ul><li><a href="https://www.javadoop.com/post/hashmap#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84%EF%BC%9AinitTable" target="_blank" rel="noopener">初始化数组：initTable</a></li><li><a href="https://www.javadoop.com/post/hashmap#%E9%93%BE%E8%A1%A8%E8%BD%AC%E7%BA%A2%E9%BB%91%E6%A0%91%3A%20treeifyBin" target="_blank" rel="noopener">链表转红黑树: treeifyBin</a></li></ul></li><li><a href="https://www.javadoop.com/post/hashmap#%E6%89%A9%E5%AE%B9%EF%BC%9AtryPresize" target="_blank" rel="noopener">扩容：tryPresize</a><ul><li><a href="https://www.javadoop.com/post/hashmap#%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%EF%BC%9Atransfer" target="_blank" rel="noopener">数据迁移：transfer</a></li></ul></li><li><a href="https://www.javadoop.com/post/hashmap#get%20%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90" target="_blank" rel="noopener">get 过程分析</a></li></ul></li><li><a href="https://www.javadoop.com/post/hashmap#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">总结</a></li></ul><h2 id="Java7-HashMap"><a href="#Java7-HashMap" class="headerlink" title="Java7 HashMap"></a>Java7 HashMap</h2><p>HashMap 是最简单的，一来我们非常熟悉，二来就是它不支持并发操作，所以源码也非常简单。</p><p>首先，我们用下面这张图来介绍 HashMap 的结构。</p><p><img src="https://www.javadoop.com/blogimages/map/1.png" alt="1"></p><blockquote><p>这个仅仅是示意图，因为没有考虑到数组要扩容的情况，具体的后面再说。</p></blockquote><p>大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。</p><p>上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。</p><p>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。</p><p>loadFactor：负载因子，默认为 0.75。</p><p>threshold：扩容的阈值，等于 capacity * loadFactor</p><h3 id="put-过程分析"><a href="#put-过程分析" class="headerlink" title="put 过程分析"></a>put 过程分析</h3><p>还是比较简单的，跟着代码走一遍吧。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当插入第一个元素的时候，需要先初始化数组大小</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 key 为 null，感兴趣的可以往里看，最终会将这个 entry 放到 table[0] 中</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(<span class="keyword">value</span>);</span><br><span class="line">    <span class="comment">// 1\. 求 key 的 hash 值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 2\. 找到对应的数组下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 3\. 遍历一下对应下标处的链表，看是否有重复的 key 已经存在，</span></span><br><span class="line">    <span class="comment">//    如果有，直接覆盖，put 方法返回旧值就结束了</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.<span class="keyword">equals</span>(k))) &#123;</span><br><span class="line">            V oldValue = e.<span class="keyword">value</span>;</span><br><span class="line">            e.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 4\. 不存在重复的 key，将此 entry 添加到链表中，细节后面说</span></span><br><span class="line">    addEntry(hash, key, <span class="keyword">value</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h4><p>在第一个元素插入 HashMap 的时候做一次数组的初始化，就是先确定初始的数组大小，并计算数组扩容的阈值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保证数组大小一定是 2 的 n 次方。</span></span><br><span class="line">    <span class="comment">// 比如这样初始化：new HashMap(20)，那么处理成初始数组大小是 32</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line">    <span class="comment">// 计算扩容阈值：capacity * loadFactor</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 算是初始化数组吧</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity); <span class="comment">//ignore</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个将数组大小保持为 2 的 n 次方的做法，Java7 和 Java8 的 HashMap 和 ConcurrentHashMap 都有相应的要求，只不过实现的代码稍微有些不同，后面再看到的时候就知道了。</p><h4 id="计算具体数组位置"><a href="#计算具体数组位置" class="headerlink" title="计算具体数组位置"></a>计算具体数组位置</h4><p>这个简单，我们自己也能 YY 一个：使用 key 的 hash 值对数组长度进行取模就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> hash, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></span><br><span class="line">    <span class="keyword">return</span> hash &amp; (length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法很简单，简单说就是取 hash 值的低 n 位。如在数组长度为 32 的时候，其实取的就是 key 的 hash 值的低 5 位，作为它在数组中的下标位置。</p><h4 id="添加节点到链表中"><a href="#添加节点到链表中" class="headerlink" title="添加节点到链表中"></a>添加节点到链表中</h4><p>找到数组下标后，会先进行 key 判重，如果没有重复，就准备将新值放入到链表的表头。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> addEntry(<span class="built_in">int</span> hash, K <span class="built_in">key</span>, V value, <span class="built_in">int</span> bucketIndex) &#123;</span><br><span class="line">    <span class="comment">// 如果当前 HashMap 大小已经达到了阈值，并且新值要插入的数组位置已经有元素了，那么要扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">size</span> &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">// 扩容，后面会介绍一下</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        <span class="comment">// 扩容以后，重新计算 hash 值</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != <span class="built_in">key</span>) ? hash(<span class="built_in">key</span>) : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 重新计算扩容后的新的下标</span></span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 往下看</span></span><br><span class="line">    createEntry(hash, <span class="built_in">key</span>, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个很简单，其实就是将新值放到链表的表头，然后 size++</span></span><br><span class="line"><span class="keyword">void</span> createEntry(<span class="built_in">int</span> hash, K <span class="built_in">key</span>, V value, <span class="built_in">int</span> bucketIndex) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, <span class="built_in">key</span>, value, e);</span><br><span class="line">    <span class="built_in">size</span>++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的主要逻辑就是先判断是否需要扩容，需要的话先扩容，然后再将这个新的数据插入到扩容后的数组的相应位置处的链表的表头。</p><h4 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h4><p>前面我们看到，在插入新值的时候，如果当前的 size 已经达到了阈值，并且要插入的数组位置上已经有元素，那么就会触发扩容，扩容后，数组大小为原来的 2 倍。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void resize(int <span class="keyword">new</span><span class="type">Capacity</span>) &#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    int oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的数组</span></span><br><span class="line">    Entry[] <span class="keyword">new</span><span class="type">Table</span> = <span class="keyword">new</span> <span class="type">Entry</span>[<span class="keyword">new</span><span class="type">Capacity</span>];</span><br><span class="line">    <span class="comment">// 将原来数组中的值迁移到新的更大的数组中</span></span><br><span class="line">    transfer(<span class="keyword">new</span><span class="type">Table</span>, initHashSeedAsNeeded(<span class="keyword">new</span><span class="type">Capacity</span>));</span><br><span class="line">    table = <span class="keyword">new</span><span class="type">Table</span>;</span><br><span class="line">    threshold = (int)Math.min(<span class="keyword">new</span><span class="type">Capacity</span> * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这篇文章没有讲清楚1.7和1.8hashmap扩容的区别，这里特地补充：</p><h3 id="HashMap扩容机制：-JDK1-7与1-8的区别"><a href="#HashMap扩容机制：-JDK1-7与1-8的区别" class="headerlink" title="HashMap扩容机制： JDK1.7与1.8的区别"></a>HashMap扩容机制： JDK1.7与1.8的区别</h3><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p><p>我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。</p><table><thead><tr><th><code>1</code> <code>void</code> <code>resize(`</code>int<code></code>newCapacity) {   <code>//传入新的容量</code>2<code></code>Entry[] oldTable = table;    <code>//引用扩容前的Entry数组</code>3<code></code>int<code></code>oldCapacity = oldTable.length;        <code>4`     `if` `(oldCapacity == MAXIMUM_CAPACITY) {</code>//扩容前的数组大小如果已经达到最大(2^30)了<code>5`         `threshold = Integer.MAX_VALUE;</code>//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了<code>6`         `return</code>;<code>7`     `}</code>8<code></code>9<code></code>Entry[] newTable = <code>new` `Entry[newCapacity];</code>//初始化一个新的Entry数组<code>10`     `transfer(newTable);</code>//！！将数据转移到新的Entry数组里<code>11`     `table = newTable;</code>//HashMap的table属性引用新的Entry数组<code>12`     `threshold = (</code>int<code>)(newCapacity * loadFactor);</code>//修改阈值<code></code>13<code></code>}`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p><table><thead><tr><th><code>1</code> <code>void</code> <code>transfer(Entry[] newTable) {`</code>2<code></code>Entry[] src = table;                   <code>//src引用了旧的Entry数组</code>3<code></code>int<code></code>newCapacity = newTable.length;<code>4`     `for` `(</code>int<code></code>j = <code>0</code>; j &lt; src.length; j++) { <code>//遍历旧的Entry数组</code>5<code></code>Entry&lt;K,V&gt; e = src[j];             <code>//取得旧Entry数组的每个元素</code>6<code></code>if<code></code>(e != <code>null</code>) {<code>7`             `src[j] =</code>null<code>;</code>//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）<code>8`             `do` `{</code>9<code></code>Entry&lt;K,V&gt; next = e.next;<code>10`                 `int` `i = indexFor(e.hash, newCapacity);</code>//！！重新计算每个元素在数组中的位置<code>11`                 `e.next = newTable[i];</code>//标记[1]<code>12`                 `newTable[i] = e;</code>//将元素放在数组上<code>13`                 `e = next;</code>//访问下一个Entry链上的元素<code>14`             `}</code>while<code></code>(e != <code>null</code>);<code>15`         `}</code>16<code></code>}<code></code>17<code></code>}`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p><p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p><p><img src="http://tech.meituan.com/img/java-hashmap/jdk1.7%E6%89%A9%E5%AE%B9%E4%BE%8B%E5%9B%BE.png" alt="jdk1.7扩容例图"></p><p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p><p><img src="http://tech.meituan.com/img/java-hashmap/hashMap%201.8%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE1.png" alt="hashMap 1.8 哈希算法例图1"></p><p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="http://tech.meituan.com/img/java-hashmap/hashMap%201.8%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE2.png" alt="hashMap 1.8 哈希算法例图2"></p><p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p><p><img src="http://tech.meituan.com/img/java-hashmap/jdk1.8%20hashMap%E6%89%A9%E5%AE%B9%E4%BE%8B%E5%9B%BE.png" alt="jdk1.8 hashMap扩容例图"></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下:</p><table><thead><tr><th><code>1</code> <code>final</code> <code>Node&lt;K,V&gt;[] resize() {`</code>2<code></code>Node&lt;K,V&gt;[] oldTab = table;<code>3`     `int` `oldCap = (oldTab ==</code>null<code>) ?</code>0<code></code>: oldTab.length;<code>4`     `int` `oldThr = threshold;</code>5<code></code>int<code></code>newCap, newThr = <code>0</code>;<code>6`     `if` `(oldCap &gt;</code>0<code>) {</code>7<code></code>// 超过最大值就不再扩充了，就只好随你碰撞去吧<code>8`         `if` `(oldCap &gt;= MAXIMUM_CAPACITY) {</code>9<code></code>threshold = Integer.MAX_VALUE;<code>10`             `return` `oldTab;</code>11<code></code>}<code>12`         `// 没超过最大值，就扩充为原来的2倍</code>13<code></code>else<code></code>if<code></code>((newCap = oldCap &lt;&lt; <code>1</code>) &lt; MAXIMUM_CAPACITY &amp;&amp;<code>14`                  `oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</code>15<code></code>newThr = oldThr &lt;&lt; <code>1</code>; <code>// double threshold</code>16<code></code>}<code>17`     `else` `if` `(oldThr &gt;</code>0<code>)</code>// initial capacity was placed in threshold<code>18`         `newCap = oldThr;</code>19<code></code>else<code></code>{               <code>// zero initial threshold signifies using defaults</code>20<code></code>newCap = DEFAULT_INITIAL_CAPACITY;<code>21`         `newThr = (</code>int<code>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</code>22<code></code>}<code>23`     `// 计算新的resize上限</code>24<code></code>if<code></code>(newThr == <code>0</code>) {<code>25</code>26<code></code>float<code></code>ft = (<code>float</code>)newCap * loadFactor;<code>27`         `newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (</code>float<code>)MAXIMUM_CAPACITY ?</code>28<code></code>(<code>int</code>)ft : Integer.MAX_VALUE);<code>29`     `}</code>30<code></code>threshold = newThr;<code>31`     `@SuppressWarnings</code>({<code>&quot;rawtypes&quot;</code>，<code>&quot;unchecked&quot;</code>})<code>32`         `Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])</code>new<code></code>Node[newCap];<code>33`     `table = newTab;</code>34<code></code>if<code></code>(oldTab != <code>null</code>) {<code>35`         `// 把每个bucket都移动到新的buckets中</code>36<code></code>for<code></code>(<code>int` `j =</code>0<code>; j &lt; oldCap; ++j) {</code>37<code></code>Node&lt;K,V&gt; e;<code>38`             `if` `((e = oldTab[j]) !=</code>null<code>) {</code>39<code></code>oldTab[j] = <code>null</code>;<code>40`                 `if` `(e.next ==</code>null<code>)</code>41<code></code>newTab[e.hash &amp; (newCap - <code>1</code>)] = e;<code>42`                 `else` `if` `(e</code>instanceof<code></code>TreeNode)<code>43`                     `((TreeNode&lt;K,V&gt;)e).split(</code>this<code>, newTab, j, oldCap);</code>44<code></code>else<code></code>{ <code>// 链表优化重hash的代码块</code>45<code></code>Node&lt;K,V&gt; loHead = <code>null</code>, loTail = <code>null</code>;<code>46`                     `Node&lt;K,V&gt; hiHead =</code>null<code>, hiTail =</code>null<code>;</code>47<code></code>Node&lt;K,V&gt; next;<code>48`                     `do` `{</code>49<code></code>next = e.next;<code>50`                         `// 原索引</code>51<code></code>if<code></code>((e.hash &amp; oldCap) == <code>0</code>) {<code>52`                             `if` `(loTail ==</code>null<code>)</code>53<code></code>loHead = e;<code>54`                             `else</code>55<code></code>loTail.next = e;<code>56`                             `loTail = e;</code>57<code></code>}<code>58`                         `// 原索引+oldCap</code>59<code></code>else<code></code>{<code>60`                             `if` `(hiTail ==</code>null<code>)</code>61<code></code>hiHead = e;<code>62`                             `else</code>63<code></code>hiTail.next = e;<code>64`                             `hiTail = e;</code>65<code></code>}<code>66`                     `}</code>while<code></code>((e = next) != <code>null</code>);<code>67`                     `// 原索引放到bucket里</code>68<code></code>if<code></code>(loTail != <code>null</code>) {<code>69`                         `loTail.next =</code>null<code>;</code>70<code></code>newTab[j] = loHead;<code>71`                     `}</code>72<code></code>// 原索引+oldCap放到bucket里<code>73`                     `if` `(hiTail !=</code>null<code>) {</code>74<code></code>hiTail.next = <code>null</code>;<code>75`                         `newTab[j + oldCap] = hiHead;</code>76<code></code>}<code>77`                 `}</code>78<code></code>}<code>79`         `}</code>80<code></code>}<code>81`     `return` `newTab;</code>82<code></code>}`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p><strong>HashMap线程安全经典问题：并发修改时的死锁</strong></p><p>另外这里要引入一个经典的问题，多线程put操作时可能导致的遍历死锁问题。</p><p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：</p><table><thead><tr><th>1234567891011121314151617181920</th><th><code>public</code> <code>class</code> <code>HashMapInfiniteLoop { `</code>private<code></code>static<code></code>HashMap&lt;Integer,String&gt; map = <code>new` `HashMap&lt;Integer,String&gt;(</code>2<code>，</code>0<code>.75f);</code>public<code></code>static<code></code>void<code></code>main(String[] args) { <code>map.put(</code>5<code>，</code>“C”<code>);</code>new<code></code>Thread(<code>&quot;Thread1&quot;</code>) { <code>public` `void` `run() {</code>map.put(<code>7</code>, <code>&quot;B&quot;</code>); <code>System.out.println(map);</code>}; <code>}.start();</code>new<code></code>Thread(<code>&quot;Thread2&quot;</code>) { <code>public` `void` `run() {</code>map.put(<code>3</code>, “A); <code>System.out.println(map);</code>}; <code>}.start();</code>} <code></code>}`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。</p><p>通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。</p><p><img src="http://tech.meituan.com/img/java-hashmap/jdk1.7%20hashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%BE%8B%E5%9B%BE1.png" alt="jdk1.7 hashMap死循环例图1"></p><p>注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。</p><p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。</p><p><img src="http://tech.meituan.com/img/java-hashmap/jdk1.7%20hashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%BE%8B%E5%9B%BE2.png" alt="jdk1.7 hashMap死循环例图2"></p><p><img src="http://tech.meituan.com/img/java-hashmap/jdk1.7%20hashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%BE%8B%E5%9B%BE3.png" alt="jdk1.7 hashMap死循环例图3"></p><p>e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p><p><img src="http://tech.meituan.com/img/java-hashmap/jdk1.7%20hashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%BE%8B%E5%9B%BE4.png" alt="jdk1.7 hashMap死循环例图4"></p><p>于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。</p><h3 id="get-过程分析"><a href="#get-过程分析" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><p>相对于 put 过程，get 过程是非常简单的。</p><ol><li>根据 key 计算 hash 值。</li><li>找到相应的数组下标：hash &amp; (length - 1)。</li><li>遍历该数组位置处的链表，直到找到相等(==或equals)的 key。</li></ol><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="comment">// 之前说过，key 为 null 的话，会被放到 table[0]，所以只要遍历下 table[0] 处的链表就可以了</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(<span class="built_in">key</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getEntry(key):</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; getEntry(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> hash = (<span class="built_in">key</span> == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(<span class="built_in">key</span>);</span><br><span class="line">    <span class="comment">// 确定数组下标，然后从头开始遍历链表，直到找到为止</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        <span class="keyword">Object</span> k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java7-ConcurrentHashMap"><a href="#Java7-ConcurrentHashMap" class="headerlink" title="Java7 ConcurrentHashMap"></a>Java7 ConcurrentHashMap</h2><p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。</p><p>整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个 segment。</p><p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p><p><img src="https://www.javadoop.com/blogimages/map/3.png" alt="3"></p><p>concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。</p><p>再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>initialCapacity：初始容量，这个值指的是整个 ConcurrentHashMap 的初始容量，实际操作的时候需要平均分给每个 Segment。</p><p>loadFactor：负载因子，之前我们说了，Segment 数组不可以扩容，所以这个负载因子是给每个 Segment 内部使用的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 我们这里先不要那么烧脑，用默认值，concurrencyLevel 为 16，sshift 为 4</span></span><br><span class="line">    <span class="comment">// 那么计算出 segmentShift 为 28，segmentMask 为 15，后面会用到这两个值</span></span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialCapacity 是设置整个 map 初始的大小，</span></span><br><span class="line">    <span class="comment">// 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小</span></span><br><span class="line">    <span class="comment">// 如 initialCapacity 为 64，那么每个 Segment 或称之为"槽"可以分到 4 个</span></span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="comment">// 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上，</span></span><br><span class="line">    <span class="comment">// 插入一个元素不至于扩容，插入第二个的时候才会扩容</span></span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY; </span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 Segment 数组，</span></span><br><span class="line">    <span class="comment">// 并创建数组的第一个元素 segment[0]</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 =</span><br><span class="line">        <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">    <span class="comment">// 往数组写入 segment[0]</span></span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化完成，我们得到了一个 Segment 数组。</p><p>我们就当是用 new ConcurrentHashMap() 无参构造函数进行初始化的，那么初始化完成后：</p><ul><li>Segment 数组长度为 16，不可以扩容</li><li>Segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容</li><li>这里初始化了 segment[0]，其他位置还是 null，至于为什么要初始化 segment[0]，后面的代码会介绍</li><li>当前 segmentShift 的值为 32 - 4 = 28，segmentMask 为 16 - 1 = 15，姑且把它们简单翻译为移位数和掩码，这两个值马上就会用到</li></ul><h3 id="put-过程分析-1"><a href="#put-过程分析-1" class="headerlink" title="put 过程分析"></a>put 过程分析</h3><p>我们先看 put 的主流程，对于其中的一些关键细节操作，后面会进行详细介绍。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 1\. 计算 key 的 hash 值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 2\. 根据 hash 值找到 Segment 数组中的位置 j</span></span><br><span class="line">    <span class="comment">//    hash 是 32 位，无符号右移 segmentShift(28) 位，剩下低 4 位，</span></span><br><span class="line">    <span class="comment">//    然后和 segmentMask(15) 做一次与操作，也就是说 j 是 hash 值的最后 4 位，也就是槽的数组下标</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="comment">// 刚刚说了，初始化的时候初始化了 segment[0]，但是其他位置还是 null，</span></span><br><span class="line">    <span class="comment">// ensureSegment(j) 对 segment[j] 进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="literal">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="comment">// 3\. 插入新值到 槽 s 中</span></span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, <span class="keyword">value</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一层皮很简单，根据 hash 值很快就能找到相应的 Segment，之后就是 Segment 内部的 put 操作了。</p><p>Segment 内部是由 数组+链表 组成的。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">final V <span class="title">put</span>(<span class="params">K key, <span class="keyword">int</span> hash, V <span class="keyword">value</span>, boolean onlyIfAbsent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在往该 segment 写入前，需要先获取该 segment 的独占锁</span></span><br><span class="line">    <span class="comment">//    先看主流程，后面还会具体介绍这部分内容</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> :</span><br><span class="line">        scanAndLockForPut(key, hash, <span class="keyword">value</span>);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这个是 segment 内部的数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 再利用 hash 值，求应该放置的数组下标</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// first 是数组该位置处的链表的表头</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.<span class="keyword">equals</span>(k))) &#123;</span><br><span class="line">                    oldValue = e.<span class="keyword">value</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        <span class="comment">// 覆盖旧值</span></span><br><span class="line">                        e.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 继续顺着链表走</span></span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。</span></span><br><span class="line">                <span class="comment">// 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="literal">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, <span class="keyword">value</span>, first);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果超过了该 segment 的阈值，这个 segment 需要扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node); <span class="comment">// 扩容后面也会具体分析</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 没有达到阈值，将 node 放到数组 tab 的 index 位置，</span></span><br><span class="line">                    <span class="comment">// 其实就是将新的节点设置成原链表的表头</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体流程还是比较简单的，由于有独占锁的保护，所以 segment 内部的操作并不复杂。至于这里面的并发问题，我们稍后再进行介绍。</p><p>到这里 put 操作就结束了，接下来，我们说一说其中几步关键的操作。</p><h4 id="初始化槽-ensureSegment"><a href="#初始化槽-ensureSegment" class="headerlink" title="初始化槽: ensureSegment"></a>初始化槽: ensureSegment</h4><p>ConcurrentHashMap 初始化的时候会初始化第一个槽 segment[0]，对于其他槽来说，在插入第一个值的时候进行初始化。</p><p>这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽 segment[k]，不过只要有一个成功了就可以。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private <span class="meta">Segment</span>&lt;K,V&gt; ensureSegment(<span class="keyword">int</span> k) &#123;</span><br><span class="line">    final <span class="meta">Segment</span>&lt;K,V&gt;[] <span class="built_in">ss</span> = this.segments<span class="comment">;</span></span><br><span class="line">    long u = (k &lt;&lt; SSHIFT) + SBASE<span class="comment">; // raw offset</span></span><br><span class="line">    <span class="meta">Segment</span>&lt;K,V&gt; <span class="built_in">seg</span><span class="comment">;</span></span><br><span class="line">    if ((<span class="built_in">seg</span> = (<span class="meta">Segment</span>&lt;K,V&gt;)UNSAFE.getObjectVolatile(<span class="built_in">ss</span>, u)) == null) &#123;</span><br><span class="line">        // 这里看到为什么之前要初始化 <span class="meta">segment</span>[<span class="number">0</span>] 了，</span><br><span class="line">        // 使用当前 <span class="meta">segment</span>[<span class="number">0</span>] 处的数组长度和负载因子来初始化 <span class="meta">segment</span>[k]</span><br><span class="line">        // 为什么要用“当前”，因为 <span class="meta">segment</span>[<span class="number">0</span>] 可能早就扩容过了</span><br><span class="line">        <span class="meta">Segment</span>&lt;K,V&gt; proto = <span class="built_in">ss</span>[<span class="number">0</span>]<span class="comment">;</span></span><br><span class="line">        <span class="keyword">int</span> cap = proto.table.length<span class="comment">;</span></span><br><span class="line">        <span class="meta">float</span> lf = proto.loadFactor<span class="comment">;</span></span><br><span class="line">        <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        // 初始化 <span class="meta">segment</span>[k] 内部的数组</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])new HashEntry[cap]<span class="comment">;</span></span><br><span class="line">        if ((<span class="built_in">seg</span> = (<span class="meta">Segment</span>&lt;K,V&gt;)UNSAFE.getObjectVolatile(<span class="built_in">ss</span>, u))</span><br><span class="line">            == null) &#123; // 再次检查一遍该槽是否被其他线程初始化了。</span><br><span class="line"></span><br><span class="line">            <span class="meta">Segment</span>&lt;K,V&gt; s = new <span class="meta">Segment</span>&lt;K,V&gt;(lf, threshold, tab)<span class="comment">;</span></span><br><span class="line">            // 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出</span><br><span class="line">            while ((<span class="built_in">seg</span> = (<span class="meta">Segment</span>&lt;K,V&gt;)UNSAFE.getObjectVolatile(<span class="built_in">ss</span>, u))</span><br><span class="line">                   == null) &#123;</span><br><span class="line">                if (UNSAFE.compareAndSwapObject(<span class="built_in">ss</span>, u, null, <span class="built_in">seg</span> = s))</span><br><span class="line">                    break<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="built_in">seg</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，ensureSegment(int k) 比较简单，对于并发操作使用 CAS 进行控制。</p><blockquote><p>我没搞懂这里为什么要搞一个 while 循环，CAS 失败不就代表有其他线程成功了吗，为什么要再进行判断？</p><p>感谢评论区的李子木，如果当前线程 CAS 失败，这里的 while 循环是为了将 seg 赋值返回。</p></blockquote><h4 id="获取写入锁-scanAndLockForPut"><a href="#获取写入锁-scanAndLockForPut" class="headerlink" title="获取写入锁: scanAndLockForPut"></a>获取写入锁: scanAndLockForPut</h4><p>前面我们看到，在往某个 segment 中 put 的时候，首先会调用 node = tryLock() ? null : scanAndLockForPut(key, hash, value)，也就是说先进行一次 tryLock() 快速获取该 segment 的独占锁，如果失败，那么进入到 scanAndLockForPut 这个方法来获取锁。</p><p>下面我们来具体分析这个方法中是怎么控制加锁的。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span>(<span class="params">K key, <span class="keyword">int</span> hash, V <span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">int</span> retries = <span class="number">-1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环获取锁</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    <span class="comment">// 进到这里说明数组该位置的链表是空的，没有任何元素</span></span><br><span class="line">                    <span class="comment">// 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, <span class="keyword">value</span>, <span class="literal">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.<span class="keyword">equals</span>(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 顺着链表往下走</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重试次数如果超过 MAX_SCAN_RETRIES（单核1多核64），那么不抢了，进入到阻塞队列等待锁</span></span><br><span class="line">        <span class="comment">//    lock() 是阻塞方法，直到获取锁后返回</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            <span class="keyword">lock</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 <span class="comment">// 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头</span></span><br><span class="line">                 <span class="comment">//     所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法</span></span><br><span class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法有两个出口，一个是 tryLock() 成功了，循环终止，另一个就是重试次数超过了 MAX_SCAN_RETRIES，进到 lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。</p><p>这个方法就是看似复杂，但是其实就是做了一件事，那就是获取该 segment 的独占锁，如果需要的话顺便实例化了一下 node。</p><h4 id="扩容-rehash"><a href="#扩容-rehash" class="headerlink" title="扩容: rehash"></a>扩容: rehash</h4><p>重复一下，segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry[] 进行扩容，扩容后，容量为原来的 2 倍。</p><p>首先，我们要回顾一下触发扩容的地方，put 的时候，如果判断该值的插入会导致该 segment 的元素个数超过阈值，那么先进行扩容，再插值，读者这个时候可以回去 put 方法看一眼。</p><p>该方法不需要考虑并发，因为到这里的时候，是持有该 segment 的独占锁的。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。</span></span><br><span class="line"><span class="keyword">private</span> void rehash(HashEntry&lt;K,V&gt; node) &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    int oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 2 倍</span></span><br><span class="line">    int <span class="keyword">new</span><span class="type">Capacity</span> = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    threshold = (int)(<span class="keyword">new</span><span class="type">Capacity</span> * loadFactor);</span><br><span class="line">    <span class="comment">// 创建新数组</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] <span class="keyword">new</span><span class="type">Table</span> =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> <span class="type">HashEntry</span>[<span class="keyword">new</span><span class="type">Capacity</span>];</span><br><span class="line">    <span class="comment">// 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘000...00011111’</span></span><br><span class="line">    int sizeMask = <span class="keyword">new</span><span class="type">Capacity</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置</span></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        <span class="comment">// e 是链表的第一个元素</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 计算应该放置在新数组中的位置，</span></span><br><span class="line">            <span class="comment">// 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 = 19</span></span><br><span class="line">            int idx = e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>)   <span class="comment">// 该位置处只有一个元素，那比较好办</span></span><br><span class="line">                <span class="keyword">new</span><span class="type">Table</span>[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                <span class="comment">// e 是链表表头</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="comment">// idx 是当前链表的头结点 e 的新位置</span></span><br><span class="line">                int lastIdx = idx;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="literal">null</span>;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    int k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置</span></span><br><span class="line">                <span class="keyword">new</span><span class="type">Table</span>[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// 下面的操作是处理 lastRun 之前的节点，</span></span><br><span class="line">                <span class="comment">//    这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    int h = p.hash;</span><br><span class="line">                    int k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = <span class="keyword">new</span><span class="type">Table</span>[k];</span><br><span class="line">                    <span class="keyword">new</span><span class="type">Table</span>[k] = <span class="keyword">new</span> <span class="type">HashEntry</span>&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部</span></span><br><span class="line">    int nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(<span class="keyword">new</span><span class="type">Table</span>[nodeIndex]);</span><br><span class="line">    <span class="keyword">new</span><span class="type">Table</span>[nodeIndex] = node;</span><br><span class="line">    table = <span class="keyword">new</span><span class="type">Table</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的扩容比之前的 HashMap 要复杂一些，代码难懂一点。上面有两个挨着的 for 循环，第一个 for 有什么用呢？</p><p>仔细一看发现，如果没有第一个 for 循环，也是可以工作的，但是，这个 for 循环下来，如果 lastRun 的后面还有比较多的节点，那么这次就是值得的。因为我们只需要克隆 lastRun 前面的节点，后面的一串节点跟着 lastRun 走就是了，不需要做任何操作。</p><p>我觉得 Doug Lea 的这个想法也是挺有意思的，不过比较坏的情况就是每次 lastRun 都是链表的最后一个元素或者很靠后的元素，那么这次遍历就有点浪费了。不过 Doug Lea 也说了，根据统计，如果使用默认的阈值，大约只有 1/6 的节点需要克隆。</p><h3 id="get-过程分析-1"><a href="#get-过程分析-1" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><p>相对于 put 来说，get 真的不要太简单。</p><ol><li>计算 hash 值，找到 segment 数组中的具体位置，或我们前面用的“槽”</li><li>槽中也是一个数组，根据 hash 找到数组中具体的位置</li><li>到这里是链表了，顺着链表进行查找即可</li></ol><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="comment">// 1\. hash 值</span></span><br><span class="line">    <span class="built_in">int</span> h = hash(<span class="built_in">key</span>);</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="comment">// 2\. 根据 hash 找到对应的 segment</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 3\. 找到segment 内部数组相应位置的链表，遍历</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (e.hash == h &amp;&amp; <span class="built_in">key</span>.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="size操作"><a href="#size操作" class="headerlink" title="size操作"></a>size操作</h2><p>put、remove和get操作只需要关心一个Segment，而size操作需要遍历所有的Segment才能算出整个Map的大小。一个简单的方案是，先锁住所有Sgment，计算完后再解锁。但这样做，在做size操作时，不仅无法对Map进行写操作，同时也无法进行读操作，不利于对Map的并行操作。</p><p>为更好支持并发操作，ConcurrentHashMap会在不上锁的前提逐个Segment计算3次size，如果某相邻两次计算获取的所有Segment的更新次数（每个Segment都与HashMap一样通过modCount跟踪自己的修改次数，Segment每修改一次其modCount加一）相等，说明这两次计算过程中无更新操作，则这两次计算出的总size相等，可直接作为最终结果返回。如果这三次计算过程中Map有更新，则对所有Segment加锁重新计算Size。该计算方法代码如下</p><pre><code>public int size() {final Segment&lt;K,V&gt;[] segments = this.segments;int size;boolean overflow; // true if size overflows 32 bitslong sum; // sum of modCountslong last = 0L; // previous sumint retries = -1; // first iteration isn&apos;t retrytry {for (;;) {if (retries++ == RETRIES_BEFORE_LOCK) {for (int j = 0; j &lt; segments.length; ++j)ensureSegment(j).lock(); // force creation}sum = 0L;size = 0;overflow = false;for (int j = 0; j &lt; segments.length; ++j) {Segment&lt;K,V&gt; seg = segmentAt(segments, j);if (seg != null) {sum += seg.modCount;int c = seg.count;if (c &lt; 0 || (size += c) &lt; 0)overflow = true;}}if (sum == last)break;last = sum;}} finally {if (retries &gt; RETRIES_BEFORE_LOCK) {for (int j = 0; j &lt; segments.length; ++j)segmentAt(segments, j).unlock();}}return overflow ? Integer.MAX_VALUE : size;}</code></pre><h2 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a><a href="http://www.jasongj.com/java/concurrenthashmap/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84" title="不同之处" target="_blank" rel="noopener"></a>不同之处</h2><p>JDK1.7中</p><p>ConcurrentHashMap与HashMap相比，有以下不同点</p><ul><li>ConcurrentHashMap线程安全，而HashMap非线程安全</li><li>HashMap允许Key和Value为null，而ConcurrentHashMap不允许</li><li>HashMap不允许通过Iterator遍历的同时通过HashMap修改，而ConcurrentHashMap允许该行为，并且该更新对后续的遍历可见</li></ul><h3 id="并发问题分析"><a href="#并发问题分析" class="headerlink" title="并发问题分析"></a>并发问题分析</h3><p>现在我们已经说完了 put 过程和 get 过程，我们可以看到 get 过程中是没有加锁的，那自然我们就需要去考虑并发问题。</p><p>添加节点的操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所以它们之间自然不会有问题，我们需要考虑的问题就是 get 的时候在同一个 segment 中发生了 put 或 remove 操作。</p><ol><li><p>put 操作的线程安全性。</p><ol><li>初始化槽，这个我们之前就说过了，使用了 CAS 来初始化 Segment 中的数组。</li><li>添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 setEntryAt 方法中使用的 UNSAFE.putOrderedObject。</li><li>扩容。扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果 get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么 put 操作的可见性保证就是 table 使用了 volatile 关键字。</li></ol></li><li><p>remove 操作的线程安全性。</p><p>remove 操作我们没有分析源码，所以这里说的读者感兴趣的话还是需要到源码中去求实一下的。</p><p>get 操作需要遍历链表，但是 remove 操作会”破坏”链表。</p><p>如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问题。</p><p>如果 remove 先破坏了一个节点，分两种情况考虑。 1、如果此节点是头结点，那么需要将头结点的 next 设置为数组该位置的元素，table 虽然使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见性保证，所以源码中使用了 UNSAFE 来操作数组，请看方法 setEntryAt。2、如果要删除的节点不是头结点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 next 属性是 volatile 的。</p></li></ol><h2 id="Java8-HashMap"><a href="#Java8-HashMap" class="headerlink" title="Java8 HashMap"></a>Java8 HashMap</h2><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。</p><p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。</p><p>为了降低这部分的开销，在 Java8 中，当链表中的元素达到了 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p><p>来一张图简单示意一下吧：</p><p><img src="https://www.javadoop.com/blogimages/map/2.png" alt="2"></p><blockquote><p>注意，上图是示意图，主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了。</p></blockquote><p>下面，我们还是用代码来介绍吧，个人感觉，Java8 的源码可读性要差一些，不过精简一些。</p><p>Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 Node，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。</p><p>我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。</p><h3 id="put-过程分析-2"><a href="#put-过程分析-2" class="headerlink" title="put 过程分析"></a>put 过程分析</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V put(K <span class="built_in">key</span>, V value) &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(<span class="built_in">key</span>), <span class="built_in">key</span>, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作</span></span><br><span class="line"><span class="comment">// 第四个参数 evict 我们这里不关心</span></span><br><span class="line"><span class="keyword">final</span> V putVal(<span class="built_in">int</span> hash, K <span class="built_in">key</span>, V value, <span class="built_in">boolean</span> onlyIfAbsent,</span><br><span class="line">               <span class="built_in">boolean</span> evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="built_in">int</span> n, i;</span><br><span class="line">    <span class="comment">// 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度</span></span><br><span class="line">    <span class="comment">// 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, <span class="built_in">key</span>, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 数组该位置有数据</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是"相等"，如果是，取出这个节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, <span class="built_in">key</span>, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 到这里，说明数组该位置上是一个链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 插入到链表的最后面(Java7 是插入到链表的最前面)</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, <span class="built_in">key</span>, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 8 个</span></span><br><span class="line">                    <span class="comment">// 会触发下面的 treeifyBin，也就是将链表转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果在该链表中找到了"相等"的 key(== 或 equals)</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))</span><br><span class="line">                    <span class="comment">// 此时 break，那么 e 为链表中[与要插入的新值的 key "相等"]的 node</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// e!=null 说明存在旧值的key与要插入的key"相等"</span></span><br><span class="line">        <span class="comment">// 对于我们分析的put操作，下面这个 if 其实就是进行 "值覆盖"，然后返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++<span class="built_in">size</span> &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容，不过这个不重要。</p><h4 id="数组扩容-1"><a href="#数组扩容-1" class="headerlink" title="数组扩容"></a>数组扩容</h4><p>resize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : <span class="type">oldTab</span>.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int <span class="keyword">new</span><span class="type">Cap</span>, <span class="keyword">new</span><span class="type">Thr</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">// 对应数组扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将数组大小扩大一倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">new</span><span class="type">Cap</span> = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 将阈值扩大一倍</span></span><br><span class="line">            <span class="keyword">new</span><span class="type">Thr</span> = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候</span></span><br><span class="line">        <span class="keyword">new</span><span class="type">Cap</span> = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 对应使用 new HashMap() 初始化后，第一次 put 的时候</span></span><br><span class="line">        <span class="keyword">new</span><span class="type">Cap</span> = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        <span class="keyword">new</span><span class="type">Thr</span> = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Thr</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        float ft = (float)<span class="keyword">new</span><span class="type">Cap</span> * loadFactor;</span><br><span class="line">        <span class="keyword">new</span><span class="type">Thr</span> = (<span class="keyword">new</span><span class="type">Cap</span> &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : <span class="type">Integer</span>.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = <span class="keyword">new</span><span class="type">Thr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用新的数组大小初始化新的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] <span class="keyword">new</span><span class="type">Tab</span> = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="type">Node</span>[<span class="keyword">new</span><span class="type">Cap</span>];</span><br><span class="line">    table = <span class="keyword">new</span><span class="type">Tab</span>; <span class="comment">// 如果是初始化数组，到这里就结束了，返回 newTab 即可</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 开始遍历原数组，进行数据迁移。</span></span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">new</span><span class="type">Tab</span>[e.hash &amp; (<span class="keyword">new</span><span class="type">Cap</span> - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果是红黑树，具体我们就不展开了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, <span class="keyword">new</span><span class="type">Tab</span>, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="comment">// 这块是处理链表的情况，</span></span><br><span class="line">                    <span class="comment">// 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序</span></span><br><span class="line">                    <span class="comment">// loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">// 第一条链表</span></span><br><span class="line">                        <span class="keyword">new</span><span class="type">Tab</span>[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">// 第二条链表的新的位置是 j + oldCap，这个很好理解</span></span><br><span class="line">                        <span class="keyword">new</span><span class="type">Tab</span>[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Tab</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get-过程分析-2"><a href="#get-过程分析-2" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><p>相对于 put 来说，get 真的太简单了。</p><ol><li>计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)</li><li>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步</li><li>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步</li><li>遍历链表，直到找到相等(==或equals)的 key</li></ol><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(<span class="built_in">key</span>), <span class="built_in">key</span>)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object <span class="built_in">key</span>) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] <span class="built_in">tab</span>; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">tab</span> = table) != <span class="built_in">null</span> &amp;&amp; (n = <span class="built_in">tab</span>.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = <span class="built_in">tab</span>[(n - <span class="number">1</span>) &amp; hash]) != <span class="built_in">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断第一个节点是不是就是需要的</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="built_in">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="built_in">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (first instanceof TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, <span class="built_in">key</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 链表遍历</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="built_in">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="built_in">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java8-ConcurrentHashMap"><a href="#Java8-ConcurrentHashMap" class="headerlink" title="Java8 ConcurrentHashMap"></a>Java8 ConcurrentHashMap</h2><p>Java7 中实现的 ConcurrentHashMap 说实话还是比较复杂的，Java8 对 ConcurrentHashMap 进行了比较大的改动。建议读者可以参考 Java8 中 HashMap 相对于 Java7 HashMap 的改动，对于 ConcurrentHashMap，Java8 也引入了红黑树。</p><p>说实话，Java8 ConcurrentHashMap 源码真心不简单，最难的在于扩容，数据迁移操作不容易看懂。</p><p>我们先用一个示意图来描述下其结构：</p><p><img src="https://www.javadoop.com/blogimages/map/4.png" alt="4"></p><p>结构上和 Java8 的 HashMap 基本上一样，不过它要保证线程安全性，所以在源码上确实要复杂一些。</p><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这构造函数里，什么都不干</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个初始化方法有点意思，通过提供初始容量，计算了 sizeCtl，sizeCtl = 【 (1.5 * initialCapacity + 1)，然后向上取最近的 2 的 n 次方】。如 initialCapacity 为 10，那么得到 sizeCtl 为 16，如果 initialCapacity 为 11，得到 sizeCtl 为 32。</p><p>sizeCtl 这个属性使用的场景很多，不过只要跟着文章的思路来，就不会被它搞晕了。</p><p>如果你爱折腾，也可以看下另一个有三个参数的构造方法，这里我就不说了，大部分时候，我们会使用无参构造函数进行实例化，我们也按照这个思路来进行源码分析吧。</p><h3 id="put-过程分析-3"><a href="#put-过程分析-3" class="headerlink" title="put 过程分析"></a>put 过程分析</h3><p>仔细地一行一行代码看下去：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, <span class="keyword">value</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(K <span class="built_in">key</span>, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="built_in">null</span> || value == <span class="built_in">null</span>) throw <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 得到 hash 值</span></span><br><span class="line">    int hash = spread(<span class="built_in">key</span>.hashCode());</span><br><span class="line">    <span class="comment">// 用于记录相应链表的长度</span></span><br><span class="line">    int binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] <span class="built_in">tab</span> = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">        <span class="comment">// 如果数组"空"，进行数组初始化</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">tab</span> == <span class="built_in">null</span> || (n = <span class="built_in">tab</span>.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 初始化数组，后面会详细介绍</span></span><br><span class="line">            <span class="built_in">tab</span> = initTable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找该 hash 值对应的数组下标，得到第一个节点 f</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(<span class="built_in">tab</span>, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="built_in">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果数组该位置为空，</span></span><br><span class="line">            <span class="comment">//    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了</span></span><br><span class="line">            <span class="comment">//          如果 CAS 失败，那就是有并发操作，进到下一个循环就好了</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(<span class="built_in">tab</span>, i, <span class="built_in">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, <span class="built_in">key</span>, value, <span class="built_in">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了</span></span><br><span class="line">            <span class="built_in">tab</span> = helpTransfer(<span class="built_in">tab</span>, f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 到这里就是说，f 是该位置的头结点，而且不为空</span></span><br><span class="line"></span><br><span class="line">            V oldVal = <span class="built_in">null</span>;</span><br><span class="line">            <span class="comment">// 获取数组该位置的头结点的监视器锁</span></span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(<span class="built_in">tab</span>, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// 头结点的 hash 值大于 0，说明是链表</span></span><br><span class="line">                        <span class="comment">// 用于累加，记录链表的长度</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 如果发现了"相等"的 key，判断是否要进行值覆盖，然后也就可以 break 了</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.<span class="built_in">key</span>) == <span class="built_in">key</span> ||</span><br><span class="line">                                 (ek != <span class="built_in">null</span> &amp;&amp; <span class="built_in">key</span>.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 到了链表的最末端，将这个新值放到链表的最后面</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="built_in">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, <span class="built_in">key</span>,</span><br><span class="line">                                                          value, <span class="built_in">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f instanceof TreeBin) &#123; <span class="comment">// 红黑树</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 调用红黑树的插值方法插入新节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, <span class="built_in">key</span>,</span><br><span class="line">                                                       value)) != <span class="built_in">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// binCount != 0 说明上面在做链表操作</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，</span></span><br><span class="line">                    <span class="comment">// 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树</span></span><br><span class="line">                    <span class="comment">//    具体源码我们就不看了，扩容部分后面说</span></span><br><span class="line">                    treeifyBin(<span class="built_in">tab</span>, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="built_in">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    addCount(<span class="number">1</span>L, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put 的主流程看完了，但是至少留下了几个问题，第一个是初始化，第二个是扩容，第三个是帮助数据迁移，这些我们都会在后面进行一一介绍。</p><h4 id="初始化数组：initTable"><a href="#初始化数组：initTable" class="headerlink" title="初始化数组：initTable"></a>初始化数组：initTable</h4><p>这个比较简单，主要就是初始化一个合适大小的数组，然后会设置 sizeCtl。</p><p>初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] <span class="keyword">tab</span>; int <span class="keyword">sc</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="keyword">tab</span> = <span class="keyword">table</span>) == null || <span class="keyword">tab</span>.length == 0) &#123;</span><br><span class="line">        <span class="comment">// 初始化的"功劳"被其他线程"抢去"了</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">sc</span> = sizeCtl) &lt; 0)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">U</span>.compareAndSwapInt(this, SIZECTL, <span class="keyword">sc</span>, -1)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">tab</span> = <span class="keyword">table</span>) == null || <span class="keyword">tab</span>.length == 0) &#123;</span><br><span class="line">                    <span class="comment">// DEFAULT_CAPACITY 默认初始容量是 16</span></span><br><span class="line">                    int <span class="keyword">n</span> = (<span class="keyword">sc</span> &gt; 0) ? <span class="keyword">sc</span> : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="comment">// 初始化数组，长度为 16 或初始化时提供的长度</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[<span class="keyword">n</span>];</span><br><span class="line">                    <span class="comment">// 将这个数组赋值给 table，table 是 volatile 的</span></span><br><span class="line">                    <span class="keyword">table</span> = <span class="keyword">tab</span> = nt;</span><br><span class="line">                    <span class="comment">// 如果 n 为 16 的话，那么这里 sc = 12</span></span><br><span class="line">                    <span class="comment">// 其实就是 0.75 * n</span></span><br><span class="line">                    <span class="keyword">sc</span> = <span class="keyword">n</span> - (<span class="keyword">n</span> &gt;&gt;&gt; 2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                <span class="comment">// 设置 sizeCtl 为 sc，我们就当是 12 吧</span></span><br><span class="line">                sizeCtl = <span class="keyword">sc</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">tab</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表转红黑树-treeifyBin"><a href="#链表转红黑树-treeifyBin" class="headerlink" title="链表转红黑树: treeifyBin"></a>链表转红黑树: treeifyBin</h4><p>前面我们在 put 源码分析也说过，treeifyBin 不一定就会进行红黑树转换，也可能是仅仅做数组扩容。我们还是进行源码分析吧。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> treeifyBin(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// MIN_TREEIFY_CAPACITY 为 64</span></span><br><span class="line">        <span class="comment">// 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            <span class="comment">// 后面我们再详细分析这个方法</span></span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// b 是头结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, <span class="keyword">index</span>)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            synchronized (b) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, <span class="keyword">index</span>) == b) &#123;</span><br><span class="line">                    <span class="comment">// 下面就是遍历链表，建立一颗红黑树</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将红黑树设置到数组相应位置中</span></span><br><span class="line">                    setTabAt(tab, <span class="keyword">index</span>, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩容：tryPresize"><a href="#扩容：tryPresize" class="headerlink" title="扩容：tryPresize"></a>扩容：tryPresize</h3><p>如果说 Java8 ConcurrentHashMap 的源码不简单，那么说的就是扩容操作和迁移操作。</p><p>这个方法要完完全全看懂还需要看之后的 transfer 方法，读者应该提前知道这点。</p><p>这里的扩容也是做翻倍扩容的，扩容后数组容量为原来的 2 倍。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了</span></span><br><span class="line">private final void tryPresize(int size) &#123;</span><br><span class="line">    <span class="comment">// c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。</span></span><br><span class="line">    int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY :</span><br><span class="line">        tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1);</span><br><span class="line">    int <span class="keyword">sc</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="keyword">sc</span> = sizeCtl) &gt;= 0) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] <span class="keyword">tab</span> = <span class="keyword">table</span>; int <span class="keyword">n</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">tab</span> == null || (<span class="keyword">n</span> = <span class="keyword">tab</span>.length) == 0) &#123;</span><br><span class="line">            <span class="keyword">n</span> = (<span class="keyword">sc</span> &gt; c) ? <span class="keyword">sc</span> : c;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">U</span>.compareAndSwapInt(this, SIZECTL, <span class="keyword">sc</span>, -1)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">table</span> == <span class="keyword">tab</span>) &#123;</span><br><span class="line">                        @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[<span class="keyword">n</span>];</span><br><span class="line">                        <span class="keyword">table</span> = nt;</span><br><span class="line">                        <span class="keyword">sc</span> = <span class="keyword">n</span> - (<span class="keyword">n</span> &gt;&gt;&gt; 2); <span class="comment">// 0.75 * n</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    sizeCtl = <span class="keyword">sc</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= <span class="keyword">sc</span> || <span class="keyword">n</span> &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">tab</span> == <span class="keyword">table</span>) &#123;</span><br><span class="line">            <span class="comment">// 我没看懂 rs 的真正含义是什么，不过也关系不大</span></span><br><span class="line">            int rs = resizeStamp(<span class="keyword">n</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">sc</span> &lt; 0) &#123;</span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">sc</span> &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || <span class="keyword">sc</span> == rs + 1 ||</span><br><span class="line">                    <span class="keyword">sc</span> == rs + MAX_RESIZERS || (nt = nextTable) == null ||</span><br><span class="line">                    transferIndex &lt;= 0)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 2\. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法</span></span><br><span class="line">                <span class="comment">//    此时 nextTab 不为 null</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">U</span>.compareAndSwapInt(this, SIZECTL, <span class="keyword">sc</span>, <span class="keyword">sc</span> + 1))</span><br><span class="line">                    transfer(<span class="keyword">tab</span>, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1\. 将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span></span><br><span class="line">            <span class="comment">//     我是没看懂这个值真正的意义是什么？不过可以计算出来的是，结果是一个比较大的负数</span></span><br><span class="line">            <span class="comment">//  调用 transfer 方法，此时 nextTab 参数为 null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">U</span>.compareAndSwapInt(this, SIZECTL, <span class="keyword">sc</span>,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">                transfer(<span class="keyword">tab</span>, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的核心在于 sizeCtl 值的操作，首先将其设置为一个负数，然后执行 transfer(tab, null)，再下一个循环将 sizeCtl 加 1，并执行 transfer(tab, nt)，之后可能是继续 sizeCtl 加 1，并执行 transfer(tab, nt)。</p><p>所以，可能的操作就是执行 1 次 transfer(tab, null) + 多次 transfer(tab, nt)，这里怎么结束循环的需要看完 transfer 源码才清楚。</p><h4 id="数据迁移：transfer"><a href="#数据迁移：transfer" class="headerlink" title="数据迁移：transfer"></a>数据迁移：transfer</h4><p>下面这个方法很点长，将原来的 tab 数组的元素迁移到新的 nextTab 数组中。</p><p>虽然我们之前说的 tryPresize 方法中多次调用 transfer 不涉及多线程，但是这个 transfer 方法可以在其他地方被调用，典型地，我们之前在说 put 方法的时候就说过了，请往上看 put 方法，是不是有个地方调用了 helpTransfer 方法，helpTransfer 方法会调用 transfer 方法的。</p><p>此方法支持多线程执行，外围调用此方法的时候，会保证第一个发起数据迁移的线程，nextTab 参数为 null，之后再调用此方法的时候，nextTab 不会为 null。</p><p>阅读源码之前，先要理解并发操作的机制。原数组长度为 n，所以我们有 n 个迁移任务，让每个线程每次负责一个小任务是最简单的，每做完一个任务再检测是否有其他没做完的任务，帮助迁移就可以了，而 Doug Lea 使用了一个 stride，简单理解就是步长，每个线程每次负责迁移其中的一部分，如每次迁移 16 个小任务。所以，我们就需要一个全局的调度者来安排哪个线程执行哪几个任务，这个就是属性 transferIndex 的作用。</p><p>第一个发起数据迁移的线程会将 transferIndex 指向原数组最后的位置，然后从后往前的 stride 个任务属于第一个线程，然后将 transferIndex 指向新的位置，再往前的 stride 个任务属于第二个线程，依此类推。当然，这里说的第二个线程不是真的一定指代了第二个线程，也可以是同一个线程，这个读者应该能理解吧。其实就是将一个大的迁移任务分为了一个个任务包。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</span><br><span class="line">    <span class="built_in">int</span> n = tab.length, stride;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stride 在单核下直接等于 n，多核模式下为 (n&gt;&gt;&gt;3)/NCPU，最小值是 16</span></span><br><span class="line">    <span class="comment">// stride 可以理解为”步长“，有 n 个位置是需要进行迁移的，</span></span><br><span class="line">    <span class="comment">//   将这 n 个任务分为多个任务包，每个任务包有 stride 个任务</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 nextTab 为 null，先进行一次初始化</span></span><br><span class="line">    <span class="comment">//    前面我们说了，外围会保证第一个发起迁移的线程调用此方法时，参数 nextTab 为 null</span></span><br><span class="line">    <span class="comment">//       之后参与迁移的线程调用此方法时，nextTab 不会为 null</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 容量翻倍</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nextTable 是 ConcurrentHashMap 中的属性</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">// transferIndex 也是 ConcurrentHashMap 的属性，用于控制迁移的位置</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> nextn = nextTab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ForwardingNode 翻译过来就是正在被迁移的 Node</span></span><br><span class="line">    <span class="comment">// 这个构造方法会生成一个Node，key、value 和 next 都为 null，关键是 hash 为 MOVED</span></span><br><span class="line">    <span class="comment">// 后面我们会看到，原数组中位置 i 处的节点完成迁移工作后，</span></span><br><span class="line">    <span class="comment">//    就会将位置 i 处设置为这个 ForwardingNode，用来告诉其他线程该位置已经处理过了</span></span><br><span class="line">    <span class="comment">//    所以它其实相当于是一个标志。</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// advance 指的是做完了一个位置的迁移工作，可以准备做下一个位置的了</span></span><br><span class="line">    <span class="built_in">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="built_in">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 下面这个 for 循环，最难理解的在前面，而要看懂它们，应该先看懂后面的，然后再倒回来看</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// i 是位置索引，bound 是边界，注意是从后往前</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="built_in">int</span> fh;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这个 while 真的是不好理解</span></span><br><span class="line">        <span class="comment">// advance 为 true 表示可以进行下一个位置的迁移了</span></span><br><span class="line">        <span class="comment">//   简单理解结局：i 指向了 transferIndex，bound 指向了 transferIndex-stride</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="built_in">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 transferIndex 值赋给 nextIndex</span></span><br><span class="line">            <span class="comment">// 这里 transferIndex 一旦小于等于 0，说明原数组的所有位置都有相应的线程去处理了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = <span class="number">-1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="comment">// 看括号中的代码，nextBound 是这次迁移任务的边界，注意，是从后往前</span></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="built_in">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                <span class="comment">// 所有的迁移操作已经完成</span></span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 将新的 nextTab 赋值给 table 属性，完成迁移</span></span><br><span class="line">                table = nextTab;</span><br><span class="line">                <span class="comment">// 重新计算 sizeCtl：n 是原数组长度，所以 sizeCtl 得出的值将是新数组长度的 0.75 倍</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 之前我们说过，sizeCtl 在迁移前会设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</span></span><br><span class="line">            <span class="comment">// 然后，每有一个线程参与迁移就会将 sizeCtl 加 1，</span></span><br><span class="line">            <span class="comment">// 这里使用 CAS 操作对 sizeCtl 进行减 1，代表做完了属于自己的任务</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 任务结束，方法退出</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 到这里，说明 (sc - 2) == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT，</span></span><br><span class="line">                <span class="comment">// 也就是说，所有的迁移任务都做完了，也就会进入到上面的 if(finishing)&#123;&#125; 分支了</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果位置 i 处是空的，没有任何节点，那么放入刚刚初始化的 ForwardingNode ”空节点“</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="comment">// 该位置处是一个 ForwardingNode，代表该位置已经迁移过了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对数组该位置处的结点加锁，开始处理数组该位置处的迁移工作</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="comment">// 头结点的 hash 大于 0，说明是链表的 Node 节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 下面这一块和 Java7 中的 ConcurrentHashMap 迁移是差不多的，</span></span><br><span class="line">                        <span class="comment">// 需要将链表一分为二，</span></span><br><span class="line">                        <span class="comment">//   找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的</span></span><br><span class="line">                        <span class="comment">//   lastRun 之前的节点需要进行克隆，然后分到两个链表中</span></span><br><span class="line">                        <span class="built_in">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="built_in">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="built_in">int</span> ph = p.hash; K pk = p.<span class="built_in">key</span>; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 其中的一个链表放在新数组的位置 i</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 另一个链表放在新数组的位置 i+n</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span></span><br><span class="line">                        <span class="comment">//    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">// advance 设置为 true，代表该位置已经迁移完毕</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">// 红黑树的迁移</span></span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="built_in">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="built_in">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.<span class="built_in">key</span>, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果一分为二后，节点数少于 8，那么将红黑树转换回链表</span></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 将 ln 放置在新数组的位置 i</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 将 hn 放置在新数组的位置 i+n</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span></span><br><span class="line">                        <span class="comment">//    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">// advance 设置为 true，代表该位置已经迁移完毕</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说到底，transfer 这个方法并没有实现所有的迁移任务，每次调用这个方法只实现了 transferIndex 往前 stride 个位置的迁移工作，其他的需要由外围来控制。</p><p>这个时候，再回去仔细看 tryPresize 方法可能就会更加清晰一些了。</p><h3 id="get-过程分析-3"><a href="#get-过程分析-3" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><p>get 方法从来都是最简单的，这里也不例外：</p><ol><li>计算 hash 值</li><li>根据 hash 值找到数组对应位置: (n - 1) &amp; h</li><li>根据该位置处结点性质进行相应查找<ul><li>如果该位置为 null，那么直接返回 null 就可以了</li><li>如果该位置处的节点刚好就是我们需要的，返回该节点的值即可</li><li>如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，后面我们再介绍 find 方法</li><li>如果以上 3 条都不满足，那就是链表，进行遍历比对即可</li></ul></li></ol><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="built_in">int</span> n, eh; K ek;</span><br><span class="line">    <span class="built_in">int</span> h = spread(<span class="built_in">key</span>.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断头结点是否就是我们需要的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (ek != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, <span class="built_in">key</span>)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (ek != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单说一句，此方法的大部分内容都很简单，只有正好碰到扩容的情况，ForwardingNode.find(int h, Object k) 稍微复杂一些，不过在了解了数据迁移的过程后，这个也就不难了，所以限于篇幅这里也不展开说了。</p><h2 id="size操作-1"><a href="#size操作-1" class="headerlink" title="size操作"></a>size操作</h2><p>put方法和remove方法都会通过addCount方法维护Map的size。size方法通过sumCount获取由addCount方法维护的Map的size。</p><h2 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h2><p>对于put操作，如果Key对应的数组元素为null，则通过<a href="http://www.jasongj.com/java/thread_safe/#CAS%EF%BC%88compare-and-swap%EF%BC%89" target="_blank" rel="noopener">CAS操作</a>将其设置为当前值。如果Key对应的数组元素（也即链表表头或者树的根元素）不为null，则对该元素使用synchronized关键字申请锁，然后进行操作。如果该put操作使得当前链表长度超过一定阈值，则将该链表转换为树，从而提高寻址效率。</p><p>对于读操作，由于数组被volatile关键字修饰，因此不用担心数组的可见性问题。同时每个元素是一个Node实例（Java 7中每个元素是一个HashEntry），它的Key值和hash值都由final修饰，不可变更，无须关心它们被修改后的可见性问题。而其Value及对下一个元素的引用由volatile修饰，可见性也有保障。</p><pre><code>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {final int hash;final K key;volatile V val;volatile Node&lt;K,V&gt; next;}</code></pre><p>对于Key对应的数组元素的可见性，由Unsafe的getObjectVolatile方法保证。</p><pre><code>static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) {return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实也不是很难嘛，虽然没有像之前的 AQS 和线程池一样一行一行源码进行分析，但还是把所有初学者可能会糊涂的地方都进行了深入的介绍，只要是稍微有点基础的读者，应该是很容易就能看懂 HashMap 和 ConcurrentHashMap 源码了。</p><p>看源码不算是目的吧，深入地了解 Doug Lea 的设计思路，我觉得还挺有趣的，大师就是大师，代码写得真的是好啊。</p><p>我发现很多人都以为我写博客主要是源码分析，说真的，我对于源码分析没有那么大热情，主要都是为了用源码说事罢了，可能之后的文章还是会有比较多的源码分析成分，大家该怎么看就怎么看吧。</p><p>不要脸地自以为本文的质量还是挺高的，信息量比较大，如果你觉得有写得不好的地方，或者说看完本文你还是没看懂它们，那么请提出来~~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java并发指南&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/21961.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21961.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java并发" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="JUC" scheme="http://h2pl.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java并发指南12：深度解读 java 线程池设计思想及源码实现</title>
    <link href="http://h2pl.github.io/2018/05/23/concurrent12/"/>
    <id>http://h2pl.github.io/2018/05/23/concurrent12/</id>
    <published>2018-05-23T14:46:48.000Z</published>
    <updated>2018-06-11T13:43:21.320Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java并发指南<br><a href="https://blog.csdn.net/column/details/21961.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21961.html</a></p><p>相关代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><p>深度解读 java 线程池设计思想及源码实现</p><p>转自</p><p><a href="https://javadoop.com/2017/09/05/java-thread-pool/hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">https://javadoop.com/2017/09/05/java-thread-pool/hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io</a></p><p>我相信大家都看过很多的关于线程池的文章，基本上也是面试必问的，好像我写这篇文章其实是没有什么意义的，不过，我相信你也和我一样，看了很多文章还是一知半解，甚至可能看了很多瞎说的文章。希望大家看过这篇文章以后，就可以完全掌握 Java 线程池了。</p><blockquote><p>我发现好些人都是因为这篇文章来到本站的，希望这篇让人留下第一眼印象的文章能给你带来收获。</p></blockquote><p>本文一大重点是源码解析，不过线程池设计思想以及作者实现过程中的一些巧妙用法是我想传达给读者的。本文还是会一行行关键代码进行分析，目的是为了让那些自己看源码不是很理解的同学可以得到参考。</p><p>线程池是非常重要的工具，如果你要成为一个好的工程师，还是得比较好地掌握这个知识。即使你为了谋生，也要知道，这基本上是面试必问的题目，而且面试官很容易从被面试者的回答中捕捉到被面试者的技术水平。</p><p>本文略长，建议在 pc 上阅读，边看文章边翻源码（Java7 和 Java8 都一样），建议想好好看的读者抽出至少 15 至 30 分钟的整块时间来阅读。当然，如果读者仅为面试准备，可以直接滑到最后的总结部分。</p><p>目录</p><ul><li><a href="https://javadoop.com/2017/09/05/java-thread-pool/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E6%80%BB%E8%A7%88" target="_blank" rel="noopener">总览</a></li><li><a href="https://javadoop.com/2017/09/05/java-thread-pool/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#Executor%20%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">Executor 接口</a></li><li><a href="https://javadoop.com/2017/09/05/java-thread-pool/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#ExecutorService" target="_blank" rel="noopener">ExecutorService</a></li><li><a href="https://javadoop.com/2017/09/05/java-thread-pool/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#FutureTask" target="_blank" rel="noopener">FutureTask</a></li><li><a href="https://javadoop.com/2017/09/05/java-thread-pool/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#AbstractExecutorService" target="_blank" rel="noopener">AbstractExecutorService</a></li><li><a href="https://javadoop.com/2017/09/05/java-thread-pool/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#ThreadPoolExecutor" target="_blank" rel="noopener">ThreadPoolExecutor</a></li><li><a href="https://javadoop.com/2017/09/05/java-thread-pool/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#Executors" target="_blank" rel="noopener">Executors</a></li><li><a href="https://javadoop.com/2017/09/05/java-thread-pool/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">总结</a></li></ul><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>开篇来一些废话。下图是 java 线程池几个相关类的继承结构：</p><p><img src="https://javadoop.com/blogimages/java-thread-pool/1.jpg" alt="1"></p><p>先简单说说这个继承结构，Executor 位于最顶层，也是最简单的，就一个 execute(Runnable runnable) 接口方法定义。</p><p>ExecutorService 也是接口，在 Executor 接口的基础上添加了很多的接口方法，所以一般来说我们会使用这个接口。</p><p>然后再下来一层是 AbstractExecutorService，从名字我们就知道，这是抽象类，这里实现了非常有用的一些方法供子类直接使用，之后我们再细说。</p><p>然后才到我们的重点部分 ThreadPoolExecutor 类，这个类提供了关于线程池所需的非常丰富的功能。</p><p>另外，我们还涉及到下图中的这些类：</p><p><img src="https://javadoop.com/blogimages/java-thread-pool/others.png" alt="others"></p><p>同在并发包中的 Executors 类，类名中带字母 s，我们猜到这个是工具类，里面的方法都是静态方法，如以下我们最常用的用于生成 ThreadPoolExecutor 的实例的一些方法：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">CachedThreadPool</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60</span>L, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="type">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，由于线程池支持获取线程执行的结果，所以，引入了 Future 接口，RunnableFuture 继承自此接口，然后我们最需要关心的就是它的实现类 FutureTask。到这里，记住这个概念，在线程池的使用过程中，我们是往线程池提交任务（task），使用过线程池的都知道，我们提交的每个任务是实现了 Runnable 接口的，其实就是先将 Runnable 的任务包装成 FutureTask，然后再提交到线程池。这样，读者才能比较容易记住 FutureTask 这个类名：它首先是一个任务（Task），然后具有 Future 接口的语义，即可以在将来（Future）得到执行的结果。</p><p>当然，线程池中的 BlockingQueue 也是非常重要的概念，如果线程数达到 corePoolSize，我们的每个任务会提交到等待队列中，等待线程池中的线程来取任务并执行。这里的 BlockingQueue 通常我们使用其实现类 LinkedBlockingQueue、ArrayBlockingQueue 和 SynchronousQueue，每个实现类都有不同的特征，使用场景之后会慢慢分析。想要详细了解各个 BlockingQueue 的读者，可以参考我的前面的一篇对 BlockingQueue 的各个实现类进行详细分析的文章。</p><blockquote><p>把事情说完整：除了上面说的这些类外，还有一个很重要的类，就是定时任务实现类 ScheduledThreadPoolExecutor，它继承自本文要重点讲解的 ThreadPoolExecutor，用于实现定时执行。不过本文不会介绍它的实现，我相信读者看完本文后可以比较容易地看懂它的源码。</p></blockquote><p>以上就是本文要介绍的知识，废话不多说，开始进入正文。</p><h2 id="Executor-接口"><a href="#Executor-接口" class="headerlink" title="Executor 接口"></a>Executor 接口</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * @since 1.5</span></span><br><span class="line"><span class="comment"> * @author Doug Lea</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Executor</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span>(<span class="params">Runnable command</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到 Executor 接口非常简单，就一个 <code>void execute(Runnable command)</code> 方法，代表提交一个任务。为了让大家理解 java 线程池的整个设计方案，我会按照 Doug Lea 的设计思路来多说一些相关的东西。</p><p>我们经常这样启动一个线程：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">Thread</span>(<span class="keyword">new</span> <span class="type">Runnable</span>()&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>用了线程池 Executor 后就可以像下面这么使用：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Executor executor = anExecutor;</span><br><span class="line">executor.execute(<span class="keyword">new</span> <span class="type">RunnableTask1</span>());</span><br><span class="line">executor.execute(<span class="keyword">new</span> <span class="type">RunnableTask2</span>());</span><br></pre></td></tr></table></figure><p>如果我们希望线程池同步执行每一个任务，我们可以这么实现这个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        r.run();<span class="comment">// 这里不是用的new Thread(r).start()，也就是说没有启动任何一个新的线程。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望每个任务提交进来后，直接启动一个新的线程来执行这个任务，我们可以这么实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();  <span class="comment">// 每个任务都用一个新的线程来执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看下怎么组合两个 Executor 来使用，下面这个实现是将所有的任务都加到一个 queue 中，然后从 queue 中取任务，交给真正的执行器执行，这里采用 synchronized 进行并发控制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="keyword">final</span> Queue&lt;Runnable&gt; tasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">    <span class="comment">// 这个才是真正的执行器</span></span><br><span class="line">    <span class="keyword">final</span> Executor executor;</span><br><span class="line">    <span class="comment">// 当前正在执行的任务</span></span><br><span class="line">    Runnable active;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化的时候，指定执行器</span></span><br><span class="line">    SerialExecutor(Executor executor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加任务到线程池: 将任务添加到任务队列，scheduleNext 触发执行器去任务队列取任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">        tasks.offer(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    scheduleNext();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (active == <span class="keyword">null</span>) &#123;</span><br><span class="line">            scheduleNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((active = tasks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 具体的执行转给真正的执行器 executor</span></span><br><span class="line">            executor.execute(active);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然了，Executor 这个接口只有提交任务的功能，太简单了，我们想要更丰富的功能，比如我们想知道执行结果、我们想知道当前线程池有多少个线程活着、已经完成了多少任务等等，这些都是这个接口的不足的地方。接下来我们要介绍的是继承自 <code>Executor</code> 接口的 <code>ExecutorService</code> 接口，这个接口提供了比较丰富的功能，也是我们最常使用到的接口。</p><h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><p>一般我们定义一个线程池的时候，往往都是使用这个接口：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ExecutorService executor</span> = Executors.newFixedThreadPool(args...);</span><br><span class="line"><span class="attribute">ExecutorService executor</span> = Executors.newCachedThreadPool(args...);</span><br></pre></td></tr></table></figure><p>因为这个接口中定义的一系列方法大部分情况下已经可以满足我们的需要了。</p><p>那么我们简单初略地来看一下这个接口中都有哪些方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池，已提交的任务继续执行，不接受继续提交新任务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池，尝试停止正在执行的所有任务，不接受继续提交新任务</span></span><br><span class="line">    <span class="comment">// 它和前面的方法相比，加了一个单词“now”，区别在于它会去停止当前正在进行的任务</span></span><br><span class="line">    List&lt;Runnable&gt; shutdownNow();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池是否已关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果调用了 shutdown() 或 shutdownNow() 方法后，所有任务结束了，那么返回true</span></span><br><span class="line">    <span class="comment">// 这个方法必须在调用shutdown或shutdownNow方法之后调用才会返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有任务完成，并设置超时时间</span></span><br><span class="line">    <span class="comment">// 我们这么理解，实际应用中是，先调用 shutdown 或 shutdownNow，</span></span><br><span class="line">    <span class="comment">// 然后再调这个方法等待所有的线程真正地完成，返回值意味着有没有超时</span></span><br><span class="line">    <span class="keyword">boolean</span> awaitTermination(<span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">            <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一个 Callable 任务</span></span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一个 Runnable 任务，第二个参数将会放到 Future 中，作为返回值，</span></span><br><span class="line">    <span class="comment">// 因为 Runnable 的 run 方法本身并不返回任何东西</span></span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一个 Runnable 任务</span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行所有任务，返回 Future 类型的一个 list</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? <span class="keyword">extends</span> Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">            <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也是执行所有任务，但是这里设置了超时时间</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? <span class="keyword">extends</span> Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">            <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有其中的一个任务结束了，就可以返回，返回执行完的那个任务的结果</span></span><br><span class="line">    &lt;T&gt; T invokeAny(Collection&lt;? <span class="keyword">extends</span> Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">            <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同上一个方法，只有其中的一个任务结束了，就可以返回，返回执行完的那个任务的结果，</span></span><br><span class="line">    <span class="comment">// 不过这个带超时，超过指定的时间，抛出 TimeoutException 异常</span></span><br><span class="line">    &lt;T&gt; T invokeAny(Collection&lt;? <span class="keyword">extends</span> Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">            <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些方法都很好理解，一个简单的线程池主要就是这些功能，能提交任务，能获取结果，能关闭线程池，这也是为什么我们经常用这个接口的原因。</p><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>在继续往下层介绍 ExecutorService 的实现类之前，我们先来说说相关的类 FutureTask。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">F<span class="function"><span class="title">uture</span>   -&gt;</span> R<span class="function"><span class="title">unnableFuture</span> -&gt;</span> FutureTask</span><br><span class="line">R<span class="function"><span class="title">unnable</span> -&gt;</span> RunnableFuture</span><br><span class="line"></span><br><span class="line">FutureTask 通过 RunnableFuture 间接实现了 Runnable 接口，</span><br><span class="line">所以每个 Runnable 通常都先包装成 FutureTask，</span><br><span class="line">然后调用 executor.execute(Runnable command) 将其提交给线程池</span><br></pre></td></tr></table></figure><p>我们知道，Runnable 的 void run() 方法是没有返回值的，所以，通常，如果我们需要的话，会在 submit 中指定第二个参数作为返回值：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">T</span>&gt; Future&lt;<span class="built_in">T</span>&gt; submit(Runnable task, <span class="built_in">T</span> result);</span><br></pre></td></tr></table></figure><p>其实到时候会通过这两个参数，将其包装成 Callable。</p><p>Callable 也是因为线程池的需要，所以才有了这个接口。它和 Runnable 的区别在于 run() 没有返回值，而 Callable 的 call() 方法有返回值，同时，如果运行出现异常，call() 方法会抛出异常。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Callable&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，就不展开说 FutureTask 类了，因为本文篇幅本来就够大了，这里我们需要知道怎么用就行了。</p><p>下面，我们来看看 <code>ExecutorService</code> 的抽象实现 <code>AbstractExecutorService</code> 。</p><h2 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h2><p>AbstractExecutorService 抽象类派生自 ExecutorService 接口，然后在其基础上实现了几个实用的方法，这些方法提供给子类进行调用。</p><p>这个抽象类实现了 invokeAny 方法和 invokeAll 方法，这里的两个 newTaskFor 方法也比较有用，用于将任务包装成 FutureTask。定义于最上层接口 Executor中的 <code>void execute(Runnable command)</code> 由于不需要获取结果，不会进行 FutureTask 的包装。</p><blockquote><p>需要获取结果（FutureTask），用 submit 方法，不需要获取结果，可以用 execute 方法。</p></blockquote><p>下面，我将一行一行源码地来分析这个类，跟着源码来看看其实现吧：</p><blockquote><p>Tips: invokeAny 和 invokeAll 方法占了这整个类的绝大多数篇幅，读者可以选择适当跳过，因为它们可能在你的实践中使用的频次比较低，而且它们不带有承前启后的作用，不用担心会漏掉什么导致看不懂后面的代码。</p></blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> AbstractExecutorService <span class="keyword">implements</span> ExecutorService &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RunnableFuture 是用于获取执行结果的，我们常用它的子类 FutureTask</span></span><br><span class="line">    <span class="comment">// 下面两个 newTaskFor 方法用于将我们的任务包装成 FutureTask 提交到线程池中执行</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable <span class="keyword">task</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">task</span> == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 1\. 将任务包装成 FutureTask</span></span><br><span class="line">        RunnableFuture&lt;<span class="keyword">Void</span>&gt; ftask = newTaskFor(<span class="keyword">task</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 2\. 交给执行器执行，execute 方法由具体的子类来实现</span></span><br><span class="line">        <span class="comment">// 前面也说了，FutureTask 间接实现了Runnable 接口。</span></span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; submit(Runnable <span class="keyword">task</span>, T result) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">task</span> == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 1\. 将任务包装成 FutureTask</span></span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(<span class="keyword">task</span>, result);</span><br><span class="line">        <span class="comment">// 2\. 交给执行器执行</span></span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; <span class="keyword">task</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">task</span> == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 1\. 将任务包装成 FutureTask</span></span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(<span class="keyword">task</span>);</span><br><span class="line">        <span class="comment">// 2\. 交给执行器执行</span></span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此方法目的：将 tasks 集合中的任务提交到线程池执行，任意一个线程执行完后就可以结束了</span></span><br><span class="line">    <span class="comment">// 第二个参数 timed 代表是否设置超时机制，超时时间为第三个参数，</span></span><br><span class="line">    <span class="comment">// 如果 timed 为 true，同时超时了还没有一个线程返回结果，那么抛出 TimeoutException 异常</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; T doInvokeAny(Collection&lt;? <span class="keyword">extends</span> Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                            <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">        <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 任务数</span></span><br><span class="line">        <span class="keyword">int</span> ntasks = tasks.<span class="keyword">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (ntasks == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        List&lt;Future&lt;T&gt;&gt; futures= <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(ntasks);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ExecutorCompletionService 不是一个真正的执行器，参数 this 才是真正的执行器</span></span><br><span class="line">        <span class="comment">// 它对执行器进行了包装，每个任务结束后，将结果保存到内部的一个 completionQueue 队列中</span></span><br><span class="line">        <span class="comment">// 这也是为什么这个类的名字里面有个 Completion 的原因吧。</span></span><br><span class="line">        ExecutorCompletionService&lt;T&gt; ecs =</span><br><span class="line">            <span class="keyword">new</span> ExecutorCompletionService&lt;T&gt;(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 用于保存异常信息，此方法如果没有得到任何有效的结果，那么我们可以抛出最后得到的一个异常</span></span><br><span class="line">            ExecutionException ee = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">long</span> lastTime = timed ? System.nanoTime() : <span class="number">0</span>;</span><br><span class="line">            Iterator&lt;? <span class="keyword">extends</span> Callable&lt;T&gt;&gt; it = tasks.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 首先先提交一个任务，后面的任务到下面的 for 循环一个个提交</span></span><br><span class="line">            futures.add(ecs.submit(it.<span class="keyword">next</span>()));</span><br><span class="line">            <span class="comment">// 提交了一个任务，所以任务数量减 1</span></span><br><span class="line">            --ntasks;</span><br><span class="line">            <span class="comment">// 正在执行的任务数(提交的时候 +1，任务结束的时候 -1)</span></span><br><span class="line">            <span class="keyword">int</span> active = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// ecs 上面说了，其内部有一个 completionQueue 用于保存执行完成的结果</span></span><br><span class="line">                <span class="comment">// BlockingQueue 的 poll 方法不阻塞，返回 null 代表队列为空</span></span><br><span class="line">                Future&lt;T&gt; f = ecs.poll();</span><br><span class="line">                <span class="comment">// 为 null，说明刚刚提交的第一个线程还没有执行完成</span></span><br><span class="line">                <span class="comment">// 在前面先提交一个任务，加上这里做一次检查，也是为了提高性能</span></span><br><span class="line">                <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ntasks &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        --ntasks;</span><br><span class="line">                        futures.add(ecs.submit(it.<span class="keyword">next</span>()));</span><br><span class="line">                        ++active;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 这里是 else if，不是 if。这里说明，没有任务了，同时 active 为 0 说明</span></span><br><span class="line">                    <span class="comment">// 任务都执行完成了。其实我也没理解为什么这里做一次 break？</span></span><br><span class="line">                    <span class="comment">// 因为我认为 active 为 0 的情况，必然从下面的 f.get() 返回了</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 2018-02-23 感谢读者 newmicro 的 comment，</span></span><br><span class="line">                    <span class="comment">//  这里的 active == 0，说明所有的任务都执行失败，那么这里是 for 循环出口</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (active == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 这里也是 else if。这里说的是，没有任务了，但是设置了超时时间，这里检测是否超时</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                        <span class="comment">// 带等待的 poll 方法</span></span><br><span class="line">                        f = ecs.poll(nanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                        <span class="comment">// 如果已经超时，抛出 TimeoutException 异常，这整个方法就结束了</span></span><br><span class="line">                        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                        <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">                        nanos -= now - lastTime;</span><br><span class="line">                        lastTime = now;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 这里是 else。说明，没有任务需要提交，但是池中的任务没有完成，还没有超时(如果设置了超时)</span></span><br><span class="line">                    <span class="comment">// take() 方法会阻塞，直到有元素返回，说明有任务结束了</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        f = ecs.take();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 我感觉上面这一段并不是很好理解，这里简单说下。</span></span><br><span class="line"><span class="comment">                 * 1\. 首先，这在一个 for 循环中，我们设想每一个任务都没那么快结束，</span></span><br><span class="line"><span class="comment">                 *     那么，每一次都会进到第一个分支，进行提交任务，直到将所有的任务都提交了</span></span><br><span class="line"><span class="comment">                 * 2\. 任务都提交完成后，如果设置了超时，那么 for 循环其实进入了“一直检测是否超时”</span></span><br><span class="line"><span class="comment">                       这件事情上</span></span><br><span class="line"><span class="comment">                 * 3\. 如果没有设置超时机制，那么不必要检测超时，那就会阻塞在 ecs.take() 方法上，</span></span><br><span class="line"><span class="comment">                       等待获取第一个执行结果</span></span><br><span class="line"><span class="comment">                 * 4\. 如果所有的任务都执行失败，也就是说 future 都返回了，</span></span><br><span class="line"><span class="comment">                       但是 f.get() 抛出异常，那么从 active == 0 分支出去(感谢 newmicro 提出)</span></span><br><span class="line"><span class="comment">                         // 当然，这个需要看下面的 if 分支。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 有任务结束了</span></span><br><span class="line">                <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    --active;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 返回执行结果，如果有异常，都包装成 ExecutionException</span></span><br><span class="line">                        <span class="keyword">return</span> f.get();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ExecutionException eex) &#123;</span><br><span class="line">                        ee = eex;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException rex) &#123;</span><br><span class="line">                        ee = <span class="keyword">new</span> ExecutionException(rex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">// 注意看 for 循环的范围，一直到这里</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ee == <span class="keyword">null</span>)</span><br><span class="line">                ee = <span class="keyword">new</span> ExecutionException();</span><br><span class="line">            <span class="keyword">throw</span> ee;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 方法退出之前，取消其他的任务</span></span><br><span class="line">            <span class="keyword">for</span> (Future&lt;T&gt; f : futures)</span><br><span class="line">                f.cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T invokeAny(Collection&lt;? <span class="keyword">extends</span> Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> doInvokeAny(tasks, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException cannotHappen) &#123;</span><br><span class="line">            assert <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T invokeAny(Collection&lt;? <span class="keyword">extends</span> Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                           <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">        <span class="keyword">return</span> doInvokeAny(tasks, <span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行所有的任务，返回任务结果。</span></span><br><span class="line">    <span class="comment">// 先不要看这个方法，我们先想想，其实我们自己提交任务到线程池，也是想要线程池执行所有的任务</span></span><br><span class="line">    <span class="comment">// 只不过，我们是每次 submit 一个任务，这里以一个集合作为参数提交</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? <span class="keyword">extends</span> Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        List&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.<span class="keyword">size</span>());</span><br><span class="line">        <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这个很简单</span></span><br><span class="line">            <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks) &#123;</span><br><span class="line">                <span class="comment">// 包装成 FutureTask</span></span><br><span class="line">                RunnableFuture&lt;T&gt; f = newTaskFor(t);</span><br><span class="line">                futures.add(f);</span><br><span class="line">                <span class="comment">// 提交任务</span></span><br><span class="line">                execute(f);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Future&lt;T&gt; f : futures) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 这是一个阻塞方法，直到获取到值，或抛出了异常</span></span><br><span class="line">                        <span class="comment">// 这里有个小细节，其实 get 方法签名上是会抛出 InterruptedException 的</span></span><br><span class="line">                        <span class="comment">// 可是这里没有进行处理，而是抛给外层去了。此异常发生于还没执行完的任务被取消了</span></span><br><span class="line">                        f.get();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (CancellationException ignore) &#123;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ExecutionException ignore) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            done = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 这个方法返回，不像其他的场景，返回 List&lt;Future&gt;，其实执行结果还没出来</span></span><br><span class="line">            <span class="comment">// 这个方法返回是真正的返回，任务都结束了</span></span><br><span class="line">            <span class="keyword">return</span> futures;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 为什么要这个？就是上面说的有异常的情况</span></span><br><span class="line">            <span class="keyword">if</span> (!done)</span><br><span class="line">                <span class="keyword">for</span> (Future&lt;T&gt; f : futures)</span><br><span class="line">                    f.cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带超时的 invokeAll，我们找不同吧</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? <span class="keyword">extends</span> Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                         <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (tasks == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">        List&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.<span class="keyword">size</span>());</span><br><span class="line">        <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks)</span><br><span class="line">                futures.add(newTaskFor(t));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> lastTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">            Iterator&lt;Future&lt;T&gt;&gt; it = futures.iterator();</span><br><span class="line">            <span class="comment">// 提交一个任务，检测一次是否超时</span></span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                execute((Runnable)(it.<span class="keyword">next</span>()));</span><br><span class="line">                <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">                nanos -= now - lastTime;</span><br><span class="line">                lastTime = now;</span><br><span class="line">                <span class="comment">// 超时</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> futures;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Future&lt;T&gt; f : futures) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> futures;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 调用带超时的 get 方法，这里的参数 nanos 是剩余的时间，</span></span><br><span class="line">                        <span class="comment">// 因为上面其实已经用掉了一些时间了</span></span><br><span class="line">                        f.get(nanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (CancellationException ignore) &#123;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ExecutionException ignore) &#123;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">                        <span class="keyword">return</span> futures;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">                    nanos -= now - lastTime;</span><br><span class="line">                    lastTime = now;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            done = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> futures;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!done)</span><br><span class="line">                <span class="keyword">for</span> (Future&lt;T&gt; f : futures)</span><br><span class="line">                    f.cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们发现，这个抽象类包装了一些基本的方法，可是像 submit、invokeAny、invokeAll 等方法，它们都没有真正开启线程来执行任务，它们都只是在方法内部调用了 execute 方法，所以最重要的 execute(Runnable runnable) 方法还没出现，需要等具体执行器来实现这个最重要的部分，这里我们要说的就是 ThreadPoolExecutor 类了。</p><blockquote><p>鉴于本文的篇幅，我觉得看到这里的读者应该已经不多了，快餐文化使然啊！我写的每篇文章都力求让读者可以通过我的一篇文章而记住所有的相关知识点，所以篇幅不免长了些。其实，工作了很多年的话，会有一个感觉，比如说线程池，即使看了 20 篇各种总结，也不如一篇长文实实在在讲解清楚每一个知识点，有点少即是多，多即是少的意味了。</p></blockquote><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>ThreadPoolExecutor 是 JDK 中的线程池实现，这个类实现了一个线程池需要的各个方法，它实现了任务提交、线程管理、监控等等方法。</p><p>我们可以基于它来进行业务上的扩展，以实现我们需要的其他功能，比如实现定时任务的类 ScheduledThreadPoolExecutor 就继承自 ThreadPoolExecutor。当然，这不是本文关注的重点，下面，还是赶紧进行源码分析吧。</p><p>首先，我们来看看线程池实现中的几个概念和处理流程。</p><p>我们先回顾下提交任务的几个方法：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable <span class="keyword">task</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">task</span> == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;<span class="keyword">Void</span>&gt; ftask = newTaskFor(<span class="keyword">task</span>, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; submit(Runnable <span class="keyword">task</span>, T result) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">task</span> == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(<span class="keyword">task</span>, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; <span class="keyword">task</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">task</span> == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(<span class="keyword">task</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个最基本的概念是，submit 方法中，参数是 Runnable 类型（也有Callable 类型），这个参数不是用于 new Thread(runnable).start() 中的，此处的这个参数不是用于启动线程的，这里指的是任务，任务要做的事情是 run() 方法里面定义的或 Callable 中的 call() 方法里面定义的。</p><p>初学者往往会搞混这个，因为 Runnable 总是在各个地方出现，经常把一个 Runnable 包到另一个 Runnable 中。请把它想象成有个 Task 接口，这个接口里面有一个 run() 方法（我想作者只是不想因为这个再定义一个完全可以用 Runnable 来代替的接口，Callable 的出现，完全是因为 Runnable 不能满足需要）。</p><p>我们回过神来继续往下看，我画了一个简单的示意图来描述线程池中的一些主要的构件：</p><p><img src="https://javadoop.com/blogimages/java-thread-pool/pool-1.png" alt="pool-1"></p><p>当然，上图没有考虑队列是否有界，提交任务时队列满了怎么办？什么情况下会创建新的线程？提交任务时线程池满了怎么办？空闲线程怎么关掉？这些问题下面我们会一一解决。</p><p>我们经常会使用 <code>Executors</code> 这个工具类来快速构造一个线程池，对于初学者而言，这种工具类是很有用的，开发者不需要关注太多的细节，只要知道自己需要一个线程池，仅仅提供必需的参数就可以了，其他参数都采用作者提供的默认值。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">CachedThreadPool</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60</span>L, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="type">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先不说有什么区别，它们最终都会导向这个构造方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                          <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                          <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler <span class="keyword">handler</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 这几个参数都是必须要有的</span></span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || <span class="keyword">handler</span> == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.<span class="keyword">handler</span> = <span class="keyword">handler</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上，上面的构造方法中列出了我们最需要关心的几个属性了，下面逐个介绍下构造方法中出现的这几个属性：</p><ul><li><p>corePoolSize</p><blockquote><p>核心线程数，不要抠字眼，反正先记着有这么个属性就可以了。</p></blockquote></li><li><p>maximumPoolSize</p><blockquote><p>​最大线程数，线程池允许创建的最大线程数。</p></blockquote></li><li><p>workQueue</p><blockquote><p>任务队列，BlockingQueue 接口的某个实现（常使用 ArrayBlockingQueue 和 LinkedBlockingQueue）。</p></blockquote></li><li><p>keepAliveTime</p><blockquote><p>空闲线程的保活时间，如果某线程的空闲时间超过这个值都没有任务给它做，那么可以被关闭了。注意这个值并不会对所有线程起作用，如果线程池中的线程数少于等于核心线程数 corePoolSize，那么这些线程不会因为空闲太长时间而被关闭，当然，也可以通过调用 <code>allowCoreThreadTimeOut(true)</code>使核心线程数内的线程也可以被回收。</p></blockquote></li><li><p>threadFactory</p><blockquote><p>用于生成线程，一般我们可以用默认的就可以了。通常，我们可以通过它将我们的线程的名字设置得比较可读一些，如 Message-Thread-1， Message-Thread-2 类似这样。</p></blockquote></li><li><p>handler：</p><blockquote><p>当线程池已经满了，但是又有新的任务提交的时候，该采取什么策略由这个来指定。有几种方式可供选择，像抛出异常、直接拒绝然后返回等，也可以自己实现相应的接口实现自己的逻辑，这个之后再说。</p></blockquote></li></ul><p>除了上面几个属性外，我们再看看其他重要的属性。</p><p>Doug Lea 采用一个 32 位的整数来存放线程池的状态和当前池中的线程数，其中高 3 位用于存放线程池状态，低 29 位表示线程数（即使只有 29 位，也已经不小了，大概 5 亿多，现在还没有哪个机器能起这么多线程的吧）。我们知道，java 语言在整数编码上是统一的，都是采用补码的形式，下面是简单的移位操作和布尔操作，都是挺简单的。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里 COUNT_BITS 设置为 29(32-3)，意味着前三位用于存放线程状态，后29位用于存放线程数</span></span><br><span class="line"><span class="comment">// 很多初学者很喜欢在自己的代码中写很多 29 这种数字，或者某个特殊的字符串，然后分布在各个地方，这是非常糟糕的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 000 11111111111111111111111111111</span></span><br><span class="line"><span class="comment">// 这里得到的是 29 个 1，也就是说线程池的最大线程数是 2^29-1=536870911</span></span><br><span class="line"><span class="comment">// 以我们现在计算机的实际情况，这个数量还是够用的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们说了，线程池的状态存放在高 3 位中</span></span><br><span class="line"><span class="comment">// 运算结果为 111跟29个0：111 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = <span class="number">-1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 000 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 001 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 010 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 011 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将整数 c 的低 29 位修改为 0，就得到了线程池的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 将整数 c 的高 3 为修改为 0，就得到了线程池中的线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Bit field accessors that don't require unpacking ctl.</span></span><br><span class="line"><span class="comment"> * These depend on the bit layout and on workerCount being never negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是对一个整数的简单的位操作，几个操作方法将会在后面的源码中一直出现，所以读者最好把方法名字和其代表的功能记住，看源码的时候也就不需要来来回回翻了。</p><p>在这里，介绍下线程池中的各个状态和状态变化的转换过程：</p><ul><li>RUNNING：这个没什么好说的，这是最正常的状态：接受新的任务，处理等待队列中的任务</li><li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务</li><li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程</li><li>TIDYING：所有的任务都销毁了，workCount 为 0。线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()</li><li>TERMINATED：terminated() 方法结束后，线程池的状态就会变成这个</li></ul><blockquote><p>RUNNING 定义为 -1，SHUTDOWN 定义为 0，其他的都比 0 大，所以等于 0 的时候不能提交任务，大于 0 的话，连正在执行的任务也需要中断。</p></blockquote><p>看了这几种状态的介绍，读者大体也可以猜到十之八九的状态转换了，各个状态的转换过程有以下几种：</p><ul><li>RUNNING -&gt; SHUTDOWN：当调用了 shutdown() 后，会发生这个状态转换，这也是最重要的</li><li>(RUNNING or SHUTDOWN) -&gt; STOP：当调用 shutdownNow() 后，会发生这个状态转换，这下要清楚 shutDown() 和 shutDownNow() 的区别了</li><li>SHUTDOWN -&gt; TIDYING：当任务队列和线程池都清空后，会由 SHUTDOWN 转换为 TIDYING</li><li>STOP -&gt; TIDYING：当任务队列清空后，发生这个转换</li><li>TIDYING -&gt; TERMINATED：这个前面说了，当 terminated() 方法结束后</li></ul><p>上面的几个记住核心的就可以了，尤其第一个和第二个。</p><p>另外，我们还要看看一个内部类 Worker，因为 Doug Lea 把线程池中的线程包装成了一个个 Worker，翻译成工人，就是线程池中做任务的线程。所以到这里，我们知道任务是 Runnable（内部叫 task 或 command），线程是 Worker。</p><p>Worker 这里又用到了抽象类 AbstractQueuedSynchronizer。题外话，AQS 在并发中真的是到处出现，而且非常容易使用，写少量的代码就能实现自己需要的同步方式（对 AQS 源码感兴趣的读者请参看我之前写的几篇文章）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个是真正的线程，任务靠你啦</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前面说了，这里的 Runnable 是任务。为什么叫 firstTask？因为在创建线程的时候，如果同时指定了</span></span><br><span class="line">    <span class="comment">// 这个线程起来以后需要执行的第一个任务，那么第一个任务就是存放在这里的(线程可不止执行这一个任务)</span></span><br><span class="line">    <span class="comment">// 当然了，也可以为 null，这样线程起来了，自己到任务队列（BlockingQueue）中取任务（getTask 方法）就行了</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于存放此线程完全的任务数，注意了，这里用了 volatile，保证可见性</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Worker 只有这一个构造方法，传入 firstTask，也可以传 null</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 调用 ThreadFactory 来创建一个新的线程</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里调用了外部类的 runWorker 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...<span class="comment">// 其他几个方法没什么好看的，就是用 AQS 操作，来获取这个线程的执行权，用了独占锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面虽然啰嗦，但是简单。有了上面的这些基础后，我们终于可以看看 ThreadPoolExecutor 的 execute 方法了，前面源码分析的时候也说了，各种方法都最终依赖于 execute 方法：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>(<span class="params">Runnable command</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前面说的那个表示 “线程池状态” 和 “线程数” 的整数</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.<span class="keyword">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前线程数少于核心线程数，那么直接添加一个 worker 来执行任务，</span></span><br><span class="line">    <span class="comment">// 创建一个新的线程，并把当前任务 command 作为这个线程的第一个任务(firstTask)</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 添加任务成功，那么就结束了。提交任务嘛，线程池已经接受了这个任务，这个方法也就可以返回了</span></span><br><span class="line">        <span class="comment">// 至于执行的结果，到时候会包装到 FutureTask 中。</span></span><br><span class="line">        <span class="comment">// 返回 false 代表线程池不允许提交任务</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.<span class="keyword">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这里说明，要么当前线程数大于等于核心线程数，要么刚刚 addWorker 失败了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">/* 这里面说的是，如果任务进入了 workQueue，我们是否需要开启新的线程</span></span><br><span class="line"><span class="comment">         * 因为线程数在 [0, corePoolSize) 是无条件开启新的线程</span></span><br><span class="line"><span class="comment">         * 如果线程数已经大于等于 corePoolSize，那么将任务添加到队列中，然后进到这里</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.<span class="keyword">get</span>();</span><br><span class="line">        <span class="comment">// 如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; <span class="keyword">remove</span>(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 如果线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程</span></span><br><span class="line">        <span class="comment">// 到这里，我们知道了，这块代码的真正意图是：担心任务提交到队列中了，但是线程都关闭了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 workQueue 队列满了，那么进入到这个分支</span></span><br><span class="line">    <span class="comment">// 以 maximumPoolSize 为界创建新的 worker，</span></span><br><span class="line">    <span class="comment">// 如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对创建线程的错误理解：如果线程数少于 corePoolSize，创建一个线程，如果线程数在 [corePoolSize, maximumPoolSize] 之间那么可以创建线程或复用空闲线程，keepAliveTime 对这个区间的线程有效。</p><p>从上面的几个分支，我们就可以看出，上面的这段话是错误的。</p></blockquote><p>上面这些一时半会也不可能全部消化搞定，我们先继续往下吧，到时候再回头看几遍。</p><p>这个方法非常重要 addWorker(Runnable firstTask, boolean core) 方法，我们看看它是怎么创建新的线程的：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是准备提交给这个线程执行的任务，之前说了，可以为 null</span></span><br><span class="line"><span class="comment">// 第二个参数为 true 代表使用核心线程数 corePoolSize 作为创建线程的界线，也就说创建这个线程的时候，</span></span><br><span class="line"><span class="comment">//         如果线程池中的线程总数已经达到 corePoolSize，那么不能响应这次创建线程的请求</span></span><br><span class="line"><span class="comment">//         如果是 false，代表使用最大线程数 maximumPoolSize 作为界线</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">boolean</span> addWorker(Runnable firstTask, <span class="built_in">boolean</span> core) &#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="built_in">int</span> c = ctl.<span class="built_in">get</span>();</span><br><span class="line">        <span class="built_in">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个非常不好理解</span></span><br><span class="line">        <span class="comment">// 如果线程池已关闭，并满足以下条件之一，那么不创建新的 worker：</span></span><br><span class="line">        <span class="comment">// 1\. 线程池状态大于 SHUTDOWN，其实也就是 STOP, TIDYING, 或 TERMINATED</span></span><br><span class="line">        <span class="comment">// 2\. firstTask != null</span></span><br><span class="line">        <span class="comment">// 3\. workQueue.isEmpty()</span></span><br><span class="line">        <span class="comment">// 简单分析下：</span></span><br><span class="line">        <span class="comment">// 还是状态控制的问题，当线程池处于 SHUTDOWN 的时候，不允许提交任务，但是已有的任务继续执行</span></span><br><span class="line">        <span class="comment">// 当状态大于 SHUTDOWN 时，不允许提交任务，且中断正在执行的任务</span></span><br><span class="line">        <span class="comment">// 多说一句：如果线程池处于 SHUTDOWN，但是 firstTask 为 null，且 workQueue 非空，那么是允许创建 worker 的</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="built_in">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 如果成功，那么就是所有创建线程前的条件校验都满足了，准备创建线程执行任务了</span></span><br><span class="line">            <span class="comment">// 这里失败的话，说明有其他线程也在尝试往线程池中创建线程</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// 由于有并发，重新再读取一下 ctl</span></span><br><span class="line">            c = ctl.<span class="built_in">get</span>();</span><br><span class="line">            <span class="comment">// 正常如果是 CAS 失败的话，进到下一个里层的for循环就可以了</span></span><br><span class="line">            <span class="comment">// 可是如果是因为其他线程的操作，导致线程池的状态发生了变更，如有其他线程关闭了这个线程池</span></span><br><span class="line">            <span class="comment">// 那么需要回到外层的for循环</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 到这里，我们认为在当前这个时刻，可以开始创建线程来执行任务了，</span></span><br><span class="line"><span class="comment">     * 因为该校验的都校验了，至于以后会发生什么，那是以后的事，至少当前是满足条件的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// worker 是否已经启动</span></span><br><span class="line">    <span class="built_in">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 是否已将这个 worker 添加到 workers 这个 HashSet 中</span></span><br><span class="line">    <span class="built_in">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        <span class="comment">// 把 firstTask 传给 worker 的构造方法</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="comment">// 取 worker 中的线程对象，之前说了，Worker的构造方法会调用 ThreadFactory 来创建一个新的线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这个是整个类的全局锁，持有这个锁才能让下面的操作“顺理成章”，</span></span><br><span class="line">            <span class="comment">// 因为关闭一个线程池需要这个锁，至少我持有锁的期间，线程池不会被关闭</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">int</span> c = ctl.<span class="built_in">get</span>();</span><br><span class="line">                <span class="built_in">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 小于 SHUTTDOWN 那就是 RUNNING，这个自不必说，是最正常的情况</span></span><br><span class="line">                <span class="comment">// 如果等于 SHUTDOWN，前面说了，不接受新的任务，但是会继续执行等待队列中的任务</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// worker 里面的 thread 可不能是已经启动的</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">// 加到 workers 这个 HashSet 中</span></span><br><span class="line">                    workers.<span class="built_in">add</span>(w);</span><br><span class="line">                    <span class="built_in">int</span> s = workers.<span class="built_in">size</span>();</span><br><span class="line">                    <span class="comment">// largestPoolSize 用于记录 workers 中的个数的最大值</span></span><br><span class="line">                    <span class="comment">// 因为 workers 是不断增加减少的，通过这个值可以知道线程池的大小曾经达到的最大值</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加成功的话，启动这个线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 启动线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果线程没有启动，需要做一些清理工作，如前面 workCount 加了 1，将其减掉</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回线程是否启动成功</span></span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单看下 addWorkFailed 的处理：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// workers 中删除掉相应的 worker</span></span><br><span class="line"><span class="comment">// workCount 减 1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span>(<span class="params">Worker w</span>) </span>&#123;</span><br><span class="line">    final ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="literal">null</span>)</span><br><span class="line">            workers.<span class="keyword">remove</span>(w);</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        <span class="comment">// rechecks for termination, in case the existence of this worker was holding up termination</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回过头来，继续往下走。我们知道，worker 中的线程 start 后，其 run 方法会调用 runWorker 方法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Worker 类的 <span class="keyword">run</span><span class="bash">() 方法</span></span><br><span class="line"><span class="bash">public void <span class="function"><span class="title">run</span></span>() &#123;</span></span><br><span class="line"><span class="bash">    runWorker(this);</span></span><br><span class="line"><span class="bash">&#125;</span></span><br></pre></td></tr></table></figure><p>继续往下看 runWorker 方法：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此方法由 worker 线程启动后调用，这里用一个 while 循环来不断地从等待队列中获取任务并执行</span></span><br><span class="line"><span class="comment">// 前面说了，worker 在初始化的时候，可以指定 firstTask，那么第一个任务也就可以不需要从队列中获取</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> runWorker(Worker w) &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 该线程的第一个任务(如果有的话)</span></span><br><span class="line">    Runnable <span class="keyword">task</span> = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 循环调用 getTask 获取任务</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">task</span> != <span class="keyword">null</span> || (<span class="keyword">task</span> = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();          </span><br><span class="line">            <span class="comment">// 如果线程池状态大于等于 STOP，那么意味着该线程也要中断</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 这是一个钩子方法，留给需要的子类实现</span></span><br><span class="line">                beforeExecute(wt, <span class="keyword">task</span>);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 到这里终于可以执行任务了</span></span><br><span class="line">                    <span class="keyword">task</span>.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    <span class="comment">// 这里不允许抛出 Throwable，所以转换为 Error</span></span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 也是一个钩子方法，将 task 和异常作为参数，留给需要的子类实现</span></span><br><span class="line">                    afterExecute(<span class="keyword">task</span>, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 置空 task，准备 getTask 获取下一个任务</span></span><br><span class="line">                <span class="keyword">task</span> = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 累加完成的任务数</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                <span class="comment">// 释放掉 worker 的独占锁</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果到这里，需要执行线程关闭：</span></span><br><span class="line">        <span class="comment">// 1\. 说明 getTask 返回 null，也就是说，这个 worker 的使命结束了，执行关闭</span></span><br><span class="line">        <span class="comment">// 2\. 任务执行过程中发生了异常</span></span><br><span class="line">        <span class="comment">// 第一种情况，已经在代码处理了将 workCount 减 1，这个在 getTask 方法分析中会说</span></span><br><span class="line">        <span class="comment">// 第二种情况，workCount 没有进行处理，所以需要在 processWorkerExit 中处理</span></span><br><span class="line">        <span class="comment">// 限于篇幅，我不准备分析这个方法了，感兴趣的读者请自行分析源码</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看 getTask() 是怎么获取任务的，这个方法写得真的很好，每一行都很简单，组合起来却所有的情况都想好了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此方法有三种可能：</span></span><br><span class="line"><span class="comment">// 1\. 阻塞直到获取到任务返回。我们知道，默认 corePoolSize 之内的线程是不会被回收的，</span></span><br><span class="line"><span class="comment">//      它们会一直等待任务</span></span><br><span class="line"><span class="comment">// 2\. 超时退出。keepAliveTime 起作用的时候，也就是如果这么多时间内都没有任务，那么应该执行关闭</span></span><br><span class="line"><span class="comment">// 3\. 如果发生了以下条件，此方法必须返回 null:</span></span><br><span class="line"><span class="comment">//    - 池中有大于 maximumPoolSize 个 workers 存在(通过调用 setMaximumPoolSize 进行设置)</span></span><br><span class="line"><span class="comment">//    - 线程池处于 SHUTDOWN，而且 workQueue 是空的，前面说了，这种不再接受新的任务</span></span><br><span class="line"><span class="comment">//    - 线程池处于 STOP，不仅不接受新的线程，连 workQueue 中的线程也不再执行</span></span><br><span class="line"><span class="keyword">private</span> Runnable getTask() &#123;</span><br><span class="line">    boolean timedOut = <span class="literal">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        int c = ctl.<span class="keyword">get</span>();</span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line">        <span class="comment">// 两种可能</span></span><br><span class="line">        <span class="comment">// 1\. rs == SHUTDOWN &amp;&amp; workQueue.isEmpty()</span></span><br><span class="line">        <span class="comment">// 2\. rs &gt;= STOP</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">// CAS 操作，减少工作线程数</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean timed;      <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            int wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// 允许核心线程数内的线程回收，或当前线程数超过了核心线程数，那么有可能发生超时关闭</span></span><br><span class="line">            timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里 break，是为了不往下执行后一个 if (compareAndDecrementWorkerCount(c))</span></span><br><span class="line">            <span class="comment">// 两个 if 一起看：如果当前线程数 wc &gt; maximumPoolSize，或者超时，都返回 null</span></span><br><span class="line">            <span class="comment">// 那这里的问题来了，wc &gt; maximumPoolSize 的情况，为什么要返回 null？</span></span><br><span class="line">            <span class="comment">//    换句话说，返回 null 意味着关闭线程。</span></span><br><span class="line">            <span class="comment">// 那是因为有可能开发者调用了 setMaximumPoolSize 将线程池的 maximumPoolSize 调小了</span></span><br><span class="line">            <span class="keyword">if</span> (wc &lt;= maximumPoolSize &amp;&amp; ! (timedOut &amp;&amp; timed))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            c = ctl.<span class="keyword">get</span>();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// compareAndDecrementWorkerCount(c) 失败，线程池中的线程数发生了改变</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// wc &lt;= maximumPoolSize 同时没有超时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 到 workQueue 中获取任务</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            <span class="comment">// 如果此 worker 发生了中断，采取的方案是重试</span></span><br><span class="line">            <span class="comment">// 解释下为什么会发生中断，这个读者要去看 setMaximumPoolSize 方法，</span></span><br><span class="line">            <span class="comment">// 如果开发者将 maximumPoolSize 调小了，导致其小于当前的 workers 数量，</span></span><br><span class="line">            <span class="comment">// 那么意味着超出的部分线程要被关闭。重新进入 for 循环，自然会有部分线程会返回 null</span></span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，基本上也说完了整个流程，读者这个时候应该回到 execute(Runnable command) 方法，看看各个分支，我把代码贴过来一下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>(<span class="params">Runnable command</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前面说的那个表示 “线程池状态” 和 “线程数” 的整数</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.<span class="keyword">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前线程数少于核心线程数，那么直接添加一个 worker 来执行任务，</span></span><br><span class="line">    <span class="comment">// 创建一个新的线程，并把当前任务 command 作为这个线程的第一个任务(firstTask)</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 添加任务成功，那么就结束了。提交任务嘛，线程池已经接受了这个任务，这个方法也就可以返回了</span></span><br><span class="line">        <span class="comment">// 至于执行的结果，到时候会包装到 FutureTask 中。</span></span><br><span class="line">        <span class="comment">// 返回 false 代表线程池不允许提交任务</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.<span class="keyword">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这里说明，要么当前线程数大于等于核心线程数，要么刚刚 addWorker 失败了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">/* 这里面说的是，如果任务进入了 workQueue，我们是否需要开启新的线程</span></span><br><span class="line"><span class="comment">         * 因为线程数在 [0, corePoolSize) 是无条件开启新的线程</span></span><br><span class="line"><span class="comment">         * 如果线程数已经大于等于 corePoolSize，那么将任务添加到队列中，然后进到这里</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.<span class="keyword">get</span>();</span><br><span class="line">        <span class="comment">// 如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; <span class="keyword">remove</span>(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 如果线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程</span></span><br><span class="line">        <span class="comment">// 到这里，我们知道了，这块代码的真正意图是：担心任务提交到队列中了，但是线程都关闭了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 workQueue 队列满了，那么进入到这个分支</span></span><br><span class="line">    <span class="comment">// 以 maximumPoolSize 为界创建新的 worker，</span></span><br><span class="line">    <span class="comment">// 如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面各个分支中，有两种情况会调用 reject(command) 来处理任务，因为按照正常的流程，线程池此时不能接受这个任务，所以需要执行我们的拒绝策略。接下来，我们说一说 ThreadPoolExecutor 中的拒绝策略。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 执行拒绝策略</span></span><br><span class="line">    <span class="keyword">handler</span>.rejectedExecution(command, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的 handler 我们需要在构造线程池的时候就传入这个参数，它是 RejectedExecutionHandler 的实例。</p><p>RejectedExecutionHandler 在 ThreadPoolExecutor 中有四个已经定义好的实现类可供我们直接使用，当然，我们也可以实现自己的策略，不过一般也没有必要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只要线程池没有被关闭，那么由提交任务的线程自己来执行这个任务。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不管怎样，直接抛出 RejectedExecutionException 异常</span></span><br><span class="line"><span class="comment">// 这个是默认的策略，如果我们构造线程池的时候不传相应的 handler 的话，那就会指定使用这个</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                                             <span class="string">" rejected from "</span> +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不做任何处理，直接忽略掉这个任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个相对霸道一点，如果线程池没有被关闭的话，</span></span><br><span class="line"><span class="comment">// 把队列队头的任务(也就是等待了最长时间的)直接扔掉，然后提交这个任务到等待队列中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，ThreadPoolExecutor 的源码算是分析结束了。单纯从源码的难易程度来说，ThreadPoolExecutor 的源码还算是比较简单的，只是需要我们静下心来好好看看罢了。</p><h2 id="结束线程池的相关方法"><a href="#结束线程池的相关方法" class="headerlink" title="结束线程池的相关方法"></a>结束线程池的相关方法</h2><p>tryTerminate()</p><p>当线程池涉及到要移除worker时候都会调用tryTerminate()，该方法主要用于判断线程池中的线程是否已经全部移除了，如果是的话则关闭线程池。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> void tryTerminate() &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        int c = ctl.<span class="keyword">get</span>();</span><br><span class="line">        <span class="comment">// 线程池处于Running状态</span></span><br><span class="line">        <span class="comment">// 线程池已经终止了</span></span><br><span class="line">        <span class="comment">// 线程池处于ShutDown状态，但是阻塞队列不为空</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">                runStateAtLeast(c, TIDYING) ||</span><br><span class="line">                (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行到这里，就意味着线程池要么处于STOP状态，要么处于SHUTDOWN且阻塞队列为空</span></span><br><span class="line">        <span class="comment">// 这时如果线程池中还存在线程，则会尝试中断线程</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// /线程池还有线程，但是队列没有任务了，需要中断唤醒等待任务的线程</span></span><br><span class="line">            <span class="comment">// （runwoker的时候首先就通过w.unlock设置线程可中断，getTask最后面的catch处理中断）</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试终止线程池</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 线程池状态转为TERMINATED</span></span><br><span class="line">                    ctl.<span class="keyword">set</span>(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在关闭线程池的过程中，如果线程池处于STOP状态或者处于SHUDOWN状态且阻塞队列为null，则线程池会调用interruptIdleWorkers()方法中断所有线程，注意ONLY_ONE== true，表示仅中断一个线程。</p><p>interruptIdleWorkers</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onlyOne==true仅终止一个线程，否则终止所有线程。</p><h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><p>线程池ThreadPoolExecutor提供了shutdown()和shutDownNow()用于关闭线程池。</p><p>shutdown()：按过去执行已提交任务的顺序发起一个有序的关闭，但是不接受新任务。</p><p>shutdownNow() :尝试停止所有的活动执行任务、暂停等待任务的处理，并返回等待执行的任务列表。</p><p>shutdown</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 推进线程状态</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 中断空闲的线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        <span class="comment">// 交给子类实现</span></span><br><span class="line">        onShutdown();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shutdownNow</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Runnable&gt; shutdownNow() &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks<span class="comment">;</span></span><br><span class="line">    final ReentrantLock mainLock = this.mainLock<span class="comment">;</span></span><br><span class="line">    mainLock.lock()<span class="comment">;</span></span><br><span class="line">    try &#123;</span><br><span class="line">        checkShutdownAccess()<span class="comment">;</span></span><br><span class="line">        advanceRunState(STOP)<span class="comment">;</span></span><br><span class="line">        // 中断所有线程</span><br><span class="line">        interruptWorkers()<span class="comment">;</span></span><br><span class="line">        // 返回等待执行的任务列表</span><br><span class="line">        tasks = drainQueue()<span class="comment">;</span></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock()<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate()<span class="comment">;</span></span><br><span class="line">    return tasks<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与shutdown不同，shutdownNow会调用interruptWorkers()方法中断所有线程。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            w.interruptIfStarted();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时会调用drainQueue()方法返回等待执行到任务列表。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Runnable&gt; <span class="title">drainQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; q = workQueue;</span><br><span class="line">    ArrayList&lt;Runnable&gt; taskList = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</span><br><span class="line">    q.drainTo(taskList);</span><br><span class="line">    <span class="keyword">if</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Runnable r : q.toArray(<span class="keyword">new</span> Runnable[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="keyword">remove</span>(r))</span><br><span class="line">                taskList.<span class="keyword">add</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> taskList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>这节其实也不是分析 Executors 这个类，因为它仅仅是工具类，它的所有方法都是 static 的。</p><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><p>创建固定长度的线程池，每次提交任务创建一个线程，直到达到线程池的最大数量，线程池的大小不再变化。</p><p>这个线程池可以创建固定线程数的线程池。特点就是可以重用固定数量线程的线程池。它的构造源码如下：</p><pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {         return new ThreadPoolExecutor(nThreads, nThreads, 0L,                                      TimeUnit.MILLISECONDS,                                       new LinkedBlockingQueue&lt;Runnable&gt;()); } </code></pre><ul><li>FixedThreadPool的corePoolSize和maxiumPoolSize都被设置为创建FixedThreadPool时指定的参数nThreads。</li><li>0L则表示当线程池中的线程数量操作核心线程的数量时，多余的线程将被立即停止</li><li>最后一个参数表示FixedThreadPool使用了无界队列LinkedBlockingQueue作为线程池的做工队列，由于是无界的，当线程池的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池的线程数量不会超过corePoolSize，同时maxiumPoolSize也就变成了一个无效的参数，并且运行中的线程池并不会拒绝任务。</li></ul><p>FixedThreadPool运行图如下</p><p><img src="https://images2015.cnblogs.com/blog/926638/201704/926638-20170420111954915-1390955029.png" alt=""></p><p>执行过程如下：</p><p>1.如果当前工作中的线程数量少于corePool的数量，就创建新的线程来执行任务。</p><p>2.当线程池的工作中的线程数量达到了corePool，则将任务加入LinkedBlockingQueue。</p><p>3.线程执行完1中的任务后会从队列中去任务。</p><p>注意LinkedBlockingQueue是无界队列，所以可以一直添加新任务到线程池。</p><h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor　　"></a>SingleThreadExecutor　　</h3><p>SingleThreadExecutor是使用单个worker线程的Executor。特点是使用单个工作线程执行任务。它的构造源码如下：</p><pre><code>public static ExecutorService newSingleThreadExecutor() {        return new FinalizableDelegatedExecutorService            (new ThreadPoolExecutor(1, 1,                                    0L, TimeUnit.MILLISECONDS,                                    new LinkedBlockingQueue&lt;Runnable&gt;()));}</code></pre><p>SingleThreadExecutor的corePoolSize和maxiumPoolSize都被设置1。</p><p>其他参数均与FixedThreadPool相同，其运行图如下：</p><p> <img src="https://images2015.cnblogs.com/blog/926638/201704/926638-20170420112245462-2072409666.png" alt=""></p><p>执行过程如下：</p><p>1.如果当前工作中的线程数量少于corePool的数量，就创建一个新的线程来执行任务。</p><p>2.当线程池的工作中的线程数量达到了corePool，则将任务加入LinkedBlockingQueue。</p><p>3.线程执行完1中的任务后会从队列中去任务。</p><p>注意：由于在线程池中只有一个工作线程，所以任务可以按照添加顺序执行。</p><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p> CachedThreadPool是一个”无限“容量的线程池，它会根据需要创建新线程。特点是可以根据需要来创建新的线程执行任务，没有特定的corePool。下面是它的构造方法：</p><pre><code>public static ExecutorService newCachedThreadPool() {        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                      60L, TimeUnit.SECONDS,                                      new SynchronousQueue&lt;Runnable&gt;());}</code></pre><p>CachedThreadPool的corePoolSize被设置为0，即corePool为空；maximumPoolSize被设置为Integer.MAX_VALUE，即maximum是无界的。这里keepAliveTime设置为60秒，意味着空闲的线程最多可以等待任务60秒，否则将被回收。</p><p>CachedThreadPool使用没有容量的SynchronousQueue作为主线程池的工作队列，它是一个没有容量的阻塞队列。每个插入操作必须等待另一个线程的对应移除操作。这意味着，如果主线程提交任务的速度高于线程池中处理任务的速度时，CachedThreadPool会不断创建新线程。极端情况下，CachedThreadPool会因为创建过多线程而耗尽CPU资源。其运行图如下：</p><p><img src="https://images2015.cnblogs.com/blog/926638/201704/926638-20170420112615102-1872791768.png" alt=""></p><p>执行过程如下：</p><p>1.首先执行SynchronousQueue.offer(Runnable task)。如果在当前的线程池中有空闲的线程正在执行SynchronousQueue.poll()，那么主线程执行的offer操作与空闲线程执行的poll操作配对成功，主线程把任务交给空闲线程执行。，execute()方法执行成功，否则执行步骤2</p><p>2.当线程池为空(初始maximumPool为空)或没有空闲线程时，配对失败，将没有线程执行SynchronousQueue.poll操作。这种情况下，线程池会创建一个新的线程执行任务。</p><p>3.在创建完新的线程以后，将会执行poll操作。当步骤2的线程执行完成后，将等待60秒，如果此时主线程提交了一个新任务，那么这个空闲线程将执行新任务，否则被回收。因此长时间不提交任务的CachedThreadPool不会占用系统资源。</p><p>SynchronousQueue是一个不存储元素阻塞队列，每次要进行offer操作时必须等待poll操作，否则不能继续添加元素。</p><blockquote><p>具体使用案例</p></blockquote><p>(1). newCachedThreadPool<br>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。示例代码如下：</p><p>Java</p><pre><code>ExecutorService cachedThreadPool = Executors.newCachedThreadPool();for (int i = 0; i &lt; 10; i++) {final int index = i;try {Thread.sleep(index * 1000);} catch (InterruptedException e) {e.printStackTrace();}cachedThreadPool.execute(new Runnable() {@Overridepublic void run() {System.out.println(index);}});}</code></pre><p>线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。</p><p>(2). newFixedThreadPool<br>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。示例代码如下：</p><p>Java</p><pre><code>ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);for (int i = 0; i &lt; 10; i++) {final int index = i;fixedThreadPool.execute(new Runnable() {@Overridepublic void run() {try {System.out.println(index);Thread.sleep(2000);} catch (InterruptedException e) {// TODO Auto-generated catch blocke.printStackTrace();}}});}</code></pre><p>因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字。</p><p>定长线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()。可参考<a href="http://www.trinea.cn/android/preloaddatacache%E6%94%AF%E6%8C%81%E9%A2%84%E5%8F%96%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95%EF%BC%8C%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E7%BC%93/" title="PreloadDataCache支持预取的数据缓存，使用简单，支持多种缓存算法，支持不同网络类型，扩展性强" target="_blank" rel="noopener">PreloadDataCache</a>。</p><p>(3) newScheduledThreadPool<br>创建一个定长线程池，支持定时及周期性任务执行。延迟执行示例代码如下：</p><p>Java</p><pre><code>ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);scheduledThreadPool.schedule(new Runnable() {@Overridepublic void run() {System.out.println(&quot;delay 3 seconds&quot;);}}, 3, TimeUnit.SECONDS);</code></pre><p>表示延迟3秒执行。</p><p>定期执行示例代码如下：</p><p>Java</p><pre><code>scheduledThreadPool.scheduleAtFixedRate(new Runnable() {@Overridepublic void run() {System.out.println(&quot;delay 1 seconds, and excute every 3 seconds&quot;);}}, 1, 3, TimeUnit.SECONDS);</code></pre><p>表示延迟1秒后每3秒执行一次。</p><p>ScheduledExecutorService比Timer更安全，功能更强大，后面会有一篇单独进行对比。</p><p>(4)、newSingleThreadExecutor<br>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。示例代码如下：</p><p>Java</p><pre><code>ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();for (int i = 0; i &lt; 10; i++) {final int index = i;singleThreadExecutor.execute(new Runnable() {@Overridepublic void run() {try {System.out.println(index);Thread.sleep(2000);} catch (InterruptedException e) {// TODO Auto-generated catch blocke.printStackTrace();}}});}</code></pre><p>结果依次输出，相当于顺序执行各个任务。</p><p>现行大多数GUI程序都是单线程的。Android中单线程可用于<a href="http://www.trinea.cn/android/database-performance/" title="性能优化之数据库优化" target="_blank" rel="noopener">数据库操作</a>，文件操作，应用批量安装，应用批量删除等不适合并发但可能IO阻塞性及影响UI线程响应的操作。</p><h3 id="特别的线程池：ScheduledThreadPoolExecutor"><a href="#特别的线程池：ScheduledThreadPoolExecutor" class="headerlink" title="特别的线程池：ScheduledThreadPoolExecutor"></a>特别的线程池：<a href="http://cmsblogs.com/?p=2451" target="_blank" rel="noopener">ScheduledThreadPoolExecutor</a></h3><p>原文出处<a href="http://cmsblogs.com/" target="_blank" rel="noopener">http://cmsblogs.com/</a>chenssy</p><p>在上篇博客<a href="http://cmsblogs.com/?p=2448" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之线程池：ThreadPoolExecutor</a>已经介绍了线程池中最核心的类ThreadPoolExecutor，这篇就来看看另一个核心类ScheduledThreadPoolExecutor的实现。</p><h2 id="ScheduledThreadPoolExecutor解析"><a href="#ScheduledThreadPoolExecutor解析" class="headerlink" title="ScheduledThreadPoolExecutor解析"></a>ScheduledThreadPoolExecutor解析</h2><p>我们知道Timer与TimerTask虽然可以实现线程的周期和延迟调度，但是Timer与TimerTask存在一些缺陷，所以对于这种定期、周期执行任务的调度策略，我们一般都是推荐ScheduledThreadPoolExecutor来实现。下面就深入分析ScheduledThreadPoolExecutor是如何来实现线程的周期、延迟调度的。</p><p>ScheduledThreadPoolExecutor，继承ThreadPoolExecutor且实现了ScheduledExecutorService接口，它就相当于提供了“延迟”和“周期执行”功能的ThreadPoolExecutor。在JDK API中是这样定义它的：ThreadPoolExecutor，它可另行安排在给定的延迟后运行命令，或者定期执行命令。需要多个辅助线程时，或者要求 ThreadPoolExecutor 具有额外的灵活性或功能时，此类要优于 Timer。 一旦启用已延迟的任务就执行它，但是有关何时启用，启用后何时执行则没有任何实时保证。按照提交的先进先出 (FIFO) 顺序来启用那些被安排在同一执行时间的任务。</p><p>它提供了四个构造方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">            <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ScheduledThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                                   ThreadFactory threadFactory) &#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">            <span class="keyword">new</span> DelayedWorkQueue(), threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ScheduledThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                                   RejectedExecutionHandler <span class="keyword">handler</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">            <span class="keyword">new</span> DelayedWorkQueue(), <span class="keyword">handler</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ScheduledThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                                   ThreadFactory threadFactory,</span><br><span class="line">                                   RejectedExecutionHandler <span class="keyword">handler</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">            <span class="keyword">new</span> DelayedWorkQueue(), threadFactory, <span class="keyword">handler</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然我们一般都不会直接通过其构造函数来生成一个ScheduledThreadPoolExecutor对象（例如new ScheduledThreadPoolExecutor(10)之类的），而是通过Executors类（例如Executors.newScheduledThreadPool(int);）</p><p>在ScheduledThreadPoolExecutor的构造函数中，我们发现它都是利用ThreadLocalExecutor来构造的，唯一变动的地方就在于它所使用的阻塞队列变成了DelayedWorkQueue，而不是ThreadLocalhExecutor的LinkedBlockingQueue（通过Executors产生ThreadLocalhExecutor对象）。DelayedWorkQueue为ScheduledThreadPoolExecutor中的内部类，它其实和阻塞队列DelayQueue有点儿类似。DelayQueue是可以提供延迟的阻塞队列，它只有在延迟期满时才能从中提取元素，其列头是延迟期满后保存时间最长的Delayed元素。如果延迟都还没有期满，则队列没有头部，并且 poll 将返回 null。有关于DelayQueue的更多介绍请参考这篇博客<a href="http://cmsblogs.com/?p=2413" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之阻塞队列：DelayQueue</a>。所以DelayedWorkQueue中的任务必然是按照延迟时间从短到长来进行排序的。下面我们再深入分析DelayedWorkQueue，这里留一个引子。</p><p>ScheduledThreadPoolExecutor提供了如下四个方法，也就是四个调度器：</p><ol><li>schedule(Callable callable, long delay, TimeUnit unit) :创建并执行在给定延迟后启用的 ScheduledFuture。</li><li>schedule(Runnable command, long delay, TimeUnit unit) :创建并执行在给定延迟后启用的一次性操作。</li><li>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) :创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。</li><li>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) :创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。</li></ol><p>第一、二个方法差不多，都是一次性操作，只不过参数一个是Callable，一个是Runnable。稍微分析下第三（scheduleAtFixedRate）、四个（scheduleWithFixedDelay）方法，加入initialDelay = 5，period/delay = 3，unit为秒。如果每个线程都是都运行非常良好不存在延迟的问题，那么这两个方法线程运行周期是5、8、11、14、17…….，但是如果存在延迟呢？比如第三个线程用了5秒钟，那么这两个方法的处理策略是怎样的？第三个方法（scheduleAtFixedRate）是周期固定，也就说它是不会受到这个延迟的影响的，每个线程的调度周期在初始化时就已经绝对了，是什么时候调度就是什么时候调度，它不会因为上一个线程的调度失效延迟而受到影响。但是第四个方法（scheduleWithFixedDelay），则不一样，它是每个线程的调度间隔固定，也就是说第一个线程与第二线程之间间隔delay，第二个与第三个间隔delay，以此类推。如果第二线程推迟了那么后面所有的线程调度都会推迟，例如，上面第二线程推迟了2秒，那么第三个就不再是11秒执行了，而是13秒执行。</p><p>查看着四个方法的源码，会发现其实他们的处理逻辑都差不多，所以我们就挑scheduleWithFixedDelay方法来分析，如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                 long initialDelay,</span><br><span class="line">                                                 long delay,</span><br><span class="line">                                                 TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span> || unit == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>();</span><br><span class="line">    ScheduledFutureTask&lt;<span class="keyword">Void</span>&gt; sft =</span><br><span class="line">        <span class="keyword">new</span> <span class="type">ScheduledFutureTask</span>&lt;<span class="keyword">Void</span>&gt;(command,</span><br><span class="line">                                      <span class="literal">null</span>,</span><br><span class="line">                                      triggerTime(initialDelay, unit),</span><br><span class="line">                                      unit.toNanos(-delay));</span><br><span class="line">    RunnableScheduledFuture&lt;<span class="keyword">Void</span>&gt; t = decorateTask(command, sft);</span><br><span class="line">    sft.outerTask = t;</span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scheduleWithFixedDelay方法处理的逻辑如下：</p><ol><li>校验，如果参数不合法则抛出异常</li><li>构造一个task，该task为ScheduledFutureTask</li><li>调用delayedExecute()方法做后续相关处理</li></ol><p>这段代码涉及两个类ScheduledFutureTask和RunnableScheduledFuture，其中RunnableScheduledFuture不用多说，他继承RunnableFuture和ScheduledFuture两个接口，除了具备RunnableFuture和ScheduledFuture两类特性外，它还定义了一个方法isPeriodic() ，该方法用于判断执行的任务是否为定期任务，如果是则返回true。而ScheduledFutureTask作为ScheduledThreadPoolExecutor的内部类，它扮演着极其重要的作用，因为它的作用则是负责ScheduledThreadPoolExecutor中任务的调度。</p><p>ScheduledFutureTask内部继承FutureTask，实现RunnableScheduledFuture接口，它内部定义了三个比较重要的变量</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/** 任务被添加到ScheduledThreadPoolExecutor中的序号 */</span><br><span class="line">private<span class="keyword"> final</span><span class="built_in"> long </span>sequenceNumber;</span><br><span class="line"></span><br><span class="line">/** 任务要执行的具体时间 */</span><br><span class="line">private<span class="built_in"> long </span>time;</span><br><span class="line"></span><br><span class="line">/**  任务的间隔周期 /</span><br><span class="line">private<span class="keyword"> final</span><span class="built_in"> long </span>period;</span><br></pre></td></tr></table></figure><p>这三个变量与任务的执行有着非常密切的关系，什么关系？先看ScheduledFutureTask的几个构造函数和核心方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ScheduledFutureTask(Runnable r, V result, long ns) &#123;</span><br><span class="line">    <span class="keyword">super</span>(r, result);</span><br><span class="line">    <span class="keyword">this</span>.time = ns;</span><br><span class="line">    <span class="keyword">this</span>.period = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ScheduledFutureTask(Runnable r, V result, long ns, long period) &#123;</span><br><span class="line">    <span class="keyword">super</span>(r, result);</span><br><span class="line">    <span class="keyword">this</span>.time = ns;</span><br><span class="line">    <span class="keyword">this</span>.period = period;</span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ScheduledFutureTask(Callable&lt;V&gt; callable, long ns) &#123;</span><br><span class="line">    <span class="keyword">super</span>(callable);</span><br><span class="line">    <span class="keyword">this</span>.time = ns;</span><br><span class="line">    <span class="keyword">this</span>.period = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ScheduledFutureTask(Callable&lt;V&gt; callable, long ns) &#123;</span><br><span class="line">    <span class="keyword">super</span>(callable);</span><br><span class="line">    <span class="keyword">this</span>.time = ns;</span><br><span class="line">    <span class="keyword">this</span>.period = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ScheduledFutureTask 提供了四个构造方法，这些构造方法与上面三个参数是不是一一对应了？这些参数有什么用，如何用，则要看ScheduledFutureTask在那些方法使用了该方法，在ScheduledFutureTask中有一个compareTo()方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> int compareTo(Delayed other) &#123;</span><br><span class="line">    <span class="keyword">if</span> (other == <span class="keyword">this</span>) <span class="comment">// compare zero if same object</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (other instanceof ScheduledFutureTask) &#123;</span><br><span class="line">        ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;</span><br><span class="line">        long diff = time - x.time;</span><br><span class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    long diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);</span><br><span class="line">    <span class="keyword">return</span> (diff &lt; <span class="number">0</span>) ? <span class="number">-1</span> : (diff &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信各位都知道该方法是干嘛用的，提供一个排序算法，该算法规则是：首先按照time排序，time小的排在前面，大的排在后面，如果time相同，则使用sequenceNumber排序，小的排在前面，大的排在后面。那么为什么在这个类里面提供compareTo()方法呢？在前面就介绍过ScheduledThreadPoolExecutor在构造方法中提供的是DelayedWorkQueue()队列中，也就是说ScheduledThreadPoolExecutor是把任务添加到DelayedWorkQueue中的，而DelayedWorkQueue则是类似于DelayQueue，内部维护着一个以时间为先后顺序的队列，所以compareTo()方法使用与DelayedWorkQueue队列对其元素ScheduledThreadPoolExecutor task进行排序的算法。</p><p>排序已经解决了，那么ScheduledThreadPoolExecutor 是如何对task任务进行调度和延迟的呢？任何线程的执行，都是通过run()方法执行，ScheduledThreadPoolExecutor 的run()方法如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> periodic = isPeriodic();</span><br><span class="line">    <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</span><br><span class="line">        cancel(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</span><br><span class="line">        ScheduledFutureTask.<span class="keyword">super</span>.run();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="keyword">super</span>.runAndReset()) &#123;</span><br><span class="line">        setNextRunTime();</span><br><span class="line">        reExecutePeriodic(outerTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>调用isPeriodic()获取该线程是否为周期性任务标志，然后调用canRunInCurrentRunState()方法判断该线程是否可以执行，如果不可以执行则调用cancel()取消任务。</li><li>如果当线程已经到达了执行点，则调用run()方法执行task，该run()方法是在FutureTask中定义的。</li><li>否则调用runAndReset()方法运行并充值，调用setNextRunTime()方法计算任务下次的执行时间，重新把任务添加到队列中，让该任务可以重复执行。</li></ol><p>isPeriodic()</p><p>该方法用于判断指定的任务是否为定期任务。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isPeriodic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> period != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>canRunInCurrentRunState()判断任务是否可以取消，cancel()取消任务，这两个方法比较简单，而run()执行任务，runAndReset()运行并重置状态，牵涉比较广，我们放在FutureTask后面介绍。所以重点介绍setNextRunTime()和reExecutePeriodic()这两个涉及到延迟的方法。</p><p>setNextRunTime()</p><p>setNextRunTime()方法用于重新计算任务的下次执行时间。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNextRunTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> p = period;</span><br><span class="line">    <span class="keyword">if</span> (p &gt; <span class="number">0</span>)</span><br><span class="line">        time += p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        time = triggerTime(-p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法定义很简单，p &gt; 0 ,time += p ，否则调用triggerTime()方法重新计算time：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> triggerTime(<span class="keyword">long</span> <span class="built_in">delay</span>) &#123;</span><br><span class="line">    <span class="built_in">return</span> now() +</span><br><span class="line">        ((<span class="built_in">delay</span> &lt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>)) ? <span class="built_in">delay</span> : overflowFree(<span class="built_in">delay</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reExecutePeriodic</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> reExecutePeriodic(RunnableScheduledFuture&lt;?&gt; <span class="keyword">task</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (canRunInCurrentRunState(<span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(<span class="keyword">task</span>);</span><br><span class="line">        <span class="keyword">if</span> (!canRunInCurrentRunState(<span class="keyword">true</span>) &amp;&amp; remove(<span class="keyword">task</span>))</span><br><span class="line">            <span class="keyword">task</span>.cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reExecutePeriodic重要的是调用super.getQueue().add(task);将任务task加入的队列DelayedWorkQueue中。ensurePrestart()在<a href="http://cmsblogs.com/?p=2448" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之线程池：ThreadPoolExecutor</a>已经做了详细介绍。</p><p>到这里ScheduledFutureTask已经介绍完了，ScheduledFutureTask在ScheduledThreadPoolExecutor扮演作用的重要性不言而喻。其实ScheduledThreadPoolExecutor的实现不是很复杂，因为有FutureTask和ThreadPoolExecutor的支撑，其实现就显得不是那么难了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我一向不喜欢写总结，因为我把所有需要表达的都写在正文中了，写小篇幅的总结并不能真正将话说清楚，本文的总结部分为准备面试的读者而写，希望能帮到面试者或者没有足够的时间看完全文的读者。</p><ol><li><p>java 线程池有哪些关键属性？</p><blockquote><p>corePoolSize，maximumPoolSize，workQueue，keepAliveTime，rejectedExecutionHandler</p><p>corePoolSize 到 maximumPoolSize 之间的线程会被回收，当然 corePoolSize 的线程也可以通过设置而得到回收（allowCoreThreadTimeOut(true)）。</p><p>workQueue 用于存放任务，添加任务的时候，如果当前线程数超过了 corePoolSize，那么往该队列中插入任务，线程池中的线程会负责到队列中拉取任务。</p><p>keepAliveTime 用于设置空闲时间，如果线程数超出了 corePoolSize，并且有些线程的空闲时间超过了这个值，会执行关闭这些线程的操作</p><p>rejectedExecutionHandler 用于处理当线程池不能执行此任务时的情况，默认有抛出 RejectedExecutionException 异常、忽略任务、使用提交任务的线程来执行此任务和将队列中等待最久的任务删除，然后提交此任务这四种策略，默认为抛出异常。</p></blockquote></li><li><p>说说线程池中的线程创建时机？</p><blockquote><ol><li>如果当前线程数少于 corePoolSize，那么提交任务的时候创建一个新的线程，并由这个线程执行这个任务；</li><li>如果当前线程数已经达到 corePoolSize，那么将提交的任务添加到队列中，等待线程池中的线程去队列中取任务；</li><li>如果队列已满，那么创建新的线程来执行任务，需要保证池中的线程数不会超过 maximumPoolSize，如果此时线程数超过了 maximumPoolSize，那么执行拒绝策略。</li></ol></blockquote><ul><li>注意：如果将队列设置为无界队列，那么线程数达到 corePoolSize 后，其实线程数就不会再增长了。</li></ul></li><li><p>Executors.newFixedThreadPool(…) 和 Executors.newCachedThreadPool() 构造出来的线程池有什么差别？</p><blockquote><p>细说太长，往上滑一点点，在 Executors 的小节进行了详尽的描述。</p></blockquote></li><li><p>任务执行过程中发生异常怎么处理？</p><blockquote><p>如果某个任务执行出现异常，那么执行任务的线程会被关闭，而不是继续接收其他任务。然后会启动一个新的线程来代替它。</p></blockquote></li><li><p>什么时候会执行拒绝策略？</p><blockquote><ol><li>workers 的数量达到了 corePoolSize（任务此时需要进入任务队列），任务入队成功，与此同时线程池被关闭了，而且关闭线程池并没有将这个任务出队，那么执行拒绝策略。这里说的是非常边界的问题，入队和关闭线程池并发执行，读者仔细看看 execute 方法是怎么进到第一个 reject(command) 里面的。</li><li>workers 的数量大于等于 corePoolSize，将任务加入到任务队列，可是队列满了，任务入队失败，那么准备开启新的线程，可是线程数已经达到 maximumPoolSize，那么执行拒绝策略。</li></ol></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java并发指南&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/21961.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21961.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java并发" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="JUC" scheme="http://h2pl.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java并发指南11：解读 Java阻塞队列 BlockingQueue</title>
    <link href="http://h2pl.github.io/2018/05/22/concurrent11/"/>
    <id>http://h2pl.github.io/2018/05/22/concurrent11/</id>
    <published>2018-05-22T14:46:41.000Z</published>
    <updated>2018-06-11T13:43:21.233Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java并发指南<br><a href="https://blog.csdn.net/column/details/21961.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21961.html</a></p><p>相关代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><p>解读 Java 并发队列 BlockingQueue</p><p>转自：<a href="https://javadoop.com/post/java-concurrent-queue" target="_blank" rel="noopener">https://javadoop.com/post/java-concurrent-queue</a></p><p>最近得空，想写篇文章好好说说 java 线程池问题，我相信很多人都一知半解的，包括我自己在仔仔细细看源码之前，也有许多的不解，甚至有些地方我一直都没有理解到位。</p><p>说到线程池实现，那么就不得不涉及到各种 BlockingQueue 的实现，那么我想就 BlockingQueue 的问题和大家分享分享我了解的一些知识。</p><p>本文没有像之前分析 AQS 那样一行一行源码分析了，不过还是把其中最重要和最难理解的代码说了一遍，所以不免篇幅略长。本文涉及到比较多的 Doug Lea 对 BlockingQueue 的设计思想，希望有心的读者真的可以有一些收获，我觉得自己还是写了一些干货的。</p><p>本文直接参考 Doug Lea 写的 Java doc 和注释，这也是我们在学习 java 并发包时最好的材料了。希望大家能有所思、有所悟，学习 Doug Lea 的代码风格，并将其优雅、严谨的作风应用到我们写的每一行代码中。</p><p>目录</p><ul><li>阻塞队列概览</li><li>Java中的阻塞队列</li><li><p><a href="https://javadoop.com/post/java-concurrent-queue#BlockingQueue" target="_blank" rel="noopener">BlockingQueue源码分析</a></p></li><li><p><a href="https://javadoop.com/post/java-concurrent-queue#BlockingQueue%20%E5%AE%9E%E7%8E%B0%E4%B9%8B%20ArrayBlockingQueue" target="_blank" rel="noopener">        BlockingQueue 实现之 ArrayBlockingQueue</a></p></li><li><a href="https://javadoop.com/post/java-concurrent-queue#BlockingQueue%20%E5%AE%9E%E7%8E%B0%E4%B9%8B%20LinkedBlockingQueue" target="_blank" rel="noopener">        BlockingQueue 实现之 LinkedBlockingQueue</a></li><li><a href="https://javadoop.com/post/java-concurrent-queue#BlockingQueue%20%E5%AE%9E%E7%8E%B0%E4%B9%8B%20SynchronousQueue" target="_blank" rel="noopener">        BlockingQueue 实现之 SynchronousQueue</a></li><li><a href="https://javadoop.com/post/java-concurrent-queue#BlockingQueue%20%E5%AE%9E%E7%8E%B0%E4%B9%8B%20PriorityBlockingQueue" target="_blank" rel="noopener">        BlockingQueue 实现之 PriorityBlockingQueue</a></li><li><a href="https://javadoop.com/post/java-concurrent-queue#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">总结</a></li></ul><h2 id="阻塞队列概览"><a href="#阻塞队列概览" class="headerlink" title="阻塞队列概览"></a>阻塞队列概览</h2><h3 id="什么是阻塞队列？"><a href="#什么是阻塞队列？" class="headerlink" title="什么是阻塞队列？"></a>什么是阻塞队列？</h3><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p>阻塞队列提供了四种处理方法:</p><table><thead><tr><th>方法\处理方式</th><th>抛出异常</th><th>返回特殊值</th><th>一直阻塞</th><th>超时退出</th></tr></thead><tbody><tr><td>插入方法</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>移除方法</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time,unit)</td></tr><tr><td>检查方法</td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><ul><li>抛出异常：是指当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。</li><li>返回特殊值：插入方法会返回是否成功，成功则返回true。移除方法，则是从队列里拿出一个元素，如果没有则返回null</li><li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到拿到数据，或者响应中断退出。当队列空时，消费者线程试图从队列里take元素，队列也会阻塞消费者线程，直到队列可用。</li><li>超时退出：当阻塞队列满时，队列会阻塞生产者线程一段时间，如果超过一定的时间，生产者线程就会退出。</li></ul><h3 id="Java里的阻塞队列"><a href="#Java里的阻塞队列" class="headerlink" title="Java里的阻塞队列"></a>Java里的阻塞队列</h3><p>JDK7提供了7个阻塞队列。分别是</p><ul><li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</li><li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</li><li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li><li><p>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p><p>ArrayBlockingQueue</p></li></ul><p>ArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。</p><p> LinkedBlockingQueue</p><p>LinkedBlockingQueue是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</p><p> PriorityBlockingQueue</p><p>PriorityBlockingQueue是一个支持优先级的无界队列。默认情况下元素采取自然顺序排列，也可以通过比较器comparator来指定元素的排序规则。元素按照升序排列。</p><p> DelayQueue</p><p>DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将DelayQueue运用在以下应用场景：</p><ul><li>缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。</li><li>定时任务调度。使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，从比如TimerQueue就是使用DelayQueue实现的。</li></ul><p>阻塞队列源码分析：</p><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>首先，最基本的来说， BlockingQueue 是一个先进先出的队列（Queue），为什么说是阻塞（Blocking）的呢？是因为 BlockingQueue 支持当获取队列元素但是队列为空时，会阻塞等待队列中有元素再返回；也支持添加元素时，如果队列已满，那么等到队列可以放入新元素时再放入。</p><p>BlockingQueue 是一个接口，继承自 Queue，所以其实现类也可以作为 Queue 的实现来使用，而 Queue 又继承自 Collection 接口。</p><p>BlockingQueue 对插入操作、移除操作、获取元素操作提供了四种不同的方法用于不同的场景中使用：1、抛出异常；2、返回特殊值（null 或 true/false，取决于具体的操作）；3、阻塞等待此操作，直到这个操作成功；4、阻塞等待此操作，直到成功或者超时指定时间。总结如下：</p><table><thead><tr><th></th><th><em>Throws exception</em></th><th><em>Special value</em></th><th><em>Blocks</em></th><th><em>Times out</em></th></tr></thead><tbody><tr><td>Insert</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td>Remove</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td>Examine</td><td>element()</td><td>peek()</td><td><em>not applicable</em></td><td><em>not applicable</em></td></tr></tbody></table><p>BlockingQueue 的各个实现都遵循了这些规则，当然我们也不用死记这个表格，知道有这么回事，然后写代码的时候根据自己的需要去看方法的注释来选取合适的方法即可。</p><blockquote><p>对于 BlockingQueue，我们的关注点应该在 put(e) 和 take() 这两个方法，因为这两个方法是带阻塞的。</p></blockquote><p>BlockingQueue 不接受 null 值的插入，相应的方法在碰到 null 的插入时会抛出 NullPointerException 异常。null 值在这里通常用于作为特殊值返回（表格中的第三列），代表 poll 失败。所以，如果允许插入 null 值的话，那获取的时候，就不能很好地用 null 来判断到底是代表失败，还是获取的值就是 null 值。</p><p>一个 BlockingQueue 可能是有界的，如果在插入的时候，发现队列满了，那么 put 操作将会阻塞。通常，在这里我们说的无界队列也不是说真正的无界，而是它的容量是 Integer.MAX_VALUE（21亿多）。</p><p>BlockingQueue 是设计用来实现生产者-消费者队列的，当然，你也可以将它当做普通的 Collection 来用，前面说了，它实现了 java.util.Collection 接口。例如，我们可以用 remove(x) 来删除任意一个元素，但是，这类操作通常并不高效，所以尽量只在少数的场合使用，比如一条消息已经入队，但是需要做取消操作的时候。</p><p>BlockingQueue 的实现都是线程安全的，但是批量的集合操作如 <code>addAll</code>, <code>containsAll</code>, <code>retainAll</code> 和 <code>removeAll</code> 不一定是原子操作。如 addAll(c) 有可能在添加了一些元素后中途抛出异常，此时 BlockingQueue 中已经添加了部分元素，这个是允许的，取决于具体的实现。</p><p>BlockingQueue 不支持 close 或 shutdown 等关闭操作，因为开发者可能希望不会有新的元素添加进去，此特性取决于具体的实现，不做强制约束。</p><p>最后，BlockingQueue 在生产者-消费者的场景中，是支持多消费者和多生产者的，说的其实就是线程安全问题。</p><p>相信上面说的每一句都很清楚了，BlockingQueue 是一个比较简单的线程安全容器，下面我会分析其具体的在 JDK 中的实现，这里又到了 Doug Lea 表演时间了。</p><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>ArrayBlockingQueue 是 BlockingQueue 接口的有界队列实现类，底层采用数组来实现。</p><p>其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。</p><p>如果读者看过我之前写的《<a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2" target="_blank" rel="noopener">一行一行源码分析清楚 AbstractQueuedSynchronizer（二）</a>》 的关于 Condition 的文章的话，那么你一定能很容易看懂 ArrayBlockingQueue 的源码，它采用一个 ReentrantLock 和相应的两个 Condition 来实现。</p><p>ArrayBlockingQueue 共有以下几个属性：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于存放元素的数组</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"><span class="comment">// 下一次读取操作的位置</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"><span class="comment">// 下一次写入操作的位置</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"><span class="comment">// 队列中的元素数量</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">count</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下几个就是控制并发用的同步器</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure><p>我们用个示意图来描述其同步机制：</p><p><img src="https://javadoop.com/blogimages/java-concurrent-queue/array-blocking-queue.png" alt="array-blocking-queue"></p><p>ArrayBlockingQueue 实现并发同步的原理就是，读操作和写操作都需要获取到 AQS 独占锁才能进行操作。如果队列为空，这个时候读操作的线程进入到读线程队列排队，等待写线程写入新的元素，然后唤醒读线程队列的第一个等待线程。如果队列已满，这个时候写操作的线程进入到写线程队列排队，等待读线程将队列元素移除腾出空间，然后唤醒写线程队列的第一个等待线程。</p><p>对于 ArrayBlockingQueue，我们可以在构造的时候指定以下三个参数：</p><ol><li>队列容量，其限制了队列中最多允许的元素个数；</li><li>指定独占锁是公平锁还是非公平锁。非公平锁的吞吐量比较高，公平锁可以保证每次都是等待最久的线程获取到锁；</li><li>可以指定用一个集合来初始化，将此集合中的元素在构造方法期间就先添加到队列中。</li></ol><p>更具体的源码我就不进行分析了，因为它就是 AbstractQueuedSynchronizer 中 Condition 的使用，感兴趣的读者请看我写的《<a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2/" target="_blank" rel="noopener">一行一行源码分析清楚 AbstractQueuedSynchronizer（二）</a>》，因为只要看懂了那篇文章，ArrayBlockingQueue 的代码就没有分析的必要了，当然，如果你完全不懂 Condition，那么基本上也就可以说看不懂 ArrayBlockingQueue 的源码了。</p><h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>底层基于单向链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用。看构造方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传说中的无界队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传说中的有界队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看这个类有哪些属性：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列中的元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger <span class="keyword">count</span> = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// take, poll, peek 等读操作的方法需要获取到这个锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果读操作的时候队列是空的，那么等待 notEmpty 条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">// put, offer 等写操作的方法需要获取到这个锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果写操作的时候队列是满的，那么等待 notFull 条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure><p>这里用了两个锁，两个 Condition，简单介绍如下：</p><p>takeLock 和 notEmpty 怎么搭配：如果要获取（take）一个元素，需要获取 takeLock 锁，但是获取了锁还不够，如果队列此时为空，还需要队列不为空（notEmpty）这个条件（Condition）。</p><p>putLock 需要和 notFull 搭配：如果要插入（put）一个元素，需要获取 putLock 锁，但是获取了锁还不够，如果队列此时已满，还需要队列不是满的（notFull）这个条件（Condition）。</p><p>首先，这里用一个示意图来看看 LinkedBlockingQueue 的并发读写控制，然后再开始分析源码：</p><p><img src="https://javadoop.com/blogimages/java-concurrent-queue/linked-blocking-queue.png" alt="linked-blocking-queue"></p><p>看懂这个示意图，源码也就简单了，读操作是排好队的，写操作也是排好队的，唯一的并发问题在于一个写操作和一个读操作同时进行，只要控制好这个就可以了。</p><p>先上构造方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里会初始化一个空的头结点，那么第一个元素入队的时候，队列中就会有两个元素。读取元素时，也总是获取头节点后面的一个节点。count 的计数值不包括这个头节点。</p><p>我们来看下 put 方法是怎么将元素插入到队尾的：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> put(E e) <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 如果你纠结这里为什么是 -1，可以看看 offer 方法。这就是个标识成功、失败的标志而已。</span></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger <span class="keyword">count</span> = <span class="keyword">this</span>.<span class="keyword">count</span>;</span><br><span class="line">    <span class="comment">// 必须要获取到 putLock 才可以进行插入操作</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列满，等待 notFull 的条件满足。</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">count</span>.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        <span class="comment">// count 原子加 1，c 还是加 1 前的值</span></span><br><span class="line">        c = <span class="keyword">count</span>.getAndIncrement();</span><br><span class="line">        <span class="comment">// 如果这个元素入队后，还有至少一个槽可以使用，调用 notFull.signal() 唤醒等待线程。</span></span><br><span class="line">        <span class="comment">// 哪些线程会等待在 notFull 这个 Condition 上呢？</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 入队后，释放掉 putLock</span></span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 c == 0，那么代表队列在这个元素入队前是空的（不包括head空节点），</span></span><br><span class="line">    <span class="comment">// 那么所有的读线程都在等待 notEmpty 这个条件，等待唤醒，这里做一次唤醒操作</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队的代码非常简单，就是将 last 属性指向这个新元素，并且让原队尾的 next 指向这个元素</span></span><br><span class="line"><span class="comment">// 这里入队没有并发问题，因为只有获取到 putLock 独占锁以后，才可以进行此操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> enqueue(Node&lt;E&gt; node) &#123;</span><br><span class="line">    <span class="comment">// assert putLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert last.next == null;</span></span><br><span class="line">    last = last.<span class="keyword">next</span> = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素入队后，如果需要，调用这个方法唤醒读线程来读</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> signalNotEmpty() &#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再看看 take 方法：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E take() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger <span class="keyword">count</span> = <span class="keyword">this</span>.<span class="keyword">count</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    <span class="comment">// 首先，需要获取到 takeLock 才能进行出队操作</span></span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列为空，等待 notEmpty 这个条件满足再继续执行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">count</span>.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 出队</span></span><br><span class="line">        x = dequeue();</span><br><span class="line">        <span class="comment">// count 进行原子减 1</span></span><br><span class="line">        c = <span class="keyword">count</span>.getAndDecrement();</span><br><span class="line">        <span class="comment">// 如果这次出队后，队列中至少还有一个元素，那么调用 notEmpty.signal() 唤醒其他的读线程</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 出队后释放掉 takeLock</span></span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 c == capacity，那么说明在这个 take 方法发生的时候，队列是满的</span></span><br><span class="line">    <span class="comment">// 既然出队了一个，那么意味着队列不满了，唤醒写线程去写</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取队头，出队</span></span><br><span class="line"><span class="keyword">private</span> E dequeue() &#123;</span><br><span class="line">    <span class="comment">// assert takeLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert head.item == null;</span></span><br><span class="line">    <span class="comment">// 之前说了，头结点是空的</span></span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.<span class="keyword">next</span>;</span><br><span class="line">    h.<span class="keyword">next</span> = h; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">// 设置这个为新的头结点</span></span><br><span class="line">    head = first;</span><br><span class="line">    E x = first.item;</span><br><span class="line">    first.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 元素出队后，如果需要，调用这个方法唤醒写线程来写</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> signalNotFull() &#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码分析就到这里结束了吧，毕竟还是比较简单的源码，基本上只要读者认真点都看得懂。</p><h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>它是一个特殊的队列，它的名字其实就蕴含了它的特征 - - 同步的队列。为什么说是同步的呢？这里说的并不是多线程的并发问题，而是因为当一个线程往队列中写入一个元素时，写入操作不会立即返回，需要等待另一个线程来将这个元素拿走；同理，当一个读线程做读操作的时候，同样需要一个相匹配的写线程的写操作。这里的 Synchronous 指的就是读线程和写线程需要同步，一个读线程匹配一个写线程。</p><p>我们比较少使用到 SynchronousQueue 这个类，不过它在线程池的实现类 ScheduledThreadPoolExecutor 中得到了应用，感兴趣的读者可以在看完这个后去看看相应的使用。</p><p>虽然上面我说了队列，但是 SynchronousQueue 的队列其实是虚的，其不提供任何空间（一个都没有）来存储元素。数据必须从某个写线程交给某个读线程，而不是写到某个队列中等待被消费。</p><p>你不能在 SynchronousQueue 中使用 peek 方法（在这里这个方法直接返回 null），peek 方法的语义是只读取不移除，显然，这个方法的语义是不符合 SynchronousQueue 的特征的。SynchronousQueue 也不能被迭代，因为根本就没有元素可以拿来迭代的。虽然 SynchronousQueue 间接地实现了 Collection 接口，但是如果你将其当做 Collection 来用的话，那么集合是空的。当然，这个类也是不允许传递 null 值的（并发包中的容器类好像都不支持插入 null 值，因为 null 值往往用作其他用途，比如用于方法的返回值代表操作失败）。</p><p>接下来，我们来看看具体的源码实现吧，它的源码不是很简单的那种，我们需要先搞清楚它的设计思想。</p><p>源码加注释大概有 1200 行，我们先看大框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造时，我们可以指定公平模式还是非公平模式，区别之后再说</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    transferer = fair ? <span class="keyword">new</span> TransferQueue() : <span class="keyword">new</span> TransferStack();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Transferer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从方法名上大概就知道，这个方法用于转移元素，从生产者手上转到消费者手上</span></span><br><span class="line">    <span class="comment">// 也可以被动地，消费者调用这个方法来从生产者手上取元素</span></span><br><span class="line">    <span class="comment">// 第一个参数 e 如果不是 null，代表场景为：将元素从生产者转移给消费者</span></span><br><span class="line">    <span class="comment">// 如果是 null，代表消费者等待生产者提供元素，然后返回值就是相应的生产者提供的元素</span></span><br><span class="line">    <span class="comment">// 第二个参数代表是否设置超时，如果设置超时，超时时间是第三个参数的值</span></span><br><span class="line">    <span class="comment">// 返回值如果是 null，代表超时，或者中断。具体是哪个，可以通过检测中断状态得到。</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Object <span class="title">transfer</span><span class="params">(Object e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Transferer 有两个内部实现类，是因为构造 SynchronousQueue 的时候，我们可以指定公平策略。公平模式意味着，所有的读写线程都遵守先来后到，FIFO 嘛，对应 TransferQueue。而非公平模式则对应 TransferStack。</p><p>SynchronousQueue采用队列TransferQueue来实现公平性策略，采用堆栈TransferStack来实现非公平性策略，他们两种都是通过链表实现的，其节点分别为QNode，SNode。TransferQueue和TransferStack在SynchronousQueue中扮演着非常重要的作用，SynchronousQueue的put、take操作都是委托这两个类来实现的。</p><p><img src="https://javadoop.com/blogimages/java-concurrent-queue/synchronous-queue.png" alt="synchronous-queue"></p><p>我们先采用公平模式分析源码，然后再说说公平模式和非公平模式的区别。</p><p>接下来，我们看看 put 方法和 take 方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入值</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E o)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (transferer.transfer(o, <span class="keyword">false</span>, <span class="number">0</span>) == <span class="keyword">null</span>) &#123; <span class="comment">// 1</span></span><br><span class="line">        Thread.interrupted();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取值并移除</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Object e = transferer.transfer(<span class="keyword">null</span>, <span class="keyword">false</span>, <span class="number">0</span>); <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> (E)e;</span><br><span class="line">    Thread.interrupted();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，写操作 put(E o) 和读操作 take() 都是调用 Transferer.transfer(…) 方法，区别在于第一个参数是否为 null 值。</p><p>我们来看看 transfer 的设计思路，其基本算法如下：</p><ol><li>当调用这个方法时，如果队列是空的，或者队列中的节点和当前的线程操作类型一致（如当前操作是 put 操作，而队列中的元素也都是写线程）。这种情况下，将当前线程加入到等待队列即可。</li><li>如果队列中有等待节点，而且与当前操作可以匹配（如队列中都是读操作线程，当前线程是写操作线程，反之亦然）。这种情况下，匹配等待队列的队头，出队，返回相应数据。</li></ol><p>其实这里有个隐含的条件被满足了，队列如果不为空，肯定都是同种类型的节点，要么都是读操作，要么都是写操作。这个就要看到底是读线程积压了，还是写线程积压了。</p><p>我们可以假设出一个男女配对的场景：一个男的过来，如果一个人都没有，那么他需要等待；如果发现有一堆男的在等待，那么他需要排到队列后面；如果发现是一堆女的在排队，那么他直接牵走队头的那个女的。</p><p>既然这里说到了等待队列，我们先看看其实现，也就是 QNode:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> QNode &#123;</span><br><span class="line">    <span class="keyword">volatile</span> QNode <span class="keyword">next</span>;          <span class="comment">// 可以看出来，等待队列是单向链表</span></span><br><span class="line">    <span class="keyword">volatile</span> Object item;         <span class="comment">// CAS'ed to or from null</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;       <span class="comment">// 将线程对象保存在这里，用于挂起和唤醒</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isData;         <span class="comment">// 用于判断是写线程节点(isData == true)，还是读线程节点</span></span><br><span class="line"></span><br><span class="line">    QNode(Object item, <span class="keyword">boolean</span> isData) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">        <span class="keyword">this</span>.isData = isData;</span><br><span class="line">    &#125;</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><p>相信说了这么多以后，我们再来看 transfer 方法的代码就轻松多了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Puts or takes an item.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Object transfer(Object e, boolean timed, long nanos) &#123;</span><br><span class="line"></span><br><span class="line">    QNode s = <span class="literal">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line">    boolean isData = (e != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        QNode t = tail;</span><br><span class="line">        QNode h = head;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span> || h == <span class="literal">null</span>)         <span class="comment">// saw uninitialized value</span></span><br><span class="line">            <span class="keyword">continue</span>;                       <span class="comment">// spin</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列空，或队列中节点类型和当前节点一致，</span></span><br><span class="line">        <span class="comment">// 即我们说的第一种情况，将节点入队即可。读者要想着这块 if 里面方法其实就是入队</span></span><br><span class="line">        <span class="keyword">if</span> (h == t || t.isData == isData) &#123; <span class="comment">// empty or same-mode</span></span><br><span class="line">            QNode tn = t.next;</span><br><span class="line">            <span class="comment">// t != tail 说明刚刚有节点入队，continue 即可</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail)                  <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 有其他节点入队，但是 tail 还是指向原来的，此时设置 tail 即可</span></span><br><span class="line">            <span class="keyword">if</span> (tn != <span class="literal">null</span>) &#123;               <span class="comment">// lagging tail</span></span><br><span class="line">                <span class="comment">// 这个方法就是：如果 tail 此时为 t 的话，设置为 tn</span></span><br><span class="line">                advanceTail(t, tn);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)        <span class="comment">// can't wait</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="literal">null</span>)</span><br><span class="line">                s = new QNode(e, isData);</span><br><span class="line">            <span class="comment">// 将当前节点，插入到 tail 的后面</span></span><br><span class="line">            <span class="keyword">if</span> (!t.casNext(<span class="literal">null</span>, s))        <span class="comment">// failed to link in</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将当前节点设置为新的 tail</span></span><br><span class="line">            advanceTail(t, s);              <span class="comment">// swing tail and wait</span></span><br><span class="line">            <span class="comment">// 看到这里，请读者先往下滑到这个方法，看完了以后再回来这里，思路也就不会断了</span></span><br><span class="line">            Object x = awaitFulfill(s, e, timed, nanos);</span><br><span class="line">            <span class="comment">// 到这里，说明之前入队的线程被唤醒了，准备往下执行</span></span><br><span class="line">            <span class="keyword">if</span> (x == s) &#123;                   <span class="comment">// wait was cancelled</span></span><br><span class="line">                clean(t, s);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!s.isOffList()) &#123;           <span class="comment">// not already unlinked</span></span><br><span class="line">                advanceHead(t, s);          <span class="comment">// unlink if head</span></span><br><span class="line">                <span class="keyword">if</span> (x != <span class="literal">null</span>)              <span class="comment">// and forget fields</span></span><br><span class="line">                    s.item = s;</span><br><span class="line">                s.waiter = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (x != <span class="literal">null</span>) ? x : e;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里的 else 分支就是上面说的第二种情况，有相应的读或写相匹配的情况</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// complementary-mode</span></span><br><span class="line">            QNode m = h.next;               <span class="comment">// node to fulfill</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail || m == <span class="literal">null</span> || h != head)</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// inconsistent read</span></span><br><span class="line"></span><br><span class="line">            Object x = m.item;</span><br><span class="line">            <span class="keyword">if</span> (isData == (x != <span class="literal">null</span>) ||    <span class="comment">// m already fulfilled</span></span><br><span class="line">                x == m ||                   <span class="comment">// m cancelled</span></span><br><span class="line">                !m.casItem(x, e)) &#123;         <span class="comment">// lost CAS</span></span><br><span class="line">                advanceHead(h, m);          <span class="comment">// dequeue and retry</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            advanceHead(h, m);              <span class="comment">// successfully fulfilled</span></span><br><span class="line">            LockSupport.unpark(m.waiter);</span><br><span class="line">            <span class="keyword">return</span> (x != <span class="literal">null</span>) ? x : e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void advanceTail(QNode t, QNode nt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tail == t)</span><br><span class="line">        UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, t, nt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自旋或阻塞，直到满足条件，这个方法返回</span></span><br><span class="line"><span class="keyword">Object</span> awaitFulfill(QNode s, <span class="keyword">Object</span> e, <span class="built_in">boolean</span> timed, <span class="keyword">long</span> nanos) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> lastTime = timed ? System.nanoTime() : <span class="number">0</span>;</span><br><span class="line">    Thread w = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 判断需要自旋的次数，</span></span><br><span class="line">    <span class="built_in">int</span> spins = ((head.next == s) ?</span><br><span class="line">                 (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 如果被中断了，那么取消这个节点</span></span><br><span class="line">        <span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">            <span class="comment">// 就是将当前节点 s 中的 item 属性设置为 this</span></span><br><span class="line">            s.tryCancel(e);</span><br><span class="line">        <span class="keyword">Object</span> x = s.item;</span><br><span class="line">        <span class="comment">// 这里是这个方法的唯一的出口</span></span><br><span class="line">        <span class="keyword">if</span> (x != e)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="comment">// 如果需要，检测是否超时</span></span><br><span class="line">        <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">            nanos -= now - lastTime;</span><br><span class="line">            lastTime = now;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                s.tryCancel(e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line">            --spins;</span><br><span class="line">        <span class="comment">// 如果自旋达到了最大的次数，那么检测</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)</span><br><span class="line">            s.waiter = w;</span><br><span class="line">        <span class="comment">// 如果自旋到了最大的次数，那么线程挂起，等待唤醒</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// spinForTimeoutThreshold 这个之前讲 AQS 的时候其实也说过，剩余时间小于这个阈值的时候，就</span></span><br><span class="line">        <span class="comment">// 不要进行挂起了，自旋的性能会比较好</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Doug Lea 的巧妙之处在于，将各个代码凑在了一起，使得代码非常简洁，当然也同时增加了我们的阅读负担，看代码的时候，还是得仔细想想各种可能的情况。</p><p>下面，再说说前面说的公平模式和非公平模式的区别。</p><p>相信大家心里面已经有了公平模式的工作流程的概念了，我就简单说说 TransferStack 的算法，就不分析源码了。</p><ol><li>当调用这个方法时，如果队列是空的，或者队列中的节点和当前的线程操作类型一致（如当前操作是 put 操作，而栈中的元素也都是写线程）。这种情况下，将当前线程加入到等待栈中，等待配对。然后返回相应的元素，或者如果被取消了的话，返回 null。</li><li>如果栈中有等待节点，而且与当前操作可以匹配（如栈里面都是读操作线程，当前线程是写操作线程，反之亦然）。将当前节点压入栈顶，和栈中的节点进行匹配，然后将这两个节点出栈。配对和出栈的动作其实也不是必须的，因为下面的一条会执行同样的事情。</li><li>如果栈顶是进行匹配而入栈的节点，帮助其进行匹配并出栈，然后再继续操作。</li></ol><p>应该说，TransferStack 的源码要比 TransferQueue 的复杂一些，如果读者感兴趣，请自行进行源码阅读。</p><h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p>带排序的 BlockingQueue 实现，其并发控制采用的是 ReentrantLock，队列为无界队列（ArrayBlockingQueue 是有界队列，LinkedBlockingQueue 也可以通过在构造函数中传入 capacity 指定队列最大的容量，但是 PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容）。</p><p>简单地说，它就是 PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。</p><p>它的源码相对比较简单，本节将介绍其核心源码部分。</p><p>我们来看看它有哪些属性：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法中，如果不指定大小的话，默认大小为 11</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"><span class="comment">// 数组的最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个就是存放数据的数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">Object</span>[] queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列当前大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="built_in">int</span> <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大小比较器，如果按照自然序排序，那么此属性可设置为 null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发控制所用的锁，所有的 public 且涉及到线程安全的方法，都必须先获取到这个锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个很好理解，其实例由上面的 lock 属性创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个也是用于锁，用于数组扩容的时候，需要先获取到这个锁，才能进行扩容操作</span></span><br><span class="line"><span class="comment">// 其使用 CAS 操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="built_in">int</span> allocationSpinLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于序列化和反序列化的时候用，对于 PriorityBlockingQueue 我们应该比较少使用到序列化</span></span><br><span class="line"><span class="keyword">private</span> PriorityQueue q;</span><br></pre></td></tr></table></figure><p>此类实现了 Collection 和 Iterator 接口中的所有接口方法，对其对象进行迭代并遍历时，不能保证有序性。如果你想要实现有序遍历，建议采用 Arrays.sort(queue.toArray()) 进行处理。PriorityBlockingQueue 提供了 drainTo 方法用于将部分或全部元素有序地填充（准确说是转移，会删除原队列中的元素）到另一个集合中。还有一个需要说明的是，如果两个对象的优先级相同（compare 方法返回 0），此队列并不保证它们之间的顺序。</p><p>PriorityBlockingQueue 使用了基于数组的二叉堆来存放元素，所有的 public 方法采用同一个 lock 进行并发控制。</p><p>二叉堆：一颗完全二叉树，它非常适合用数组进行存储，对于数组中的元素 a[i]，其左子节点为 a[2_i+1]，其右子节点为 a[2_i + 2]，其父节点为 a[(i-1)/2]，其堆序性质为，每个节点的值都小于其左右子节点的值。二叉堆中最小的值就是根节点，但是删除根节点是比较麻烦的，因为需要调整树。</p><p>简单用个图解释一下二叉堆，我就不说太多专业的严谨的术语了，这种数据结构的优点是一目了然的，最小的元素一定是根元素，它是一棵满的树，除了最后一层，最后一层的节点从左到右紧密排列。</p><p><img src="https://javadoop.com/blogimages/java-concurrent-queue/priority-blocking-queue-1.png" alt="priority-blocking-queue-1"></p><p>下面开始 PriorityBlockingQueue 的源码分析，首先我们来看看构造方法:</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造方法，采用默认值(11)来进行初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定数组的初始大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定比较器</span></span><br><span class="line"><span class="keyword">public</span> PriorityBlockingQueue(<span class="keyword">int</span> initialCapacity,</span><br><span class="line">                             Comparator&lt;? <span class="keyword">super</span> E&gt; comparator) &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在构造方法中就先填充指定的集合中的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(Collection&lt;? <span class="keyword">extends</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">boolean</span> heapify = <span class="keyword">true</span>; <span class="comment">// true if not known to be in heap order</span></span><br><span class="line">    <span class="keyword">boolean</span> screen = <span class="keyword">true</span>;  <span class="comment">// true if must screen for nulls</span></span><br><span class="line">    <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SortedSet&lt;?&gt;) &#123;</span><br><span class="line">        SortedSet&lt;? <span class="keyword">extends</span> E&gt; ss = (SortedSet&lt;? <span class="keyword">extends</span> E&gt;) c;</span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) ss.comparator();</span><br><span class="line">        heapify = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(c <span class="keyword">instanceof</span> PriorityBlockingQueue&lt;?&gt;)</span> </span>&#123;</span><br><span class="line">        PriorityBlockingQueue&lt;? <span class="keyword">extends</span> E&gt; pq =</span><br><span class="line">            (PriorityBlockingQueue&lt;? <span class="keyword">extends</span> E&gt;) c;</span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) pq.comparator();</span><br><span class="line">        screen = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (pq.getClass() == PriorityBlockingQueue.class) <span class="comment">// exact match</span></span><br><span class="line">            heapify = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="comment">// If c.toArray incorrectly doesn't return Object[], copy it.</span></span><br><span class="line">    <span class="keyword">if</span> (a.getClass() != Object[].class)</span><br><span class="line">        a = Arrays.copyOf(a, n, Object[].class);</span><br><span class="line">    <span class="keyword">if</span> (screen &amp;&amp; (n == <span class="number">1</span> || <span class="keyword">this</span>.comparator != <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (a[i] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.queue = a;</span><br><span class="line">    <span class="keyword">this</span>.size = n;</span><br><span class="line">    <span class="keyword">if</span> (heapify)</span><br><span class="line">        heapify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们来看看其内部的自动扩容实现：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> void tryGrow(Object[] array, int oldCap) &#123;</span><br><span class="line">    <span class="comment">// 这边做了释放锁的操作</span></span><br><span class="line">    lock.unlock(); <span class="comment">// must release and then re-acquire main lock</span></span><br><span class="line">    Object[] <span class="keyword">new</span><span class="type">Array</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 用 CAS 操作将 allocationSpinLock 由 0 变为 1，也算是获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (allocationSpinLock == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, allocationSpinLockOffset,</span><br><span class="line">                                 <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果节点个数小于 64，那么增加的 oldCap + 2 的容量</span></span><br><span class="line">            <span class="comment">// 如果节点数大于等于 64，那么增加 oldCap 的一半</span></span><br><span class="line">            <span class="comment">// 所以节点数较小时，增长得快一些</span></span><br><span class="line">            int <span class="keyword">new</span><span class="type">Cap</span> = oldCap + ((oldCap &lt; <span class="number">64</span>) ?</span><br><span class="line">                                   (oldCap + <span class="number">2</span>) :<span class="type"></span></span><br><span class="line"><span class="type">                                   </span>(oldCap &gt;&gt; <span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 这里有可能溢出</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Cap</span> - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;    <span class="comment">// possible overflow</span></span><br><span class="line">                int minCap = oldCap + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (minCap &lt; <span class="number">0</span> || minCap &gt; MAX_ARRAY_SIZE)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">OutOfMemoryError</span>();</span><br><span class="line">                <span class="keyword">new</span><span class="type">Cap</span> = MAX_ARRAY_SIZE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 queue != array，那么说明有其他线程给 queue 分配了其他的空间</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Cap</span> &gt; oldCap &amp;&amp; queue == array)</span><br><span class="line">                <span class="comment">// 分配一个新的大数组</span></span><br><span class="line">                <span class="keyword">new</span><span class="type">Array</span> = <span class="keyword">new</span> <span class="type">Object</span>[<span class="keyword">new</span><span class="type">Cap</span>];</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            <span class="comment">// 重置，也就是释放锁</span></span><br><span class="line">            allocationSpinLock = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有其他的线程也在做扩容的操作</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Array</span> == <span class="literal">null</span>) <span class="comment">// back off if another thread is allocating</span></span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="comment">// 重新获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="comment">// 将原来数组中的元素复制到新分配的大数组中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Array</span> != <span class="literal">null</span> &amp;&amp; queue == array) &#123;</span><br><span class="line">        queue = <span class="keyword">new</span><span class="type">Array</span>;</span><br><span class="line">        System.arraycopy(array, <span class="number">0</span>, <span class="keyword">new</span><span class="type">Array</span>, <span class="number">0</span>, oldCap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容方法对并发的控制也非常的巧妙，释放了原来的独占锁 lock，这样的话，扩容操作和读操作可以同时进行，提高吞吐量。</p><p>下面，我们来分析下写操作 put 方法和读操作 take 方法。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span>(<span class="params">E e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 直接调用 offer 方法，因为前面我们也说了，在这里，put 方法不会阻塞</span></span><br><span class="line">    offer(e); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">offer</span>(<span class="params">E e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">    <span class="comment">// 首先获取到独占锁</span></span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">int</span> n, cap;</span><br><span class="line">    Object[] array;</span><br><span class="line">    <span class="comment">// 如果当前队列中的元素个数 &gt;= 数组的大小，那么需要扩容了</span></span><br><span class="line">    <span class="keyword">while</span> ((n = size) &gt;= (cap = (array = queue).length))</span><br><span class="line">        tryGrow(array, cap);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Comparator&lt;? super E&gt; cmp = comparator;</span><br><span class="line">        <span class="comment">// 节点添加到二叉堆中</span></span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="literal">null</span>)</span><br><span class="line">            siftUpComparable(n, e, array);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUpUsingComparator(n, e, array, cmp);</span><br><span class="line">        <span class="comment">// 更新 size</span></span><br><span class="line">        size = n + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 唤醒等待的读线程</span></span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于二叉堆而言，插入一个节点是简单的，插入的节点如果比父节点小，交换它们，然后继续和父节点比较。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法就是将数据 x 插入到数组 array 的位置 k 处，然后再调整树</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> siftUpComparable(<span class="built_in">int</span> k, T x, <span class="keyword">Object</span>[] array) &#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> T&gt; <span class="built_in">key</span> = (Comparable&lt;? <span class="keyword">super</span> T&gt;) x;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 二叉堆中 a[k] 节点的父节点位置</span></span><br><span class="line">        <span class="built_in">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">Object</span> e = array[parent];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">key</span>.compareTo((T) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        array[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    array[k] = <span class="built_in">key</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用图来示意一下，我们接下来要将 11 插入到队列中，看看 siftUp 是怎么操作的。</p><p><img src="https://javadoop.com/blogimages/java-concurrent-queue/priority-blocking-queue-2.png" alt="priority-blocking-queue-2"></p><p>我们再看看 take 方法：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span>(<span class="params"></span>) throws InterruptedException </span>&#123;</span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">    <span class="comment">// 独占锁</span></span><br><span class="line">    <span class="keyword">lock</span>.lockInterruptibly();</span><br><span class="line">    E result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// dequeue 出队</span></span><br><span class="line">        <span class="keyword">while</span> ( (result = dequeue()) == <span class="literal">null</span>)</span><br><span class="line">            notEmpty.<span class="keyword">await</span>();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E dequeue() &#123;</span><br><span class="line">    int n = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Object[] <span class="keyword">array</span> = queue;</span><br><span class="line">        <span class="comment">// 队头，用于返回</span></span><br><span class="line">        E result = (E) <span class="keyword">array</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 队尾元素先取出</span></span><br><span class="line">        E x = (E) <span class="keyword">array</span>[n];</span><br><span class="line">        <span class="comment">// 队尾置空</span></span><br><span class="line">        <span class="keyword">array</span>[n] = <span class="keyword">null</span>;</span><br><span class="line">        Comparator<span class="meta">&lt;?</span> super E&gt; cmp = comparator;</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">            siftDownComparable(<span class="number">0</span>, x, <span class="keyword">array</span>, n);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownUsingComparator(<span class="number">0</span>, x, <span class="keyword">array</span>, n, cmp);</span><br><span class="line">        size = n;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dequeue 方法返回队头，并调整二叉堆的树，调用这个方法必须先获取独占锁。</p><p>废话不多说，出队是非常简单的，因为队头就是最小的元素，对应的是数组的第一个元素。难点是队头出队后，需要调整树。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> siftDownComparable(<span class="built_in">int</span> k, T x, <span class="keyword">Object</span>[] array,</span><br><span class="line">                                           <span class="built_in">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> T&gt; <span class="built_in">key</span> = (Comparable&lt;? <span class="keyword">super</span> T&gt;)x;</span><br><span class="line">        <span class="comment">// 这里得到的 half 肯定是非叶节点</span></span><br><span class="line">        <span class="comment">// a[n] 是最后一个元素，其父节点是 a[(n-1)/2]。所以 n &gt;&gt;&gt; 1 代表的节点肯定不是叶子节点</span></span><br><span class="line">        <span class="comment">// 下面，我们结合图来一行行分析，这样比较直观简单</span></span><br><span class="line">        <span class="comment">// 此时 k 为 0, x 为 17，n 为 9</span></span><br><span class="line">        <span class="built_in">int</span> half = n &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 得到 half = 4</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="comment">// 先取左子节点</span></span><br><span class="line">            <span class="built_in">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 得到 child = 1</span></span><br><span class="line">            <span class="keyword">Object</span> c = array[child];  <span class="comment">// c = 12</span></span><br><span class="line">            <span class="built_in">int</span> right = child + <span class="number">1</span>;  <span class="comment">// right = 2</span></span><br><span class="line">            <span class="comment">// 如果右子节点存在，而且比左子节点小</span></span><br><span class="line">            <span class="comment">// 此时 array[right] = 20，所以条件不满足</span></span><br><span class="line">            <span class="keyword">if</span> (right &lt; n &amp;&amp;</span><br><span class="line">                ((Comparable&lt;? <span class="keyword">super</span> T&gt;) c).compareTo((T) array[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                c = array[child = right];</span><br><span class="line">            <span class="comment">// key = 17, c = 12，所以条件不满足</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">key</span>.compareTo((T) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 把 12 填充到根节点</span></span><br><span class="line">            array[k] = c;</span><br><span class="line">            <span class="comment">// k 赋值后为 1</span></span><br><span class="line">            k = child;</span><br><span class="line">            <span class="comment">// 一轮过后，我们发现，12 左边的子树和刚刚的差不多，都是缺少根节点，接下来处理就简单了</span></span><br><span class="line">        &#125;</span><br><span class="line">        array[k] = <span class="built_in">key</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://javadoop.com/blogimages/java-concurrent-queue/priority-blocking-queue-3.png" alt="priority-blocking-queue-3"></p><p>记住二叉堆是一棵完全二叉树，那么根节点 10 拿掉后，最后面的元素 17 必须找到合适的地方放置。首先，17 和 10 不能直接交换，那么先将根节点 10 的左右子节点中较小的节点往上滑，即 12 往上滑，然后原来 12 留下了一个空节点，然后再把这个空节点的较小的子节点往上滑，即 13 往上滑，最后，留出了位子，17 补上即可。</p><p>我稍微调整下这个树，以便读者能更明白：</p><p><img src="https://javadoop.com/blogimages/java-concurrent-queue/priority-blocking-queue-4.png" alt="priority-blocking-queue-4"></p><p>好了， PriorityBlockingQueue 我们也说完了。</p><h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><blockquote><p>原文出处<a href="http://cmsblogs.com/" target="_blank" rel="noopener">http://cmsblogs.com/</a> 『chenssy』</p></blockquote><p>DelayQueue是一个支持延时获取元素的无界阻塞队列。里面的元素全部都是“可延期”的元素，列头的元素是最先“到期”的元素，如果队列里面没有元素到期，是不能从列头获取元素的，哪怕有元素也不行。也就是说只有在延迟期到时才能够从队列中取元素。</p><p>DelayQueue主要用于两个方面：</p><ul><li>缓存：清掉缓存中超时的缓存数据</li><li>任务超时处理</li></ul><p>DelayQueue</p><p>DelayQueue实现的关键主要有如下几个：</p><ol><li>可重入锁ReentrantLock</li><li>用于阻塞和通知的Condition对象</li><li>根据Delay时间排序的优先级队列：PriorityQueue</li><li>用于优化阻塞通知的线程元素leader</li></ol><p>ReentrantLock、Condition这两个对象就不需要阐述了，他是实现整个BlockingQueue的核心。PriorityQueue是一个支持优先级线程排序的队列（参考<a href="http://cmsblogs.com/?p=2407" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之阻塞队列：PriorityBlockingQueue</a>），leader后面阐述。这里我们先来了解Delay，他是实现延时操作的关键。</p><p>Delayed</p><p>Delayed接口是用来标记那些应该在给定延迟时间之后执行的对象，它定义了一个long getDelay(TimeUnit unit)方法，该方法返回与此对象相关的的剩余时间。同时实现该接口的对象必须定义一个compareTo 方法，该方法提供与此接口的 getDelay 方法一致的排序。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Delayed extends Comparable&lt;Delayed&gt; &#123;</span><br><span class="line">    long getDelay(TimeUnit unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何使用该接口呢？上面说的非常清楚了，实现该接口的getDelay()方法，同时定义compareTo()方法即可。</p><p>内部结构</p><p>先看DelayQueue的定义：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue&lt;E</span> <span class="keyword">extends</span> <span class="title">Delayed&gt;</span> <span class="keyword">extends</span> <span class="title">AbstractQueue&lt;E&gt;</span></span></span><br><span class="line"><span class="class">        <span class="title">implements</span> <span class="title">BlockingQueue&lt;E&gt;</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 可重入锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> transient <span class="type">ReentrantLock</span> lock = <span class="keyword">new</span> <span class="type">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">/** 支持优先级的BlockingQueue */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">PriorityQueue</span>&lt;<span class="type">E</span>&gt; q = <span class="keyword">new</span> <span class="type">PriorityQueue</span>&lt;<span class="type">E</span>&gt;();</span><br><span class="line">    <span class="comment">/** 用于优化阻塞 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Thread</span> leader = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/** Condition */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> available = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 省略很多代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了DelayQueue的内部结构就对上面几个关键点一目了然了，但是这里有一点需要注意，DelayQueue的元素都必须继承Delayed接口。同时也可以从这里初步理清楚DelayQueue内部实现的机制了：以支持优先级无界队列的PriorityQueue作为一个容器，容器里面的元素都应该实现Delayed接口，在每次往优先级队列中添加元素时以元素的过期时间作为排序条件，最先过期的元素放在优先级最高。</p><p>offer()</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">offer</span>(<span class="params">E e</span>) </span>&#123;</span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 向 PriorityQueue中插入元素</span></span><br><span class="line">        q.offer(e);</span><br><span class="line">        <span class="comment">// 如果当前元素的对首元素（优先级最高），leader设置为空，唤醒所有等待线程</span></span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">            leader = <span class="literal">null</span>;</span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无界队列，永远返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>offer(E e)就是往PriorityQueue中添加元素，具体可以参考（<a href="http://cmsblogs.com/?p=2407" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之阻塞队列：PriorityBlockingQueue</a>）。整个过程还是比较简单，但是在判断当前元素是否为对首元素，如果是的话则设置leader=null，这是非常关键的一个步骤，后面阐述。</p><p>take()</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span>(<span class="params"></span>) throws InterruptedException </span>&#123;</span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">    <span class="keyword">lock</span>.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 对首元素</span></span><br><span class="line">            E first = q.peek();</span><br><span class="line">            <span class="comment">// 对首为空，阻塞，等待off()操作唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="literal">null</span>)</span><br><span class="line">                available.<span class="keyword">await</span>();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 获取对首元素的超时时间</span></span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="comment">// &lt;=0 表示已过期，出对，return</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> q.poll();</span><br><span class="line">                first = <span class="literal">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                <span class="comment">// leader != null 证明有其他线程在操作，阻塞</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="literal">null</span>)</span><br><span class="line">                    available.<span class="keyword">await</span>();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 否则将leader 设置为当前线程，独占</span></span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 超时阻塞</span></span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 释放leader</span></span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 唤醒阻塞线程</span></span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="literal">null</span> &amp;&amp; q.peek() != <span class="literal">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是获取对首元素，如果对首元素的延时时间 delay &lt;= 0 ，则可以出对了，直接return即可。否则设置first = null，这里设置为null的主要目的是为了避免内存泄漏。如果 leader != null 则表示当前有线程占用，则阻塞，否则设置leader为当前线程，然后调用awaitNanos()方法超时等待。</p><p>first = null</p><p>这里为什么如果不设置first = null，则会引起内存泄漏呢？线程A到达，列首元素没有到期，设置leader = 线程A，这是线程B来了因为leader != null，则会阻塞，线程C一样。假如线程阻塞完毕了，获取列首元素成功，出列。这个时候列首元素应该会被回收掉，但是问题是它还被线程B、线程C持有着，所以不会回收，这里只有两个线程，如果有线程D、线程E…呢？这样会无限期的不能回收，就会造成内存泄漏。</p><p>这个入队、出对过程和其他的阻塞队列没有很大区别，无非是在出对的时候增加了一个到期时间的判断。同时通过leader来减少不必要阻塞。</p><p>ConcurrentLinkedQueue</p><blockquote><p>原文出处<a href="http://cmsblogs.com/" target="_blank" rel="noopener">http://cmsblogs.com/</a> 『chenssy』</p></blockquote><p>要实现一个线程安全的队列有两种方式：阻塞和非阻塞。阻塞队列无非就是锁的应用，而非阻塞则是CAS算法的应用。下面我们就开始一个非阻塞算法的研究：CoucurrentLinkedQueue。</p><p>ConcurrentLinkedQueue是一个基于链接节点的无边界的线程安全队列，它采用FIFO原则对元素进行排序。采用“wait-free”算法（即CAS算法）来实现的。</p><p>CoucurrentLinkedQueue规定了如下几个不变性：</p><ol><li>在入队的最后一个元素的next为null</li><li>队列中所有未删除的节点的item都不能为null且都能从head节点遍历到</li><li>对于要删除的节点，不是直接将其设置为null，而是先将其item域设置为null（迭代器会跳过item为null的节点）</li><li>允许head和tail更新滞后。这是什么意思呢？意思就说是head、tail不总是指向第一个元素和最后一个元素（后面阐述）。</li></ol><p>head的不变性和可变性：</p><ul><li>不变性<ol><li>所有未删除的节点都可以通过head节点遍历到</li><li>head不能为null</li><li>head节点的next不能指向自身</li></ol></li><li>可变性<ol><li>head的item可能为null，也可能不为null<br>2.允许tail滞后head，也就是说调用succc()方法，从head不可达tail</li></ol></li></ul><p>tail的不变性和可变性</p><ul><li>不变性<ol><li>tail不能为null</li></ol></li><li>可变性<ol><li>tail的item可能为null，也可能不为null</li><li>tail节点的next域可以指向自身<br>3.允许tail滞后head，也就是说调用succc()方法，从head不可达tail</li></ol></li></ul><p>这些特性是否已经晕了？没关系，我们看下面的源码分析就可以理解这些特性了。</p><h2 id="ConcurrentLinkedQueue源码分析"><a href="#ConcurrentLinkedQueue源码分析" class="headerlink" title="ConcurrentLinkedQueue源码分析"></a>ConcurrentLinkedQueue源码分析</h2><p>CoucurrentLinkedQueue的结构由head节点和tail节点组成，每个节点由节点元素item和指向下一个节点的next引用组成，而节点与节点之间的关系就是通过该next关联起来的，从而组成一张链表的队列。节点Node为ConcurrentLinkedQueue的内部类，定义如下：</p><pre name="code">  private  static  class  Node<e>  {  /** 节点元素域 */  volatile E item;  volatile  Node<e>  next;  //初始化,获得item 和 next 的偏移量,为后期的CAS做准备  Node(E item)  { UNSAFE.putObject(this, itemOffset, item);  }  boolean casItem(E cmp, E val)  {  return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val);  }  void lazySetNext(Node<e> val)  { UNSAFE.putOrderedObject(this, nextOffset, val);  }  boolean casNext(Node<e> cmp,  Node<e> val)  {  return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);  }  // Unsafe mechanics  private  static  final sun.misc.Unsafe UNSAFE;  /** 偏移量 */  private  static  final  long itemOffset;  /** 下一个元素的偏移量 */  private  static  final  long nextOffset;  static  {  try  { UNSAFE = sun.misc.Unsafe.getUnsafe();  Class<?> k =  Node.class; itemOffset = UNSAFE.objectFieldOffset (k.getDeclaredField("item")); nextOffset = UNSAFE.objectFieldOffset (k.getDeclaredField("next"));  }  catch  (Exception e)  {  throw  new  Error(e);  }  }  }</e></e></e></e></e></pre><h3 id="入列"><a href="#入列" class="headerlink" title="入列"></a>入列</h3><p>入列，我们认为是一个非常简单的过程：tail节点的next执行新节点，然后更新tail为新节点即可。从单线程角度我们这么理解应该是没有问题的，但是多线程呢？如果一个线程正在进行插入动作，那么它必须先获取尾节点，然后设置尾节点的下一个节点为当前节点，但是如果已经有一个线程刚刚好完成了插入，那么尾节点是不是发生了变化？对于这种情况ConcurrentLinkedQueue怎么处理呢？我们先看源码：</p><p>offer(E e)：将指定元素插入都队列尾部：</p><pre name="code">public  boolean offer(E e)  {  //检查节点是否为null checkNotNull(e);  // 创建新节点  final  Node<e> newNode =  new  Node<e>(e);  //死循环 直到成功为止  for  (Node<e> t = tail, p = t;;)  {  Node<e> q = p.next;  // q == null 表示 p已经是最后一个节点了，尝试加入到队列尾  // 如果插入失败，则表示其他线程已经修改了p的指向  if  (q ==  null)  {  // --- 1  // casNext：t节点的next指向当前节点  // casTail：设置tail 尾节点  if  (p.casNext(null, newNode))  {  // --- 2  // node 加入节点后会导致tail距离最后一个节点相差大于一个，需要更新tail  if  (p != t)  // --- 3 casTail(t, newNode);  // --- 4  return  true;  }  }  // p == q 等于自身  else  if  (p == q)  // --- 5  // p == q 代表着该节点已经被删除了  // 由于多线程的原因，我们offer()的时候也会poll()，如果offer()的时候正好该节点已经poll()了  // 那么在poll()方法中的updateHead()方法会将head指向当前的q，而把p.next指向自己，即：p.next == p  // 这样就会导致tail节点滞后head（tail位于head的前面），则需要重新设置p p =  (t !=  (t = tail))  ? t : head;  // --- 6  // tail并没有指向尾节点  else  // tail已经不是最后一个节点，将p指向最后一个节点 p =  (p != t && t !=  (t = tail))  ? t : q;  // --- 7  }  }</e></e></e></e></pre><p>光看源码还是有点儿迷糊的，插入节点一次分析就会明朗很多。</p><p>初始化</p><p>ConcurrentLinkedQueue初始化时head、tail存储的元素都为null，且head等于tail：</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201703160001.png" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201703160001_thumb.png" alt="201703160001" title="201703160001"></a></p><p>添加元素A</p><p>按照程序分析：第一次插入元素A，head = tail = dummyNode，所有q = p.next = null，直接走步骤2：p.casNext(null, newNode)，由于 p == t成立，所以不会执行步骤3：casTail(t, newNode)，直接return。插入A节点后如下：</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201703160002.png" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201703160002_thumb.png" alt="201703160002" title="201703160002"></a></p><p>添加元素B</p><p>q = p.next = A ,p = tail = dummyNode，所以直接跳到步骤7：p = (p != t &amp;&amp; t != (t = tail)) ? t : q;。此时p = q，然后进行第二次循环 q = p.next = null，步骤2：p == null成立，将该节点插入，因为p = q，t = tail，所以步骤3：p != t 成立，执行步骤4：casTail(t, newNode)，然后return。如下：<br><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201703160003.png" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201703160003_thumb.png" alt="201703160003" title="201703160003"></a></p><p>添加节点C</p><p>此时t = tail ,p = t，q = p.next = null，和插入元素A无异，如下：<br><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201703160004.png" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201703160004_thumb.png" alt="201703160004" title="201703160004"></a></p><p>这里整个offer()过程已经分析完成了，可能p == q 有点儿难理解，p 不是等于q.next么，怎么会有p == q呢？这个疑问我们在出列poll()中分析</p><h3 id="出列"><a href="#出列" class="headerlink" title="出列"></a>出列</h3><p>ConcurrentLinkedQueue提供了poll()方法进行出列操作。入列主要是涉及到tail，出列则涉及到head。我们先看源码：</p><pre name="code">public E poll()  {  // 如果出现p被删除的情况需要从head重新开始 restartFromHead:  // 这是什么语法？真心没有见过  for  (;;)  {  for  (Node<e> h = head, p = h, q;;)  {  // 节点 item E item = p.item;  // item 不为null，则将item 设置为null  if  (item !=  null  && p.casItem(item,  null))  {  // --- 1  // p != head 则更新head  if  (p != h)  // --- 2  // p.next != null，则将head更新为p.next ,否则更新为p updateHead(h,  ((q = p.next)  !=  null)  ? q : p);  // --- 3  return item;  }  // p.next == null 队列为空  else  if  ((q = p.next)  ==  null)  {  // --- 4 updateHead(h, p);  return  null;  }  // 当一个线程在poll的时候，另一个线程已经把当前的p从队列中删除——将p.next = p，p已经被移除不能继续，需要重新开始  else  if  (p == q)  // --- 5  continue restartFromHead;  else p = q;  // --- 6  }  }  }</e></pre><p>这个相对于offer()方法而言会简单些，里面有一个很重要的方法：updateHead()，该方法用于CAS更新head节点，如下：</p><pre name="code">  final  void updateHead(Node<e> h,  Node<e> p)  {  if  (h != p && casHead(h, p)) h.lazySetNext(h);  }</e></e></pre><p>我们先将上面offer()的链表poll()掉，添加A、B、C节点结构如下：</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201703160004_2.png" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201703160004_2_thumb.png" alt="201703160004_2" title="201703160004_2"></a></p><p>poll A</p><p>head = dumy，p = head， item = p.item = null，步骤1不成立，步骤4：(q = p.next) == null不成立，p.next = A，跳到步骤6，下一个循环，此时p = A，所以步骤1 item != null，进行p.casItem(item, null)成功，此时p == A != h，所以执行步骤3：updateHead(h, ((q = p.next) != null) ? q : p)，q = p.next = B != null，则将head CAS更新成B，如下：</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201703160005.png" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201703160005_thumb.png" alt="201703160005" title="201703160005"></a></p><p>poll B</p><p>head = B ， p = head = B，item = p.item = B，步骤成立，步骤2：p != h 不成立，直接return，如下：</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201703160006.png" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201703160006_thumb.png" alt="201703160006" title="201703160006"></a></p><p>poll C</p><p>head = dumy ，p = head = dumy，tiem = p.item = null，步骤1不成立，跳到步骤4：(q = p.next) == null，不成立，然后跳到步骤6，此时，p = q = C，item = C(item)，步骤1成立，所以讲C（item）设置为null，步骤2：p != h成立，执行步骤3：updateHead(h, ((q = p.next) != null) ? q : p)，如下：</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201703160007.png" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201703160007_thumb.png" alt="201703160007" title="201703160007"></a></p><p>看到这里是不是一目了然了，在这里我们再来分析offer()的步骤5：</p><pre name="code">else  if(p == q){ p =  (t !=  (t = tail))? t : head;  }</pre><p>ConcurrentLinkedQueue中规定，p == q表明，该节点已经被删除了，也就说tail滞后于head，head无法通过succ()方法遍历到tail，怎么做？ (t != (t = tail))? t : head;（这段代码的可读性实在是太差了，真他妈难理解：不知道是否可以理解为t != tail ? tail : head）这段代码主要是来判读tail节点是否已经发生了改变，如果发生了改变，则说明tail已经重新定位了，只需要重新找到tail即可，否则就只能指向head了。</p><p>就上面那个我们再次插入一个元素D。则p = head，q = p.next = null，执行步骤1： q = null且 p != t ，所以执行步骤4:，如下：</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201703160008_2.png" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201703160008_2_thumb.png" alt="201703160008_2" title="201703160008_2"></a></p><p>再插入元素E，q = p.next = null，p == t，所以插入E后如下：</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201703160009_2.png" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/07/201703160009_2_thumb.png" alt="201703160009_2" title="201703160009_2"></a></p><p>到这里ConcurrentLinkedQueue的整个入列、出列都已经分析完毕了，对于ConcurrentLinkedQueue LZ真心感觉难看懂，看懂之后也感叹设计得太精妙了，利用CAS来完成数据操作，同时允许队列的不一致性，这种弱一致性确实是非常强大。再次感叹Doug Lea的天才。</p><h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><blockquote><p>原文出处<a href="http://cmsblogs.com/" target="_blank" rel="noopener">http://cmsblogs.com/</a> 『chenssy』</p></blockquote><p>前面提到的各种BlockingQueue对读或者写都是锁上整个队列，在并发量大的时候，各种锁是比较耗资源和耗时间的，而前面的SynchronousQueue虽然不会锁住整个队列，但它是一个没有容量的“队列”，那么有没有这样一种队列，它即可以像其他的BlockingQueue一样有容量又可以像SynchronousQueue一样不会锁住整个队列呢？有！答案就是LinkedTransferQueue。</p><p>LinkedTransferQueue是基于链表的FIFO无界阻塞队列，它出现在JDK7中。Doug Lea 大神说LinkedTransferQueue是一个聪明的队列。它是<a href="http://cmsblogs.com/?p=2353" target="_blank" rel="noopener">ConcurrentLinkedQueue</a>、<a href="http://cmsblogs.com/?p=2418" target="_blank" rel="noopener">SynchronousQueue</a> (公平模式下)、无界的<a href="http://cmsblogs.com/?p=2381" target="_blank" rel="noopener">LinkedBlockingQueues</a>等的超集。既然这么牛逼，那势必要弄清楚其中的原理了。</p><h2 id="LinkedTransferQueue-1"><a href="#LinkedTransferQueue-1" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h2><p>看源码之前我们先稍微了解下它的原理，这样看源码就会有迹可循了。</p><p>LinkedTransferQueue采用一种预占模式。什么意思呢？有就直接拿走，没有就占着这个位置直到拿到或者超时或者中断。即消费者线程到队列中取元素时，如果发现队列为空，则会生成一个null节点，然后park住等待生产者。后面如果生产者线程入队时发现有一个null元素节点，这时生产者就不会入列了，直接将元素填充到该节点上，唤醒该节点的线程，被唤醒的消费者线程拿东西走人。是不是有点儿<a href="http://cmsblogs.com/?p=2418" target="_blank" rel="noopener">SynchronousQueue</a>的味道？</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>LinkedTransferQueue与其他的BlockingQueue一样，同样继承AbstractQueue类，但是它实现了TransferQueue，TransferQueue接口继承BlockingQueue，所以TransferQueue算是对BlockingQueue一种扩充，该接口提供了一整套的transfer接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransferQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若当前存在一个正在等待获取的消费者线程（使用take()或者poll()函数），使用该方法会即刻转移/传输对象元素e；</span></span><br><span class="line"><span class="comment">     * 若不存在，则返回false，并且不进入队列。这是一个不阻塞的操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryTransfer</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若当前存在一个正在等待获取的消费者线程，即立刻移交之；</span></span><br><span class="line"><span class="comment">     * 否则，会插入当前元素e到队列尾部，并且等待进入阻塞状态，到有消费者线程取走该元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若当前存在一个正在等待获取的消费者线程，会立即传输给它;否则将插入元素e到队列尾部，并且等待被消费者线程获取消费掉；</span></span><br><span class="line"><span class="comment">     * 若在指定的时间内元素e无法被消费者线程获取，则返回false，同时该元素被移除。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryTransfer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否存在消费者线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasWaitingConsumer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有等待获取元素的消费线程数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWaitingConsumerCount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相对于其他的BlockingQueue，LinkedTransferQueue就多了上面几个方法。这几个方法在LinkedTransferQueue中起到了核心作用。</p><p>LinkedTransferQueue定义的变量如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否为多核</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> MP =</span><br><span class="line">        <span class="keyword">Runtime</span>.getRuntime().availableProcessors() &gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自旋次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FRONT_SPINS   = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前驱节点正在处理，当前节点需要自旋的次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHAINED_SPINS = FRONT_SPINS &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SWEEP_THRESHOLD = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头节点</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点失败的次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sweepVotes;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 调用xfer()方法时需要传入,区分不同处理</span></span><br><span class="line"><span class="comment"> * xfer()方法是LinkedTransferQueue的最核心的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NOW   = <span class="number">0</span>; <span class="comment">// for untimed poll, tryTransfer</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ASYNC = <span class="number">1</span>; <span class="comment">// for offer, put, add</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SYNC  = <span class="number">2</span>; <span class="comment">// for transfer, take</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMED = <span class="number">3</span>; <span class="comment">// for timed poll, tryTransfer</span></span><br></pre></td></tr></table></figure><h3 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h3><p>Node节点由四个部分构成：</p><ul><li>isData：表示该节点是存放数据还是获取数据</li><li>item：存放数据，isData为false时，该节点为null，为true时，匹配后，该节点会置为null</li><li>next：指向下一个节点</li><li>waiter：park住消费者线程，线程就放在这里</li></ul><p>结构如下：</p><p><img src="https://img-blog.csdn.net/20170924210642971?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hlbnNzeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>源码如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> class Node &#123;</span><br><span class="line">    <span class="comment">// 表示该节点是存放数据还是获取数据</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">boolean</span> isData;</span><br><span class="line">    <span class="comment">// 存放数据，isData为false时，该节点为null，为true时，匹配后，该节点会置为null</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">Object</span> item;</span><br><span class="line">    <span class="comment">//指向下一个节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// park住消费者线程，线程就放在这里</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter; <span class="comment">// null until waiting</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CAS Next域</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">boolean</span> casNext(Node cmp, Node val) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CAS itme域</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">boolean</span> casItem(<span class="keyword">Object</span> cmp, <span class="keyword">Object</span> val) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node(<span class="keyword">Object</span> item, <span class="built_in">boolean</span> isData) &#123;</span><br><span class="line">        UNSAFE.putObject(<span class="keyword">this</span>, itemOffset, item); <span class="comment">// relaxed write</span></span><br><span class="line">        <span class="keyword">this</span>.isData = isData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将next域指向自身，其实就是剔除节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> forgetNext() &#123;</span><br><span class="line">        UNSAFE.putObject(<span class="keyword">this</span>, nextOffset, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  匹配过或节点被取消的时候会调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> forgetContents() &#123;</span><br><span class="line">        UNSAFE.putObject(<span class="keyword">this</span>, itemOffset, <span class="keyword">this</span>);</span><br><span class="line">        UNSAFE.putObject(<span class="keyword">this</span>, waiterOffset, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验节点是否匹配过，如果匹配做取消了，item则会发生变化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">boolean</span> isMatched() &#123;</span><br><span class="line">        <span class="keyword">Object</span> x = item;</span><br><span class="line">        <span class="keyword">return</span> (x == <span class="keyword">this</span>) || ((x == <span class="keyword">null</span>) == isData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是一个未匹配的请求节点</span></span><br><span class="line"><span class="comment">     * 如果是的话isData应为false，item == null，因位如果匹配了，item则会有值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">boolean</span> isUnmatchedRequest() &#123;</span><br><span class="line">        <span class="keyword">return</span> !isData &amp;&amp; item == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如给定节点类型不能挂在当前节点后返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">boolean</span> cannotPrecede(<span class="built_in">boolean</span> haveData) &#123;</span><br><span class="line">        <span class="built_in">boolean</span> d = isData;</span><br><span class="line">        <span class="keyword">Object</span> x;</span><br><span class="line">        <span class="keyword">return</span> d != haveData &amp;&amp; (x = item) != <span class="keyword">this</span> &amp;&amp; (x != <span class="keyword">null</span>) == d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配一个数据节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">boolean</span> tryMatchData() &#123;</span><br><span class="line">        <span class="comment">// assert isData;</span></span><br><span class="line">        <span class="keyword">Object</span> x = item;</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="keyword">null</span> &amp;&amp; x != <span class="keyword">this</span> &amp;&amp; casItem(x, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            LockSupport.unpark(waiter);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">-3375979862319811754</span>L;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> itemOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> waiterOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = Node.class;</span><br><span class="line">            itemOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">"item"</span>));</span><br><span class="line">            nextOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line">            waiterOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">"waiter"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节点Node为LinkedTransferQueue的内部类，其内部结构和公平方式的SynchronousQueue差不多，里面也同样提供了一些很重要的方法。</p><h3 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h3><p>LinkedTransferQueue提供了add、put、offer三类方法，用于将元素插入队列中，如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    xfer(e, <span class="keyword">true</span>, ASYNC, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    xfer(e, <span class="keyword">true</span>, ASYNC, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    xfer(e, <span class="keyword">true</span>, ASYNC, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    xfer(e, <span class="keyword">true</span>, ASYNC, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于LinkedTransferQueue是无界的，不会阻塞，所以在调用xfer方法是传入的是ASYNC，同时直接返回true.</p><h3 id="take操作"><a href="#take操作" class="headerlink" title="take操作"></a>take操作</h3><p>LinkedTransferQueue提供了poll、take方法用于出列元素：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E e = xfer(<span class="keyword">null</span>, <span class="keyword">false</span>, SYNC, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    Thread.interrupted();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function">E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">xfer</span><span class="params">(<span class="keyword">null</span>, <span class="keyword">false</span>, NOW, <span class="number">0</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E e = xfer(<span class="keyword">null</span>, <span class="keyword">false</span>, TIMED, unit.toNanos(timeout));</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> || !Thread.interrupted())</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里和put操作有点不一样，take()方法传入的是SYNC，阻塞。poll()传入的是NOW，poll(long timeout, TimeUnit unit)则是传入TIMED。</p><h3 id="tranfer操作"><a href="#tranfer操作" class="headerlink" title="tranfer操作"></a>tranfer操作</h3><p>实现TransferQueue接口，就要实现它的方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> tryTransfer(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (xfer(e, <span class="keyword">true</span>, TIMED, unit.toNanos(timeout)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Thread.interrupted())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xfer(e, <span class="keyword">true</span>, SYNC, <span class="number">0</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Thread.interrupted(); <span class="comment">// failure possible only due to interrupt</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryTransfer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> xfer(e, <span class="keyword">true</span>, NOW, <span class="number">0</span>) == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="xfer"><a href="#xfer" class="headerlink" title="xfer()"></a>xfer()</h3><p>通过上面几个核心方法的源码我们清楚可以看到，最终都是调用xfer()方法，该方法接受四个参数，item或者null的E，put操作为true、take操作为false的havaData，how（有四个值NOW, ASYNC, SYNC, or TIMED，分别表示不同的操作），超时nanos。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E xfer(E e, <span class="keyword">boolean</span> haveData, <span class="keyword">int</span> how, <span class="keyword">long</span> nanos) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// havaData为true，但是e == null 抛出空指针</span></span><br><span class="line">    <span class="keyword">if</span> (haveData &amp;&amp; (e == <span class="keyword">null</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node s = <span class="keyword">null</span>;                        <span class="comment">// the node to append, if needed</span></span><br><span class="line"></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从首节点开始匹配</span></span><br><span class="line">        <span class="comment">// p == null 队列为空</span></span><br><span class="line">        <span class="keyword">for</span> (Node h = head, p = h; p != <span class="keyword">null</span>;) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模型，request or data</span></span><br><span class="line">            <span class="keyword">boolean</span> isData = p.isData;</span><br><span class="line">            <span class="comment">// item域</span></span><br><span class="line">            Object item = p.item;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到一个没有匹配的节点</span></span><br><span class="line">            <span class="comment">// item != p 也就是自身，则表示没有匹配过</span></span><br><span class="line">            <span class="comment">// (item != null) == isData，表示模型符合</span></span><br><span class="line">            <span class="keyword">if</span> (item != p &amp;&amp; (item != <span class="keyword">null</span>) == isData) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 节点类型和待处理类型一致，这样肯定是不能匹配的</span></span><br><span class="line">                <span class="keyword">if</span> (isData == haveData)   <span class="comment">// can't match</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 匹配，将E加入到item域中</span></span><br><span class="line">                <span class="comment">// 如果p 的item为data，那么e为null,如果p的item为null，那么e为data</span></span><br><span class="line">                <span class="keyword">if</span> (p.casItem(item, e)) &#123; <span class="comment">// match</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">for</span> (Node q = p; q != h;) &#123;</span><br><span class="line">                        Node n = q.<span class="keyword">next</span>;  <span class="comment">// update by 2 unless singleton</span></span><br><span class="line">                        <span class="keyword">if</span> (head == h &amp;&amp; casHead(h, n == <span class="keyword">null</span> ? q : n)) &#123;</span><br><span class="line">                            h.forgetNext();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;                 <span class="comment">// advance and retry</span></span><br><span class="line">                        <span class="keyword">if</span> ((h = head)   == <span class="keyword">null</span> ||</span><br><span class="line">                                (q = h.<span class="keyword">next</span>) == <span class="keyword">null</span> || !q.isMatched())</span><br><span class="line">                            <span class="keyword">break</span>;        <span class="comment">// unless slack &lt; 2</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 匹配后唤醒p的waiter线程;reservation则叫人收货，data则叫null收货</span></span><br><span class="line">                    LockSupport.unpark(p.waiter);</span><br><span class="line">                    <span class="keyword">return</span> LinkedTransferQueue.&lt;E&gt;cast(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果已经匹配了则向前推进</span></span><br><span class="line">            Node n = p.<span class="keyword">next</span>;</span><br><span class="line">            <span class="comment">// 如果p的next指向p本身，说明p节点已经有其他线程处理过了，只能从head重新开始</span></span><br><span class="line">            p = (p != n) ? n : (h = head); <span class="comment">// Use head if p offlist</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有找到匹配的节点，则进行处理</span></span><br><span class="line">        <span class="comment">// NOW为untimed poll, tryTransfer，不需要入队</span></span><br><span class="line">        <span class="keyword">if</span> (how != NOW) &#123;                 <span class="comment">// No matches available</span></span><br><span class="line">            <span class="comment">// s == null，新建一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                s = <span class="keyword">new</span> Node(e, haveData);</span><br><span class="line">            <span class="comment">// 入队，返回前驱节点</span></span><br><span class="line">            Node pred = tryAppend(s, haveData);</span><br><span class="line">            <span class="comment">// 返回的前驱节点为null，那就是有race，被其他的抢了，那就continue 整个for</span></span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ASYNC不需要阻塞等待</span></span><br><span class="line">            <span class="keyword">if</span> (how != ASYNC)</span><br><span class="line">                <span class="keyword">return</span> awaitMatch(s, pred, e, (how == TIMED), nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个算法的核心就是寻找匹配节点找到了就返回，否则就入队（NOW直接返回）：</p><ul><li>matched。判断匹配条件（isData不一样，本身没有匹配），匹配后就casItem，然后unpark匹配节点的waiter线程，如果是reservation则叫人收货，data则叫null收货。</li><li>unmatched。如果没有找到匹配节点，则根据传入的how来处理，NOW直接返回，其余三种先入对，入队后如果是ASYNC则返回，SYNC和TIMED则会阻塞等待匹配。</li></ul><p>其实相当于SynchronousQueue来说，这个处理逻辑还是比较简单的。</p><p>如果没有找到匹配节点，且how != NOW会入队，入队则是调用tryAppend方法：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node tryAppend(Node s, <span class="keyword">boolean</span> haveData) &#123;</span><br><span class="line">    <span class="comment">// 从尾节点tail开始</span></span><br><span class="line">    <span class="keyword">for</span> (Node t = tail, p = t;;) &#123;</span><br><span class="line">        Node n, u;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列为空则将节点S设置为head</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; (p = head) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casHead(<span class="keyword">null</span>, s))</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果为data</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.cannotPrecede(haveData))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不是最后一个节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((n = p.<span class="keyword">next</span>) != <span class="keyword">null</span>)</span><br><span class="line">            p = p != t &amp;&amp; t != (u = tail) ? (t = u) : (p != n) ? n : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// CAS失败，一般来说失败的原因在于p.next != null，可能有其他增加了tail，向前推荐</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!p.casNext(<span class="keyword">null</span>, s))</span><br><span class="line">            p = p.<span class="keyword">next</span>;                   <span class="comment">// re-read on CAS failure</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p != t) &#123;                 <span class="comment">// update if slack now &gt;= 2</span></span><br><span class="line">                <span class="keyword">while</span> ((tail != t || !casTail(t, s)) &amp;&amp;</span><br><span class="line">                        (t = tail)   != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (s = t.<span class="keyword">next</span>) != <span class="keyword">null</span> &amp;&amp; <span class="comment">// advance and retry</span></span><br><span class="line">                        (s = s.<span class="keyword">next</span>) != <span class="keyword">null</span> &amp;&amp; s != t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAppend方法是将S节点添加到tail上，然后返回其前驱节点。好吧，我承认这段代码我看的有点儿晕！！！</p><p>加入队列后，如果how还不是ASYNC则调用awaitMatch()方法阻塞等待：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function">E <span class="title">awaitMatch</span><span class="params">(Node s, Node pred, E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 超时控制</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : 0L;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前线程</span></span><br><span class="line">    Thread w = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自旋次数</span></span><br><span class="line">    <span class="keyword">int</span> spins = <span class="number">-1</span>; <span class="comment">// initialized after first item and cancel checks</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机数</span></span><br><span class="line">    ThreadLocalRandom randomYields = <span class="keyword">null</span>; <span class="comment">// bound if needed</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Object item = s.item;</span><br><span class="line">        <span class="comment">//匹配了，可能有其他线程匹配了线程</span></span><br><span class="line">        <span class="keyword">if</span> (item != e) &#123;</span><br><span class="line">            <span class="comment">// 撤销该节点</span></span><br><span class="line">            s.forgetContents();</span><br><span class="line">            <span class="keyword">return</span> LinkedTransferQueue.&lt;E&gt;cast(item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程中断或者超时了。则调用将s节点item设置为e，等待取消</span></span><br><span class="line">        <span class="keyword">if</span> ((w.isInterrupted() || (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)) &amp;&amp; s.casItem(e, s)) &#123;        <span class="comment">// cancel</span></span><br><span class="line">            <span class="comment">// 断开节点</span></span><br><span class="line">            unsplice(pred, s);</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">if</span> (spins &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算自旋次数</span></span><br><span class="line">            <span class="keyword">if</span> ((spins = spinsFor(pred, s.isData)) &gt; <span class="number">0</span>)</span><br><span class="line">                randomYields = ThreadLocalRandom.current();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(spins &gt; <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">            --spins;</span><br><span class="line">            <span class="comment">// 生成的随机数 == 0 ，停止线程？不是很明白....</span></span><br><span class="line">            <span class="keyword">if</span> (randomYields.nextInt(CHAINED_SPINS) == <span class="number">0</span>)</span><br><span class="line">                Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前线程设置到节点的waiter域</span></span><br><span class="line">        <span class="comment">// 一开始s.waiter == null 肯定是会成立的，</span></span><br><span class="line">        <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(s.waiter == <span class="keyword">null</span>)</span> </span>&#123;</span><br><span class="line">            s.waiter = w;                 <span class="comment">// request unpark then recheck</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 超时阻塞</span></span><br><span class="line">        <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(timed)</span> </span>&#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>L)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不是超时阻塞</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个awaitMatch过程和SynchronousQueue的awaitFulfill没有很大区别，不过在自旋过程会调用Thread.yield();这是干嘛？</p><p>在awaitMatch过程中，如果线程中断了，或者超时了则会调用unsplice()方法去除该节点：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">final void unsplice(Node pred, Node s) &#123;</span><br><span class="line">    s.forgetContents(); <span class="regexp">//</span> forget unneeded fields</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pred != null &amp;&amp; pred != s &amp;&amp; pred.<span class="keyword">next</span> == s) &#123;</span><br><span class="line">        Node n = s.<span class="keyword">next</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == null <span class="params">||</span></span><br><span class="line">                (n != s &amp;&amp; pred.casNext(s, n) &amp;&amp; pred.isMatched())) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;               <span class="regexp">//</span> check <span class="keyword">if</span> at, <span class="keyword">or</span> could be, head</span><br><span class="line">                Node h = head;</span><br><span class="line">                <span class="keyword">if</span> (h == pred <span class="params">||</span> h == s <span class="params">||</span> h == null)</span><br><span class="line">                    <span class="keyword">return</span>;          <span class="regexp">//</span> at head <span class="keyword">or</span> list empty</span><br><span class="line">                <span class="keyword">if</span> (!h.isMatched())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                Node hn = h.<span class="keyword">next</span>;</span><br><span class="line">                <span class="keyword">if</span> (hn == null)</span><br><span class="line">                    <span class="keyword">return</span>;          <span class="regexp">//</span> now empty</span><br><span class="line">                <span class="keyword">if</span> (hn != h &amp;&amp; casHead(h, hn))</span><br><span class="line">                    h.forgetNext();  <span class="regexp">//</span> advance head</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pred.<span class="keyword">next</span> != pred &amp;&amp; s.<span class="keyword">next</span> != s) &#123; <span class="regexp">//</span> recheck <span class="keyword">if</span> offlist</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;           <span class="regexp">//</span> sweep now <span class="keyword">if</span> enough votes</span><br><span class="line">                    int v = sweepVotes;</span><br><span class="line">                    <span class="keyword">if</span> (v &lt; SWEEP_THRESHOLD) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (casSweepVotes(v, v + <span class="number">1</span>))</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (casSweepVotes(v, <span class="number">0</span>)) &#123;</span><br><span class="line">                        sweep();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主体流程已经完成，这里总结下：</p><ol><li>无论是入对、出对，还是交换，最终都会跑到xfer(E e, boolean haveData, int how, long nanos)方法中，只不过传入的how不同而已</li><li>如果队列不为空，则尝试在队列中寻找是否存在与该节点相匹配的节点，如果找到则将匹配节点的item设置e，然后唤醒匹配节点的waiter线程。如果是reservation则叫人收货，data则叫null收货</li><li>如果队列为空，或者没有找到匹配的节点且how ！= NOW，则调用tryAppend()方法将节点添加到队列的tail，然后返回其前驱节点</li><li>如果节点的how != NOW &amp;&amp; how != ASYNC，则调用awaitMatch()方法阻塞等待，在阻塞等待过程中和SynchronousQuque的awaitFulfill()逻辑差不多，都是先自旋，然后判断是否需要自旋，如果中断或者超时了则将该节点从队列中移出</li></ol><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>这段摘自<a href="http://www.cnblogs.com/rockman12352/p/3790245.html" target="_blank" rel="noopener">JAVA 1.7并发之LinkedTransferQueue原理理解</a>。感觉看完上面的源码后，在结合这个例子会有更好的了解，掌握。</p><p>1：Head-&gt;Data Input-&gt;Data<br>Match: 根据他们的属性 发现 cannot match ，因为是同类的<br>处理节点: 所以把新的data放在原来的data后面，然后head往后移一位，Reservation同理<br>HEAD=DATA-&gt;DATA</p><p>2：Head-&gt;Data Input-&gt;Reservation （取数据）<br>Match: 成功match，就把Data的item变为reservation的值（null,有主了），并且返回数据。<br>处理节点： 没动，head还在原地<br>HEAD=DATA（用过）</p><p>3：Head-&gt;Reservation Input-&gt;Data（放数据）<br>Match: 成功match，就把Reservation的item变为Data的值（有主了），并且叫waiter来取<br>处理节点： 没动<br>HEAD=RESERVATION(用过)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>BlockingQueue</p><p>BlockingQueue接口实现Queue接口，它支持两个附加操作：获取元素时等待队列变为非空，以及存储元素时等待空间变得可用。相对于同一操作他提供了四种机制：抛出异常、返回特殊值、阻塞等待、超时：</p><p><img src="https://img-blog.csdn.net/20171004182403214?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hlbnNzeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="BlockingQueue操作"></p><p>BlockingQueue常用于生产者和消费者场景。</p><p>JDK 8 中提供了七个阻塞队列可供使用（上图的DelayedWorkQueue是ScheduledThreadPoolExecutor的内部类）：</p><ul><li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</li><li>LinkedBlockingQueue ：一个由链表结构组成的无界阻塞队列。</li><li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li></ul><h3 id="ArrayBlockingQueue-1"><a href="#ArrayBlockingQueue-1" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>基于数组的阻塞队列，ArrayBlockingQueue内部维护这一个定长数组，阻塞队列的大小在初始化时就已经确定了，其后无法更改。</p><p>采用可重入锁ReentrantLock来保证线程安全性，但是生产者和消费者是共用同一个锁对象，这样势必会导致降低一定的吞吐量。当然ArrayBlockingQueue完全可以采用分离锁来实现生产者和消费者的并行操作，但是我认为这样做只会给代码带来额外的复杂性，对于性能而言应该不会有太大的提升，因为基于数组的ArrayBlockingQueue在数据的写入和读取操作已经非常轻巧了。</p><p>ArrayBlockingQueue支持公平性和非公平性，默认采用非公平模式，可以通过构造函数设置为公平访问策略（true）。</p><h3 id="PriorityBlockingQueue-1"><a href="#PriorityBlockingQueue-1" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue是支持优先级的无界队列。默认情况下采用自然顺序排序，当然也可以通过自定义Comparator来指定元素的排序顺序。</p><p>PriorityBlockingQueue内部采用二叉堆的实现方式，整个处理过程并不是特别复杂。添加操作则是不断“上冒”，而删除操作则是不断“下掉”。</p><h3 id="DelayQueue-1"><a href="#DelayQueue-1" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>DelayQueue是一个支持延时操作的无界阻塞队列。列头的元素是最先“到期”的元素，如果队列里面没有元素到期，是不能从列头获取元素的，哪怕有元素也不行。也就是说只有在延迟期满时才能够从队列中去元素。</p><p>它主要运用于如下场景：</p><ul><li>缓存系统的设计：缓存是有一定的时效性的，可以用DelayQueue保存缓存的有效期，然后利用一个线程查询DelayQueue，如果取到元素就证明该缓存已经失效了。</li><li>定时任务的调度：DelayQueue保存当天将要执行的任务和执行时间，一旦取到元素（任务），就执行该任务。</li></ul><p>DelayQueue采用支持优先级的PriorityQueue来实现，但是队列中的元素必须要实现Delayed接口，Delayed接口用来标记那些应该在给定延迟时间之后执行的对象，该接口提供了getDelay()方法返回元素节点的剩余时间。同时，元素也必须要实现compareTo()方法，compareTo()方法需要提供与getDelay()方法一致的排序。</p><h3 id="SynchronousQueue-1"><a href="#SynchronousQueue-1" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>SynchronousQueue是一个神奇的队列，他是一个不存储元素的阻塞队列，也就是说他的每一个put操作都需要等待一个take操作，否则就不能继续添加元素了，有点儿像<a href="http://cmsblogs.com/?p=2269" target="_blank" rel="noopener">Exchanger</a>，类似于生产者和消费者进行交换。</p><p>队列本身不存储任何元素，所以非常适用于传递性场景，两者直接进行对接。其吞吐量会高于ArrayBlockingQueue和LinkedBlockingQueue。</p><p>SynchronousQueue支持公平和非公平的访问策略，在默认情况下采用非公平性，也可以通过构造函数来设置为公平性。</p><p>SynchronousQueue的实现核心为Transferer接口，该接口有TransferQueue和TransferStack两个实现类，分别对应着公平策略和非公平策略。接口Transferer有一个tranfer()方法，该方法定义了转移数据，如果e != null，相当于将一个数据交给消费者，如果e == null，则相当于从一个生产者接收一个消费者交出的数据。</p><h3 id="LinkedTransferQueue-2"><a href="#LinkedTransferQueue-2" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><p>LinkedTransferQueue是一个由链表组成的的无界阻塞队列，该队列是一个相当牛逼的队列：它是ConcurrentLinkedQueue、SynchronousQueue (公平模式下)、无界的LinkedBlockingQueues等的超集。</p><p>与其他BlockingQueue相比，他多实现了一个接口TransferQueue，该接口是对BlockingQueue的一种补充，多了tryTranfer()和transfer()两类方法：</p><ul><li>tranfer()：若当前存在一个正在等待获取的消费者线程，即立刻移交之。 否则，会插入当前元素e到队列尾部，并且等待进入阻塞状态，到有消费者线程取走该元素</li><li>tryTranfer()： 若当前存在一个正在等待获取的消费者线程（使用take()或者poll()函数），使用该方法会即刻转移/传输对象元素e；若不存在，则返回false，并且不进入队列。这是一个不阻塞的操作</li></ul><h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><p>LinkedBlockingDeque是一个有链表组成的双向阻塞队列，与前面的阻塞队列相比它支持从两端插入和移出元素。以first结尾的表示从对头操作，以last结尾的表示从对尾操作。</p><p>在初始化LinkedBlockingDeque时可以初始化队列的容量，用来防止其再扩容时过渡膨胀。另外双向阻塞队列可以运用在“工作窃取”模式中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java并发指南&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/21961.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21961.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java并发" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="JUC" scheme="http://h2pl.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java并发指南10：Java 读写锁 ReentrantReadWriteLock 源码分析</title>
    <link href="http://h2pl.github.io/2018/05/21/concurrent10/"/>
    <id>http://h2pl.github.io/2018/05/21/concurrent10/</id>
    <published>2018-05-21T15:06:05.000Z</published>
    <updated>2018-06-02T08:20:12.772Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java并发指南<br><a href="https://blog.csdn.net/column/details/21961.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21961.html</a></p><p>相关代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><p>Java 读写锁 ReentrantReadWriteLock 源码分析</p><p>转自：<a href="https://www.javadoop.com/post/reentrant-read-write-lock#toc5" target="_blank" rel="noopener">https://www.javadoop.com/post/reentrant-read-write-lock#toc5</a></p><p>本文内容：读写锁 ReentrantReadWriteLock 的源码分析，基于 Java7/Java8。</p><p>阅读建议：虽然我这里会介绍一些 AQS 的知识，不过如果你完全不了解 AQS，看本文就有点吃力了。</p><p>目录</p><ul><li><a href="https://www.javadoop.com/post/reentrant-read-write-lock#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B" target="_blank" rel="noopener">使用示例</a></li><li><a href="https://www.javadoop.com/post/reentrant-read-write-lock#ReentrantReadWriteLock%20%E6%80%BB%E8%A7%88" target="_blank" rel="noopener">ReentrantReadWriteLock 总览</a></li><li><a href="https://www.javadoop.com/post/reentrant-read-write-lock#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" target="_blank" rel="noopener">源码分析</a><ul><li><a href="https://www.javadoop.com/post/reentrant-read-write-lock#%E8%AF%BB%E9%94%81%E8%8E%B7%E5%8F%96" target="_blank" rel="noopener">读锁获取</a></li><li><a href="https://www.javadoop.com/post/reentrant-read-write-lock#%E8%AF%BB%E9%94%81%E9%87%8A%E6%94%BE" target="_blank" rel="noopener">读锁释放</a></li><li><a href="https://www.javadoop.com/post/reentrant-read-write-lock#%E5%86%99%E9%94%81%E8%8E%B7%E5%8F%96" target="_blank" rel="noopener">写锁获取</a></li><li><a href="https://www.javadoop.com/post/reentrant-read-write-lock#%E5%86%99%E9%94%81%E9%87%8A%E6%94%BE" target="_blank" rel="noopener">写锁释放</a></li></ul></li><li><a href="https://www.javadoop.com/post/reentrant-read-write-lock#%E9%94%81%E9%99%8D%E7%BA%A7" target="_blank" rel="noopener">锁降级</a></li><li><a href="https://www.javadoop.com/post/reentrant-read-write-lock#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">总结</a></li></ul><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>下面这个例子非常实用，我是 javadoc 的搬运工：</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个关于缓存操作的故事</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> &#123;</span></span><br><span class="line">    <span class="type">Object</span> data;</span><br><span class="line">    volatile boolean cacheValid;</span><br><span class="line">    <span class="comment">// 读写锁实例</span></span><br><span class="line">    final <span class="type">ReentrantReadWriteLock</span> rwl = <span class="function"><span class="keyword">new</span> <span class="title">ReentrantReadWriteLock</span>();</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">void</span> <span class="title">processCachedData</span>() &#123;</span></span><br><span class="line"><span class="function">        <span class="comment">// 获取读锁</span></span></span><br><span class="line"><span class="function">        <span class="title">rwl</span>.<span class="title">readLock</span>().<span class="title">lock</span>();</span></span><br><span class="line"><span class="function">        <span class="title">if</span> (!cacheValid) &#123; <span class="comment">// 如果缓存过期了，或者为 null</span></span></span><br><span class="line"><span class="function">            <span class="comment">// 释放掉读锁，然后获取写锁 (后面会看到，没释放掉读锁就获取写锁，会发生死锁情况)</span></span></span><br><span class="line"><span class="function">            <span class="title">rwl</span>.<span class="title">readLock</span>().<span class="title">unlock</span>();</span></span><br><span class="line"><span class="function">            <span class="title">rwl</span>.<span class="title">writeLock</span>().<span class="title">lock</span>();</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">            <span class="title">try</span> &#123;</span></span><br><span class="line"><span class="function">                <span class="title">if</span> (!cacheValid) &#123; <span class="comment">// 重新判断，因为在等待写锁的过程中，可能前面有其他写线程执行过了</span></span></span><br><span class="line"><span class="function">                    <span class="title">data</span> = ...</span></span><br><span class="line"><span class="function">                    <span class="title">cacheValid</span> = <span class="title">true</span>;</span></span><br><span class="line"><span class="function">                &#125;</span></span><br><span class="line"><span class="function">                <span class="comment">// 获取读锁 (持有写锁的情况下，是允许获取读锁的，称为 “锁降级”，反之不行。)</span></span></span><br><span class="line"><span class="function">                <span class="title">rwl</span>.<span class="title">readLock</span>().<span class="title">lock</span>();</span></span><br><span class="line"><span class="function">            &#125; <span class="title">finally</span> &#123;</span></span><br><span class="line"><span class="function">                <span class="comment">// 释放写锁，此时还剩一个读锁</span></span></span><br><span class="line"><span class="function">                <span class="title">rwl</span>.<span class="title">writeLock</span>().<span class="title">unlock</span>(); <span class="comment">// Unlock write, still hold read</span></span></span><br><span class="line"><span class="function">            &#125;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">try</span> &#123;</span></span><br><span class="line"><span class="function">            <span class="title">use</span>(data);</span></span><br><span class="line"><span class="function">        &#125; <span class="title">finally</span> &#123;</span></span><br><span class="line"><span class="function">            <span class="comment">// 释放读锁</span></span></span><br><span class="line"><span class="function">            <span class="title">rwl</span>.<span class="title">readLock</span>().<span class="title">unlock</span>();</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>ReentrantReadWriteLock 分为读锁和写锁两个实例，读锁是共享锁，可被多个线程同时使用，写锁是独占锁。持有写锁的线程可以继续获取读锁，反之不行。</p><h2 id="ReentrantReadWriteLock-总览"><a href="#ReentrantReadWriteLock-总览" class="headerlink" title="ReentrantReadWriteLock 总览"></a>ReentrantReadWriteLock 总览</h2><p>这一节比较重要，我们要先看清楚 ReentrantReadWriteLock 的大框架，然后再到源码细节。</p><p>首先，我们来看下 ReentrantReadWriteLock 的结构，它有好些嵌套类：</p><p><img src="https://www.javadoop.com/blogimages/reentrant-read-write-lock/11.png" alt="11"></p><p>大家先仔细看看这张图中的信息。然后我们把 ReadLock 和 WriteLock 的代码提出来一起看，清晰一些：</p><p><img src="https://www.javadoop.com/blogimages/reentrant-read-write-lock/12.png" alt="12"></p><p>很清楚了，ReadLock 和 WriteLock 中的方法都是通过 Sync 这个类来实现的。Sync 是 AQS 的子类，然后再派生了公平模式和不公平模式。</p><p>从它们调用的 Sync 方法，我们可以看到： ReadLock 使用了共享模式，WriteLock 使用了独占模式。</p><p>等等，同一个 AQS 实例怎么可以同时使用共享模式和独占模式？？？</p><p>这里给大家回顾下 AQS，我们横向对比下 AQS 的共享模式和独占模式：</p><p><img src="https://www.javadoop.com/blogimages/reentrant-read-write-lock/13.png" alt="13"></p><p>AQS 的精髓在于内部的属性 state：</p><ol><li>对于独占模式来说，通常就是 0 代表可获取锁，1 代表锁被别人获取了，重入例外</li><li>而共享模式下，每个线程都可以对 state 进行加减操作</li></ol><p>也就是说，独占模式和共享模式对于 state 的操作完全不一样，那读写锁 ReentrantReadWriteLock 中是怎么使用 state 的呢？答案是将 state 这个 32 位的 int 值分为高 16 位和低 16位，分别用于共享模式和独占模式。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>有了前面的概念，大家心里应该都有数了吧，下面就不再那么啰嗦了，直接代码分析。</p><p>源代码加注释 1500 行，并不算难，我们要看的代码量不大。如果你前面一节都理解了，那么直接从头开始一行一行往下看就是了，还是比较简单的。</p><p>ReentrantReadWriteLock 的前面几行很简单，我们往下滑到 Sync 类，先来看下它的所有的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下面这块说的就是将 state 一分为二，高 16 位用于共享模式，低16位用于独占模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 取 c 的高 16 位值，代表读锁的获取次数(包括重入)</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">    <span class="comment">// 取 c 的低 16 位值，代表写锁的重入次数，因为写锁是独占模式</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个嵌套类的实例用来记录每个线程持有的读锁数量(读锁重入)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 持有的读锁数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 线程 id</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ThreadLocal 的子类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 组合使用上面两个类，用一个 ThreadLocal 来记录当前线程持有的读锁数量</span></span><br><span class="line"><span class="comment">      */</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于缓存，记录"最后一个获取读锁的线程"的读锁重入次数，</span></span><br><span class="line">    <span class="comment">// 所以不管哪个线程获取到读锁后，就把这个值占为已用，这样就不用到 ThreadLocal 中查询 map 了</span></span><br><span class="line">    <span class="comment">// 算不上理论的依据：通常读锁的获取很快就会伴随着释放，</span></span><br><span class="line">    <span class="comment">//   显然，在 获取-&gt;释放 读锁这段时间，如果没有其他线程获取读锁的话，此缓存就能帮助提高性能</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个获取读锁的线程(并且其未释放读锁)，以及它持有的读锁数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br><span class="line"></span><br><span class="line">    Sync() &#123;</span><br><span class="line">        <span class="comment">// 初始化 readHolds 这个 ThreadLocal 属性</span></span><br><span class="line">        readHolds = <span class="keyword">new</span> ThreadLocalHoldCounter();</span><br><span class="line">        <span class="comment">// 为了保证 readHolds 的内存可见性</span></span><br><span class="line">        setState(getState()); <span class="comment">// ensures visibility of readHolds</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>state 的高 16 位代表读锁的获取次数，包括重入次数，获取到读锁一次加 1，释放掉读锁一次减 1</li><li>state 的低 16 位代表写锁的获取次数，因为写锁是独占锁，同时只能被一个线程获得，所以它代表重入次数</li><li>每个线程都需要维护自己的 HoldCounter，记录该线程获取的读锁次数，这样才能知道到底是不是读锁重入，用 ThreadLocal 属性 readHolds 维护</li><li>cachedHoldCounter 有什么用？其实没什么用，但能提示性能。将最后一次获取读锁的线程的 HoldCounter 缓存到这里，这样比使用 ThreadLocal 性能要好一些，因为 ThreadLocal 内部是基于 map 来查询的。但是 cachedHoldCounter 这一个属性毕竟只能缓存一个线程，所以它要起提升性能作用的依据就是：通常读锁的获取紧随着就是该读锁的释放。我这里可能表达不太好，但是大家应该是懂的吧。</li><li>firstReader 和 firstReaderHoldCount 有什么用？其实也没什么用，但是它也能提示性能。将”第一个”获取读锁的线程记录在 firstReader 属性中，这里的第一个不是全局的概念，等这个 firstReader 当前代表的线程释放掉读锁以后，会有后来的线程占用这个属性的。firstReader 和 firstReaderHoldCount 使得在读锁不产生竞争的情况下，记录读锁重入次数非常方便快速</li><li>如果一个线程使用了 firstReader，那么它就不需要占用 cachedHoldCounter</li><li>个人认为，读写锁源码中最让初学者头疼的就是这几个用于提升性能的属性了，使得大家看得云里雾里的。主要是因为 ThreadLocal 内部是通过一个 ThreadLocalMap 来操作的，会增加检索时间。而很多场景下，执行 unlock 的线程往往就是刚刚最后一次执行 lock 的线程，中间可能没有其他线程进行 lock。还有就是很多不怎么会发生读锁竞争的场景。</li></ol><p>上面说了这么多，是希望能帮大家降低后面阅读源码的压力，大家也可以先看看后面的，然后再慢慢体会。</p><p>前面我们好像都只说读锁，完全没提到写锁，主要是因为写锁真的是简单很多，我也特地将写锁的源码放到了后面，我们先啃下最难的读锁先。</p><h3 id="读锁获取"><a href="#读锁获取" class="headerlink" title="读锁获取"></a>读锁获取</h3><p>下面我就不一行一行按源码顺序说了，我们按照使用来说。</p><p>我们来看下读锁 ReadLock 的 lock 流程：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReadLock</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就会进到 Sync 类的 tryAcquireShared 方法：</p><blockquote><p>在 AQS 中，如果 tryAcquireShared(arg) 方法返回值小于 0 代表没有获取到共享锁(读锁)，大于 0 代表获取到</p><p>回顾 AQS 共享模式：tryAcquireShared 方法不仅仅在 acquireShared 的最开始被使用，这里是 try，也就可能会失败，如果失败的话，执行后面的 doAcquireShared，进入到阻塞队列，然后等待前驱节点唤醒。唤醒以后，还是会调用 tryAcquireShared 进行获取共享锁的。当然，唤醒以后再 try 是很容易获得锁的，因为这个节点已经排了很久的队了，组织是会照顾它的。</p><p>所以，你在看下面这段代码的时候，要想象到两种获取读锁的场景，一种是新来的，一种是排队排到它的。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">protected <span class="keyword">final</span> int tryAcquireShared(int unused) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> current = <span class="type">Thread</span>.currentThread();</span><br><span class="line">    int <span class="built_in">c</span> = getState();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exclusiveCount(c) 不等于 0，说明有线程持有写锁，</span></span><br><span class="line">    <span class="comment">//    而且不是当前线程持有写锁，那么当前线程获取读锁失败</span></span><br><span class="line">    <span class="comment">//         （另，如果持有写锁的是当前线程，是可以继续获取读锁的）</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(<span class="built_in">c</span>) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读锁的获取次数</span></span><br><span class="line">    int r = sharedCount(<span class="built_in">c</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读锁获取是否需要被阻塞，稍后细说。为了进去下面的分支，假设这里不阻塞就好了</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        <span class="comment">// 判断是否会溢出 (2^16-1，没那么容易溢出的)</span></span><br><span class="line">        r &lt; <span class="type">MAX_COUNT</span> &amp;&amp;</span><br><span class="line">        <span class="comment">// 下面这行 CAS 是将 state 属性的高 16 位加 1，低 16 位不变，如果成功就代表获取到了读锁</span></span><br><span class="line">        compareAndSetState(<span class="built_in">c</span>, <span class="built_in">c</span> + <span class="type">SHARED_UNIT</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// =======================</span></span><br><span class="line">        <span class="comment">//   进到这里就是获取到了读锁</span></span><br><span class="line">        <span class="comment">// =======================</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// r == 0 说明此线程是第一个获取读锁的，或者说在它前面获取读锁的都走光光了，它也算是第一个吧</span></span><br><span class="line">            <span class="comment">//  记录 firstReader 为当前线程，及其持有的读锁数量：1</span></span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">// 进来这里，说明是 firstReader 重入获取读锁（这非常简单，count 加 1 结束）</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 前面我们说了 cachedHoldCounter 用于缓存最后一个获取读锁的线程</span></span><br><span class="line">            <span class="comment">// 如果 cachedHoldCounter 缓存的不是当前线程，设置为缓存当前线程的 HoldCounter</span></span><br><span class="line">            <span class="type">HoldCounter</span> rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == null || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.<span class="keyword">get</span>();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.<span class="built_in">count</span> == <span class="number">0</span>) </span><br><span class="line">                <span class="comment">// 到这里，那么就是 cachedHoldCounter 缓存的是当前线程，但是 count 为 0，</span></span><br><span class="line">                <span class="comment">// 大家可以思考一下：这里为什么要 set ThreadLocal 呢？(当然，答案肯定不在这块代码中)</span></span><br><span class="line">                <span class="comment">//   既然 cachedHoldCounter 缓存的是当前线程，</span></span><br><span class="line">                <span class="comment">//   当前线程肯定调用过 readHolds.get() 进行初始化 ThreadLocal</span></span><br><span class="line">                readHolds.<span class="keyword">set</span>(rh);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// count 加 1</span></span><br><span class="line">            rh.<span class="built_in">count</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return 大于 0 的数，代表获取到了共享锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 往下看</span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，要进入 if 分支，需要满足：readerShouldBlock() 返回 false，并且 CAS 要成功（我们先不要纠结 MAX_COUNT 溢出）。</p><p>那我们反向推，怎么样进入到最后的 fullTryAcquireShared：</p><ul><li><p>readerShouldBlock() 返回 true，2 种情况：</p><ul><li><p>在 FairSync 中说的是 hasQueuedPredecessors()，即阻塞队列中有其他元素在等待锁。</p><blockquote><p>也就是说，公平模式下，有人在排队呢，你新来的不能直接获取锁</p></blockquote></li><li><p>在 NonFairSync 中说的是 apparentlyFirstQueuedIsExclusive()，即判断阻塞队列中 head 的第一个后继节点是否是来获取写锁的，如果是的话，让这个写锁先来，避免写锁饥饿。</p><blockquote><p>作者给写锁定义了更高的优先级，所以如果碰上获取写锁的线程马上就要获取到锁了，获取读锁的线程不应该和它抢。</p><p>如果 head.next 不是来获取写锁的，那么可以随便抢，因为是非公平模式，大家比比 CAS 速度</p></blockquote></li></ul></li><li><p>compareAndSetState(c, c + SHARED_UNIT) 这里 CAS 失败，存在竞争。可能是和另一个读锁获取竞争，当然也可能是和另一个写锁获取操作竞争。</p></li></ul><p>然后就会来到 fullTryAcquireShared 中再次尝试：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1\. 刚刚我们说了可能是因为 CAS 失败，如果就此返回，那么就要进入到阻塞队列了，</span></span><br><span class="line"><span class="comment"> *    想想有点不甘心，因为都已经满足了 !readerShouldBlock()，也就是说本来可以不用到阻塞队列的，</span></span><br><span class="line"><span class="comment"> *    所以进到这个方法其实是增加 CAS 成功的机会</span></span><br><span class="line"><span class="comment"> * 2\. 在 NonFairSync 情况下，虽然 head.next 是获取写锁的，我知道它等待很久了，我没想和它抢，</span></span><br><span class="line"><span class="comment"> *    可是如果我是来重入读锁的，那么只能表示对不起了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> int fullTryAcquireShared(<span class="type">Thread</span> current) &#123;</span><br><span class="line">    <span class="type">HoldCounter</span> rh = null;</span><br><span class="line">    <span class="comment">// 别忘了这外层有个 for 循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        int <span class="built_in">c</span> = getState();</span><br><span class="line">        <span class="comment">// 如果其他线程持有了写锁，自然这次是获取不到读锁了，乖乖到阻塞队列排队吧</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(<span class="built_in">c</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// else we hold the exclusive lock; blocking here</span></span><br><span class="line">            <span class="comment">// would cause deadlock.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">              * 进来这里，说明：</span></span><br><span class="line"><span class="comment">              *  1\. exclusiveCount(c) == 0：写锁没有被占用</span></span><br><span class="line"><span class="comment">              *  2\. readerShouldBlock() 为 true，说明阻塞队列中有其他线程在等待</span></span><br><span class="line"><span class="comment">              *</span></span><br><span class="line"><span class="comment">              * 既然 should block，那进来这里是干什么的呢？</span></span><br><span class="line"><span class="comment">              * 答案：是进来处理读锁重入的！</span></span><br><span class="line"><span class="comment">              * </span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// firstReader 线程重入读锁，直接到下面的 CAS</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == null) &#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == null || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        <span class="comment">// cachedHoldCounter 缓存的不是当前线程</span></span><br><span class="line">                        <span class="comment">// 那么到 ThreadLocal 中获取当前线程的 HoldCounter</span></span><br><span class="line">                        <span class="comment">// 如果当前线程从来没有初始化过 ThreadLocal 中的值，get() 会执行初始化</span></span><br><span class="line">                        rh = readHolds.<span class="keyword">get</span>();</span><br><span class="line">                        <span class="comment">// 如果发现 count == 0，也就是说，纯属上一行代码初始化的，那么执行 remove</span></span><br><span class="line">                        <span class="comment">// 然后往下两三行，乖乖排队去</span></span><br><span class="line">                        <span class="keyword">if</span> (rh.<span class="built_in">count</span> == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rh.<span class="built_in">count</span> == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 排队去。</span></span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">              * 这块代码我看了蛮久才把握好它是干嘛的，原来只需要知道，它是处理重入的就可以了。</span></span><br><span class="line"><span class="comment">              * 就是为了确保读锁重入操作能成功，而不是被塞到阻塞队列中等待</span></span><br><span class="line"><span class="comment">              *</span></span><br><span class="line"><span class="comment">              * 另一个信息就是，这里对于 ThreadLocal 变量 readHolds 的处理：</span></span><br><span class="line"><span class="comment">              *    如果 get() 后发现 count == 0，居然会做 remove() 操作，</span></span><br><span class="line"><span class="comment">              *    这行代码对于理解其他代码是有帮助的</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sharedCount(<span class="built_in">c</span>) == <span class="type">MAX_COUNT</span>)</span><br><span class="line">            <span class="keyword">throw</span> new <span class="type">Error</span>(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="built_in">c</span>, <span class="built_in">c</span> + <span class="type">SHARED_UNIT</span>)) &#123;</span><br><span class="line">            <span class="comment">// 这里 CAS 成功，那么就意味着成功获取读锁了</span></span><br><span class="line">            <span class="comment">// 下面需要做的是设置 firstReader 或 cachedHoldCounter</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sharedCount(<span class="built_in">c</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果发现 sharedCount(c) 等于 0，就将当前线程设置为 firstReader</span></span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下面这几行，就是将 cachedHoldCounter 设置为当前线程</span></span><br><span class="line">                <span class="keyword">if</span> (rh == null)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == null || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.<span class="keyword">get</span>();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.<span class="built_in">count</span> == <span class="number">0</span>)</span><br><span class="line">                    readHolds.<span class="keyword">set</span>(rh);</span><br><span class="line">                rh.<span class="built_in">count</span>++;</span><br><span class="line">                cachedHoldCounter = rh;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回大于 0 的数，代表获取到了读锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>firstReader 是每次将读锁获取次数从 0 变为 1 的那个线程。</p><p>能缓存到 firstReader 中就不要缓存到 cachedHoldCounter 中。</p></blockquote><p>上面的源码分析应该说得非常详细了，如果到这里你不太能看懂上面的有些地方的注释，那么可以先往后看，然后再多看几遍。</p><h3 id="读锁释放"><a href="#读锁释放" class="headerlink" title="读锁释放"></a>读锁释放</h3><p>下面我们看看读锁释放的流程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReadLock</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> releaseShared(<span class="keyword">int</span> arg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared(); <span class="comment">// 这句代码其实唤醒 获取写锁的线程，往下看就知道了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> tryReleaseShared(<span class="keyword">int</span> unused) &#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 如果等于 1，那么这次解锁后就不再持有锁了，把 firstReader 置为 null，给后来的线程用</span></span><br><span class="line">            <span class="comment">// 为什么不顺便设置 firstReaderHoldCount = 0？因为没必要，其他线程使用的时候自己会设值</span></span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 判断 cachedHoldCounter 是否缓存的是当前线程，不是的话要到 ThreadLocal 中取</span></span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">count</span> = rh.<span class="keyword">count</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">count</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这一步将 ThreadLocal remove 掉，防止内存泄漏。因为已经不再持有读锁了</span></span><br><span class="line">            readHolds.remove();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">count</span> &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 就是那种，lock() 一次，unlock() 好几次的逗比</span></span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// count 减 1</span></span><br><span class="line">        --rh.<span class="keyword">count</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// nextc 是 state 高 16 位减 1 后的值</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="comment">// 如果 nextc == 0，那就是 state 全部 32 位都为 0，也就是读锁和写锁都空了</span></span><br><span class="line">            <span class="comment">// 此时这里返回 true 的话，其实是帮助唤醒后继节点中的获取写锁的线程</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读锁释放的过程还是比较简单的，主要就是将 hold count 减 1，如果减到 0 的话，还要将 ThreadLocal 中的 remove 掉。</p><p>然后是在 for 循环中将 state 的高 16 位减 1，如果发现读锁和写锁都释放光了，那么唤醒后继的获取写锁的线程。</p><h3 id="写锁获取"><a href="#写锁获取" class="headerlink" title="写锁获取"></a>写锁获取</h3><ol><li>写锁是独占锁。</li><li>如果有读锁被占用，写锁获取是要进入到阻塞队列中等待的。</li></ol><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WriteLock</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        <span class="comment">// 如果 tryAcquire 失败，那么进入到阻塞队列等待</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 看下这里返回 false 的情况：</span></span><br><span class="line">        <span class="comment">//   c != 0 &amp;&amp; w == 0: 写锁可用，但是有线程持有读锁(也可能是自己持有)</span></span><br><span class="line">        <span class="comment">//   c != 0 &amp;&amp; w !=0 &amp;&amp; current != getExclusiveOwnerThread(): 其他线程持有写锁</span></span><br><span class="line">        <span class="comment">//   也就是说，只要有读锁或写锁被占用，这次就不能获取到写锁</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里不需要 CAS，仔细看就知道了，能到这里的，只可能是写锁重入，不然在上面的 if 就拦截了</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果写锁获取不需要 block，那么进行 CAS，成功就代表获取到了写锁</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看一眼 writerShouldBlock() 的判定，然后你再回去看一篇写锁获取过程。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是非公平模式，那么 lock 的时候就可以直接用 CAS 去抢锁，抢不到再排队</span></span><br><span class="line">    <span class="keyword">final</span> boolean writerShouldBlock() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> boolean writerShouldBlock() &#123;</span><br><span class="line">        <span class="comment">// 如果是公平模式，那么如果阻塞队列有线程等待的话，就乖乖去排队</span></span><br><span class="line">        <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写锁释放"><a href="#写锁释放" class="headerlink" title="写锁释放"></a>写锁释放</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WriteLock</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1\. 释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">// 2\. 如果独占锁释放"完全"，唤醒后继节点</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync </span></span><br><span class="line"><span class="comment">// 释放锁，是线程安全的，因为写锁是独占锁，具有排他性</span></span><br><span class="line"><span class="comment">// 实现很简单，state 减 1 就是了</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="comment">// 如果 exclusiveCount(nextc) == 0，也就是说包括重入的，所有的写锁都释放了，</span></span><br><span class="line">    <span class="comment">// 那么返回 true，这样会进行唤醒后继节点的操作。</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，是不是发现写锁相对于读锁来说要简单很多。</p><h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><p>Doug Lea 没有说写锁更高级，如果有线程持有读锁，那么写锁获取也需要等待。</p><p>不过从源码中也可以看出，确实会给写锁一些特殊照顾，如非公平模式下，为了提高吞吐量，lock 的时候会先 CAS 竞争一下，能成功就代表读锁获取成功了，但是如果发现 head.next 是获取写锁的线程，就不会去做 CAS 操作。</p><p>Doug Lea 将持有写锁的线程，去获取读锁的过程称为锁降级（Lock downgrading）。这样，此线程就既持有写锁又持有读锁。</p><p>但是，锁升级是不可以的。线程持有读锁的话，在没释放的情况下不能去获取写锁，因为会发生死锁。</p><p>回去看下写锁获取的源码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 看下这里返回 false 的情况：</span></span><br><span class="line">        <span class="comment">//   c != 0 &amp;&amp; w == 0: 写锁可用，但是有线程持有读锁(也可能是自己持有)</span></span><br><span class="line">        <span class="comment">//   c != 0 &amp;&amp; w !=0 &amp;&amp; current != getExclusiveOwnerThread(): 其他线程持有写锁</span></span><br><span class="line">        <span class="comment">//   也就是说，只要有读锁或写锁被占用，这次就不能获取到写锁</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细想想，如果线程 a 先获取了读锁，然后获取写锁，那么线程 a 就到阻塞队列休眠了，自己把自己弄休眠了，而且可能之后就没人去唤醒它了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://www.javadoop.com/blogimages/reentrant-read-write-lock/14.png" alt="14"></p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java并发指南&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/21961.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21961.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java并发" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://h2pl.github.io/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java并发指南9：AQS共享模式与并发工具类的实现</title>
    <link href="http://h2pl.github.io/2018/05/21/concurrent9/"/>
    <id>http://h2pl.github.io/2018/05/21/concurrent9/</id>
    <published>2018-05-21T15:05:58.000Z</published>
    <updated>2018-06-11T13:43:20.992Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java并发指南<br><a href="https://blog.csdn.net/column/details/21961.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21961.html</a></p><p>相关代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><p>一行一行源码分析清楚 AbstractQueuedSynchronizer (三)</p><p>转自：<a href="https://javadoop.com/post/AbstractQueuedSynchronizer-3" target="_blank" rel="noopener">https://javadoop.com/post/AbstractQueuedSynchronizer-3</a></p><p>这篇文章是 AQS 系列的最后一篇，第一篇，我们通过 ReentrantLock 公平锁分析了 AQS 的核心，第二篇的重点是把 Condition 说明白，同时也说清楚了对于线程中断的使用。</p><p>这篇，我们的关注点是 AQS 最后的部分，共享模式的使用。有前两篇文章的铺垫，剩下的源码分析将会简单很多。</p><p>本文先用 CountDownLatch 将共享模式说清楚，然后顺着把其他 AQS 相关的类 CyclicBarrier、Semaphore 的源码一起过一下。</p><p>老规矩：不放过任何一行代码，没有任何糊弄，没有任何瞎说。</p><ul><li>AQS的共享模式</li></ul><ul><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-3#CountDownLatch" target="_blank" rel="noopener">CountDownLatch</a><ul><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-3#%E4%BD%BF%E7%94%A8%E4%BE%8B%E5%AD%90" target="_blank" rel="noopener">使用例子</a></li><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-3#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" target="_blank" rel="noopener">源码分析</a></li></ul></li><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-3#CyclicBarrier" target="_blank" rel="noopener">CyclicBarrier</a></li><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-3#Semaphore" target="_blank" rel="noopener">Semaphore</a></li><li>Exchanger</li><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-3#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">总结</a></li></ul><p>在讲CountDownLatch之前，先让我们了解一下什么是AQS中的共享模式和共享锁。 </p><h1 id="深入浅出AQS之共享锁模式"><a href="#深入浅出AQS之共享锁模式" class="headerlink" title="深入浅出AQS之共享锁模式"></a>深入浅出AQS之共享锁模式</h1><p><a href="https://segmentfault.com/a/1190000011391092" target="_blank" rel="noopener">深入浅出AQS之共享锁模式</a></p><p>原文地址：<a href="http://www.jianshu.com/p/1161d33fc1d0" target="_blank" rel="noopener">http://www.jianshu.com/p/1161…</a></p><p>搞清楚AQS独占锁的实现原理之后，再看共享锁的实现原理就会轻松很多。两种锁模式之间很多通用的地方本文只会简单说明一下，就不在赘述了，具体细节可以参考我的上篇文章。</p><h2 id="执行过程概述"><a href="#执行过程概述" class="headerlink" title="执行过程概述"></a>执行过程概述</h2><p>获取锁的过程：</p><ol><li>当线程调用acquireShared()申请获取锁资源时，如果成功，则进入临界区。</li><li>当获取锁失败时，则创建一个共享类型的节点并进入一个FIFO等待队列，然后被挂起等待唤醒。</li><li>当队列中的等待线程被唤醒以后就重新尝试获取锁资源，如果成功则<strong>唤醒后面还在等待的共享节点并把该唤醒事件传递下去，即会依次唤醒在该节点后面的所有共享节点</strong>，然后进入临界区，否则继续挂起等待。</li></ol><p>释放锁过程：</p><ol><li>当线程调用releaseShared()进行锁资源释放时，如果释放成功，则唤醒队列中等待的节点，如果有的话。</li></ol><h2 id="源码深入分析"><a href="#源码深入分析" class="headerlink" title="源码深入分析"></a>源码深入分析</h2><p>基于上面所说的共享锁执行流程，我们接下来看下源码实现逻辑：<br>首先来看下获取锁的方法acquireShared()，如下</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//尝试获取共享锁，返回值小于0表示获取失败</span></span><br><span class="line">     <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="comment">//执行获取锁失败以后的方法</span></span><br><span class="line">         doAcquireShared(arg);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里tryAcquireShared()方法是留给用户去实现具体的获取锁逻辑的。关于该方法的实现有两点需要特别说明：</p><p><strong>一、该方法必须自己检查当前上下文是否支持获取共享锁，如果支持再进行获取。</strong></p><p><strong>二、该方法返回值是个重点。其一、由上面的源码片段可以看出返回值小于0表示获取锁失败，需要进入等待队列。其二、如果返回值等于0表示当前线程获取共享锁成功，但它后续的线程是无法继续获取的，也就是不需要把它后面等待的节点唤醒。最后、如果返回值大于0，表示当前线程获取共享锁成功且它后续等待的节点也有可能继续获取共享锁成功，也就是说此时需要把后续节点唤醒让它们去尝试获取共享锁。</strong></p><p>有了上面的约定，我们再来看下doAcquireShared方法的实现：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数不多说，就是传给acquireShared()的参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加等待节点的方法跟独占锁一样，唯一区别就是节点类型变为了共享型，不再赘述</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//表示前面的节点已经获取到锁，自己会尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">//注意上面说的， 等于0表示不用唤醒后继节点，大于0需要</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//这里是重点，获取到锁以后的唤醒操作，后面详细说</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//如果是因为中断醒来则设置中断标记位</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//挂起逻辑跟独占锁一样，不再赘述</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//获取失败的取消逻辑跟独占锁一样，不再赘述</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>独占锁模式获取成功以后设置头结点然后返回中断状态，结束流程。而共享锁模式获取成功以后，调用了setHeadAndPropagate方法，从方法名就可以看出除了设置新的头结点以外还有一个传递动作，一起看下代码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个入参，一个是当前成功获取共享锁的节点，一个就是tryAcquireShared方法的返回值，注意上面说的，它可能大于0也可能等于0</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">//记录当前头节点</span></span><br><span class="line">    <span class="comment">//设置新的头节点，即把当前获取到锁的节点设置为头节点</span></span><br><span class="line">    <span class="comment">//注：这里是获取到锁之后的操作，不需要并发控制</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">//这里意思有两种情况是需要执行唤醒操作</span></span><br><span class="line">    <span class="comment">//1.propagate &gt; 0 表示调用方指明了后继节点需要被唤醒</span></span><br><span class="line">    <span class="comment">//2.头节点后面的节点需要被唤醒（waitStatus&lt;0），不论是老的头结点还是新的头结点</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">//如果当前节点的后继节点是共享类型获取没有后继节点，则进行唤醒</span></span><br><span class="line">        <span class="comment">//这里可以理解为除非明确指明不需要唤醒（后继等待节点是独占类型），否则都要唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            <span class="comment">//后面详细说</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的唤醒操作也很复杂，专门拿出来分析一下：<br><strong>注：这个唤醒操作在releaseShare()方法里也会调用。</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//唤醒操作由头结点开始，注意这里的头节点已经是上面新设置的头结点了</span></span><br><span class="line">            <span class="comment">//其实就是唤醒上面新获取到共享锁的节点的后继节点</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="comment">//表示后继节点需要被唤醒</span></span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="comment">//这里需要控制并发，因为入口有setHeadAndPropagate跟release两个，避免两次unpark</span></span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;      </span><br><span class="line">                    <span class="comment">//执行唤醒操作      </span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果后继节点暂时不需要唤醒，则把当前节点状态设置为PROPAGATE确保以后可以传递下去</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果头结点没有发生变化，表示设置完成，退出循环</span></span><br><span class="line">            <span class="comment">//如果头结点发生变化，比如说其他线程获取到了锁，为了使自己的唤醒动作可以传递，必须进行重试</span></span><br><span class="line">            <span class="keyword">if</span> (h == head)                   </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接下来看下释放共享锁的过程：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//尝试释放共享锁</span></span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            <span class="comment">//唤醒过程，详情见上面分析</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>注：上面的setHeadAndPropagate()方法表示等待队列中的线程成功获取到共享锁，这时候它需要唤醒它后面的共享节点（如果有），但是当通过releaseShared（）方法去释放一个共享锁的时候，接下来等待独占锁跟共享锁的线程都可以被唤醒进行尝试获取。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>跟独占锁相比，共享锁的主要特征在于当一个在等待队列中的共享节点成功获取到锁以后（它获取到的是共享锁），既然是共享，那它必须要依次唤醒后面所有可以跟它一起共享当前锁资源的节点，毫无疑问，这些节点必须也是在等待共享锁（这是大前提，如果等待的是独占锁，那前面已经有一个共享节点获取锁了，它肯定是获取不到的）。当共享锁被释放的时候，可以用读写锁为例进行思考，当一个读锁被释放，此时不论是读锁还是写锁都是可以竞争资源的。</p><h1 id="并发工具类源码详解"><a href="#并发工具类源码详解" class="headerlink" title="并发工具类源码详解"></a>并发工具类源码详解</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch 这个类是比较典型的 AQS 的共享模式的使用，这是一个高频使用的类。latch 的中文意思是门栓、栅栏，具体怎么解释我就不废话了，大家随意，看两个例子就知道在哪里用、怎么用了。</p><h3 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h3><p>我们看下 Doug Lea 在 java doc 中给出的例子，这个例子非常实用，我们经常会写这个代码。</p><p>假设我们有 N ( N &gt; 0 ) 个任务，那么我们会用 N 来初始化一个 CountDownLatch，然后将这个 latch 的引用传递到各个线程中，在每个线程完成了任务后，调用 latch.countDown() 代表完成了一个任务。</p><p>调用 latch.await() 的方法的线程会阻塞，直到所有的任务完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver2</span> </span>&#123; <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line">        Executor e = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 N 个任务，提交给线程池来执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">            e.execute(<span class="keyword">new</span> WorkerRunnable(doneSignal, i));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有的任务完成，这个方法才会返回</span></span><br><span class="line">        doneSignal.await();           <span class="comment">// wait for all to finish</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    WorkerRunnable(CountDownLatch doneSignal, <span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doWork(i);</span><br><span class="line">            <span class="comment">// 这个线程的任务完成了，调用 countDown 方法</span></span><br><span class="line">            doneSignal.countDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">        &#125; <span class="comment">// return;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; ...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说 CountDownLatch 非常实用，我们常常会将一个比较大的任务进行拆分，然后开启多个线程来执行，等所有线程都执行完了以后，再往下执行其他操作。这里例子中，只有 main 线程调用了 await 方法。</p><p>我们再来看另一个例子，这个例子很典型，用了两个 CountDownLatch：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123; <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(startSignal, doneSignal)).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这边插入一些代码，确保上面的每个线程先启动起来，才执行下面的代码。</span></span><br><span class="line">        doSomethingElse();            <span class="comment">// don't let run yet</span></span><br><span class="line">        <span class="comment">// 因为这里 N == 1，所以，只要调用一次，那么所有的 await 方法都可以通过</span></span><br><span class="line">        startSignal.countDown();      <span class="comment">// let all threads proceed</span></span><br><span class="line">        doSomethingElse();</span><br><span class="line">        <span class="comment">// 等待所有任务结束</span></span><br><span class="line">        doneSignal.await();           <span class="comment">// wait for all to finish</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line"></span><br><span class="line">    Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;</span><br><span class="line">        <span class="keyword">this</span>.startSignal = startSignal;</span><br><span class="line">        <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 为了让所有线程同时开始任务，我们让所有线程先阻塞在这里</span></span><br><span class="line">            <span class="comment">// 等大家都准备好了，再打开这个门栓</span></span><br><span class="line">            startSignal.await();</span><br><span class="line">            doWork();</span><br><span class="line">            doneSignal.countDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">        &#125; <span class="comment">// return;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; ...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，doneSignal 同第一个例子的使用，我们说说这里的 startSignal。N 个新开启的线程都调用了startSignal.await() 进行阻塞等待，它们阻塞在栅栏上，只有当条件满足的时候（startSignal.countDown()），它们才能同时通过这个栅栏。</p><p><img src="https://javadoop.com/blogimages/AbstractQueuedSynchronizer-3/5.png" alt="5"></p><p>如果始终只有一个线程调用 await 方法等待任务完成，那么 CountDownLatch 就会简单很多，所以之后的源码分析读者一定要在脑海中构建出这么一个场景：有 m 个线程是做任务的，有 n 个线程在某个栅栏上等待这 m 个线程做完任务，直到所有 m 个任务完成后，n 个线程同时通过栅栏。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>Talk is cheap, show me the code.</p><p>构造方法，需要传入一个不小于 0 的整数：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CountDownLatch(<span class="keyword">int</span> <span class="keyword">count</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">count</span> &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(<span class="keyword">count</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 老套路了，内部封装一个 Sync 类继承自 AQS</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    Sync(<span class="keyword">int</span> <span class="keyword">count</span>) &#123;</span><br><span class="line">        <span class="comment">// 这样就 state == count 了</span></span><br><span class="line">        setState(<span class="keyword">count</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码都是套路，先分析套路：AQS 里面的 state 是一个整数值，这边用一个 int count 参数其实初始化就是设置了这个值，所有调用了 await 方法的等待线程会挂起，然后有其他一些线程会做 state = state - 1 操作，当 state 减到 0 的同时，那个线程会负责唤醒调用了 await 方法的所有线程。都是套路啊，只是 Doug Lea 的套路很深，代码很巧妙，不然我们也没有要分析源码的必要。</p><p>对于 CountDownLatch，我们仅仅需要关心两个方法，一个是 countDown() 方法，另一个是 await() 方法。countDown() 方法每次调用都会将 state 减 1，直到 state 的值为 0；而 await 是一个阻塞方法，当 state 减为 0 的时候，await 方法才会返回。await 可以被多个线程调用，读者这个时候脑子里要有个图：所有调用了 await 方法的线程阻塞在 AQS 的阻塞队列中，等待条件满足（state == 0），将线程从队列中一个个唤醒过来。</p><p>我们用以下程序来分析源码，t1 和 t2 负责调用 countDown() 方法，t3 和 t4 调用 await 方法阻塞：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 休息 5 秒后(模拟线程工作了 5 秒)，调用 countDown()</span></span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 休息 10 秒后(模拟线程工作了 10 秒)，调用 countDown()</span></span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 阻塞，等待 state 减为 0</span></span><br><span class="line">                    latch.<span class="keyword">await</span>();</span><br><span class="line">                    System.<span class="keyword">out</span>.println(<span class="string">"线程 t3 从 await 中返回了"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.<span class="keyword">out</span>.println(<span class="string">"线程 t3 await 被中断"</span>);</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t3"</span>);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 阻塞，等待 state 减为 0</span></span><br><span class="line">                    latch.<span class="keyword">await</span>();</span><br><span class="line">                    System.<span class="keyword">out</span>.println(<span class="string">"线程 t4 从 await 中返回了"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.<span class="keyword">out</span>.println(<span class="string">"线程 t4 await 被中断"</span>);</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t4"</span>);</span><br><span class="line"></span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序，大概在过了 10 秒左右的时候，会输出：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程 t3 从 <span class="keyword">await</span> 中返回了</span><br><span class="line">线程 t4 从 <span class="keyword">await</span> 中返回了</span><br><span class="line"><span class="comment">// 这两条输出，顺序不是绝对的</span></span><br><span class="line"><span class="comment">// 后面的分析，我们假设 t3 先进入阻塞队列</span></span><br></pre></td></tr></table></figure><p>接下来，我们按照流程一步一步走：先 await 等待，然后被唤醒，await 方法返回。</p><p>首先，我们来看 await() 方法，它代表线程阻塞，等待 state 的值减为 0。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> acquireSharedInterruptibly(<span class="keyword">int</span> arg)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 这也是老套路了，我在第二篇的中断那一节说过了</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// t3 和 t4 调用 await 的时候，state 都大于 0。</span></span><br><span class="line">    <span class="comment">// 也就是说，这个 if 返回 true，然后往里看</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只有当 state == 0 的时候，这个方法才会返回 1</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从方法名我们就可以看出，这个方法是获取共享锁，并且此方法是可中断的（中断的时候抛出 InterruptedException 退出这个方法）。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    // <span class="number">1</span>\. 入队</span><br><span class="line">    final <span class="keyword">Node</span> <span class="title">node</span> = addWaiter(<span class="keyword">Node</span>.<span class="title">SHARED</span>);</span><br><span class="line">    boolean failed = <span class="literal">true</span>;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final <span class="keyword">Node</span> <span class="title">p</span> = <span class="keyword">node</span>.<span class="title">predecessor</span>();</span><br><span class="line">            if (p == head) &#123;</span><br><span class="line">                // 同上，只要 state 不等于 <span class="number">0</span>，那么这个方法返回 -<span class="number">1</span></span><br><span class="line">                int r = tryAcquireShared(arg);</span><br><span class="line">                if (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(<span class="keyword">node</span><span class="title">, r</span>);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // <span class="number">2</span></span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, <span class="keyword">node</span><span class="title">) &amp;&amp;</span></span><br><span class="line"><span class="title">                parkAndCheckInterrupt</span>())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">    &#125;</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure><p>我们来仔细分析这个方法，线程 t3 经过第 1 步 addWaiter 入队以后，我们应该可以得到这个：</p><p><img src="https://javadoop.com/blogimages/AbstractQueuedSynchronizer-3/2.png" alt="2"></p><p>由于 tryAcquireShared 这个方法会返回 -1，所以 if (r &gt;= 0) 这个分支不会进去。到 shouldParkAfterFailedAcquire 的时候，t3 将 head 的 waitStatus 值设置为 -1，如下：</p><p><img src="https://javadoop.com/blogimages/AbstractQueuedSynchronizer-3/3.png" alt="3"></p><p>然后进入到 parkAndCheckInterrupt 的时候，t3 挂起。</p><p>我们再分析 t4 入队，t4 会将前驱节点 t3 所在节点的 waitStatus 设置为 -1，t4 入队后，应该是这样的：</p><p><img src="https://javadoop.com/blogimages/AbstractQueuedSynchronizer-3/4.png" alt="4"></p><p>然后，t4 也挂起。接下来，t3 和 t4 就等待唤醒了。</p><p>接下来，我们来看唤醒的流程，我们假设用 10 初始化 CountDownLatch。</p><p><img src="https://javadoop.com/blogimages/AbstractQueuedSynchronizer-3/1.png" alt="1"></p><p>当然，我们的例子中，其实没有 10 个线程，只有 2 个线程 t1 和 t2，只是为了让图好看些罢了。</p><p>我们再一步步看具体的流程。首先，我们看 countDown() 方法:</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 只有当 state 减为 0 的时候，tryReleaseShared 才返回 true</span></span><br><span class="line">    <span class="comment">// 否则只是简单的 state = state - 1 那么 countDown 方法就结束了</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 唤醒 await 的线程</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个方法很简单，用自旋的方法实现 state 减 1</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> nextc = c<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>countDown 方法就是每次调用都将 state 值减 1，如果 state 减到 0 了，那么就调用下面的方法进行唤醒阻塞队列中的线程：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用这个方法的时候，state == 0</span></span><br><span class="line"><span class="comment">// 这个方法先不要看所有的代码，按照思路往下到我写注释的地方，其他的之后还会仔细分析</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// t3 入队的时候，已经将头节点的 waitStatus 设置为 Node.SIGNAL（-1） 了</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点</span></span><br><span class="line">                <span class="comment">// 在这里，也就是唤醒 t3</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE)) <span class="comment">// todo</span></span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦 t3 被唤醒后，我们继续回到 await 的这段代码，parkAndCheckInterrupt 返回，我们先不考虑中断的情况：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    final <span class="keyword">Node</span> <span class="title">node</span> = addWaiter(<span class="keyword">Node</span>.<span class="title">SHARED</span>);</span><br><span class="line">    boolean failed = <span class="literal">true</span>;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final <span class="keyword">Node</span> <span class="title">p</span> = <span class="keyword">node</span>.<span class="title">predecessor</span>();</span><br><span class="line">            if (p == head) &#123;</span><br><span class="line">                int r = tryAcquireShared(arg);</span><br><span class="line">                if (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(<span class="keyword">node</span><span class="title">, r</span>); // <span class="number">2</span>\. 这里是下一步</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, <span class="keyword">node</span><span class="title">) &amp;&amp;</span></span><br><span class="line"><span class="title">                // 1</span>\. 唤醒后这个方法返回</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">    &#125;</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure><p>接下来，t3 会进到 setHeadAndPropagate(node, r) 这个方法，先把 head 给占了，然后唤醒队列中其他的线程：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面说的是，唤醒当前 node 之后的节点，即 t3 已经醒了，马上唤醒 t4</span></span><br><span class="line">    <span class="comment">// 类似的，如果 t4 后面还有 t5，那么 t4 醒了以后，马上将 t5 给唤醒了</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            <span class="comment">// 又是这个方法，只是现在的 head 已经不是原来的空节点了，是 t3 的节点了</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又回到这个方法了，那么接下来，我们好好分析 doReleaseShared 这个方法，我们根据流程，头节点 head 此时是 t3 节点了：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用这个方法的时候，state == 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 1\. h == null: 说明阻塞队列为空</span></span><br><span class="line">        <span class="comment">// 2\. h == tail: 说明头结点可能是刚刚初始化的头节点，</span></span><br><span class="line">        <span class="comment">//   或者是普通线程节点，但是此节点既然是头节点了，那么代表已经被唤醒了，阻塞队列没有其他节点了</span></span><br><span class="line">        <span class="comment">// 所以这两种情况不需要进行唤醒后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// t4 将头节点(此时是 t3)的 waitStatus 设置为 Node.SIGNAL（-1） 了</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 这里 CAS 失败的场景请看下面的解读</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点</span></span><br><span class="line">                <span class="comment">// 在这里，也就是唤醒 t4</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     <span class="comment">// 这个 CAS 失败的场景是：执行到这里的时候，刚好有一个节点入队，入队会将这个 ws 设置为 -1</span></span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果到这里的时候，前面唤醒的线程已经占领了 head，那么再循环</span></span><br><span class="line">        <span class="comment">// 否则，就是 head 没变，那么退出循环，</span></span><br><span class="line">        <span class="comment">// 退出循环是不是意味着阻塞队列中的其他节点就不唤醒了？当然不是，唤醒的线程之后还是会调用这个方法的</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们分析下最后一个 if 语句，然后才能解释第一个 CAS 为什么可能会失败：</p><ol><li>h == head：说明头节点还没有被刚刚用 unparkSuccessor 唤醒的线程（这里可以理解为 t4）占有，此时 break 退出循环。</li><li>h != head：头节点被刚刚唤醒的线程（这里可以理解为 t4）占有，那么这里重新进入下一轮循环，唤醒下一个节点（这里是 t4 ）。我们知道，等到 t4 被唤醒后，其实是会主动唤醒 t5、t6、t7…，那为什么这里要进行下一个循环来唤醒 t5 呢？我觉得是出于吞吐量的考虑。</li></ol><p>满足上面的 2 的场景，那么我们就能知道为什么上面的 CAS 操作 compareAndSetWaitStatus(h, Node.SIGNAL, 0) 会失败了？</p><p>因为当前进行 for 循环的线程到这里的时候，可能刚刚唤醒的线程 t4 也刚刚好到这里了，那么就有可能 CAS 失败了。</p><p>for 循环第一轮的时候会唤醒 t4，t4 醒后会将自己设置为头节点，如果在 t4 设置头节点后，for 循环才跑到 if (h == head)，那么此时会返回 false，for 循环会进入下一轮。t4 唤醒后也会进入到这个方法里面，那么 for 循环第二轮和 t4 就有可能在这个 CAS 相遇，那么就只会有一个成功了。</p><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>字面意思是“可重复使用的栅栏”，CyclicBarrier 相比 CountDownLatch 来说，要简单很多，其源码没有什么高深的地方，它是 ReentrantLock 和 Condition 的组合使用。看如下示意图，CyclicBarrier 和 CountDownLatch 是不是很像，只是 CyclicBarrier 可以有不止一个栅栏，因为它的栅栏（Barrier）可以重复使用（Cyclic）。</p><p><img src="https://javadoop.com/blogimages/AbstractQueuedSynchronizer-3/cyclicbarrier-2.png" alt="cyclicbarrier-2"></p><p>首先，CyclicBarrier 的源码实现和 CountDownLatch 大相径庭，CountDownLatch 基于 AQS 的共享模式的使用，而 CyclicBarrier 基于 Condition 来实现。</p><p>因为 CyclicBarrier 的源码相对来说简单许多，读者只要熟悉了前面关于 Condition 的分析，那么这里的源码是毫无压力的，就是几个特殊概念罢了。</p><p>废话结束，先上基本属性和构造方法，往下拉一点点，和图一起看：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 我们说了，CyclicBarrier 是可以重复使用的，我们把每次从开始使用到穿过栅栏当做"一代"</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The lock for guarding barrier entry */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// CyclicBarrier 是基于 Condition 的</span></span><br><span class="line">    <span class="comment">// Condition 是“条件”的意思，CyclicBarrier 的等待线程通过 barrier 的“条件”是大家都到了栅栏上</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参与的线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设置了这个，代表越过栅栏之前，要执行相应的操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前所处的“代”</span></span><br><span class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还没有到栅栏的线程数，这个值初始为 parties，然后递减</span></span><br><span class="line">    <span class="comment">// 还没有到栅栏的线程数 = parties - 已经到栅栏的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">count</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CyclicBarrier(<span class="keyword">int</span> parties, Runnable barrierAction) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.parties = parties;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">count</span> = parties;</span><br><span class="line">        <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CyclicBarrier(<span class="keyword">int</span> parties) &#123;</span><br><span class="line">        <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我用一图来描绘下 CyclicBarrier 里面的一些概念：</p><p><img src="https://javadoop.com/blogimages/AbstractQueuedSynchronizer-3/cyclicbarrier-3.png" alt="cyclicbarrier-3"></p><p>看图我们也知道了，CyclicBarrier 的源码最重要的就是 await() 方法了。</p><p>首先，先看怎么开启新的一代：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启新的一代，当最后一个线程到达栅栏上的时候，调用这个方法来唤醒其他线程，同时初始化“下一代”</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先，需要唤醒所有的在栅栏上等待的线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// 更新 count 的值</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 重新生成“新一代”</span></span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看怎么打破一个栅栏：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置状态 broken 为 true</span></span><br><span class="line">    generation.broken = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 重置 count 为初始值 parties</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 唤醒所有已经在等待的线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法之后用得到，现在开始分析最重要的等待通过栅栏方法 await 方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不带超时机制</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">dowait</span><span class="params">(<span class="keyword">false</span>, <span class="number">0</span>L)</span></span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 带超时机制，如果超时抛出 TimeoutException 异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> await(<span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException,</span><br><span class="line">           BrokenBarrierException,</span><br><span class="line">           TimeoutException &#123;</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往里看：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> dowait(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span><br><span class="line">        throws InterruptedException, BrokenBarrierException,</span><br><span class="line">               TimeoutException &#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 先要获取到锁，然后在 finally 中要记得释放锁</span></span><br><span class="line">    <span class="comment">// 如果记得 Condition 部分的话，我们知道 condition 的 await 会释放锁，signal 的时候需要重新获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">        <span class="comment">// 检查栅栏是否被打破，如果被打破，抛出 BrokenBarrierException 异常</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line">        <span class="comment">// 检查中断状态，如果中断了，抛出 InterruptedException 异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// index 是这个 await 方法的返回值</span></span><br><span class="line">        <span class="comment">// 注意到这里，这个是从 count 递减后得到的值</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">index</span> = --<span class="keyword">count</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果等于 0，说明所有的线程都到栅栏上了，准备通过</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">index</span> == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果在初始化的时候，指定了通过栅栏前需要执行的操作，在这里会得到执行</span></span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                <span class="comment">// 如果 ranAction 为 true，说明执行 command.run() 的时候，没有发生异常退出的情况</span></span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒等待的线程，然后开启新的一代</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    <span class="comment">// 进到这里，说明执行指定操作的时候，发生了异常，那么需要打破栅栏</span></span><br><span class="line">                    <span class="comment">// 之前我们说了，打破栅栏意味着唤醒所有等待的线程，设置 broken 为 true，重置 count 为 parties</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="comment">// 如果是最后一个线程调用 await，那么上面就返回了</span></span><br><span class="line">        <span class="comment">// 下面的操作是给那些不是最后一个到达栅栏的线程执行的</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果带有超时机制，调用带超时的 Condition 的 await 方法等待，直到最后一个线程调用 await</span></span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>L)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">// 如果到这里，说明等待的线程在 await（是 Condition 的 await）的时候被中断</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    <span class="comment">// 打破栅栏</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="comment">// 打破栅栏后，重新抛出这个 InterruptedException 异常给外层调用的方法</span></span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 到这里，说明 g != generation, 说明新的一代已经产生，即最后一个线程 await 执行完成，</span></span><br><span class="line">                    <span class="comment">// 那么此时没有必要再抛出 InterruptedException 异常，记录下来这个中断信息即可</span></span><br><span class="line">                    <span class="comment">// 或者是栅栏已经被打破了，那么也不应该抛出 InterruptedException 异常，</span></span><br><span class="line">                    <span class="comment">// 而是之后抛出 BrokenBarrierException 异常</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 唤醒后，检查栅栏是否是“破的”</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这个 for 循环除了异常，就是要从这里退出了</span></span><br><span class="line">            <span class="comment">// 我们要清楚，最后一个线程在执行完指定任务(如果有的话)，会调用 nextGeneration 来开启一个新的代</span></span><br><span class="line">            <span class="comment">// 然后释放掉锁，其他线程从 Condition 的 await 方法中得到锁并返回，然后到这里的时候，其实就会满足 g != generation 的</span></span><br><span class="line">            <span class="comment">// 那什么时候不满足呢？barrierCommand 执行过程中抛出了异常，那么会执行打破栅栏操作，</span></span><br><span class="line">            <span class="comment">// 设置 broken 为true，然后唤醒这些线程。这些线程会从上面的 if (g.broken) 这个分支抛 BrokenBarrierException 异常返回</span></span><br><span class="line">            <span class="comment">// 当然，还有最后一种可能，那就是 await 超时，此种情况不会从上面的 if 分支异常返回，也不会从这里返回，会执行后面的代码</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">index</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果醒来发现超时了，打破栅栏，抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>L) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，我想我应该讲清楚了吧，我好像几乎没有漏掉任何一行代码吧？</p><p>下面开始收尾工作。</p><p>首先，我们看看怎么得到有多少个线程到了栅栏上，处于等待状态：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberWaiting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> parties - count;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断一个栅栏是否被打破了，这个很简单，直接看 broken 的值即可：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">isBroken</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> generation.broken;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面我们在说 await 的时候也几乎说清楚了，什么时候栅栏会被打破，总结如下：</p><ol><li>中断，我们说了，如果某个等待的线程发生了中断，那么会打破栅栏，同时抛出 InterruptedException 异常；</li><li>超时，打破栅栏，同时抛出 TimeoutException 异常；</li><li>指定执行的操作抛出了异常，这个我们前面也说过。</li></ol><p>最后，我们来看看怎么重置一个栅栏：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">        nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们设想一下，如果初始化时，指定了线程 parties = 4，前面有 3 个线程调用了 await 等待，在第 4 个线程调用 await 之前，我们调用 reset 方法，那么会发生什么？</p><p>首先，打破栅栏，那意味着所有等待的线程（3个等待的线程）会唤醒，await 方法会通过抛出 BrokenBarrierException 异常返回。然后开启新的一代，重置了 count 和 generation，相当于一切归零了。</p><p>怎么样，CyclicBarrier 源码很简单吧。</p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>有了 CountDownLatch 的基础后，分析 Semaphore 会简单很多。Semaphore 是什么呢？它类似一个资源池（读者可以类比线程池），每个线程需要调用 acquire() 方法获取资源，然后才能执行，执行完后，需要 release 资源，让给其他的线程用。</p><p>大概大家也可以猜到，Semaphore 其实也是 AQS 中共享锁的使用，因为每个线程共享一个池嘛。</p><p>套路解读：创建 Semaphore 实例的时候，需要一个参数 permits，这个基本上可以确定是设置给 AQS 的 state 的，然后每个线程调用 acquire 的时候，执行 state = state - 1，release 的时候执行 state = state + 1，当然，acquire 的时候，如果 state = 0，说明没有资源了，需要等待其他线程 release。</p><p>构造方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里和 ReentrantLock 类似，用了公平策略和非公平策略。</p><p>看 acquire 方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.acquireSharedInterruptibly(permits);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.acquireShared(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几个方法也是老套路了，大家基本都懂了吧，这边多了两个可以传参的 acquire 方法，不过大家也都懂的吧，如果我们需要一次获取超过一个的资源，会用得着这个的。</p><p>我们接下来看不抛出 InterruptedException 异常的 acquireUninterruptibly() 方法吧：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面说了，Semaphore 分公平策略和非公平策略，我们对比一下两个 tryAcquireShared 方法：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公平策略：</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> tryAcquireShared(<span class="keyword">int</span> acquires) &#123;</span><br><span class="line">    <span class="built_in">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 区别就在于是不是会先判断是否有线程在排队，然后才进行 CAS 减操作</span></span><br><span class="line">        <span class="built_in">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="built_in">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">available</span> = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = <span class="built_in">available</span> - acquires;</span><br><span class="line">        <span class="built_in">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(<span class="built_in">available</span>, remaining))</span><br><span class="line">            <span class="built_in">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非公平策略：</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> tryAcquireShared(<span class="keyword">int</span> acquires) &#123;</span><br><span class="line">    <span class="built_in">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br><span class="line">final <span class="keyword">int</span> nonfairTryAcquireShared(<span class="keyword">int</span> acquires) &#123;</span><br><span class="line">    <span class="built_in">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">available</span> = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = <span class="built_in">available</span> - acquires;</span><br><span class="line">        <span class="built_in">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(<span class="built_in">available</span>, remaining))</span><br><span class="line">            <span class="built_in">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是老套路了，所以从源码分析角度的话，我们其实不太需要关心是不是公平策略还是非公平策略，它们的区别往往就那么一两行。</p><p>我们再回到 acquireShared 方法，</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 tryAcquireShared(arg) 返回小于 0 的时候，说明 state 已经小于 0 了（没资源了），此时 acquire 不能立马拿到资源，需要进入到阻塞队列等待，虽然贴了很多代码，不在乎多这点了：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">    final <span class="keyword">Node</span> <span class="title">node</span> = addWaiter(<span class="keyword">Node</span>.<span class="title">SHARED</span>);</span><br><span class="line">    boolean failed = <span class="literal">true</span>;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = <span class="literal">false</span>;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final <span class="keyword">Node</span> <span class="title">p</span> = <span class="keyword">node</span>.<span class="title">predecessor</span>();</span><br><span class="line">            if (p == head) &#123;</span><br><span class="line">                int r = tryAcquireShared(arg);</span><br><span class="line">                if (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(<span class="keyword">node</span><span class="title">, r</span>);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    if (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, <span class="keyword">node</span><span class="title">) &amp;&amp;</span></span><br><span class="line"><span class="title">                parkAndCheckInterrupt</span>())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">    &#125;</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure><p>这个方法我就不介绍了，线程挂起后等待有资源被 release 出来。接下来，我们就要看 release 的方法了：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务介绍，释放一个资源</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="comment">// 溢出，当然，我们一般也不会用这么大的数</span></span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryReleaseShared 方法总是会返回 true，然后是 doReleaseShared，这个也是我们熟悉的方法了，我就贴下代码，不分析了，这个方法用于唤醒所有的等待线程：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Semphore 的源码确实很简单，基本上都是分析过的老代码的组合使用了。</p><h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><blockquote><p>此篇博客所有源码均来自JDK 1.8</p></blockquote><p>前面三篇博客分别介绍了CyclicBarrier、CountDownLatch、Semaphore，现在介绍并发工具类中的最后一个Exchange。Exchange是最简单的也是最复杂的，简单在于API非常简单，就一个构造方法和两个exchange()方法，最复杂在于它的实现是最复杂的（反正我是看晕了的）。</p><p>在API是这么介绍的：可以在对中对元素进行配对和交换的线程的同步点。每个线程将条目上的某个方法呈现给 exchange 方法，与伙伴线程进行匹配，并且在返回时接收其伙伴的对象。Exchanger 可能被视为 SynchronousQueue 的双向形式。Exchanger 可能在应用程序（比如遗传算法和管道设计）中很有用。</p><p>Exchanger，它允许在并发任务之间交换数据。具体来说，Exchanger类允许在两个线程之间定义同步点。当两个线程都到达同步点时，他们交换数据结构，因此第一个线程的数据结构进入到第二个线程中，第二个线程的数据结构进入到第一个线程中。</p><p><strong>功能简介：</strong></p><ul><li>Exchanger是一种线程间安全交换数据的机制。可以和之前分析过的SynchronousQueue对比一下：线程A通过SynchronousQueue将数据a交给线程B；线程A通过Exchanger和线程B交换数据，线程A把数据a交给线程B，同时线程B把数据b交给线程A。可见，SynchronousQueue是交给一个数据，Exchanger是交换两个数据。</li></ul><h3 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h3><p>Exchange实现较为复杂，我们先看其怎么使用，然后再来分析其源码。现在我们用Exchange来模拟生产-消费者问题：</p><pre><code>    public class ExchangerTest {    static class Producer implements Runnable{        //生产者、消费者交换的数据结构        private List&lt;String&gt; buffer;        //步生产者和消费者的交换对象        private Exchanger&lt;List&lt;String&gt;&gt; exchanger;        Producer(List&lt;String&gt; buffer,Exchanger&lt;List&lt;String&gt;&gt; exchanger){            this.buffer = buffer;            this.exchanger = exchanger;        }        @Override        public void run() {            for(int i = 1 ; i &lt; 5 ; i++){                System.out.println(&quot;生产者第&quot; + i + &quot;次提供&quot;);                for(int j = 1 ; j &lt;= 3 ; j++){                    System.out.println(&quot;生产者装入&quot; + i  + &quot;--&quot; + j);                    buffer.add(&quot;buffer：&quot; + i + &quot;--&quot; + j);                }                System.out.println(&quot;生产者装满，等待与消费者交换...&quot;);                try {                    exchanger.exchange(buffer);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }    static class Consumer implements Runnable {        private List&lt;String&gt; buffer;        private final Exchanger&lt;List&lt;String&gt;&gt; exchanger;        public Consumer(List&lt;String&gt; buffer, Exchanger&lt;List&lt;String&gt;&gt; exchanger) {            this.buffer = buffer;            this.exchanger = exchanger;        }        @Override        public void run() {            for (int i = 1; i &lt; 5; i++) {                //调用exchange()与消费者进行数据交换                try {                    buffer = exchanger.exchange(buffer);                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println(&quot;消费者第&quot; + i + &quot;次提取&quot;);                for (int j = 1; j &lt;= 3 ; j++) {                    System.out.println(&quot;消费者 : &quot; + buffer.get(0));                    buffer.remove(0);                }            }        }    }    public static void main(String[] args){        List&lt;String&gt; buffer1 = new ArrayList&lt;String&gt;();        List&lt;String&gt; buffer2 = new ArrayList&lt;String&gt;();        Exchanger&lt;List&lt;String&gt;&gt; exchanger = new Exchanger&lt;List&lt;String&gt;&gt;();        Thread producerThread = new Thread(new Producer(buffer1,exchanger));        Thread consumerThread = new Thread(new Consumer(buffer2,exchanger));        producerThread.start();        consumerThread.start();    }}</code></pre><p>运行结果：<br>[<img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/05/2017022100011_thumb.jpg" alt="201702210001[1]" title="201702210001[1]">](<a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/05/2017022100011.jpg" target="_blank" rel="noopener">http://cmsblogs.qiniudn.com/wp-content/uploads/2017/05/2017022100011.jpg</a>)</p><p>首先生产者Producer、消费者Consumer首先都创建一个缓冲列表，通过Exchanger来同步交换数据。消费中通过调用Exchanger与生产者进行同步来获取数据，而生产者则通过for循环向缓存队列存储数据并使用exchanger对象消费者同步。到消费者从exchanger哪里得到数据后，他的缓冲列表中有3个数据，而生产者得到的则是一个空的列表。上面的例子充分展示了消费者-生产者是如何利用Exchanger来完成数据交换的。</p><p>在Exchanger中，如果一个线程已经到达了exchanger节点时，对于它的伙伴节点的情况有三种：</p><ol><li>如果它的伙伴节点在该线程到达之前已经调用了exchanger方法，则它会唤醒它的伙伴然后进行数据交换，得到各自数据返回。</li><li>如果它的伙伴节点还没有到达交换点，则该线程将会被挂起，等待它的伙伴节点到达被唤醒，完成数据交换。</li><li>如果当前线程被中断了则抛出异常，或者等待超时了，则抛出超时异常。</li></ol><p>核心交换算法实现</p><p><strong>  换句话说Exchanger提供的是一个交换服务，允许原子性的交换两个（多个）对象，但同时只有一对才会成功。先看一个简单的实例模型。</strong></p><p><img src="https://img-blog.csdn.net/20150424090752975" alt=""></p><p>  在上面的模型中，我们假定一个空的栈（Stack），栈顶（Top）当然是没有元素的。同时我们假定一个数据结构Node，包含一个要交换的元素E和一个要填充的“洞”Node。这时线程T1携带节点node1进入栈（cas_push)，当然这是CAS操作，这样栈顶就不为空了。线程T2携带节点node2进入栈，发现栈里面已经有元素了node1，同时发现node1的hold（Node）为空，于是将自己（node2）填充到node1的hold中（cas_fill）。然后将元素node1从栈中弹出（cas_take）。这样线程T1就得到了node1.hold.item也就是node2的元素e2，线程T2就得到了node1.item也就是e1，从而达到了交换的目的。</p><p>  算法描述就是下图展示的内容。</p><p><img src="https://img-blog.csdn.net/20150424093749583" alt=""></p><p>  JDK 5就是采用类似的思想实现的Exchanger。JDK 6以后为了支持多线程多对象同时Exchanger了就进行了改造（为了支持更好的并发），采用ConcurrentHashMap的思想，将Stack分割成很多的片段（或者说插槽Slot），线程Id（Thread.getId()）hash相同的落在同一个Slot上，这样在默认32个Slot上就有很好的吞吐量。当然会根据机器CPU内核的数量有一定的优化，有兴趣的可以去了解下Exchanger的源码。</p><h3 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h3><p>Exchanger算法的核心是通过一个可交换数据的slot，以及一个可以带有数据item的参与者。源码中的描述如下：</p><pre name="code">  for  (;;)  {  if  (slot is empty)  {  // offer place item in a Node;  if  (can CAS slot from empty to node)  { wait for release;  return matching item in node;  }  }  else  if  (can CAS slot from node to empty)  {  // release  get the item in node;  set matching item in node; release waiting thread;  }  // else retry on CAS failure  }</pre><p>Exchanger中定义了如下几个重要的成员变量：</p><pre name="code">private  final  Participant participant;  private  volatile  Node[] arena;  private  volatile  Node slot;</pre><p>participant的作用是为每个线程保留唯一的一个Node节点。</p><p>slot为单个槽，arena为数组槽。他们都是Node类型。在这里可能会感觉到疑惑，slot作为Exchanger交换数据的场景，应该只需要一个就可以了啊？为何还多了一个Participant 和数组类型的arena呢？一个slot交换场所原则上来说应该是可以的，但实际情况却不是如此，多个参与者使用同一个交换场所时，会存在严重伸缩性问题。既然单个交换场所存在问题，那么我们就安排多个，也就是数组arena。通过数组arena来安排不同的线程使用不同的slot来降低竞争问题，并且可以保证最终一定会成对交换数据。但是Exchanger不是一来就会生成arena数组来降低竞争，只有当产生竞争是才会生成arena数组。那么怎么将Node与当前线程绑定呢？Participant ，Participant 的作用就是为每个线程保留唯一的一个Node节点，它继承ThreadLocal，同时在Node节点中记录在arena中的下标index。</p><p>Node定义如下：</p><pre name="code">  @sun.misc.Contended  static  final  class  Node  {  int index;  // Arena index  int bound;  // Last recorded value of Exchanger.bound  int collides;  // Number of CAS failures at current bound  int hash;  // Pseudo-random for spins  Object item;  // This thread's current item  volatile  Object match;  // Item provided by releasing thread  volatile  Thread parked;  // Set to this thread when parked, else null  }</pre><ul><li>index：arena的下标；</li><li>bound：上一次记录的Exchanger.bound；</li><li>collides：在当前bound下CAS失败的次数；</li><li>hash：伪随机数，用于自旋；</li><li>item：这个线程的当前项，也就是需要交换的数据；</li><li>match：做releasing操作的线程传递的项；</li><li>parked：挂起时设置线程值，其他情况下为null；</li></ul><p>在Node定义中有两个变量值得思考：bound以及collides。前面提到了数组area是为了避免竞争而产生的，如果系统不存在竞争问题，那么完全没有必要开辟一个高效的arena来徒增系统的复杂性。首先通过单个slot的exchanger来交换数据，当探测到竞争时将安排不同的位置的slot来保存线程Node，并且可以确保没有slot会在同一个缓存行上。如何来判断会有竞争呢？CAS替换slot失败，如果失败，则通过记录冲突次数来扩展arena的尺寸，我们在记录冲突的过程中会跟踪“bound”的值，以及会重新计算冲突次数在bound的值被改变时。这里阐述可能有点儿模糊，不着急，我们先有这个概念，后面在arenaExchange中再次做详细阐述。</p><p>我们直接看exchange()方法</p><h3 id="exchange-V-x"><a href="#exchange-V-x" class="headerlink" title="exchange(V x)"></a>exchange(V x)</h3><p>exchange(V x)：等待另一个线程到达此交换点（除非当前线程被中断），然后将给定的对象传送给该线程，并接收该线程的对象。方法定义如下：</p><pre name="code">  public V exchange(V x)  throws  InterruptedException  {  Object v;  Object item =  (x ==  null)  ? NULL_ITEM : x;  // translate null args  if  ((arena !=  null  ||  (v = slotExchange(item,  false,  0L))  ==  null)  &&  ((Thread.interrupted()  ||  // disambiguates null return  (v = arenaExchange(item,  false,  0L))  ==  null)))  throw  new  InterruptedException();  return  (v == NULL_ITEM)  ?  null  :  (V)v;  }</pre><p>这个方法比较好理解：arena为数组槽，如果为null，则执行slotExchange()方法，否则判断线程是否中断，如果中断值抛出InterruptedException异常，没有中断则执行arenaExchange()方法。整套逻辑就是：如果slotExchange(Object item, boolean timed, long ns)方法执行失败了就执行arenaExchange(Object item, boolean timed, long ns)方法，最后返回结果V。</p><p>NULL_ITEM 为一个空节点，其实就是一个Object对象而已，slotExchange()为单个slot交换。</p><p>slotExchange(Object item, boolean timed, long ns)</p><pre name="code">private  final  Object slotExchange(Object item,  boolean timed,  long ns)  {  // 获取当前线程的节点 p  Node p = participant.get();  // 当前线程  Thread t =  Thread.currentThread();  // 线程中断，直接返回  if  (t.isInterrupted())  return  null;  // 自旋  for  (Node q;;)  {  //slot != null  if  ((q = slot)  !=  null)  {  //尝试CAS替换  if  (U.compareAndSwapObject(this, SLOT, q,  null))  {  Object v = q.item;  // 当前线程的项，也就是交换的数据 q.match = item;  // 做releasing操作的线程传递的项  Thread w = q.parked;  // 挂起时设置线程值  // 挂起线程不为null，线程挂起  if  (w !=  null) U.unpark(w);  return v;  }  //如果失败了，则创建arena  //bound 则是上次Exchanger.bound  if  (NCPU >  1  && bound ==  0  && U.compareAndSwapInt(this, BOUND,  0, SEQ)) arena =  new  Node[(FULL +  2)  << ASHIFT];  }  //如果arena != null，直接返回，进入arenaExchange逻辑处理  else  if  (arena !=  null)  return  null;  else  { p.item = item;  if  (U.compareAndSwapObject(this, SLOT,  null, p))  break; p.item =  null;  }  }  /*         * 等待 release         * 进入spin+block模式         */  int h = p.hash;  long  end  = timed ?  System.nanoTime()  + ns :  0L;  int spins =  (NCPU >  1)  ? SPINS :  1;  Object v;  while  ((v = p.match)  ==  null)  {  if  (spins >  0)  { h ^= h <<  1; h ^= h >>>  3; h ^= h <<  10;  if  (h ==  0) h = SPINS |  (int)t.getId();  else  if  (h <  0  &&  (--spins &  ((SPINS >>>  1)  -  1))  ==  0)  Thread.yield();  }  else  if  (slot != p) spins = SPINS;  else  if  (!t.isInterrupted()  && arena ==  null  &&  (!timed ||  (ns =  end  -  System.nanoTime())  >  0L))  { U.putObject(t, BLOCKER,  this); p.parked = t;  if  (slot == p) U.park(false, ns); p.parked =  null; U.putObject(t, BLOCKER,  null);  }  else  if  (U.compareAndSwapObject(this, SLOT, p,  null))  { v = timed && ns <= 0l="" &&="" !t.isinterrupted()="" ?="" timed_out="" :="" null;="" break;="" }="" u.putorderedobject(p,="" match,="" null);="" p.item="null;" p.hash="h;" return="" v;="" }<="" pre=""><p>程序首先通过participant获取当前线程节点Node。检测是否中断，如果中断return null，等待后续抛出InterruptedException异常。</p><p>如果slot不为null，则进行slot消除，成功直接返回数据V，否则失败，则创建arena消除数组。</p><p>如果slot为null，但arena不为null，则返回null，进入arenaExchange逻辑。</p><p>如果slot为null，且arena也为null，则尝试占领该slot，失败重试，成功则跳出循环进入spin+block（自旋+阻塞）模式。</p><p>在自旋+阻塞模式中，首先取得结束时间和自旋次数。如果match(做releasing操作的线程传递的项)为null，其首先尝试spins+随机次自旋（改自旋使用当前节点中的hash，并改变之）和退让。当自旋数为0后，假如slot发生了改变（slot != p）则重置自旋数并重试。否则假如：当前未中断&amp;arena为null&amp;（当前不是限时版本或者限时版本+当前时间未结束）：阻塞或者限时阻塞。假如：当前中断或者arena不为null或者当前为限时版本+时间已经结束：不限时版本：置v为null；限时版本：如果时间结束以及未中断则TIMED_OUT；否则给出null（原因是探测到arena非空或者当前线程中断）。</p><p>match不为空时跳出循环。</p><p>整个slotExchange清晰明了。</p><p>arenaExchange(Object item, boolean timed, long ns)</p><pre name="code">  private  final  Object arenaExchange(Object item,  boolean timed,  long ns)  {  Node[] a = arena;  Node p = participant.get();  for  (int i = p.index;;)  {  // access slot at i  int b, m, c;  long j;  // j is raw array offset  Node q =  (Node)U.getObjectVolatile(a, j =  (i << ASHIFT)  + ABASE);  if  (q !=  null  && U.compareAndSwapObject(a, j, q,  null))  {  Object v = q.item;  // release q.match = item;  Thread w = q.parked;  if  (w !=  null) U.unpark(w);  return v;  }  else  if  (i <= (m="(b" =="" bound)="" &="" mmask)="" &&="" q="=" null)="" {="" p.item="item;" offer="" if="" (u.compareandswapobject(a,="" j,="" null,="" p))="" long="" end="(timed" m="=" 0)="" ?="" system.nanotime()="" +="" ns="" :="" 0l;="" thread="" t="Thread.currentThread();" wait="" for="" (int="" h="p.hash," spins="SPINS;;)" object="" v="p.match;" (v="" !="null)" u.putorderedobject(p,="" match,="" null);="" clear="" next="" use="" p.hash="h;" return="" v;="" }="" else="" (spins="">  0)  { h ^= h <<  1; h ^= h >>>  3; h ^= h <<  10;  // xorshift  if  (h ==  0)  // initialize hash h = SPINS |  (int)t.getId();  else  if  (h <  0  &&  // approx 50% true  (--spins &  ((SPINS >>>  1)  -  1))  ==  0)  Thread.yield();  // two yields per wait  }  else  if  (U.getObjectVolatile(a, j)  != p) spins = SPINS;  // releaser hasn't set match yet  else  if  (!t.isInterrupted()  && m ==  0  &&  (!timed ||  (ns =  end  -  System.nanoTime())  >  0L))  { U.putObject(t, BLOCKER,  this);  // emulate LockSupport p.parked = t;  // minimize window  if  (U.getObjectVolatile(a, j)  == p) U.park(false, ns); p.parked =  null; U.putObject(t, BLOCKER,  null);  }  else  if  (U.getObjectVolatile(a, j)  == p && U.compareAndSwapObject(a, j, p,  null))  {  if  (m !=  0)  // try to shrink U.compareAndSwapInt(this, BOUND, b, b + SEQ -  1); p.item =  null; p.hash = h; i = p.index >>>=  1;  // descend  if  (Thread.interrupted())  return  null;  if  (timed && m ==  0  && ns <= 0l)="" return="" timed_out;="" break;="" expired;="" restart="" }="" else="" p.item="null;" clear="" offer="" {="" if="" (p.bound="" !="b)" stale;="" reset="" p.bound="b;" p.collides="0;" i="(i" ||="" m="=" 0)="" ?="" :="" -="" 1;="" ((c="p.collides)" <="" full="" !u.compareandswapint(this,="" bound,="" b,="" b="" +="" seq="" 1))="" =="0)" cyclically="" traverse="" grow="" p.index="i;" }<="" pre=""><p>首先通过participant取得当前节点Node，然后根据当前节点Node的index去取arena中相对应的节点node。前面提到过arena可以确保不同的slot在arena中是不会相冲突的，那么是怎么保证的呢？我们先看arena的创建：</p><pre name="code">arena =  new  Node[(FULL +  2)  << ASHIFT];</pre><p>这个arena到底有多大呢？我们先看FULL 和ASHIFT的定义：</p><pre name="code">static  final  int FULL =  (NCPU >=  (MMASK <<  1))  ? MMASK : NCPU >>>  1;  private  static  final  int ASHIFT =  7;  private  static  final  int NCPU =  Runtime.getRuntime().availableProcessors();  private  static  final  int MMASK =  0xff;  // 255</pre><p>假如我的机器NCPU = 8 ，则得到的是768大小的arena数组。然后通过以下代码取得在arena中的节点：</p><pre name="code">  Node q =  (Node)U.getObjectVolatile(a, j =  (i << ASHIFT)  + ABASE);</pre><p>他仍然是通过右移ASHIFT位来取得Node的，ABASE定义如下：</p><pre name="code">Class<?> ak =  Node[].class; ABASE = U.arrayBaseOffset(ak)  +  (1  << ASHIFT);</pre><p>U.arrayBaseOffset获取对象头长度，数组元素的大小可以通过unsafe.arrayIndexScale(T[].class) 方法获取到。这也就是说要访问类型为T的第N个元素的话，你的偏移量offset应该是arrayOffset+N*arrayScale。也就是说BASE = arrayOffset+ 128 。其次我们再看Node节点的定义</p><pre name="code">  @sun.misc.Contended  static  final  class  Node{  ....  }</pre><p>在Java 8 中我们是可以利用sun.misc.Contended来规避伪共享的。所以说通过 &lt;&lt; ASHIFT方式加上sun.misc.Contended，所以使得任意两个可用Node不会再同一个缓存行中。</p><p>关于伪共享请参考如下博文：<br><a href="http://ifeve.com/falsesharing/" target="_blank" rel="noopener">伪共享(False Sharing)</a><br><a href="[http://blog.csdn.net/aigoogle/article/details/41518369](http://blog.csdn.net/aigoogle/article/details/41518369"> Java8中用sun.misc.Contended避免伪共享(false sharing)</a>)</p><p>我们再次回到arenaExchange()。取得arena中的node节点后，如果定位的节点q 不为空，且CAS操作成功，则交换数据，返回交换的数据，唤醒等待的线程。</p><p>如果q等于null且下标在bound &amp; MMASK范围之内，则尝试占领该位置，如果成功，则采用自旋 + 阻塞的方式进行等待交换数据。</p><p>如果下标不在bound &amp; MMASK范围之内获取由于q不为null但是竞争失败的时候：消除p。加入bound 不等于当前节点的bond（b != p.bound），则更新p.bound = b，collides = 0 ，i = m或者m - 1。如果冲突的次数不到m 获取m 已经为最大值或者修改当前bound的值失败，则通过增加一次collides以及循环递减下标i的值；否则更新当前bound的值成功：我们令i为m+1即为此时最大的下标。最后更新当前index的值。</p><p>Exchanger使用、原理都比较好理解，但是这个源码看起来真心有点儿复杂，是真心难看懂，但是这种交换的思路Doug Lea在后续博文中还会提到，例如SynchronousQueue、LinkedTransferQueue。</p><p>最后用一个在网上看到的段子结束此篇博客（<a href="http://brokendreams.iteye.com/blog/2253956" target="_blank" rel="noopener">http://brokendreams.iteye.com/blog/2253956</a>），博主对其做了一点点修改，以便更加符合在1.8环境下的Exchanger：</p><p>其实就是”我”和”你”(可能有多个”我”，多个”你”)在一个叫Slot的地方做交易(一手交钱，一手交货)，过程分以下步骤：</p><ol><li>我先到一个叫做Slot的交易场所交易，发现你已经到了，那我就尝试喊你交易，如果你回应了我，决定和我交易那么进入第2步；如果别人抢先一步把你喊走了，那我就进入第5步。</li><li>我拿出钱交给你，你可能会接收我的钱，然后把货给我，交易结束；也可能嫌我掏钱太慢(超时)或者接个电话(中断)，TM的不卖了，走了，那我只能再找别人买货了(从头开始)。</li><li>我到交易地点的时候，你不在，那我先尝试把这个交易点给占了(一屁股做凳子上…)，如果我成功抢占了单间(交易点)，那就坐这儿等着你拿货来交易，进入第4步；如果被别人抢座了，那我只能在找别的地方儿了，进入第5步。</li><li>你拿着货来了，喊我交易，然后完成交易；也可能我等了好长时间你都没来，我不等了，继续找别人交易去，走的时候我看了一眼，一共没多少人，弄了这么多单间(交易地点Slot)，太TM浪费了，我喊来交易地点管理员：一共也没几个人，搞这么多单间儿干毛，给哥撤一个！。然后再找别人买货(从头开始)；或者我老大给我打了个电话，不让我买货了(中断)。</li><li>我跑去喊管理员，尼玛，就一个坑交易个毛啊，然后管理在一个更加开阔的地方开辟了好多个单间，然后我就挨个来看每个单间是否有人。如果有人我就问他是否可以交易，如果回应了我，那我就进入第2步。如果我没有人，那我就占着这个单间等其他人来交易，进入第4步。<br>6.如果我尝试了几次都没有成功，我就会认为，是不是我TM选的这个单间风水不好？不行，得换个地儿继续(从头开始)；如果我尝试了多次发现还没有成功，怒了，把管理员喊来：给哥再开一个单间(Slot)，加一个凳子，这么多人就这么几个破凳子够谁用！</li></ol><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>CountdownLatch基于AQS的共享锁实现，线程运行完内部调用cas操作修改state - 1，当state为0时阻塞的线程被一起唤醒。</p><p>collidebarrier基于lock和condition实现，线程运行到屏障时cas操作修改state - 1，并阻塞在condition上，state= 0 时conditon.signal阻塞的线程。</p><p>Semaphore基于AQS共享实现。同上。</p><p>exchanger内部保持一个栈（后来改为slot或slot数组），一个线程进入时cas把数据放到栈中，并阻塞，另一个线程进来发现有东西，cas获取并清空，同时把数据放到伙伴线程的一个结构中，唤醒伙伴线程，运行完毕。</p><p>写到这里，终于把 AbstractQueuedSynchronizer 基本上说完了，对于 Java 并发，Doug Lea 真的是神一样的存在。日后我们还会接触到很多 Doug Lea 的代码，希望我们大家都可以朝着大神的方向不断打磨自己的技术，少一些高大上的架构，多一些实实在在的优秀代码吧。</p></=></=></pre></=></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java并发指南&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/21961.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21961.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java并发" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="JUC" scheme="http://h2pl.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java并发指南8：AQS中的公平锁与非公平锁，Condtion</title>
    <link href="http://h2pl.github.io/2018/05/20/concurrent8/"/>
    <id>http://h2pl.github.io/2018/05/20/concurrent8/</id>
    <published>2018-05-20T15:05:54.000Z</published>
    <updated>2018-06-11T13:43:20.781Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java并发指南<br><a href="https://blog.csdn.net/column/details/21961.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21961.html</a></p><p>相关代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><p>一行一行源码分析清楚 AbstractQueuedSynchronizer (二)</p><p>转自<a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2" target="_blank" rel="noopener">https://www.javadoop.com/post/AbstractQueuedSynchronizer-2</a></p><p>文章比较长，信息量比较大，建议在 pc 上阅读。文章标题是为了呼应前文，其实可以单独成文的，主要是希望读者看文章能系统看。</p><p>本文关注以下几点内容：</p><ol><li>深入理解 ReentrantLock 公平锁和非公平锁的区别</li><li>深入分析 AbstractQueuedSynchronizer 中的 ConditionObject</li><li>深入理解 java 线程中断和 InterruptedException 异常</li></ol><p>基本上本文把以上几点都说清楚了，我假设读者看过<a href="http://hongjiev.github.io/2017/06/16/AbstractQueuedSynchronizer/" target="_blank" rel="noopener">上一篇文章中对 AbstractQueuedSynchronizer 的介绍 </a>，当然如果你已经熟悉 AQS 中的独占锁了，那也可以直接看这篇。各小节之间基本上没什么关系，大家可以只关注自己感兴趣的部分。</p><ul><li><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81" target="_blank" rel="noopener">公平锁和非公平锁</a></li><li><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2#Condition" target="_blank" rel="noopener">Condition</a><ul><li><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2#1.%20%E5%B0%86%E8%8A%82%E7%82%B9%E5%8A%A0%E5%85%A5%E5%88%B0%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97" target="_blank" rel="noopener">1. 将节点加入到条件队列</a></li><li><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2#2.%20%E5%AE%8C%E5%85%A8%E9%87%8A%E6%94%BE%E7%8B%AC%E5%8D%A0%E9%94%81" target="_blank" rel="noopener">2. 完全释放独占锁</a></li><li><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2#3.%20%E7%AD%89%E5%BE%85%E8%BF%9B%E5%85%A5%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97" target="_blank" rel="noopener">3. 等待进入阻塞队列</a></li><li><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2#4.%20signal%20%E5%94%A4%E9%86%92%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%BD%AC%E7%A7%BB%E5%88%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97" target="_blank" rel="noopener">4. signal 唤醒线程，转移到阻塞队列</a></li><li><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2#5.%20%E5%94%A4%E9%86%92%E5%90%8E%E6%A3%80%E6%9F%A5%E4%B8%AD%E6%96%AD%E7%8A%B6%E6%80%81" target="_blank" rel="noopener">5. 唤醒后检查中断状态</a></li><li><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2#6.%20%E8%8E%B7%E5%8F%96%E7%8B%AC%E5%8D%A0%E9%94%81" target="_blank" rel="noopener">6. 获取独占锁</a></li><li><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2#7.%20%E5%A4%84%E7%90%86%E4%B8%AD%E6%96%AD%E7%8A%B6%E6%80%81" target="_blank" rel="noopener">7. 处理中断状态</a></li><li><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2#*%20%E5%B8%A6%E8%B6%85%E6%97%B6%E6%9C%BA%E5%88%B6%E7%9A%84%20await" target="_blank" rel="noopener">* 带超时机制的 await</a></li><li><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2#*%20%E4%B8%8D%E6%8A%9B%E5%87%BA%20InterruptedException%20%E7%9A%84%20await" target="_blank" rel="noopener">* 不抛出 InterruptedException 的 await</a></li></ul></li><li><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2#AbstractQueuedSynchronizer%20%E7%8B%AC%E5%8D%A0%E9%94%81%E7%9A%84%E5%8F%96%E6%B6%88%E6%8E%92%E9%98%9F" target="_blank" rel="noopener">AbstractQueuedSynchronizer 独占锁的取消排队</a></li><li><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2#%E5%86%8D%E8%AF%B4%20java%20%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E5%92%8C%20InterruptedException%20%E5%BC%82%E5%B8%B8" target="_blank" rel="noopener">再说 java 线程中断和 InterruptedException 异常</a><ul><li><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2#%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD" target="_blank" rel="noopener">线程中断</a></li><li><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2#InterruptedException%20%E6%A6%82%E8%BF%B0" target="_blank" rel="noopener">InterruptedException 概述</a></li><li><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2#%E5%A4%84%E7%90%86%E4%B8%AD%E6%96%AD" target="_blank" rel="noopener">处理中断</a></li></ul></li><li><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">总结</a></li></ul><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>ReentrantLock 默认采用非公平锁，除非你在构造方法中传入参数 true 。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平锁的 lock 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 1\. 和非公平锁相比，这里多了一个判断：是否有线程在等待</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非公平锁的 lock 方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2\. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">nonfairTryAcquire</span><span class="params">(acquires)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment"> * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：公平锁和非公平锁只有两处不同：</p><ol><li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li><li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li></ol><p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p><p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>Tips: 这里重申一下，要看懂这个，必须要先看懂上一篇关于 <a href="http://hongjiev.github.io/2017/06/16/AbstractQueuedSynchronizer/" target="_blank" rel="noopener">AbstractQueuedSynchronizer</a> 的介绍，或者你已经有相关的知识了，否则这节肯定是看不懂的。</p><p>我们先来看看 Condition 的使用场景，Condition 经常可以用在生产者-消费者的场景中，请看 Doug Lea 给出的这个例子：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> &#123;</span><br><span class="line">    final Lock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// condition 依赖于 lock 来产生</span></span><br><span class="line">    final Condition notFull = <span class="keyword">lock</span>.newCondition();</span><br><span class="line">    final Condition notEmpty = <span class="keyword">lock</span>.newCondition();</span><br><span class="line"></span><br><span class="line">    final Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span>(<span class="params">Object x</span>) throws InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.<span class="keyword">await</span>();  <span class="comment">// 队列已满，等待，直到 not full 才能继续生产</span></span><br><span class="line">            items[putptr] = x;</span><br><span class="line">            <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal(); <span class="comment">// 生产成功，队列已经 not empty 了，发个通知出去</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">lock</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">take</span>(<span class="params"></span>) throws InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.<span class="keyword">await</span>(); <span class="comment">// 队列为空，等待，直到队列 not empty，才能继续消费</span></span><br><span class="line">            Object x = items[takeptr];</span><br><span class="line">            <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal(); <span class="comment">// 被我消费掉一个，队列 not full 了，发个通知出去</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">lock</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>（ArrayBlockingQueue 采用这种方式实现了生产者-消费者，所以请只把这个例子当做学习例子，实际生产中可以直接使用 ArrayBlockingQueue）</em></p><p>我们常用 obj.wait()，obj.notify() 或 obj.notifyAll() 来实现相似的功能，但是，它们是基于对象的监视器锁的。需要深入了解这几个方法的读者，可以参考我的另一篇文章《<a href="http://hongjiev.github.io/2017/07/05/Threads-And-Locks-md/" target="_blank" rel="noopener">深入分析 java 8 编程语言规范：Threads and Locks</a>》。而这里说的 Condition 是基于 ReentrantLock 实现的，而 ReentrantLock 是依赖于 AbstractQueuedSynchronizer 实现的。</p><p>在往下看之前，读者心里要有一个整体的概念。condition 是依赖于 ReentrantLock 的，不管是调用 await 进入等待还是 signal 唤醒，都必须获取到锁才能进行操作。</p><p>每个 ReentrantLock 实例可以通过调用多次 newCondition 产生多个 ConditionObject 的实例：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final ConditionObject <span class="keyword">new</span><span class="type">Condition</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ConditionObject</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先来看下我们关注的 Condition 的实现类 <code>AbstractQueuedSynchronizer</code> 类中的 <code>ConditionObject</code>。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> &#123;</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699</span>L;</span><br><span class="line">        <span class="comment">// 条件队列的第一个节点</span></span><br><span class="line">          <span class="comment">// 不要管这里的关键字 transient，是不参与序列化的意思</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">        <span class="comment">// 条件队列的最后一个节点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure><p>在上一篇介绍 AQS 的时候，我们有一个阻塞队列，用于保存等待获取锁的线程的队列。这里我们引入另一个概念，叫条件队列（condition queue），我画了一张简单的图用来说明这个。</p><blockquote><p>这里的阻塞队列如果叫做同步队列（sync queue）其实比较贴切，不过为了和前篇呼应，我就继续使用阻塞队列了。记住这里的两个概念，阻塞队列和条件队列。</p></blockquote><p><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer-2/aqs2-2.png" alt="condition-2"></p><blockquote><p>这里，我们简单回顾下 Node 的属性：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> volatile int waitStatus; // 可取值 0、CANCELLED(1)、SIGNAL(-1)、CONDITION(-2)、PROPAGATE(-3)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> volatile Node prev;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> volatile Node next;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> volatile Thread thread;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Node nextWaiter;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>prev 和 next 用于实现阻塞队列的双向链表，nextWaiter 用于实现条件队列的单向链表</p></blockquote><p>基本上，把这张图看懂，你也就知道 condition 的处理流程了。所以，我先简单解释下这图，然后再具体地解释代码实现。</p><ol><li><p>我们知道一个 ReentrantLock 实例可以通过多次调用 newCondition() 来产生多个 Condition 实例，这里对应 condition1 和 condition2。注意，ConditionObject 只有两个属性 firstWaiter 和 lastWaiter；</p></li><li><p>每个 condition 有一个关联的条件队列，如线程 1 调用 condition1.await() 方法即可将当前线程 1 包装成 Node 后加入到条件队列中，然后阻塞在这里，不继续往下执行，条件队列是一个单向链表；</p></li><li>调用 condition1.signal() 会将condition1 对应的条件队列的 firstWaiter 移到阻塞队列的队尾，等待获取锁，获取锁后 await 方法返回，继续往下执行。</li></ol><p>我这里说的 1、2、3 是最简单的流程，没有考虑中断、signalAll、还有带有超时参数的 await 方法等，不过把这里弄懂是这节的主要目的。</p><p>同时，从图中也可以很直观地看出，哪些操作是线程安全的，哪些操作是线程不安全的。</p><p>这个图看懂后，下面的代码分析就简单了。</p><p>接下来，我们一步步按照流程来走代码分析，我们先来看看 wait 方法：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 首先，这个方法是可被中断的，不可被中断的是另一个方法 awaitUninterruptibly()</span><br><span class="line">// 这个方法会阻塞，直到调用 signal 方法（指 signal() 和 signalAll()，下同），或被中断</span><br><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    // 添加到 condition 的条件队列中</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">node</span> = addConditionWaiter();</span><br><span class="line">    // 释放锁，返回值是释放锁之前的 state 值</span><br><span class="line">    int savedState = fullyRelease(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">    int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    // 这里退出循环有两种情况，之后再仔细分析</span><br><span class="line">    // <span class="number">1</span>\. isOnSyncQueue(<span class="keyword">node</span><span class="title">) 返回 true</span>，即当前 <span class="keyword">node</span> <span class="title">已经转移到阻塞队列了</span></span><br><span class="line"><span class="title">    // 2</span>\. checkInterruptWhileWaiting(<span class="keyword">node</span><span class="title">) != 0</span> 会到 break，然后退出循环，代表的是线程中断</span><br><span class="line">    while (!isOnSyncQueue(<span class="keyword">node</span><span class="title">)) &#123;</span></span><br><span class="line"><span class="title">        LockSupport</span>.park(this);</span><br><span class="line">        if ((interruptMode = checkInterruptWhileWaiting(<span class="keyword">node</span><span class="title">)) != 0</span>)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    // 被唤醒后，将进入阻塞队列，等待获取锁</span><br><span class="line">    if (acquireQueued(<span class="keyword">node</span><span class="title">, savedState</span>) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    if (<span class="keyword">node</span>.<span class="title">nextWaiter</span> != null) // clean up if cancelled</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    if (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，我大体上也把整个 await 过程说得十之八九了，下面我们分步把上面的几个点用源码说清楚。</p><h3 id="1-将节点加入到条件队列"><a href="#1-将节点加入到条件队列" class="headerlink" title="1. 将节点加入到条件队列"></a>1. 将节点加入到条件队列</h3><p>addConditionWaiter() 是将当前节点加入到条件队列，看图我们知道，这种条件队列内的操作是线程安全的。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 将当前线程对应的节点入队，插入队尾</span><br><span class="line">private <span class="keyword">Node</span> <span class="title">addConditionWaiter</span>() &#123;</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">t</span> = lastWaiter;</span><br><span class="line">    // 如果条件队列的最后一个节点取消了，将其清除出去</span><br><span class="line">    if (t != null &amp;&amp; t.waitStatus != <span class="keyword">Node</span>.<span class="title">CONDITION</span>) &#123;</span><br><span class="line">        // 这个方法会遍历整个条件队列，然后会将已取消的所有节点清除出队列</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">node</span> = new <span class="keyword">Node</span><span class="title">(Thread</span>.currentThread(), <span class="keyword">Node</span>.<span class="title">CONDITION</span>);</span><br><span class="line">    // 如果队列为空</span><br><span class="line">    if (t == null)</span><br><span class="line">        firstWaiter = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    else</span></span><br><span class="line">        t.nextWaiter = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    lastWaiter</span> = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    return</span> <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure><p>在addWaiter 方法中，有一个 unlinkCancelledWaiters() 方法，该方法用于清除队列中已经取消等待的节点。</p><p>当 await 的时候如果发生了取消操作（这点之后会说），或者是在节点入队的时候，发现最后一个节点是被取消的，会调用一次这个方法。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待队列是一个单向链表，遍历链表将已经取消等待的节点清除出去</span></span><br><span class="line"><span class="comment">// 纯属链表操作，很好理解，看不懂多看几遍就可以了</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> unlinkCancelledWaiters() &#123;</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    Node trail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node <span class="keyword">next</span> = t.nextWaiter;</span><br><span class="line">        <span class="comment">// 如果节点的状态不是 Node.CONDITION 的话，这个节点就是被取消的</span></span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = <span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail.nextWaiter = <span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">next</span> == <span class="keyword">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t;</span><br><span class="line">        t = <span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-完全释放独占锁"><a href="#2-完全释放独占锁" class="headerlink" title="2. 完全释放独占锁"></a>2. 完全释放独占锁</h3><p>回到 wait 方法，节点入队了以后，会调用 <code>int savedState = fullyRelease(node);</code> 方法释放锁，注意，这里是完全释放独占锁，因为 ReentrantLock 是可以重入的。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先，我们要先观察到返回值 savedState 代表 release 之前的 state 值</span></span><br><span class="line"><span class="comment">// 对于最简单的操作：先 lock.lock()，然后 condition1.await()。</span></span><br><span class="line"><span class="comment">//         那么 state 经过这个方法由 1 变为 0，锁释放，此方法返回 1</span></span><br><span class="line"><span class="comment">//         相应的，如果 lock 重入了 n 次，savedState == n</span></span><br><span class="line"><span class="comment">// 如果这个方法失败，会将节点设置为"取消"状态，并抛出异常 IllegalMonitorStateException</span></span><br><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="comment">// 这里使用了当前的 state 作为 release 的参数，也就是完全释放掉锁，将 state 置为 0</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-等待进入阻塞队列"><a href="#3-等待进入阻塞队列" class="headerlink" title="3. 等待进入阻塞队列"></a>3. 等待进入阻塞队列</h3><p>释放掉锁以后，接下来是这段，这边会自旋，如果发现自己还没到阻塞队列，那么挂起，等待被转移到阻塞队列。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int interruptMode = <span class="number">0</span>;</span><br><span class="line">while (!isOnSyncQueue(<span class="keyword">node</span><span class="title">)) &#123;</span></span><br><span class="line"><span class="title">    // 线程挂起</span></span><br><span class="line"><span class="title">    LockSupport</span>.park(this);</span><br><span class="line"></span><br><span class="line">    if ((interruptMode = checkInterruptWhileWaiting(<span class="keyword">node</span><span class="title">)) != 0</span>)</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isOnSyncQueue(Node node) 用于判断节点是否已经转移到阻塞队列了：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 在节点入条件队列的时候，初始化时设置了 waitStatus = <span class="keyword">Node</span>.<span class="title">CONDITION</span></span><br><span class="line">// 前面我提到，signal 的时候需要将节点从条件队列移到阻塞队列，</span><br><span class="line">// 这个方法就是判断 <span class="keyword">node</span> <span class="title">是否已经移动到阻塞队列了</span></span><br><span class="line"><span class="title">final</span> boolean isOnSyncQueue(<span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line">    // 移动过去的时候，<span class="keyword">node</span> <span class="title">的 waitStatus</span> 会置为 <span class="number">0</span>，这个之后在说 signal 方法的时候会说到</span><br><span class="line">    // 如果 waitStatus 还是 <span class="keyword">Node</span>.<span class="title">CONDITION</span>，也就是 -<span class="number">2</span>，那肯定就是还在条件队列中</span><br><span class="line">    // 如果 <span class="keyword">node</span> <span class="title">的前驱 prev</span> 指向还是 null，说明肯定没有在 阻塞队列</span><br><span class="line">    if (<span class="keyword">node</span>.<span class="title">waitStatus</span> == <span class="keyword">Node</span>.<span class="title">CONDITION</span> || <span class="keyword">node</span>.<span class="title">prev</span> == null)</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    // 如果 <span class="keyword">node</span> <span class="title">已经有后继节点 next</span> 的时候，那肯定是在阻塞队列了</span><br><span class="line">    if (<span class="keyword">node</span>.<span class="title">next</span> != null) </span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    // 这个方法从阻塞队列的队尾开始从后往前遍历找，如果找到相等的，说明在阻塞队列，否则就是不在阻塞队列</span><br><span class="line"></span><br><span class="line">    // 可以通过判断 <span class="keyword">node</span>.<span class="title">prev</span>() != null 来推断出 <span class="keyword">node</span> <span class="title">在阻塞队列吗？答案是：不能。</span></span><br><span class="line"><span class="title">    // 这个可以看上篇 AQS</span> 的入队方法，首先设置的是 <span class="keyword">node</span>.<span class="title">prev</span> 指向 tail，</span><br><span class="line">    // 然后是 CAS 操作将自己设置为新的 tail，可是这次的 CAS 是可能失败的。</span><br><span class="line"></span><br><span class="line">    // 调用这个方法的时候，往往我们需要的就在队尾的部分，所以一般都不需要完全遍历整个队列的</span><br><span class="line">    return findNodeFromTail(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">&#125;</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">// 从同步队列的队尾往前遍历，如果找到，返回 true</span></span><br><span class="line">private boolean findNodeFromTail(<span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">t</span> = tail;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        if (t == <span class="keyword">node</span><span class="title">)</span></span><br><span class="line"><span class="title">            return</span> <span class="literal">true</span>;</span><br><span class="line">        if (t == null)</span><br><span class="line">            return <span class="literal">false</span>;</span><br><span class="line">        t = t.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到前面的循环，isOnSyncQueue(node) 返回 false 的话，那么进到 <code>LockSupport.park(this);</code> 这里线程挂起。</p><h3 id="4-signal-唤醒线程，转移到阻塞队列"><a href="#4-signal-唤醒线程，转移到阻塞队列" class="headerlink" title="4. signal 唤醒线程，转移到阻塞队列"></a>4. signal 唤醒线程，转移到阻塞队列</h3><p>为了大家理解，这里我们先看唤醒操作，因为刚刚到 LockSupport.park(this); 把线程挂起了，等待唤醒。</p><p>唤醒操作通常由另一个线程来操作，就像生产者-消费者模式中，如果线程因为等待消费而挂起，那么当生产者生产了一个东西后，会调用 signal 唤醒正在等待的线程来消费。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 唤醒等待了最久的线程</span><br><span class="line">// 其实就是，将这个线程对应的 <span class="keyword">node</span> <span class="title">从条件队列转移到阻塞队列</span></span><br><span class="line"><span class="title">public</span> final void signal() &#123;</span><br><span class="line">    // 调用 signal 方法的线程必须持有当前的独占锁</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">first</span> = firstWaiter;</span><br><span class="line">    if (first != null)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 从条件队列队头往后遍历，找出第一个需要转移的 <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">// 因为前面我们说过，有些线程会取消排队，但是还在队列中</span></span><br><span class="line"><span class="title">private</span> void doSignal(<span class="keyword">Node</span> <span class="title">first</span>) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">          // 将 firstWaiter 指向 first 节点后面的第一个</span><br><span class="line">        // 如果将队头移除后，后面没有节点在等待了，那么需要将 lastWaiter 置为 null</span><br><span class="line">        if ( (firstWaiter = first.nextWaiter) == null)</span><br><span class="line">            lastWaiter = null;</span><br><span class="line">        // 因为 first 马上要被移到阻塞队列了，和条件队列的链接关系在这里断掉</span><br><span class="line">        first.nextWaiter = null;</span><br><span class="line">    &#125; while (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != null);</span><br><span class="line">      // 这里 while 循环，如果 first 转移不成功，那么选择 first 后面的第一个节点进行转移，依此类推</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将节点从条件队列转移到阻塞队列</span><br><span class="line">// <span class="literal">true</span> 代表成功转移</span><br><span class="line">// <span class="literal">false</span> 代表在 signal 之前，节点已经取消了</span><br><span class="line">final boolean transferForSignal(<span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line"></span><br><span class="line">    // CAS 如果失败，说明此 <span class="keyword">node</span> <span class="title">的 waitStatus</span> 已不是 <span class="keyword">Node</span>.<span class="title">CONDITION</span>，说明节点已经取消，</span><br><span class="line">    // 既然已经取消，也就不需要转移了，方法返回，转移后面一个节点</span><br><span class="line">    // 否则，将 waitStatus 置为 <span class="number">0</span></span><br><span class="line">    if (!compareAndSetWaitStatus(<span class="keyword">node</span><span class="title">, Node</span>.CONDITION, <span class="number">0</span>))</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    // enq(<span class="keyword">node</span><span class="title">): 自旋进入阻塞队列的队尾</span></span><br><span class="line"><span class="title">    // 注意，这里的返回值 p</span> 是 <span class="keyword">node</span> <span class="title">在阻塞队列的前驱节点</span></span><br><span class="line"><span class="title">    Node</span> p = enq(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">    int</span> ws = p.waitStatus;</span><br><span class="line">    // ws &gt; <span class="number">0</span> 说明 <span class="keyword">node</span> <span class="title">在阻塞队列中的前驱节点取消了等待锁，直接唤醒 node</span> 对应的线程。唤醒之后会怎么样，后面再解释</span><br><span class="line">    // 如果 ws <span class="tag">&lt;= 0, 那么 compareAndSetWaitStatus 将会被调用，上篇介绍的时候说过，节点入队后，需要把前驱节点的状态设为 Node.SIGNAL(-1)</span></span><br><span class="line"><span class="tag">    if (ws &gt;</span> <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, <span class="keyword">Node</span>.<span class="title">SIGNAL</span>))</span><br><span class="line">        // 如果前驱节点取消或者 CAS 失败，会进到这里唤醒线程，之后的操作看下一节</span><br><span class="line">        LockSupport.unpark(<span class="keyword">node</span>.<span class="title">thread</span>);</span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况下，<code>ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)</code> 这句中，ws &lt;= 0，而且 compareAndSetWaitStatus(p, ws, Node.SIGNAL) 会返回 true，所以一般也不会进去 if 语句块中唤醒 node 对应的线程。然后这个方法返回 true，也就意味着 signal 方法结束了，节点进入了阻塞队列。</p><p>假设发生了阻塞队列中的前驱节点取消等待，或者 CAS 失败，只要唤醒线程，让其进到下一步即可。</p><h3 id="5-唤醒后检查中断状态"><a href="#5-唤醒后检查中断状态" class="headerlink" title="5. 唤醒后检查中断状态"></a>5. 唤醒后检查中断状态</h3><p>上一步 signal 之后，我们的线程由条件队列转移到了阻塞队列，之后就准备获取锁了。只要重新获取到锁了以后，继续往下执行。</p><p>等线程从挂起中恢复过来，继续往下看</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int interruptMode = <span class="number">0</span>;</span><br><span class="line">while (!isOnSyncQueue(<span class="keyword">node</span><span class="title">)) &#123;</span></span><br><span class="line"><span class="title">    // 线程挂起</span></span><br><span class="line"><span class="title">    LockSupport</span>.park(this);</span><br><span class="line"></span><br><span class="line">    if ((interruptMode = checkInterruptWhileWaiting(<span class="keyword">node</span><span class="title">)) != 0</span>)</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先解释下 interruptMode。interruptMode 可以取值为 REINTERRUPT（1），THROW_IE（-1），0</p><ul><li>REINTERRUPT： 代表 await 返回的时候，需要重新设置中断状态</li><li>THROW_IE： 代表 await 返回的时候，需要抛出 InterruptedException 异常</li><li>0 ：说明在 await 期间，没有发生中断</li></ul><p>有以下三种情况会让 LockSupport.park(this); 这句返回继续往下执行：</p><ol><li>常规路劲。signal -&gt; 转移节点到阻塞队列 -&gt; 获取了锁（unpark）</li><li>线程中断。在 park 的时候，另外一个线程对这个线程进行了中断</li><li>signal 的时候我们说过，转移以后的前驱节点取消了，或者对前驱节点的CAS操作失败了</li><li>假唤醒。这个也是存在的，和 Object.wait() 类似，都有这个问题</li></ol><p>线程唤醒后第一步是调用 checkInterruptWhileWaiting(node) 这个方法，此方法用于判断是否在线程挂起期间发生了中断，如果发生了中断，是 signal 调用之前中断的，还是 signal 之后发生的中断。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// <span class="number">1</span>\. 如果在 signal 之前已经中断，返回 THROW_IE</span><br><span class="line">// <span class="number">2</span>\. 如果是 signal 之后中断，返回 REINTERRUPT</span><br><span class="line">// <span class="number">3</span>\. 没有发生中断，返回 <span class="number">0</span></span><br><span class="line">private int checkInterruptWhileWaiting(<span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line">    return Thread.interrupted() ?</span><br><span class="line">        (transferAfterCancelledWait(<span class="keyword">node</span><span class="title">) ? THROW_IE</span> : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Thread.interrupted()：如果当前线程已经处于中断状态，那么该方法返回 true，同时将中断状态重置为 false，所以，才有后续的 <code>重新中断（REINTERRUPT）</code> 的使用。</p></blockquote><p>看看怎么判断是 signal 之前还是之后发生的中断：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有线程处于中断状态，才会调用此方法</span></span><br><span class="line"><span class="comment">// 如果需要的话，将这个已经取消等待的节点转移到阻塞队列</span></span><br><span class="line"><span class="comment">// 返回 true：如果此线程在 signal 之前被取消，</span></span><br><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用 CAS 将节点状态设置为 0 </span></span><br><span class="line">    <span class="comment">// 如果这步 CAS 成功，说明是 signal 方法之前发生的中断，因为如果 signal 先发生的话，signal 中会将 waitStatus 设置为 0</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// 将节点放入阻塞队列</span></span><br><span class="line">        <span class="comment">// 这里我们看到，即使中断了，依然会转移到阻塞队列</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里是因为 CAS 失败，肯定是因为 signal 方法已经将 waitStatus 设置为了 0</span></span><br><span class="line">    <span class="comment">// signal 方法会将节点转移到阻塞队列，但是可能还没完成，这边自旋等待其完成</span></span><br><span class="line">    <span class="comment">// 当然，这种事情还是比较少的吧：signal 调用之后，没完成转移之前，发生了中断</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里再说一遍，即使发生了中断，节点依然会转移到阻塞队列。</p></blockquote><p>到这里，大家应该都知道这个 while 循环怎么退出了吧。要么中断，要么转移成功。</p><h3 id="6-获取独占锁"><a href="#6-获取独占锁" class="headerlink" title="6. 获取独占锁"></a>6. 获取独占锁</h3><p>while 循环出来以后，下面是这段代码：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (<span class="name">acquireQueued</span>(<span class="name">node</span>, savedState) <span class="symbol">&amp;&amp;</span> interruptMode != THROW_IE)</span><br><span class="line">    interruptMode = REINTERRUPT<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>由于 while 出来后，我们确定节点已经进入了阻塞队列，准备获取锁。</p><p>这里的 acquireQueued(node, savedState) 的第一个参数 node 之前已经经过 enq(node) 进入了队列，参数 savedState 是之前释放锁前的 state，这个方法返回的时候，代表当前线程获取了锁，而且 state == savedState了。</p><p>注意，前面我们说过，不管有没有发生中断，都会进入到阻塞队列，而 acquireQueued(node, savedState) 的返回值就是代表线程是否被中断。如果返回 true，说明被中断了，而且 interruptMode != THROW_IE，说明在 signal 之前就发生中断了，这里将 interruptMode 设置为 REINTERRUPT，用于待会重新中断。</p><p>继续往下：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (<span class="name">node</span>.nextWaiter != null) // clean up if cancelled</span><br><span class="line">    unlinkCancelledWaiters()<span class="comment">;</span></span><br><span class="line">if (<span class="name">interruptMode</span> != <span class="number">0</span>)</span><br><span class="line">    reportInterruptAfterWait(<span class="name">interruptMode</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>本着一丝不苟的精神，这边说说 <code>node.nextWaiter != null</code> 怎么满足。我前面也说了 signal 的时候会将节点转移到阻塞队列，有一步是 node.nextWaiter = null，将断开节点和条件队列的联系。</p><p>可是，<code>在判断发生中断的情况下，是 signal 之前还是之后发生的？</code> 这部分的时候，我也介绍了，如果 signal 之前就中断了，也需要将节点进行转移到阻塞队列，这部分转移的时候，是没有设置 node.nextWaiter = null 的。</p><p>之前我们说过，如果有节点取消，也会调用 unlinkCancelledWaiters 这个方法，就是这里了。</p><h3 id="7-处理中断状态"><a href="#7-处理中断状态" class="headerlink" title="7. 处理中断状态"></a>7. 处理中断状态</h3><p>到这里，我们终于可以好好说下这个 interruptMode 干嘛用了。</p><ul><li>0：什么都不做。</li><li>THROW_IE：await 方法抛出 InterruptedException 异常</li><li>REINTERRUPT：重新中断当前线程</li></ul><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> reportInterruptAfterWait(<span class="keyword">int</span> interruptMode)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么这么处理？这部分的知识在本文的最后一节</p></blockquote><h3 id="带超时机制的-await"><a href="#带超时机制的-await" class="headerlink" title="* 带超时机制的 await"></a>* 带超时机制的 await</h3><p>经过前面的 7 步，整个 ConditionObject 类基本上都分析完了，接下来简单分析下带超时机制的 await 方法。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> awaitNanos(<span class="keyword">long</span> nanosTimeout) </span><br><span class="line">                  <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> awaitUntil(Date deadline)</span><br><span class="line">                <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> await(<span class="keyword">long</span> time, TimeUnit unit)</span><br><span class="line">                <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure><p>这三个方法都差不多，我们就挑一个出来看看吧：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> await(<span class="keyword">long</span> time, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 等待这么多纳秒</span></span><br><span class="line">    <span class="keyword">long</span> nanosTimeout = unit.toNanos(time);</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="comment">// 当前时间 + 等待时长 = 过期时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">// 用于返回 await 是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 时间到啦</span></span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span>L) &#123;</span><br><span class="line">            <span class="comment">// 这里因为要 break 取消等待了。取消等待的话一定要调用 transferAfterCancelledWait(node) 这个方法</span></span><br><span class="line">            <span class="comment">// 如果这个方法返回 true，在这个方法内，将节点转移到阻塞队列成功</span></span><br><span class="line">            <span class="comment">// 返回 false 的话，说明 signal 已经发生，signal 方法将节点转移了。也就是说没有超时嘛</span></span><br><span class="line">            timedout = transferAfterCancelledWait(node);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// spinForTimeoutThreshold 的值是 1000 纳秒，也就是 1 毫秒</span></span><br><span class="line">        <span class="comment">// 也就是说，如果不到 1 毫秒了，那就不要选择 parkNanos 了，自旋的性能反而更好</span></span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 得到剩余时间</span></span><br><span class="line">        nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">    <span class="keyword">return</span> !timedout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超时的思路还是很简单的，不带超时参数的 await 是 park，然后等待别人唤醒。而现在就是调用 parkNanos 方法来休眠指定的时间，醒来后判断是否 signal 调用了，调用了就是没有超时，否则就是超时了。超时的话，自己来进行转移到阻塞队列，然后抢锁。</p><h3 id="不抛出-InterruptedException-的-await"><a href="#不抛出-InterruptedException-的-await" class="headerlink" title="* 不抛出 InterruptedException 的 await"></a>* 不抛出 InterruptedException 的 await</h3><p>关于 Condition 最后一小节了。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final void awaitUninterruptibly() &#123;</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">node</span> = addConditionWaiter();</span><br><span class="line">    int savedState = fullyRelease(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">    boolean</span> interrupted = <span class="literal">false</span>;</span><br><span class="line">    while (!isOnSyncQueue(<span class="keyword">node</span><span class="title">)) &#123;</span></span><br><span class="line"><span class="title">        LockSupport</span>.park(this);</span><br><span class="line">        if (Thread.interrupted())</span><br><span class="line">            interrupted = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    if (acquireQueued(<span class="keyword">node</span><span class="title">, savedState</span>) || interrupted)</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，我就不废话了。</p><h2 id="AbstractQueuedSynchronizer-独占锁的取消排队"><a href="#AbstractQueuedSynchronizer-独占锁的取消排队" class="headerlink" title="AbstractQueuedSynchronizer 独占锁的取消排队"></a>AbstractQueuedSynchronizer 独占锁的取消排队</h2><p>这篇文章说的是 AbstractQueuedSynchronizer，只不过好像 Condition 说太多了，赶紧把思路拉回来。</p><p>接下来，我想说说怎么取消对锁的竞争？</p><p>上篇文章提到过，最重要的方法是这个，我们要在这里面找答案：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final <span class="keyword">Node</span> <span class="title">node</span>, int arg) &#123;</span><br><span class="line">    boolean failed = <span class="literal">true</span>;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = <span class="literal">false</span>;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final <span class="keyword">Node</span> <span class="title">p</span> = <span class="keyword">node</span>.<span class="title">predecessor</span>();</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">                p</span>.next = null; // help GC</span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, <span class="keyword">node</span><span class="title">) &amp;&amp;</span></span><br><span class="line"><span class="title">                parkAndCheckInterrupt</span>())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">    &#125;</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure><p>首先，到这个方法的时候，节点一定是入队成功的。</p><p>我把 parkAndCheckInterrupt() 代码贴过来：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function"><span class="keyword">return</span> Thread.<span class="title">interrupted</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两段代码联系起来看，是不是就清楚了。</p><p>如果我们要取消一个线程的排队，我们需要在另外一个线程中对其进行中断。比如某线程调用 lock() 老久不返回，我想中断它。一旦对其进行中断，此线程会从 <code>LockSupport.park(this);</code> 中唤醒，然后 <code>Thread.interrupted();</code>返回 true。</p><p>我们发现一个问题，即使是中断唤醒了这个线程，也就只是设置了 <code>interrupted = true</code> 然后继续下一次循环。而且，由于 <code>Thread.interrupted();</code> 会清除中断状态，第二次进 parkAndCheckInterrupt 的时候，返回会是 false。</p><p>所以，我们要看到，在这个方法中，interrupted 只是用来记录是否发生了中断，然后用于方法返回值，其他没有做任何相关事情。</p><p>所以，我们看外层方法怎么处理 acquireQueued 返回 false 的情况。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说，lock() 方法处理中断的方法就是，你中断归中断，我抢锁还是照样抢锁，几乎没关系，只是我抢到锁了以后，设置线程的中断状态而已，也不抛出任何异常出来。调用者获取锁后，可以去检查是否发生过中断，也可以不理会。</p><hr><p>来条分割线。有没有被骗的感觉，我说了一大堆，可是和取消没有任何关系啊。</p><p>我们来看 ReentrantLock 的另一个 lock 方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法上多了个 <code>throws InterruptedException</code> ，经过前面那么多知识的铺垫，这里我就不再啰里啰嗦了。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> acquireInterruptibly(<span class="keyword">int</span> arg)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往里：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireInterruptibly(int arg) throws InterruptedException &#123;</span><br><span class="line">    final <span class="keyword">Node</span> <span class="title">node</span> = addWaiter(<span class="keyword">Node</span>.<span class="title">EXCLUSIVE</span>);</span><br><span class="line">    boolean failed = <span class="literal">true</span>;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final <span class="keyword">Node</span> <span class="title">p</span> = <span class="keyword">node</span>.<span class="title">predecessor</span>();</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">                p</span>.next = null; // help GC</span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, <span class="keyword">node</span><span class="title">) &amp;&amp;</span></span><br><span class="line"><span class="title">                parkAndCheckInterrupt</span>())</span><br><span class="line">                // 就是这里了，一旦异常，马上结束这个方法，抛出异常。</span><br><span class="line">                // 这里不再只是标记这个方法的返回值代表中断状态</span><br><span class="line">                // 而是直接抛出异常，而且外层也不捕获，一直往外抛到 lockInterruptibly</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 如果通过 InterruptedException 异常出去，那么 failed 就是 <span class="literal">true</span> 了</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">    &#125;</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure><p>既然到这里了，顺便说说 cancelAcquire 这个方法吧：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private void cancelAcquire(<span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line">    // Ignore if <span class="keyword">node</span> <span class="title">doesn</span>'t exist</span><br><span class="line">    if (<span class="keyword">node</span> <span class="title">== null</span>)</span><br><span class="line">        return;</span><br><span class="line">    <span class="keyword">node</span>.<span class="title">thread</span> = null;</span><br><span class="line">    // Skip cancelled predecessors</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">pred</span> = <span class="keyword">node</span>.<span class="title">prev</span>;</span><br><span class="line">    while (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">node</span>.<span class="title">prev</span> = pred = pred.prev;</span><br><span class="line">    // predNext is the apparent <span class="keyword">node</span> <span class="title">to</span> unsplice. CASes below will</span><br><span class="line">    // fail if not, <span class="keyword">in</span> which case, we lost race vs another cancel</span><br><span class="line">    // <span class="keyword">or</span> signal, so no further action is necessary.</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">predNext</span> = pred.next;</span><br><span class="line">    // Can use unconditional <span class="keyword">write</span> instead of CAS here.</span><br><span class="line">    // After this atomic step, other Nodes can skip past us.</span><br><span class="line">    // Before, we are free of interference from other threads.</span><br><span class="line">    <span class="keyword">node</span>.<span class="title">waitStatus</span> = <span class="keyword">Node</span>.<span class="title">CANCELLED</span>;</span><br><span class="line">    // If we are the tail, remove ourselves.</span><br><span class="line">    if (<span class="keyword">node</span> <span class="title">== tail</span> &amp;&amp; compareAndSetTail(<span class="keyword">node</span><span class="title">, pred</span>)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, null);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // If successor needs signal, try to set pred's next-link</span><br><span class="line">        // so it will get one. Otherwise wake it up to propagate.</span><br><span class="line">        int ws;</span><br><span class="line">        if (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == <span class="keyword">Node</span>.<span class="title">SIGNAL</span> ||</span><br><span class="line">             (ws <span class="tag">&lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span></span><br><span class="line"><span class="tag">            pred.thread != null) &#123;</span></span><br><span class="line"><span class="tag">            Node next = node.next;</span></span><br><span class="line"><span class="tag">            if (next != null &amp;&amp; next.waitStatus &lt;= 0)</span></span><br><span class="line"><span class="tag">                compareAndSetNext(pred, predNext, next);</span></span><br><span class="line"><span class="tag">        &#125; else &#123;</span></span><br><span class="line"><span class="tag">            unparkSuccessor(node);</span></span><br><span class="line"><span class="tag">        &#125;</span></span><br><span class="line"><span class="tag">        node.next = node; // help GC</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure><p>到这里，我想我应该把取消排队这件事说清楚了吧。</p><h2 id="再说-java-线程中断和-InterruptedException-异常"><a href="#再说-java-线程中断和-InterruptedException-异常" class="headerlink" title="再说 java 线程中断和 InterruptedException 异常"></a>再说 java 线程中断和 InterruptedException 异常</h2><p>在之前的文章中，我们接触了大量的中断，这边算是个总结吧。如果你完全熟悉中断了，没有必要再看这节，本节为新手而写。</p><h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>首先，我们要明白，中断不是类似 linux 里面的命令 kill -9 pid，不是说我们中断某个线程，这个线程就停止运行了。中断代表线程状态，每个线程都关联了一个中断状态，是一个 true 或 false 的 boolean 值，初始值为 false。</p><p>关于中断状态，我们需要重点关注以下几个方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 类中的实例方法，持有线程实例引用即可检测线程中断状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 中的静态方法，检测调用这个方法的线程是否已经中断</span></span><br><span class="line"><span class="comment">// 注意：这个方法返回中断状态的同时，会将此线程的中断状态重置为 false</span></span><br><span class="line"><span class="comment">// 所以，如果我们连续调用两次这个方法的话，第二次的返回值肯定就是 false 了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 类中的实例方法，用于设置一个线程的中断状态为 true</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>我们说中断一个线程，其实就是设置了线程的 interrupted status 为 true，至于说被中断的线程怎么处理这个状态，那是那个线程自己的事。如以下代码：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">   <span class="selector-tag">doWork</span>();</span><br><span class="line">   <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"我做完一件事了，准备做下一件，如果没有其他线程中断我的话"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，中断除了是线程状态外，还有其他含义，否则也不需要专门搞一个这个概念出来了。</p><p>如果线程处于以下三种情况，那么当线程被中断的时候，能自动感知到：</p><ol><li><p>来自 Object 类的 wait()、wait(long)、wait(long, int)，</p><p>来自 Thread 类的 join()、join(long)、join(long, int)、sleep(long)、sleep(long, int)</p><blockquote><p>这几个方法的相同之处是，方法上都有: throws InterruptedException</p><p>如果线程阻塞在这些方法上（我们知道，这些方法会让当前线程阻塞），这个时候如果其他线程对这个线程进行了中断，那么这个线程会从这些方法中立即返回，抛出 InterruptedException 异常，同时重置中断状态为 false。</p></blockquote></li><li><p>实现了 InterruptibleChannel 接口的类中的一些 I/O 阻塞操作，如 DatagramChannel 中的 connect 方法和 receive 方法等</p><blockquote><p>如果线程阻塞在这里，中断线程会导致这些方法抛出 ClosedByInterruptException 并重置中断状态。</p></blockquote></li><li><p>Selector 中的 select 方法，这个有机会我们在讲 NIO 的时候说</p><blockquote><p>一旦中断，方法立即返回</p></blockquote></li></ol><p>对于以上 3 种情况是最特殊的，因为他们能自动感知到中断（这里说自动，当然也是基于底层实现），并且在做出相应的操作后都会重置中断状态为 false。</p><p>那是不是只有以上 3 种方法能自动感知到中断呢？不是的，如果线程阻塞在 LockSupport.park(Object obj) 方法，也叫挂起，这个时候的中断也会导致线程唤醒，但是唤醒后不会重置中断状态，所以唤醒后去检测中断状态将是 true。</p><h3 id="InterruptedException-概述"><a href="#InterruptedException-概述" class="headerlink" title="InterruptedException 概述"></a>InterruptedException 概述</h3><p>它是一个特殊的异常，不是说 JVM 对其有特殊的处理，而是它的使用场景比较特殊。通常，我们可以看到，像 Object 中的 wait() 方法，ReentrantLock 中的 lockInterruptibly() 方法，Thread 中的 sleep() 方法等等，这些方法都带有 <code>throws InterruptedException</code>，我们通常称这些方法为阻塞方法（blocking method）。</p><p>阻塞方法一个很明显的特征是，它们需要花费比较长的时间（不是绝对的，只是说明时间不可控），还有它们的方法结束返回往往依赖于外部条件，如 wait 方法依赖于其他线程的 notify，lock 方法依赖于其他线程的 unlock等等。</p><p>当我们看到方法上带有 <code>throws InterruptedException</code> 时，我们就要知道，这个方法应该是阻塞方法，我们如果希望它能早点返回的话，我们往往可以通过中断来实现。</p><p>除了几个特殊类（如 Object，Thread等）外，感知中断并提前返回是通过轮询中断状态来实现的。我们自己需要写可中断的方法的时候，就是通过在合适的时机（通常在循环的开始处）去判断线程的中断状态，然后做相应的操作（通常是方法直接返回或者抛出异常）。当然，我们也要看到，如果我们一次循环花的时间比较长的话，那么就需要比较长的时间才能注意到线程中断了。</p><h3 id="处理中断"><a href="#处理中断" class="headerlink" title="处理中断"></a>处理中断</h3><p>一旦中断发生，我们接收到了这个信息，然后怎么去处理中断呢？本小节将简单分析这个问题。</p><p>我们经常会这么写代码：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.<span class="built_in">sleep</span>(<span class="number">10000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// ignore</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// go on</span></span><br></pre></td></tr></table></figure><p>当 sleep 结束继续往下执行的时候，我们往往都不知道这块代码是真的 sleep 了 10 秒，还是只休眠了 1 秒就被中断了。这个代码的问题在于，我们将这个异常信息吞掉了。（对于 sleep 方法，我相信大部分情况下，我们都不在意是否是中断了，这里是举例）</p><p>AQS 的做法很值得我们借鉴，我们知道 ReentrantLock 有两种 lock 方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面我们提到过，lock() 方法不响应中断。如果 thread1 调用了 lock() 方法，过了很久还没抢到锁，这个时候 thread2 对其进行了中断，thread1 是不响应这个请求的，它会继续抢锁，当然它不会把“被中断”这个信息扔掉。我们可以看以下代码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        <span class="comment">// 我们看到，这里也没做任何特殊处理，就是记录下来中断状态。</span></span><br><span class="line">        <span class="comment">// 这样，如果外层方法需要去检测的时候，至少我们没有把这个信息丢了</span></span><br><span class="line">        selfInterrupt();<span class="comment">// Thread.currentThread().interrupt();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于 lockInterruptibly() 方法，因为其方法上面有 <code>throws InterruptedException</code> ，这个信号告诉我们，如果我们要取消线程抢锁，直接中断这个线程即可，它会立即返回，抛出 InterruptedException 异常。</p><p>在并发包中，有非常多的这种处理中断的例子，提供两个方法，分别为响应中断和不响应中断，对于不响应中断的方法，记录中断而不是丢失这个信息。如 Condition 中的两个方法就是这样的：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>通常，如果方法会抛出 InterruptedException 异常，往往方法体的第一句就是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> public final void await() throws InterruptedException &#123;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     <span class="keyword">if</span> (Thread.interrupted())</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">         throw new InterruptedException();</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">      ...... </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>熟练使用中断，对于我们写出优雅的代码是有帮助的，也有助于我们分析别人的源码。</p><blockquote><p>参考：<a href="https://www.ibm.com/developerworks/library/j-jtp05236/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/library/j-jtp05236/index.html</a></p><p>翻译：<a href="https://www.ibm.com/developerworks/cn/java/j-jtp05236.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-jtp05236.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java并发指南&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/21961.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21961.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java并发" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="JUC" scheme="http://h2pl.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java并发指南7：JUC的核心类AQS详解</title>
    <link href="http://h2pl.github.io/2018/05/20/concurrent7/"/>
    <id>http://h2pl.github.io/2018/05/20/concurrent7/</id>
    <published>2018-05-20T15:05:50.000Z</published>
    <updated>2018-06-11T13:43:20.606Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java并发指南<br><a href="https://blog.csdn.net/column/details/21961.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21961.html</a></p><p>相关代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><p>一行一行源码分析清楚AbstractQueuedSynchronizer</p><p>转自<br><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer#toc4" target="_blank" rel="noopener">https://www.javadoop.com/post/AbstractQueuedSynchronizer#toc4</a></p><p>在分析 Java 并发包 java.util.concurrent 源码的时候，少不了需要了解 AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是 Java 并发包的基础工具类，是实现 ReentrantLock、CountDownLatch、Semaphore、FutureTask 等类的基础。</p><p>Google 一下 AbstractQueuedSynchronizer，我们可以找到很多关于 AQS 的介绍，但是很多都没有介绍清楚，因为大部分文章没有把其中的一些关键的细节说清楚。</p><p>本文将从 ReentrantLock 的公平锁源码出发，分析下 AbstractQueuedSynchronizer 这个类是怎么工作的，希望能给大家提供一些简单的帮助。</p><p>申明以下几点：</p><ol><li>本文有点长，但是很简单很简单很简单，主要面向读者对象为并发编程的初学者，或者想要阅读java并发包源码的开发者。</li><li>建议在电脑上阅读，如果你想好好地理解所有的细节，而且你从来没看过相关的分析，你可能至少需要 20 分钟仔细看所有的描述，本文后面的 1/3 以上很简单，前面的 1/4 更简单，中间的部分要好好看。</li><li>如果你不知道为什么要看这个，我想告诉你，即使你看懂了所有的细节，你可能也不能把你的业务代码写得更好</li><li>源码环境 JDK1.7，看到不懂或有疑惑的部分，最好能自己打开源码看看。Doug Lea 大神的代码写得真心不错。</li><li>有很多英文注释我没有删除，这样读者可以参考着英文说的来，万一被我忽悠了呢</li><li>本文不分析共享模式，这样可以给读者减少很多负担，只要把独占模式看懂，共享模式读者应该就可以顺着代码看懂了。而且也不分析 condition 部分，所以应该说很容易就可以看懂了。</li><li>本文大量使用我们平时用得最多的 ReentrantLock 的概念，本质上来说是不正确的，读者应该清楚，AQS 不仅仅用来实现锁，只是希望读者可以用锁来联想 AQS 的使用场景，降低读者的阅读压力</li><li>ReentrantLock 的公平锁和非公平锁只有一点点区别，没有任何阅读压力</li><li>你需要提前知道什么是 CAS(CompareAndSet)</li></ol><p>废话结束，开始。</p><blockquote><p>此篇博客所有源码均来自JDK 1.8</p></blockquote><p>在上篇博客<a href="http://cmsblogs.com/?p=2174" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之AQS：AQS简介</a>中提到了AQS内部维护着一个FIFO队列，该队列就是CLH同步队列。</p><p>CLH同步队列是一个FIFO双向队列，AQS依赖它来完成同步状态的管理，当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。</p><p>在CLH同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、状态（waitStatus）、前驱节点（prev）、后继节点（next），其定义如下：</p><pre name="code">static  final  class  Node  {  /** 共享 */  static  final  Node SHARED =  new  Node();  /** 独占 */  static  final  Node EXCLUSIVE =  null;  /**     * 因为超时或者中断，节点会被设置为取消状态，被取消的节点时不会参与到竞争中的，他会一直保持取消状态不会转变为其他状态；     */  static  final  int CANCELLED =  1;  /**     * 后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行     */  static  final  int SIGNAL =  -1;  /**     * 节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()后，改节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中     */  static  final  int CONDITION =  -2;  /**     * 表示下一次共享式同步状态获取将会无条件地传播下去     */  static  final  int PROPAGATE =  -3;  /** 等待状态 */  volatile  int waitStatus;  /** 前驱节点 */  volatile  Node prev;  /** 后继节点 */  volatile  Node  next;  /** 获取同步状态的线程 */  volatile  Thread thread;  Node nextWaiter;  final  boolean isShared()  {  return nextWaiter == SHARED;  }  final  Node predecessor()  throws  NullPointerException  {  Node p = prev;  if  (p ==  null)  throw  new  NullPointerException();  else  return p;  }  Node()  {  }  Node(Thread thread,  Node mode)  {  this.nextWaiter = mode;  this.thread = thread;  }  Node(Thread thread,  int waitStatus)  {  this.waitStatus = waitStatus;  this.thread = thread;  }  }</pre><p>CLH同步队列结构图如下：</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/03/201701240001-1.png" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/03/201701240001_thumb-1.png" alt="201701240001" title="201701240001"></a></p><h2 id="入列"><a href="#入列" class="headerlink" title="入列"></a>入列</h2><p>学了数据结构的我们，CLH队列入列是再简单不过了，无非就是tail指向新节点、新节点的prev指向当前最后的节点，当前最后一个节点的next指向当前节点。代码我们可以看看addWaiter(Node node)方法：</p><pre name="code">  private  Node addWaiter(Node mode)  {  //新建Node  Node node =  new  Node(Thread.currentThread(), mode);  //快速尝试添加尾节点  Node pred = tail;  if  (pred !=  null)  { node.prev = pred;  //CAS设置尾节点  if  (compareAndSetTail(pred, node))  { pred.next  = node;  return node;  }  }  //多次尝试 enq(node);  return node;  }</pre><p>addWaiter(Node node)先通过快速尝试设置尾节点，如果失败，则调用enq(Node node)方法设置尾节点</p><pre name="code">  private  Node enq(final  Node node)  {  //多次尝试，直到成功为止  for  (;;)  {  Node t = tail;  //tail不存在，设置为首节点  if  (t ==  null)  {  if  (compareAndSetHead(new  Node())) tail = head;  }  else  {  //设置为尾节点 node.prev = t;  if  (compareAndSetTail(t, node))  { t.next  = node;  return t;  }  }  }  }</pre><p>在上面代码中，两个方法都是通过一个CAS方法compareAndSetTail(Node expect, Node update)来设置尾节点，该方法可以确保节点是线程安全添加的。在enq(Node node)方法中，AQS通过“死循环”的方式来保证节点可以正确添加，只有成功添加后，当前线程才会从该方法返回，否则会一直执行下去。</p><p>过程图如下：</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/03/1485225206860201701240002.png" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/03/1485225206860201701240002_thumb.png" alt="1485225206860201701240002" title="1485225206860201701240002"></a></p><h2 id="出列"><a href="#出列" class="headerlink" title="出列"></a>出列</h2><p>CLH同步队列遵循FIFO，首节点的线程释放同步状态后，将会唤醒它的后继节点（next），而后继节点将会在获取同步状态成功时将自己设置为首节点，这个过程非常简单，head执行该节点并断开原首节点的next和当前节点的prev即可，注意在这个过程是不需要使用CAS来保证的，因为只有一个线程能够成功获取到同步状态。过程图如下：</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/03/201701240003.png" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/03/201701240003_thumb.png" alt="201701240003" title="201701240003"></a></p><h2 id="AQS-结构"><a href="#AQS-结构" class="headerlink" title="AQS 结构"></a>AQS 结构</h2><p>先来看看 AQS 有哪些属性，搞清楚这些基本就知道 AQS 是什么套路了，毕竟可以猜嘛！</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="comment">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个隐视的链表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"><span class="comment">// 这个是最重要的，不过也是最简单的，代表当前锁的状态，0代表没有被占用，大于0代表有线程持有当前锁</span></span><br><span class="line"><span class="comment">// 之所以说大于0，而不是等于1，是因为锁可以重入嘛，每次重入都加上1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span></span><br><span class="line"><span class="comment">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span></span><br><span class="line"><span class="comment">// if (currentThread == getExclusiveOwnerThread()) &#123;state++&#125;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread; <span class="comment">//继承自AbstractOwnableSynchronizer</span></span><br></pre></td></tr></table></figure><p>怎么样，看样子应该是很简单的吧，毕竟也就四个属性啊。</p><p>AbstractQueuedSynchronizer 的等待队列示意如下所示，注意了，之后分析过程中所说的 queue，也就是阻塞队列不包含 head，不包含 head，不包含 head。</p><p><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-0.png" alt="aqs-0"></p><p>等待队列中每个线程被包装成一个 node，数据结构是链表，一起看看源码吧：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> Node &#123;</span><br><span class="line">    <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">    <span class="comment">// 标识节点当前在共享模式下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">    <span class="comment">// 标识节点当前在独占模式下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ======== 下面的几个int常量是给waitStatus用的 ===========</span></span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">    <span class="comment">// 代码此线程取消了争抢这个锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class="line">    <span class="comment">// 官方的描述是，其表示当前node的后继节点对应的线程需要被唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">    <span class="comment">// 本文不分析condition，所以略过吧，下一篇文章会介绍这个</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">     * unconditionally propagate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 同样的不分析，略过吧</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">    <span class="comment">// =====================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取值为上面的1、-1、-2、-3，或者0(以后会讲到)</span></span><br><span class="line">    <span class="comment">// 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待，</span></span><br><span class="line">    <span class="comment">// 也许就是说半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的。。。</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="comment">// 前驱节点的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">// 后继节点的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> Node <span class="keyword">next</span>;</span><br><span class="line">    <span class="comment">// 这个就是线程本尊</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node 的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已，大家先要有这个概念在心里。</p><p>上面的是基础知识，后面会多次用到，心里要时刻记着它们，心里想着这个结构图就可以了。下面，我们开始说 ReentrantLock 的公平锁。多嘴一下，我说的阻塞队列不包含 head 节点。</p><p><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-0.png" alt="aqs-0"></p><p>首先，我们先看下 ReentrantLock 的使用方式。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我用个web开发中的service概念吧</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderService</span> &#123;</span><br><span class="line">    <span class="comment">// 使用static，这样每个线程拿到的是同一把锁，当然，spring mvc中service默认就是单例，别纠结这个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOrder</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 比如我们同一时间，只允许一个线程创建订单</span></span><br><span class="line">        reentrantLock.<span class="keyword">lock</span>();</span><br><span class="line">        <span class="comment">// 通常，lock 之后紧跟着 try 语句</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这块代码同一时间只能有一个线程进来(获取到锁的线程)，</span></span><br><span class="line">            <span class="comment">// 其他的线程在lock()方法上阻塞，等待获取到锁，再进来</span></span><br><span class="line">            <span class="comment">// 执行代码...</span></span><br><span class="line">            <span class="comment">// 执行代码...</span></span><br><span class="line">            <span class="comment">// 执行代码...</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock 在内部用了内部类 Sync 来管理锁，所以真正的获取锁和释放锁是由 Sync 的实现类来控制的。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> static <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sync 有两个实现，分别为 NonfairSync（非公平锁）和 FairSync（公平锁），我们看 FairSync 部分。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程抢锁"><a href="#线程抢锁" class="headerlink" title="线程抢锁"></a>线程抢锁</h2><p>很多人肯定开始嫌弃上面废话太多了，下面跟着代码走，我就不废话了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line">      <span class="comment">// 争锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 来自父类AQS，我直接贴过来这边，下面分析的时候同样会这样做，不会给读者带来阅读压力</span></span><br><span class="line">    <span class="comment">// 我们看到，这个方法，如果tryAcquire(arg) 返回true, 也就结束了。</span></span><br><span class="line">    <span class="comment">// 否则，acquireQueued方法会将线程压到队列中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">// 此时 arg == 1</span></span><br><span class="line">        <span class="comment">// 首先调用tryAcquire(1)一下，名字上就知道，这个只是试一试</span></span><br><span class="line">        <span class="comment">// 因为有可能直接就成功了呢，也就不需要进队列排队了，</span></span><br><span class="line">        <span class="comment">// 对于公平锁的语义就是：本来就没人持有锁，根本没必要进队列等待(又是挂起，又是等待被唤醒的)</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">// tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;</span><br><span class="line">              selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 尝试直接获取锁，返回值是boolean，代表是否获取到锁</span></span><br><span class="line">    <span class="comment">// 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// state == 0 此时此刻没有线程持有锁</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span></span><br><span class="line">            <span class="comment">// 看看有没有别人在队列中等了半天了</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                <span class="comment">// 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span></span><br><span class="line">                <span class="comment">// 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了</span></span><br><span class="line">                <span class="comment">// 因为刚刚还没人的，我判断过了</span></span><br></pre></td></tr></table></figure><p>说到这里，也就明白了，多看几遍 <code>final boolean acquireQueued(final Node node, int arg)</code> 这个方法吧。自己推演下各个分支怎么走，哪种情况下会发生什么，走到哪里。</p><h2 id="解锁操作"><a href="#解锁操作" class="headerlink" title="解锁操作"></a>解锁操作</h2><p>最后，就是还需要介绍下唤醒的动作了。我们知道，正常情况下，如果线程没获取到锁，线程会被 <code>LockSupport.park(this);</code> 挂起停止，等待被唤醒。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒的代码还是比较简单的，你如果上面加锁的都看懂了，下面都不需要看就知道怎么回事了</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 往后看吧</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回到ReentrantLock看tryRelease方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 是否完全释放锁</span></span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 其实就是重入的问题，如果c==0，也就是说没有嵌套锁了，可以释放了，否则还不能释放掉</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wakes up node's successor, if one exists.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 唤醒后继节点</span></span><br><span class="line"><span class="comment">// 从上面调用处知道，参数node是head头结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// 如果head节点当前waitStatus&lt;0, 将其修改为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待（waitStatus==1）</span></span><br><span class="line">    <span class="comment">// 从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从后往前找，仔细看代码，不必担心中间有节点取消(waitStatus==1)的情况</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 唤醒线程</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唤醒线程以后，被唤醒的线程将从以下代码中继续往前走：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>); <span class="comment">// 刚刚线程被挂起在这里了</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> Thread.<span class="title">interrupted</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了</span></span><br></pre></td></tr></table></figure><p>好了，后面就不分析源码了，剩下的还有问题自己去仔细看看代码吧。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下吧。</p><p>在并发环境下，加锁和解锁需要以下三个部件的协调：</p><ol><li>锁状态。我们要知道锁是不是被别的线程占有了，这个就是 state 的作用，它为 0 的时候代表没有线程占有锁，可以去争抢这个锁，用 CAS 将 state 设为 1，如果 CAS 成功，说明抢到了锁，这样其他线程就抢不到了，如果锁重入的话，state进行+1 就可以，解锁就是减 1，直到 state 又变为 0，代表释放锁，所以 lock() 和 unlock() 必须要配对啊。然后唤醒等待队列中的第一个线程，让其来占有锁。</li><li>线程的阻塞和解除阻塞。AQS 中采用了 LockSupport.park(thread) 来挂起线程，用 unpark 来唤醒线程。</li><li>阻塞队列。因为争抢锁的线程可能很多，但是只能有一个线程拿到锁，其他的线程都必须等待，这个时候就需要一个 queue 来管理这些线程，AQS 用的是一个 FIFO 的队列，就是一个链表，每个 node 都持有后继节点的引用。AQS 采用了 CLH 锁的变体来实现，感兴趣的读者可以参考这篇文章<a href="http://coderbee.net/index.php/concurrent/20131115/577" target="_blank" rel="noopener">关于CLH的介绍</a>，写得简单明了。</li></ol><h2 id="示例图解析"><a href="#示例图解析" class="headerlink" title="示例图解析"></a>示例图解析</h2><p>下面属于回顾环节，用简单的示例来说一遍，如果上面的有些东西没看懂，这里还有一次帮助你理解的机会。</p><p>首先，第一个线程调用 reentrantLock.lock()，翻到最前面可以发现，tryAcquire(1) 直接就返回 true 了，结束。只是设置了 state=1，连 head 都没有初始化，更谈不上什么阻塞队列了。要是线程 1 调用 unlock() 了，才有线程 2 来，那世界就太太太平了，完全没有交集嘛，那我还要 AQS 干嘛。</p><p>如果线程 1 没有调用 unlock() 之前，线程 2 调用了 lock(), 想想会发生什么？</p><p>线程 2 会初始化 head【new Node()】，同时线程 2 也会插入到阻塞队列并挂起 (注意看这里是一个 for 循环，而且设置 head 和 tail 的部分是不 return 的，只有入队成功才会跳出循环)</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">Node</span> <span class="title">enq</span>(final <span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">t</span> = tail;</span><br><span class="line">        if (t == null) &#123; // Must initialize</span><br><span class="line">            if (compareAndSetHead(new <span class="keyword">Node</span><span class="title">()))</span></span><br><span class="line"><span class="title">                tail</span> = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            <span class="keyword">node</span>.<span class="title">prev</span> = t;</span><br><span class="line">            if (compareAndSetTail(t, <span class="keyword">node</span><span class="title">)) &#123;</span></span><br><span class="line"><span class="title">                t</span>.next = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">                return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，是线程 2 初始化 head 节点，此时 head==tail, waitStatus==0</p><p><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-1.png" alt="aqs-1"></p><p>然后线程 2 入队：</p><p><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-2.png" alt="aqs-2"></p><p>同时我们也要看此时节点的 waitStatus，我们知道 head 节点是线程 2 初始化的，此时的 waitStatus 没有设置， java 默认会设置为 0，但是到 shouldParkAfterFailedAcquire 这个方法的时候，线程 2 会把前驱节点，也就是 head 的waitStatus设置为-1。</p><p>那线程 2 节点此时的 waitStatus 是多少呢，由于没有设置，所以是 0；</p><p>如果线程3此时再进来，直接插到线程2的后面就可以了，此时线程 3 的 waitStatus 是 0，到 shouldParkAfterFailedAcquire 方法的时候把前驱节点线程 2 的 waitStatus 设置为 -1。</p><p><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-3.png" alt="aqs-3"></p><p>这里可以简单说下 waitStatus 中 SIGNAL(-1) 状态的意思，Doug Lea 注释的是：代表后继节点需要被唤醒。也就是说这个 waitStatus 其实代表的不是自己的状态，而是后继节点的状态，我们知道，每个 node 在入队的时候，都会把前驱节点的状态改为 SIGNAL，然后阻塞，等待被前驱唤醒。这里涉及的是两个问题：有线程取消了排队、唤醒操作。其实本质是一样的，读者也可以顺着 “waitStatus代表后继节点的状态” 这种思路去看一遍源码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java并发指南&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/21961.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21961.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java并发" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="JUC" scheme="http://h2pl.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java并发指南6：Java内存模型JMM总结</title>
    <link href="http://h2pl.github.io/2018/05/20/concurrent6/"/>
    <id>http://h2pl.github.io/2018/05/20/concurrent6/</id>
    <published>2018-05-20T15:05:46.000Z</published>
    <updated>2018-06-11T12:52:49.192Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java并发指南<br><a href="https://blog.csdn.net/column/details/21961.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21961.html</a></p><p>相关代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><p>深入理解Java内存模型 —— 总结</p><p> 在前面的文章中我们介绍了Java并发基础和线程安全的概念，以及JMM内存模型的介绍，包括其定义的各种规则。同时我们也介绍了volatile在JMM中的实现原理，以及Lock锁和synchronized实现同步方式的区别。最后还讲述了final关键字在JSR-133中的语义加强。</p><p>介绍了这么多内容，主要还是围绕着JMM来讲的，所以本文再次对JMM做一个总结。</p><h2 id="处理器内存模型"><a href="#处理器内存模型" class="headerlink" title="处理器内存模型"></a>处理器内存模型</h2><p>顺序一致性内存模型是一个理论参考模型，JMM和处理器内存模型在设计时通常会把顺序一致性内存模型作为参照。JMM和处理器内存模型在设计时会对顺序一致性模型做一些放松，因为如果完全按照顺序一致性模型来实现处理器和JMM，那么很多的处理器和编译器优化都要被禁止，这对执行性能将会有很大的影响。</p><p>根据对不同类型读/写操作组合的执行顺序的放松，可以把常见处理器的内存模型划分为下面几种类型：</p><ol><li>放松程序中写-读操作的顺序，由此产生了total store ordering内存模型（简称为TSO）。</li><li>在前面1的基础上，继续放松程序中写-写操作的顺序，由此产生了partial store order 内存模型（简称为PSO）。</li><li>在前面1和2的基础上，继续放松程序中读-写和读-读操作的顺序，由此产生了relaxed memory order内存模型（简称为RMO）和PowerPC内存模型。</li></ol><p>注意，这里处理器对读/写操作的放松，是以两个操作之间不存在数据依赖性为前提的（因为处理器要遵守as-if-serial语义，处理器不会对存在数据依赖性的两个内存操作做重排序）。</p><table><thead><tr><th>内存模型名称</th><th>对应的处理器</th><th>Store-Load 重排序</th><th>Store-Store重排序</th><th>Load-Load 和Load-Store重排序</th><th>可以更早读取到其它处理器的写</th><th>可以更早读取到当前处理器的写</th></tr></thead><tbody><tr><td>TSO</td><td>sparc-TSOX64</td><td>Y</td><td></td><td></td><td></td><td>Y</td></tr><tr><td>PSO</td><td>sparc-PSO</td><td>Y</td><td>Y</td><td></td><td></td><td>Y</td></tr><tr><td>RMO</td><td>ia64</td><td>Y</td><td>Y</td><td>Y</td><td></td><td>Y</td></tr><tr><td>PowerPC</td><td>PowerPC</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr></tbody></table><p>下面的表格展示了常见处理器内存模型的细节特征：</p><p>在这个表格中，我们可以看到所有处理器内存模型都允许写-读重排序，原因在第一章以说明过：它们都使用了写缓存区，写缓存区可能导致写-读操作重排序。同时，我们可以看到这些处理器内存模型都允许更早读到当前处理器的写，原因同样是因为写缓存区：由于写缓存区仅对当前处理器可见，这个特性导致当前处理器可以比其他处理器先看到临时保存在自己的写缓存区中的写。</p><p>上面表格中的各种处理器内存模型，从上到下，模型由强变弱。越是追求性能的处理器，内存模型设计的会越弱。因为这些处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。</p><p>由于常见的处理器内存模型比JMM要弱，java编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时，由于各种处理器内存模型的强弱并不相同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM在不同的处理器中需要插入的内存屏障的数量和种类也不相同。下图展示了JMM在不同处理器内存模型中需要插入的内存屏障的示意图：</p><p><img src="https://res.infoq.com/articles/java-memory-model-7/zh/resources/1.png" alt=""></p><p>如上图所示，JMM屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为java程序员呈现了一个一致的内存模型。</p><h2 id="JMM，处理器内存模型与顺序一致性内存模型之间的关系"><a href="#JMM，处理器内存模型与顺序一致性内存模型之间的关系" class="headerlink" title="JMM，处理器内存模型与顺序一致性内存模型之间的关系"></a>JMM，处理器内存模型与顺序一致性内存模型之间的关系</h2><p>JMM是一个语言级的内存模型，处理器内存模型是硬件级的内存模型，顺序一致性内存模型是一个理论参考模型。下面是语言内存模型，处理器内存模型和顺序一致性内存模型的强弱对比示意图：</p><p><img src="https://res.infoq.com/articles/java-memory-model-7/zh/resources/22.png" alt=""></p><p>从上图我们可以看出：常见的4种处理器内存模型比常用的3中语言内存模型要弱，处理器内存模型和语言内存模型都比顺序一致性内存模型要弱。同处理器内存模型一样，越是追求执行性能的语言，内存模型设计的会越弱。</p><h2 id="JMM的设计"><a href="#JMM的设计" class="headerlink" title="JMM的设计"></a>JMM的设计</h2><p>从JMM设计者的角度来说，在设计JMM时，需要考虑两个关键因素：</p><ul><li>程序员对内存模型的使用。程序员希望内存模型易于理解，易于编程。程序员希望基于一个强内存模型来编写代码。</li><li>编译器和处理器对内存模型的实现。编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现一个弱内存模型。</li></ul><p>由于这两个因素互相矛盾，所以JSR-133专家组在设计JMM时的核心目标就是找到一个好的平衡点：一方面要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能的放松。下面让我们看看JSR-133是如何实现这一目标的。</p><p>为了具体说明，请看前面提到过的计算圆面积的示例代码：</p><pre>double pi  = 3.14;    //Adouble r   = 1.0;     //Bdouble area = pi * r * r; //C</pre><p>上面计算圆的面积的示例代码存在三个happens- before关系：</p><ol><li>A happens- before B；</li><li>B happens- before C；</li><li>A happens- before C；</li></ol><p>由于A happens- before B，happens- before的定义会要求：A操作执行的结果要对B可见，且A操作的执行顺序排在B操作之前。 但是从程序语义的角度来说，对A和B做重排序即不会改变程序的执行结果，也还能提高程序的执行性能（允许这种重排序减少了对编译器和处理器优化的束缚）。也就是说，上面这3个happens- before关系中，虽然2和3是必需要的，但1是不必要的。因此，JMM把happens- before要求禁止的重排序分为了下面两类：</p><ul><li>会改变程序执行结果的重排序。</li><li>不会改变程序执行结果的重排序。</li></ul><p>JMM对这两种不同性质的重排序，采取了不同的策略：</p><ul><li>对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。</li><li>对于不会改变程序执行结果的重排序，JMM对编译器和处理器不作要求（JMM允许这种重排序）。</li></ul><p>下面是JMM的设计示意图：</p><p><img src="https://res.infoq.com/articles/java-memory-model-7/zh/resources/33.png" alt=""></p><p>从上图可以看出两点：</p><ul><li>JMM向程序员提供的happens- before规则能满足程序员的需求。JMM的happens- before规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证（有些内存可见性保证其实并不一定真实存在，比如上面的A happens- before B）。</li><li>JMM对编译器和处理器的束缚已经尽可能的少。从上面的分析我们可以看出，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。比如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再比如，如果编译器经过细致的分析后，认定一个volatile变量仅仅只会被单个线程访问，那么编译器可以把这个volatile变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。</li></ul><h2 id="JMM的内存可见性保证"><a href="#JMM的内存可见性保证" class="headerlink" title="JMM的内存可见性保证"></a>JMM的内存可见性保证</h2><p>Java程序的内存可见性保证按程序类型可以分为下列三类：</p><ol><li>单线程程序。单线程程序不会出现内存可见性问题。编译器，runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</li><li>正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</li><li>未同步/未正确同步的多线程程序。JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。</li></ol><p>下图展示了这三类程序在JMM中与在顺序一致性内存模型中的执行结果的异同：</p><p><img src="https://res.infoq.com/articles/java-memory-model-7/zh/resources/4.png" alt=""></p><p>只要多线程程序是正确同步的，JMM保证该程序在任意的处理器平台上的执行结果，与该程序在顺序一致性内存模型中的执行结果一致。</p><h2 id="JSR-133对旧内存模型的修补"><a href="#JSR-133对旧内存模型的修补" class="headerlink" title="JSR-133对旧内存模型的修补"></a>JSR-133对旧内存模型的修补</h2><p>JSR-133对JDK5之前的旧内存模型的修补主要有两个：</p><ul><li>增强volatile的内存语义。旧内存模型允许volatile变量与普通变量重排序。JSR-133严格限制volatile变量与普通变量的重排序，使volatile的写-读和锁的释放-获取具有相同的内存语义。</li><li>增强final的内存语义。在旧内存模型中，多次读取同一个final变量的值可能会不相同。为此，JSR-133为final增加了两个重排序规则。现在，final具有了初始化安全性。</li></ul><p><em>转载自</em><a href="http://ifeve.com/" target="_blank" rel="noopener">并发编程网 – ifeve.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java并发指南&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/21961.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21961.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java并发" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发原理" scheme="http://h2pl.github.io/tags/Java%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java并发指南5：JMM中的final关键字解析</title>
    <link href="http://h2pl.github.io/2018/05/18/concurrent5/"/>
    <id>http://h2pl.github.io/2018/05/18/concurrent5/</id>
    <published>2018-05-18T15:05:43.000Z</published>
    <updated>2018-06-11T13:43:20.539Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java并发指南<br><a href="https://blog.csdn.net/column/details/21961.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21961.html</a></p><p>相关代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><p>与前面介绍的锁和volatile相比较，对final域的读和写更像是普通的变量访问。对于final域，编译器和处理器要遵守两个重排序规则：</p><ol><li>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li><li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</li></ol><p>下面，我们通过一些示例性的代码来分别说明这两个规则：</p><pre>public class FinalExample {    int i;                            //普通变量    final int j;                      //final变量    static FinalExample obj;    public void FinalExample () {     //构造函数        i = 1;                        //写普通域        j = 2;                        //写final域    }    public static void writer () {    //写线程A执行        obj = new FinalExample ();    }    public static void reader () {       //读线程B执行        FinalExample object = obj;       //读对象引用        int a = object.i;                //读普通域        int b = object.j;                //读final域    }}</pre><p>这里假设一个线程A执行writer ()方法，随后另一个线程B执行reader ()方法。下面我们通过这两个线程的交互来说明这两个规则。</p><h2 id="写final域的重排序规则"><a href="#写final域的重排序规则" class="headerlink" title="写final域的重排序规则"></a>写final域的重排序规则</h2><p>写final域的重排序规则禁止把final域的写重排序到构造函数之外。这个规则的实现包含下面2个方面：</p><ul><li>JMM禁止编译器把final域的写重排序到构造函数之外。</li><li>编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。</li></ul><p>现在让我们分析writer ()方法。writer ()方法只包含一行代码：finalExample = new FinalExample ()。这行代码包含两个步骤：</p><ol><li>构造一个FinalExample类型的对象；</li><li>把这个对象的引用赋值给引用变量obj。</li></ol><p>假设线程B读对象引用与读对象的成员域之间没有重排序（马上会说明为什么需要这个假设），下图是一种可能的执行时序：</p><p><img src="https://res.infoq.com/articles/java-memory-model-6/zh/resources/111.jpg" alt=""></p><p>在上图中，写普通域的操作被编译器重排序到了构造函数之外，读线程B错误的读取了普通变量i初始化之前的值。而写final域的操作，被写final域的重排序规则“限定”在了构造函数之内，读线程B正确的读取了final变量初始化之后的值。</p><p>写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。以上图为例，在读线程B“看到”对象引用obj时，很可能obj对象还没有构造完成（对普通域i的写操作被重排序到构造函数外，此时初始值2还没有写入普通域i）。</p><h2 id="读final域的重排序规则"><a href="#读final域的重排序规则" class="headerlink" title="读final域的重排序规则"></a>读final域的重排序规则</h2><p>读final域的重排序规则如下：</p><ul><li>在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。</li></ul><p>初次读对象引用与初次读该对象包含的final域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，大多数处理器也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（比如alpha处理器），这个规则就是专门用来针对这种处理器。</p><p>reader()方法包含三个操作：</p><ol><li>初次读引用变量obj;</li><li>初次读引用变量obj指向对象的普通域j。</li><li>初次读引用变量obj指向对象的final域i。</li></ol><p>现在我们假设写线程A没有发生任何重排序，同时程序在不遵守间接依赖的处理器上执行，下面是一种可能的执行时序：</p><p><img src="https://res.infoq.com/articles/java-memory-model-6/zh/resources/22.png" alt=""></p><p>在上图中，读对象的普通域的操作被处理器重排序到读对象引用之前。读普通域时，该域还没有被写线程A写入，这是一个错误的读取操作。而读final域的重排序规则会把读对象final域的操作“限定”在读对象引用之后，此时该final域已经被A线程初始化过了，这是一个正确的读取操作。</p><p>读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。在这个示例程序中，如果该引用不为null，那么引用对象的final域一定已经被A线程初始化过了。</p><h2 id="如果final域是引用类型"><a href="#如果final域是引用类型" class="headerlink" title="如果final域是引用类型"></a>如果final域是引用类型</h2><p>上面我们看到的final域是基础数据类型，下面让我们看看如果final域是引用类型，将会有什么效果？</p><p>请看下列示例代码：</p><pre>public class FinalReferenceExample {final int[] intArray;                     //final是引用类型static FinalReferenceExample obj;public FinalReferenceExample () {        //构造函数    intArray = new int[1];              //1    intArray[0] = 1;                   //2}public static void writerOne () {          //写线程A执行    obj = new FinalReferenceExample ();  //3}public static void writerTwo () {          //写线程B执行    obj.intArray[0] = 2;                 //4}public static void reader () {              //读线程C执行    if (obj != null) {                    //5        int temp1 = obj.intArray[0];       //6    }}}</pre><p>这里final域为一个引用类型，它引用一个int型的数组对象。对于引用类型，写final域的重排序规则对编译器和处理器增加了如下约束：</p><ol><li>在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li></ol><p>对上面的示例程序，我们假设首先线程A执行writerOne()方法，执行完后线程B执行writerTwo()方法，执行完后线程C执行reader ()方法。下面是一种可能的线程执行时序：</p><p><img src="https://res.infoq.com/articles/java-memory-model-6/zh/resources/33.png" alt=""></p><p>在上图中，1是对final域的写入，2是对这个final域引用的对象的成员域的写入，3是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的1不能和3重排序外，2和3也不能重排序。</p><p>JMM可以确保读线程C至少能看到写线程A在构造函数中对final引用对象的成员域的写入。即C至少能看到数组下标0的值为1。而写线程B对数组元素的写入，读线程C可能看的到，也可能看不到。JMM不保证线程B的写入对读线程C可见，因为写线程B和读线程C之间存在数据竞争，此时的执行结果不可预知。</p><p>如果想要确保读线程C看到写线程B对数组元素的写入，写线程B和读线程C之间需要使用同步原语（lock或volatile）来确保内存可见性。</p><h2 id="为什么final引用不能从构造函数内“逸出”"><a href="#为什么final引用不能从构造函数内“逸出”" class="headerlink" title="为什么final引用不能从构造函数内“逸出”"></a>为什么final引用不能从构造函数内“逸出”</h2><p>前面我们提到过，写final域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了。其实要得到这个效果，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程可见，也就是对象引用不能在构造函数中“逸出”。为了说明问题，让我们来看下面示例代码：</p><pre>public class FinalReferenceEscapeExample {final int i;static FinalReferenceEscapeExample obj;public FinalReferenceEscapeExample () {    i = 1;                              //1写final域    obj = this;                          //2 this引用在此“逸出”}public static void writer() {    new FinalReferenceEscapeExample ();}public static void reader {    if (obj != null) {                     //3        int temp = obj.i;                 //4    }}}</pre><p>假设一个线程A执行writer()方法，另一个线程B执行reader()方法。这里的操作2使得对象还未完成构造前就为线程B可见。即使这里的操作2是构造函数的最后一步，且即使在程序中操作2排在操作1后面，执行read()方法的线程仍然可能无法看到final域被初始化后的值，因为这里的操作1和操作2之间可能被重排序。实际的执行时序可能如下图所示：</p><p><img src="https://res.infoq.com/articles/java-memory-model-6/zh/resources/44.png" alt=""></p><p>从上图我们可以看出：在构造函数返回前，被构造对象的引用不能为其他线程可见，因为此时的final域可能还没有被初始化。在构造函数返回后，任意线程都将保证能看到final域正确初始化之后的值。</p><h2 id="final语义在处理器中的实现"><a href="#final语义在处理器中的实现" class="headerlink" title="final语义在处理器中的实现"></a>final语义在处理器中的实现</h2><p>现在我们以x86处理器为例，说明final语义在处理器中的具体实现。</p><p>上面我们提到，写final域的重排序规则会要求译编器在final域的写之后，构造函数return之前，插入一个StoreStore障屏。读final域的重排序规则要求编译器在读final域的操作前面插入一个LoadLoad屏障。</p><p>由于x86处理器不会对写-写操作做重排序，所以在x86处理器中，写final域需要的StoreStore障屏会被省略掉。同样，由于x86处理器不会对存在间接依赖关系的操作做重排序，所以在x86处理器中，读final域需要的LoadLoad屏障也会被省略掉。也就是说在x86处理器中，final域的读/写不会插入任何内存屏障！</p><h2 id="JSR-133为什么要增强final的语义"><a href="#JSR-133为什么要增强final的语义" class="headerlink" title="JSR-133为什么要增强final的语义"></a>JSR-133为什么要增强final的语义</h2><p>在旧的Java内存模型中 ，最严重的一个缺陷就是线程可能看到final域的值会改变。比如，一个线程当前看到一个整形final域的值为0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个final域的值时，却发现值变为了1（被某个线程初始化之后的值）。最常见的例子就是在旧的Java内存模型中，String的值可能会改变（参考文献2中有一个具体的例子，感兴趣的读者可以自行参考，这里就不赘述了）。</p><p>为了修补这个漏洞，JSR-133专家组增强了final的语义。通过为final域增加写和读重排序规则，可以为java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指lock和volatile的使用），就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。</p><p>参考文献</p><ol><li><p><a href="http://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601/ref=pd_sim_b_1" target="_blank" rel="noopener"> Java Concurrency in Practice</a></p></li><li><p><a href="http://www.cs.umd.edu/users/pugh/java/memoryModel/jsr-133-faq.html" target="_blank" rel="noopener"> JSR 133 (Java Memory Model) FAQ</a></p></li><li><p><a href="http://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601/ref=pd_sim_b_1" target="_blank" rel="noopener"> Java Concurrency in Practice</a></p></li><li><p><a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html" target="_blank" rel="noopener"> The JSR-133 Cookbook for Compiler Writers</a></p></li></ol><p><a href="http://download.intel.com/products/processor/manual/253668.pdf" target="_blank" rel="noopener">Intel® 64 and IA-32 ArchitecturesvSoftware Developer’s Manual Volume 3A: System Programming Guide, Part 1</a></p><p><em>转载自</em><a href="http://ifeve.com/" target="_blank" rel="noopener">并发编程网 – ifeve.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java并发指南&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/21961.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21961.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java并发" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发原理" scheme="http://h2pl.github.io/tags/Java%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java并发指南4：Java中的锁 Lock和synchronized</title>
    <link href="http://h2pl.github.io/2018/05/18/concurrent4/"/>
    <id>http://h2pl.github.io/2018/05/18/concurrent4/</id>
    <published>2018-05-18T15:05:40.000Z</published>
    <updated>2018-06-11T13:43:20.228Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java并发指南<br><a href="https://blog.csdn.net/column/details/21961.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21961.html</a></p><p>相关代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><h1 id="Java中的锁机制及Lock类"><a href="#Java中的锁机制及Lock类" class="headerlink" title="Java中的锁机制及Lock类"></a>Java中的锁机制及Lock类</h1><p>锁的释放-获取建立的happens before 关系</p><p>锁是java并发编程中最重要的同步机制。锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。</p><p>下面是锁释放-获取的示例代码：</p><pre>class MonitorExample {    int a = 0;    public synchronized void writer() {  //1        a++;                             //2    }                                    //3    public synchronized void reader() {  //4        int i = a;                       //5        ……    }                                    //6}</pre><p>假设线程A执行writer()方法，随后线程B执行reader()方法。根据happens before规则，这个过程包含的happens before 关系可以分为两类：</p><ol><li>根据程序次序规则，1 happens before 2, 2 happens before 3; 4 happens before 5, 5 happens before 6。</li><li>根据监视器锁规则，3 happens before 4。</li><li>根据happens before 的传递性，2 happens before 5。</li></ol><p>上述happens before 关系的图形化表现形式如下：</p><p><img src="https://res.infoq.com/articles/java-memory-model-5/zh/resources/11.png" alt=""></p><p>在上图中，每一个箭头链接的两个节点，代表了一个happens before 关系。黑色箭头表示程序顺序规则；橙色箭头表示监视器锁规则；蓝色箭头表示组合这些规则后提供的happens before保证。</p><p>上图表示在线程A释放了锁之后，随后线程B获取同一个锁。在上图中，2 happens before 5。因此，线程A在释放锁之前所有可见的共享变量，在线程B获取同一个锁之后，将立刻变得对B线程可见。</p><h2 id="锁释放和获取的内存语义"><a href="#锁释放和获取的内存语义" class="headerlink" title="锁释放和获取的内存语义"></a>锁释放和获取的内存语义</h2><p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。以上面的MonitorExample程序为例，A线程释放锁后，共享数据的状态示意图如下：</p><p><img src="https://res.infoq.com/articles/java-memory-model-5/zh/resources/22.png" alt=""></p><p>当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须要从主内存中去读取共享变量。下面是锁获取的状态示意图：</p><p><img src="https://res.infoq.com/articles/java-memory-model-5/zh/resources/33.png" alt=""></p><p>对比锁释放-获取的内存语义与volatile写-读的内存语义，可以看出：锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。</p><p>下面对锁释放和锁获取的内存语义做个总结：</p><ul><li>线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。</li><li>线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。</li><li>线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。</li></ul><h2 id="锁内存语义的实现"><a href="#锁内存语义的实现" class="headerlink" title="锁内存语义的实现"></a>锁内存语义的实现</h2><p>本文将借助ReentrantLock的源代码，来分析锁内存语义的具体实现机制。</p><p>请看下面的示例代码：</p><pre>class ReentrantLockExample {int a = 0;ReentrantLock lock = new ReentrantLock();public void writer() {    lock.lock();         //获取锁    try {        a++;    } finally {        lock.unlock();  //释放锁    }}public void reader () {    lock.lock();        //获取锁    try {        int i = a;        ……    } finally {        lock.unlock();  //释放锁    }}}</pre><p>在ReentrantLock中，调用lock()方法获取锁；调用unlock()方法释放锁。</p><p>ReentrantLock的实现依赖于java同步器框架AbstractQueuedSynchronizer（本文简称之为AQS）。AQS使用一个整型的volatile变量（命名为state）来维护同步状态，马上我们会看到，这个volatile变量是ReentrantLock内存语义实现的关键。 下面是ReentrantLock的类图（仅画出与本文相关的部分）：</p><p><img src="https://res.infoq.com/articles/java-memory-model-5/zh/resources/44.png" alt=""></p><p>ReentrantLock分为公平锁和非公平锁，我们首先分析公平锁。</p><p>使用公平锁时，加锁方法lock()的方法调用轨迹如下：</p><ol><li>ReentrantLock : lock()</li><li>FairSync : lock()</li><li>AbstractQueuedSynchronizer : acquire(int arg)</li><li>ReentrantLock : tryAcquire(int acquires)</li></ol><p>在第4步真正开始加锁，下面是该方法的源代码：</p><pre>protected final boolean tryAcquire(int acquires) {    final Thread current = Thread.currentThread();    int c = getState();   //获取锁的开始，首先读volatile变量state    if (c == 0) {        if (isFirst(current) &&            compareAndSetState(0, acquires)) {            setExclusiveOwnerThread(current);            return true;        }    }    else if (current == getExclusiveOwnerThread()) {        int nextc = c + acquires;        if (nextc < 0)              throw new Error("Maximum lock count exceeded");        setState(nextc);        return true;    }    return false;}</pre><p>从上面源代码中我们可以看出，加锁方法首先读volatile变量state。</p><p>在使用公平锁时，解锁方法unlock()的方法调用轨迹如下：</p><ol><li>ReentrantLock : unlock()</li><li>AbstractQueuedSynchronizer : release(int arg)</li><li>Sync : tryRelease(int releases)</li></ol><p>在第3步真正开始释放锁，下面是该方法的源代码：</p><pre>protected final boolean tryRelease(int releases) {    int c = getState() - releases;    if (Thread.currentThread() != getExclusiveOwnerThread())        throw new IllegalMonitorStateException();    boolean free = false;    if (c == 0) {        free = true;        setExclusiveOwnerThread(null);    }    setState(c);           //释放锁的最后，写volatile变量state    return free;}</pre><p>从上面的源代码我们可以看出，在释放锁的最后写volatile变量state。</p><p>公平锁在释放锁的最后写volatile变量state；在获取锁时首先读这个volatile变量。根据volatile的happens-before规则，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变的对获取锁的线程可见。</p><p>现在我们分析非公平锁的内存语义的实现。</p><p>非公平锁的释放和公平锁完全一样，所以这里仅仅分析非公平锁的获取。</p><p>使用公平锁时，加锁方法lock()的方法调用轨迹如下：</p><ol><li>ReentrantLock : lock()</li><li>NonfairSync : lock()</li><li>AbstractQueuedSynchronizer : compareAndSetState(int expect, int update)</li></ol><p>在第3步真正开始加锁，下面是该方法的源代码：</p><pre>protected final boolean compareAndSetState(int expect, int update) {    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);}</pre><p>该方法以原子操作的方式更新state变量，本文把java的compareAndSet()方法调用简称为CAS。JDK文档对该方法的说明如下：如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值。此操作具有 volatile 读和写的内存语义。</p><p>这里我们分别从编译器和处理器的角度来分析,CAS如何同时具有volatile读和volatile写的内存语义。</p><p>前文我们提到过，编译器不会对volatile读与volatile读后面的任意内存操作重排序；编译器不会对volatile写与volatile写前面的任意内存操作重排序。组合这两个条件，意味着为了同时实现volatile读和volatile写的内存语义，编译器不能对CAS与CAS前面和后面的任意内存操作重排序。</p><p>下面我们来分析在常见的intel x86处理器中，CAS是如何同时具有volatile读和volatile写的内存语义的。</p><p>下面是sun.misc.Unsafe类的compareAndSwapInt()方法的源代码：</p><pre>public final native boolean compareAndSwapInt(Object o, long offset,                                              int expected,                                              int x);</pre><p>可以看到这是个本地方法调用。这个本地方法在openjdk中依次调用的c++代码为：unsafe.cpp，atomic.cpp和atomicwindowsx86.inline.hpp。这个本地方法的最终实现在openjdk的如下位置：openjdk-7-fcs-src-b147-27jun2011\openjdk\hotspot\src\oscpu\windowsx86\vm\ atomicwindowsx86.inline.hpp（对应于windows操作系统，X86处理器）。下面是对应于intel x86处理器的源代码的片段：</p><pre>// Adding a lock prefix to an instruction on MP machine// VC++ doesn't like the lock prefix to be on a single line// so we can't insert a label after the lock prefix.// By emitting a lock prefix, we can define a label after it.#define LOCK_IF_MP(mp) __asm cmp mp, 0  \                       __asm je L0      \                       __asm _emit 0xF0 \                       __asm L0:inline jint     Atomic::cmpxchg    (jint     exchange_value, volatile jint*     dest, jint     compare_value) {  // alternative for InterlockedCompareExchange  int mp = os::is_MP();  __asm {    mov edx, dest    mov ecx, exchange_value    mov eax, compare_value    LOCK_IF_MP(mp)    cmpxchg dword ptr [edx], ecx  }}</pre><p>如上面源代码所示，程序会根据当前处理器的类型来决定是否为cmpxchg指令添加lock前缀。如果程序是在多处理器上运行，就为cmpxchg指令加上lock前缀（lock cmpxchg）。反之，如果程序是在单处理器上运行，就省略lock前缀（单处理器自身会维护单处理器内的顺序一致性，不需要lock前缀提供的内存屏障效果）。</p><p>intel的手册对lock前缀的说明如下：</p><ol><li>确保对内存的读-改-写操作原子执行。在Pentium及Pentium之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其他处理器暂时无法通过总线访问内存。很显然，这会带来昂贵的开销。从Pentium 4，Intel Xeon及P6处理器开始，intel在原有总线锁的基础上做了一个很有意义的优化：如果要访问的内存区域（area of memory）在lock前缀指令执行期间已经在处理器内部的缓存中被锁定（即包含该内存区域的缓存行当前处于独占或以修改状态），并且该内存区域被完全包含在单个缓存行（cache line）中，那么处理器将直接执行该指令。由于在指令执行期间该缓存行会一直被锁定，其它处理器无法读/写该指令要访问的内存区域，因此能保证指令执行的原子性。这个操作过程叫做缓存锁定（cache locking），缓存锁定将大大降低lock前缀指令的执行开销，但是当多处理器之间的竞争程度很高或者指令访问的内存地址未对齐时，仍然会锁住总线。</li><li>禁止该指令与之前和之后的读和写指令重排序。</li><li>把写缓冲区中的所有数据刷新到内存中。</li></ol><p>上面的第2点和第3点所具有的内存屏障效果，足以同时实现volatile读和volatile写的内存语义。</p><p>经过上面的这些分析，现在我们终于能明白为什么JDK文档说CAS同时具有volatile读和volatile写的内存语义了。</p><p>现在对公平锁和非公平锁的内存语义做个总结：</p><ul><li>公平锁和非公平锁释放时，最后都要写一个volatile变量state。</li><li>公平锁获取时，首先会去读这个volatile变量。</li><li>非公平锁获取时，首先会用CAS更新这个volatile变量,这个操作同时具有volatile读和volatile写的内存语义。</li></ul><p>从本文对ReentrantLock的分析可以看出，锁释放-获取的内存语义的实现至少有下面两种方式：</p><ol><li>利用volatile变量的写-读所具有的内存语义。</li><li>利用CAS所附带的volatile读和volatile写的内存语义。</li></ol><h2 id="concurrent包的实现"><a href="#concurrent包的实现" class="headerlink" title="concurrent包的实现"></a>concurrent包的实现</h2><p>由于java的CAS同时具有 volatile 读和volatile写的内存语义，因此Java线程之间的通信现在有了下面四种方式：</p><ol><li>A线程写volatile变量，随后B线程读这个volatile变量。</li><li>A线程写volatile变量，随后B线程用CAS更新这个volatile变量。</li><li>A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。</li><li>A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。</li></ol><p>Java的CAS会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读-改-写指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式：</p><ol><li>首先，声明共享变量为volatile；</li><li>然后，使用CAS的原子条件更新来实现线程之间的同步；</li><li>同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。</li></ol><p>AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent包的实现示意图如下：</p><p><img src="https://res.infoq.com/articles/java-memory-model-5/zh/resources/55.png" alt=""></p><h1 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h1><p>记得刚刚开始学习Java的时候，一遇到多线程情况就是synchronized，相对于当时的我们来说synchronized是这么的神奇而又强大，那个时候我们赋予它一个名字“同步”，也成为了我们解决多线程情况的百试不爽的良药。但是，随着我们学习的进行我们知道synchronized是一个重量级锁，相对于Lock，它会显得那么笨重，以至于我们认为它不是那么的高效而慢慢摒弃它。<br>诚然，随着Javs SE 1.6对synchronized进行的各种优化后，synchronized并不会显得那么重了。下面跟随LZ一起来探索synchronized的实现机制、Java是如何对它进行了优化、锁优化机制、锁的存储结构和升级过程；</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><blockquote><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性</p></blockquote><p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p><ol><li>普通同步方法，锁是当前实例对象</li><li>静态同步方法，锁是当前类的class对象</li><li>同步方法块，锁是括号里面的对象</li></ol><p>当一个线程访问同步代码块时，它首先是需要得到锁才能执行同步代码，当退出或者抛出异常时必须要释放锁，那么它是如何来实现这个机制的呢？我们先看一段简单的代码：</p><pre name="code">public  class  SynchronizedTest  {  public  synchronized  void test1(){  }  public  void test2(){  synchronized  (this){  }  }  }</pre><p>利用javap工具查看生成的class文件信息来分析Synchronized的实现<br><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/02/Synchronize-1-1.jpg" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/02/Synchronize-1_thumb-1.jpg" alt="Synchronize-1" title="Synchronize-1"></a><br>从上面可以看出，同步代码块是使用monitorenter和monitorexit指令实现的，同步方法（在这看不出来需要看JVM底层实现）依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。<br>同步代码块：monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁；<br>同步方法：synchronized方法则会被翻译成普通的方法调用和返回指令如:invokevirtual、areturn指令，在VM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass做为锁对象。(摘自：<a href="http://www.cnblogs.com/javaminer/p/3889023.html" target="_blank" rel="noopener">http://www.cnblogs.com/javaminer/p/3889023.html</a>)</p><p>下面我们来继续分析，但是在深入之前我们需要了解两个重要的概念：Java对象头，Monitor。</p><h2 id="Java对象头、monitor"><a href="#Java对象头、monitor" class="headerlink" title="Java对象头、monitor"></a>Java对象头、monitor</h2><p>Java对象头和monitor是实现synchronized的基础！下面就这两个概念来做详细介绍。</p><h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>synchronized用的锁是存在Java对象头里的，那么什么是Java对象头呢？Hotspot虚拟机的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。其中Klass Point是是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键，所以下面将重点阐述</p><p>Mark Word。<br>Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。Java对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit），但是如果对象是数组类型，则需要三个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。下图是Java对象头的存储结构（32位虚拟机）：<br><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/02/222222_2-1.jpg" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/02/222222_2_thumb-1.jpg" alt="222222_2" title="222222_2"></a><br>对象头信息是与对象自身定义的数据无关的额外存储成本，但是考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据，它会根据对象的状态复用自己的存储空间，也就是说，Mark Word会随着程序的运行发生变化，变化状态如下（32位虚拟机）：<br><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/02/11111111111_2-1.jpg" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/02/11111111111_2_thumb-1.jpg" alt="11111111111_2" title="11111111111_2"></a></p><p>简单介绍了Java对象头，我们下面再看Monitor。</p><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p>什么是Monitor？我们可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。<br>与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。<br>Monitor 是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。其结构如下：<br><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/02/44444-1.png" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/02/44444_thumb-1.png" alt="44444" title="44444"></a><br>Owner：初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；<br>EntryQ:关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程。<br>RcThis:表示blocked或waiting在该monitor record上的所有线程的个数。<br>Nest:用来实现重入锁的计数。<br>HashCode:保存从对象头拷贝过来的HashCode值（可能还包含GC age）。<br>Candidate:用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁。<br>摘自：<a href="http://blog.csdn.net/u012465296/article/details/53022317" target="_blank" rel="noopener">Java中synchronized的实现原理与应用）</a><br>我们知道synchronized是重量级锁，效率不怎么滴，同时这个观念也一直存在我们脑海里，不过在jdk 1.6中对synchronize的实现进行了各种优化，使得它显得不是那么重了，那么JVM采用了那些优化手段呢？</p><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>jdk1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。<br>锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。<br>何谓自旋锁？<br>所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。<br>自旋等待不能替代阻塞，先不说对处理器数量的要求（多核，貌似现在没有单核的处理器了），虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。<br>自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整；<br>如果通过参数-XX:preBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。</p><h3 id="适应自旋锁"><a href="#适应自旋锁" class="headerlink" title="适应自旋锁"></a>适应自旋锁</h3><p>JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。<br>有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。<br>如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法：</p><pre name="code">  public  void vectorTest(){  Vector<string> vector =  new  Vector<string>();  for(int i =  0  ; i <  10  ; i++){ vector.add(i +  "");  }  System.out.println(vector);  }</string></string></pre><p>在运行这段代码时，JVM可以明显检测到变量vector没有逃逸出方法vectorTest()之外，所以JVM可以大胆地将vector内部的加锁操作消除。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。<br>在大多数的情况下，上述观点是正确的，LZ也一直坚持着这个观点。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。<br>锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如上面实例：vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>引入轻量级锁的主要目的是在多没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下：<br>获取锁</p><ol><li>判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）；</li><li>JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；</li><li>判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；</li></ol><p>释放锁<br>轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：</p><ol><li>取出在获取轻量级锁保存在Displaced Mark Word中的数据；</li><li>用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）；</li><li>如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。</li></ol><p>对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢；</p><hr><p>下图是轻量级锁的获取和释放过程<br><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/02/22222222222222-1.png" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/02/22222222222222_thumb-1.png" alt="22222222222222" title="22222222222222"></a></p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>引入偏向锁主要目的是：为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。上面提到了轻量级锁的加锁解锁操作是需要依赖多次CAS原子指令的。那么偏向锁是如何来减少不必要的CAS操作呢？我们可以查看Mark work的结构就明白了。只需要检查是否为偏向锁、锁标识为以及ThreadID即可，处理流程如下：<br>获取锁</p><ol><li>检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；</li><li>若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）；</li><li>如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）；</li><li>通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；</li><li>执行同步代码块</li></ol><p>释放锁<br>偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</p><ol><li>暂停拥有偏向锁的线程，判断锁对象石是否还处于被锁定状态；</li><li>撤销偏向苏，恢复到无锁状态（01）或者轻量级锁的状态；</li></ol><hr><p>下图是偏向锁的获取和释放流程<br><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/02/image2-1.png" target="_blank" rel="noopener"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/02/image2_thumb-1.png" alt="image2" title="image2"></a></p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p><strong>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</strong></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>周志明：《深入理解Java虚拟机》</li><li>方腾飞：《Java并发编程的艺术》</li><li><a href="http://blog.csdn.net/u012465296/article/details/53022317" target="_blank" rel="noopener">Java中synchronized的实现原理与应用）</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java并发指南&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/21961.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21961.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java并发" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发原理" scheme="http://h2pl.github.io/tags/Java%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java并发指南3：并发三大问题与volatile关键字，CAS操作</title>
    <link href="http://h2pl.github.io/2018/05/17/concurrent3/"/>
    <id>http://h2pl.github.io/2018/05/17/concurrent3/</id>
    <published>2018-05-17T15:05:36.000Z</published>
    <updated>2018-06-11T13:43:20.051Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java并发指南<br><a href="https://blog.csdn.net/column/details/21961.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21961.html</a></p><p>相关代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><pre><code>01  final class SetCheck {02  private int  a = 0;03  private long b = 0;04   05  void set() {06  a =  1;07  b = -1;08  }09   10  boolean check() {11  return ((b ==  0) ||12  (b == -1 &amp;&amp; a == 1));13  }14  }</code></pre><p>如果是在一个串行执行的语言中，执行SetCheck类中的check方法永远不会返回false，即使编译器，运行时和计算机硬件并没有按照你所期望的逻辑来处理这段程序，该方法依然不会返回false。在程序执行过程中，下面这些你所不能预料的行为都是可能发生的：</p><ul><li>编译器可能会进行指令重排序，所以b变量的赋值操作可能先于a变量。如果是一个内联方法，编译器可能更甚一步将该方法的指令与其他语句进行重排序。</li><li>处理器可能会对语句所对应的机器指令进行重排序之后再执行，甚至并发地去执行。</li><li>内存系统（由高速缓存控制单元组成）可能会对变量所对应的内存单元的写操作指令进行重排序。重排之后的写操作可能会对其他的计算/内存操作造成覆盖。</li><li>编译器，处理器以及内存系统可能会让两条语句的机器指令交错。比如在32位机器上，b变量的高位字节先被写入，然后是a变量，紧接着才会是b变量的低位字节。</li><li>编译器，处理器以及内存系统可能会导致代表两个变量的内存单元在（如果有的话）连续的check调用（如果有的话）之后的某个时刻才更新，而以这种方式保存相应的值（如在CPU寄存器中）仍会得到预期的结果（check永远不会返回false）。</li></ul><p>在串行执行的语言中，只要程序执行遵循类似串行的语义，如上几种行为就不会有任何的影响。在一段简单的代码块中，串行执行程序不会依赖于代码的内部执行细节，因此如上的几种行为可以随意控制代码。这样就为编译器和计算机硬件提供了基本的灵活性。基于此，在过去的数十年内很多技术（CPU的流水线操作，多级缓存，读写平衡，寄存器分配等等）应运而生，为计算机处理速度的大幅提升奠定了基础。这些操作的类似串行执行的特性可以让开发人员无须知道其内部发生了什么。对于开发人员来说，如果不创建自己的线程，那么这些行为也不会对其产生任何的影响。</p><p>然而这些情况在并发编程中就完全不一样了，上面的代码在并发过程中，当一个线程调用check方法的时候完全有可能另一个线程正在执行set方法，这种情况下check方法就会将上面提到的优化操作过程暴露出来。如果上述任意一个操作发生，那么check方法就有可能返回false。例如，check方法读取long类型的变量b的时候可能得到的既不是0也不是-1.而是一个被写入一半的值。另一种情况，set方法中的语句的乱序执行有可能导致check方法读取变量b的值的时候是-1，然而读取变量a时却依然是0。</p><p>换句话说，不仅是并发执行会导致问题，而且在一些优化操作（比如指令重排序）进行之后也会导致代码执行结果和源代码中的逻辑有所出入。由于编译器和运行时技术的日趋成熟以及多处理器的逐渐普及，这种现象就变得越来越普遍。对于那些一直从事串行编程背景的开发人员（其实，基本上所有的程序员）来说，这可能会导致令人诧异的结果，而这些结果可能从没在串行编程中出现过。这可能就是那些微妙难解的并发编程错误的根本源头吧。</p><p>在绝大部分的情况下，有一个很简单易行的方法来避免那些在复杂的并发程序中因代码执行优化导致的问题：<strong>使用同步</strong>。例如，如果SetCheck类中所有的方法都被声明为synchronized,那么你就可以确保那么内部处理细节都不会影响代码预期的结果了。</p><p>但是在有些情况下你却不能或者不想去使用同步，抑或着你需要推断别人未使用同步的代码。在这些情况下你只能依赖Java内存模型所阐述的结果语义所提供的最小保证。Java内存模型允许上面提到的所有操作，但是限制了它们在执行语义上潜在的结果，此外还提出了一些技术让程序员可以用来控制这些语义的某些方面。</p><p>Java内存模型是Java语言规范的一部分，主要在JLS的第17章节介绍。这里，我们只是讨论一些基本的动机，属性以及模型的程序一致性。这里对JLS第一版中所缺少的部分进行了澄清。</p><p>我们假设Java内存模型可以被看作在1.2.4中描述的那种标准的SMP机器的理想化模型。</p><p><img src="http://gee.cs.oswego.edu/dl/cpj/mm-1.gif" alt=""></p><p>（1.2.4）</p><p>在这个模型中，<strong>每一个线程都可以被看作为运行在不同的CPU上，然而即使是在多处理器上，这种情况也是很罕见的</strong>。但是实际上，通过模型所具备的某些特性，这种CPU和线程单一映射能够通过一些合理的方法去实现。例如，因为CPU的寄存器不能被另一个CPU直接访问，这种模型必须考虑到某个线程无法得知被另一个线程操作变量的值的情况。这种情况不仅仅存在于多处理器环境上，在单核CPU环境里，因为编译器和处理器的不可预测的行为也可能导致同样的情况。</p><p>Java内存模型没有具体讲述前面讨论的执行策略是由编译器，CPU，缓存控制器还是其它机制促成的。甚至没有用开发人员所熟悉的类，对象及方法来讨论。取而代之，Java内存模型中仅仅定义了线程和内存之间那种抽象的关系。众所周知，每个线程都拥有自己的工作存储单元（缓存和寄存器的抽象）来存储线程当前使用的变量的值。Java内存模型仅仅保证了代码指令与变量操作的有序性，大多数规则都只是指出什么时候变量值应该在内存和线程工作内存之间传输。这些规则主要是为了解决如下三个相互牵连的问题：</p><ol><li><strong>原子性</strong>：哪些指令必须是不可分割的。在Java内存模型中，这些规则需声明仅适用于-—实例变量和静态变量，也包括数组元素，但不包括方法中的局部变量-—的内存单元的简单读写操作。</li><li><strong>可见性</strong>：在哪些情况下，一个线程执行的结果对另一个线程是可见的。这里需要关心的结果有，写入的字段以及读取这个字段所看到的值。</li><li><strong>有序性</strong>：在什么情况下，某个线程的操作结果对其它线程来看是无序的。最主要的乱序执行问题主要表现在读写操作和赋值语句的相互执行顺序上。</li></ol><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>当正确的使用了同步，上面属性都会具有一个简单的特性：一个同步方法或者代码块中所做的修改对于使用了同一个锁的同步方法或代码块都具有原子性和可见性。同步方法或代码块之间的执行过程都会和代码指定的执行顺序保持一致。即使代码块内部指令也许是乱序执行的，也不会对使用了同步的其它线程造成任何影响。</p><p>当没有使用同步或者使用的不一致的时候，情况就会变得复杂。Java内存模型所提供的保障要比大多数开发人员所期望的弱，也远不及目前业界所实现的任意一款Java虚拟机。这样，开发人员就必须负起额外的义务去保证对象的一致性关系：对象间若有能被多个线程看到的某种恒定关系，所有依赖这种关系的线程就必须一直维持这种关系，而不仅仅由执行状态修改的线程来维持。</p><p>除了long型字段和double型字段外，java内存模型确保访问任意类型字段所对应的内存单元都是原子的。这包括引用其它对象的引用类型的字段。此外，volatile long 和volatile double也具有原子性 。（虽然java内存模型不保证non-volatile long 和 non-volatile double的原子性，当然它们在某些场合也具有原子性。）（译注：non-volatile long在64位JVM，OS，CPU下具有原子性）</p><p>当在一个表达式中使用一个non-long或者non-double型字段时，原子性可以确保你将获得这个字段的初始值或者某个线程对这个字段写入之后的值；但不会是两个或更多线程在同一时间对这个字段写入之后产生混乱的结果值（即原子性可以确保，获取到的结果值所对应的所有bit位，全部都是由单个线程写入的）。但是，如下面（译注：指可见性章节）将要看到的，原子性不能确保你获得的是任意线程写入之后的最新值。 因此，原子性保证通常对并发程序设计的影响很小。</p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>只有在下列情况时，一个线程对字段的修改才能确保对另一个线程可见：</p><p>一个写线程释放一个锁之后，另一个读线程随后获取了同一个锁。本质上，线程释放锁时会将强制刷新工作内存中的脏数据到主内存中，获取一个锁将强制线程装载（或重新装载）字段的值。锁提供对一个同步方法或块的互斥性执行，线程执行获取锁和释放锁时，所有对字段的访问的内存效果都是已定义的。</p><p>注意同步的双重含义：锁提供高级同步协议，同时在线程执行同步方法或块时，内存系统（有时通过内存屏障指令）保证值的一致性。这说明，与顺序程序设计相比较，并发程序设计与分布式程序设计更加类似。同步的第二个特性可以视为一种机制：一个线程在运行已同步方法时，它将发送和/或接收其他线程在同步方法中对变量所做的修改。从这一点来说，使用锁和发送消息仅仅是语法不同而已。</p><p>如果把一个字段声明为volatile型，线程对这个字段写入后，在执行后续的内存访问之前，线程必须刷新这个字段且让这个字段对其他线程可见（即该字段立即刷新）。每次对volatile字段的读访问，都要重新装载字段的值。</p><p>一个线程首次访问一个对象的字段，它将读到这个字段的初始值或被某个线程写入后的值。<br>此外，把还未构造完成的对象的引用暴露给某个线程，这是一个错误的做法 (see ?.1.2)。在构造函数内部开始一个新线程也是危险的，特别是这个类可能被子类化时。Thread.start有如下的内存效果：调用start方法的线程释放了锁，随后开始执行的新线程获取了这个锁。如果在子类构造函数执行之前，可运行的超类调用了new Thread(this).start()，当run方法执行时，对象很可能还没有完全初始化。同样，如果你创建且开始一个新线程T，这个线程使用了在执行start之后才创建的一个对象X。你不能确信X的字段值将能对线程T可见。除非你把所有用到X的引用的方法都同步。如果可行的话，你可以在开始T线程之前创建X。</p><p>线程终止时，所有写过的变量值都要刷新到主内存中。比如，一个线程使用Thread.join来终止另一个线程，那么第一个线程肯定能看到第二个线程对变量值得修改。</p><p>注意，在同一个线程的不同方法之间传递对象的引用，永远也不会出现内存可见性问题。<br>内存模型确保上述操作最终会发生，一个线程对一个特定字段的特定更新，最终将会对其他线程可见，但这个“最终”可能是很长一段时间。线程之间没有同步时，很难保证对字段的值能在多线程之间保持一致（指写线程对字段的写入立即能对读线程可见）。特别是，如果字段不是volatile或没有通过同步来访问这个字段，在一个循环中等待其他线程对这个字段的写入，这种情况总是错误的(see ?.2.6)。</p><p>在缺乏同步的情况下，模型还允许不一致的可见性。比如，得到一个对象的一个字段的最新值，同时得到这个对象的其他字段的过期的值。同样，可能读到一个引用变量的最新值，但读取到这个引用变量引用的对象的字段的过期值。<br>不管怎样，线程之间的可见性并不总是失效（指线程即使没有使用同步，仍然有可能读取到字段的最新值），内存模型仅仅是允许这种失效发生而已。因此，即使多个线程之间没有使用同步，也不保证一定会发生内存可见性问题（指线程读取到过期的值），java内存模型仅仅是允许内存可见性问题发生而已。在很多当前的JVM实现和java执行平台中，甚至是在那些使用多处理器的JVM和平台中，也很少出现内存可见性问题。共享同一个CPU的多个线程使用公共的缓存，缺少强大的编译器优化，以及存在强缓存一致性的硬件，这些都会使线程更新后的值能够立即在多线程之间传递。这使得测试基于内存可见性的错误是不切实际的，因为这样的错误极难发生。或者这种错误仅仅在某个你没有使用过的平台上发生，或仅在未来的某个平台上发生。这些类似的解释对于多线程之间的内存可见性问题来说非常普遍。没有同步的并发程序会出现很多问题，包括内存一致性问题。</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>有序性规则表现在以下两种场景: 线程内和线程间</p><ul><li>从某个线程的角度看方法的执行，指令会按照一种叫“串行”（as-if-serial）的方式执行，此种方式已经应用于顺序编程语言。</li><li>这个线程“观察”到其他线程并发地执行非同步的代码时，任何代码都有可能交叉执行。唯一起作用的约束是：对于同步方法，同步块以及volatile字段的操作仍维持相对有序。</li></ul><p>再次提醒，这些仅是最小特性的规则。具体到任何一个程序或平台上，可能存在更严格的有序性规则。所以你不能依赖它们，因为即使你的代码遵循了这些更严格的规则，仍可能在不同特性的JVM上运行失败，而且测试非常困难。</p><p>需要注意的是，线程内部的观察视角被JLS _<strong>[1]</strong> _中其他的语义的讨论所采用。例如，算术表达式的计算在线程内看来是从左到右地执行操作（JLS 15.6章节），而这种执行效果是没有必要被其他线程观察到的。</p><p>仅当某一时刻只有一个线程操作变量时，线程内的执行表现为串行。出现上述情景，可能是因为使用了同步，互斥体<strong>_[2] _</strong>或者纯属巧合。当多线程同时运行在非同步的代码里进行公用字段的读写时，会形成一种执行模式。在这种模式下，代码会任意交叉执行，原子性和可见性会失效，以及产生竞态条件。这时线程执行不再表现为串行。</p><p>尽管JLS列出了一些特定的合法和非法的重排序，如果碰到所列范围之外的问题，会降低以下这条实践保证 ：运行结果反映了几乎所有的重排序产生的代码交叉执行的情况。所以，没必要去探究这些代码的有序性。</p><h1 id="volatile关键字详解：在JMM中volatile的内存语义是锁"><a href="#volatile关键字详解：在JMM中volatile的内存语义是锁" class="headerlink" title="volatile关键字详解：在JMM中volatile的内存语义是锁"></a>volatile关键字详解：在JMM中volatile的内存语义是锁</h1><h2 id="volatile的特性"><a href="#volatile的特性" class="headerlink" title="volatile的特性"></a>volatile的特性</h2><p>当我们声明共享变量为volatile后，对这个变量的读/写将会很特别。理解volatile特性的一个好方法是：把对volatile变量的单个读/写，看成是使用同一个监视器锁对这些单个读/写操作做了同步。下面我们通过具体的示例来说明，请看下面的示例代码：</p><pre>class VolatileFeaturesExample {    volatile long vl = 0L;  //使用volatile声明64位的long型变量    public void set(long l) {        vl = l;   //单个volatile变量的写    }    public void getAndIncrement () {        vl++;    //复合（多个）volatile变量的读/写    }    public long get() {        return vl;   //单个volatile变量的读    }}</pre><p>假设有多个线程分别调用上面程序的三个方法，这个程序在语意上和下面程序等价：</p><pre>class VolatileFeaturesExample {    long vl = 0L;               // 64位的long型普通变量    public synchronized void set(long l) {     //对单个的普通 变量的写用同一个监视器同步        vl = l;    }    public void getAndIncrement () { //普通方法调用        long temp = get();           //调用已同步的读方法        temp += 1L;                  //普通写操作        set(temp);                   //调用已同步的写方法    }    public synchronized long get() {     //对单个的普通变量的读用同一个监视器同步        return vl;    }}</pre><p>如上面示例程序所示，对一个volatile变量的单个读/写操作，与对一个普通变量的读/写操作使用同一个监视器锁来同步，它们之间的执行效果相同。</p><p>监视器锁的happens-before规则保证释放监视器和获取监视器的两个线程之间的内存可见性，这意味着对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</p><p>简而言之，volatile变量自身具有下列特性：监视器锁的语义决定了临界区代码的执行具有原子性。这意味着即使是64位的long型和double型变量，只要它是volatile变量，对该变量的读写就将具有原子性。如果是多个volatile操作或类似于volatile++这种复合操作，这些操作整体上不具有原子性。</p><ul><li>可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</li><li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。</li></ul><h2 id="volatile写-读建立的happens-before关系"><a href="#volatile写-读建立的happens-before关系" class="headerlink" title="volatile写-读建立的happens before关系"></a>volatile写-读建立的happens before关系</h2><p>上面讲的是volatile变量自身的特性，对程序员来说，volatile对线程的内存可见性的影响比volatile自身的特性更为重要，也更需要我们去关注。</p><p>从JSR-133开始，volatile变量的写-读可以实现线程之间的通信。</p><p>从内存语义的角度来说，volatile与监视器锁有相同的效果：volatile写和监视器的释放有相同的内存语义；volatile读与监视器的获取有相同的内存语义。</p><p>请看下面使用volatile变量的示例代码：</p><pre>class VolatileExample {    int a = 0;    volatile boolean flag = false;    public void writer() {        a = 1;                   //1        flag = true;               //2    }    public void reader() {        if (flag) {                //3            int i =  a;           //4            ……        }    }}</pre><p>假设线程A执行writer()方法之后，线程B执行reader()方法。根据happens before规则，这个过程建立的happens before 关系可以分为两类：</p><ol><li>根据程序次序规则，1 happens before 2; 3 happens before 4。</li><li>根据volatile规则，2 happens before 3。</li><li>根据happens before 的传递性规则，1 happens before 4。</li></ol><p>上述happens before 关系的图形化表现形式如下：</p><p><img src="https://res.infoq.com/articles/java-memory-model-4/zh/resources/1.png" alt=""></p><p>在上图中，每一个箭头链接的两个节点，代表了一个happens before 关系。黑色箭头表示程序顺序规则；橙色箭头表示volatile规则；蓝色箭头表示组合这些规则后提供的happens before保证。</p><p>这里A线程写一个volatile变量后，B线程读同一个volatile变量。A线程在写volatile变量之前所有可见的共享变量，在B线程读同一个volatile变量后，将立即变得对B线程可见。</p><h2 id="volatile写-读的内存语义"><a href="#volatile写-读的内存语义" class="headerlink" title="volatile写-读的内存语义"></a>volatile写-读的内存语义</h2><p>volatile写的内存语义如下：</p><ul><li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。</li></ul><p>以上面示例程序VolatileExample为例，假设线程A首先执行writer()方法，随后线程B执行reader()方法，初始时两个线程的本地内存中的flag和a都是初始状态。下图是线程A执行volatile写后，共享变量的状态示意图：</p><p><img src="https://res.infoq.com/articles/java-memory-model-4/zh/resources/2.png" alt=""></p><p>如上图所示，线程A在写flag变量后，本地内存A中被线程A更新过的两个共享变量的值被刷新到主内存中。此时，本地内存A和主内存中的共享变量的值是一致的。</p><p>volatile读的内存语义如下：</p><ul><li>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li></ul><p>下面是线程B读同一个volatile变量后，共享变量的状态示意图：</p><p><img src="https://res.infoq.com/articles/java-memory-model-4/zh/resources/3.png" alt=""></p><p>如上图所示，在读flag变量后，本地内存B已经被置为无效。此时，线程B必须从主内存中读取共享变量。线程B的读取操作将导致本地内存B与主内存中的共享变量的值也变成一致的了。</p><p>如果我们把volatile写和volatile读这两个步骤综合起来看的话，在读线程B读一个volatile变量后，写线程A在写这个volatile变量之前所有可见的共享变量的值都将立即变得对读线程B可见。</p><p>下面对volatile写和volatile读的内存语义做个总结：</p><ul><li>线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出了（其对共享变量所在修改的）消息。</li><li>线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息。</li><li>线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息。</li></ul><h2 id="volatile内存语义的实现"><a href="#volatile内存语义的实现" class="headerlink" title="volatile内存语义的实现"></a>volatile内存语义的实现</h2><p>下面，让我们来看看JMM如何实现volatile写/读的内存语义。</p><p>前文我们提到过重排序分为编译器重排序和处理器重排序。为了实现volatile内存语义，JMM会分别限制这两种类型的重排序类型。下面是JMM针对编译器制定的volatile重排序规则表：</p><table><thead><tr><th>是否能重排序</th><th>第二个操作</th></tr></thead><tbody><tr><td>第一个操作</td><td>普通读/写</td><td>volatile读</td><td>volatile写</td></tr><tr><td>普通读/写</td><td></td><td></td><td>NO</td></tr><tr><td>volatile读</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>volatile写</td><td></td><td>NO</td><td>NO</td></tr></tbody></table><p>举例来说，第三行最后一个单元格的意思是：在程序顺序中，当第一个操作为普通变量的读或写时，如果第二个操作为volatile写，则编译器不能重排序这两个操作。</p><p>从上表我们可以看出：</p><ul><li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li><li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</li><li>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</li></ul><p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略：</p><ul><li>在每个volatile写操作的前面插入一个StoreStore屏障。</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadStore屏障。</li></ul><p>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。</p><p>下面是保守策略下，volatile写插入内存屏障后生成的指令序列示意图：</p><p><img src="https://res.infoq.com/articles/java-memory-model-4/zh/resources/4.png" alt=""></p><p>上图中的StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作已经对任意处理器可见了。这是因为StoreStore屏障将保障上面所有的普通写在volatile写之前刷新到主内存。</p><p>这里比较有意思的是volatile写后面的StoreLoad屏障。这个屏障的作用是避免volatile写与后面可能有的volatile读/写操作重排序。因为编译器常常无法准确判断在一个volatile写的后面，是否需要插入一个StoreLoad屏障（比如，一个volatile写之后方法立即return）。为了保证能正确实现volatile的内存语义，JMM在这里采取了保守策略：在每个volatile写的后面或在每个volatile读的前面插入一个StoreLoad屏障。从整体执行效率的角度考虑，JMM选择了在每个volatile写的后面插入一个StoreLoad屏障。因为volatile写-读内存语义的常见使用模式是：一个写线程写volatile变量，多个读线程读同一个volatile变量。当读线程的数量大大超过写线程时，选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。从这里我们可以看到JMM在实现上的一个特点：首先确保正确性，然后再去追求执行效率。</p><p>下面是在保守策略下，volatile读插入内存屏障后生成的指令序列示意图：</p><p><img src="https://res.infoq.com/articles/java-memory-model-4/zh/resources/5.png" alt=""></p><p>上图中的LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。</p><p>上述volatile写和volatile读的内存屏障插入策略非常保守。在实际执行时，只要不改变volatile写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。下面我们通过具体的示例代码来说明：</p><pre>class VolatileBarrierExample {    int a;    volatile int v1 = 1;    volatile int v2 = 2;    void readAndWrite() {        int i = v1;           //第一个volatile读        int j = v2;           // 第二个volatile读        a = i + j;            //普通写        v1 = i + 1;          // 第一个volatile写        v2 = j * 2;          //第二个 volatile写    }    …                    //其他方法}</pre><p>针对readAndWrite()方法，编译器在生成字节码时可以做如下的优化：</p><p><img src="https://res.infoq.com/articles/java-memory-model-4/zh/resources/6.png" alt=""></p><p>注意，最后的StoreLoad屏障不能省略。因为第二个volatile写之后，方法立即return。此时编译器可能无法准确断定后面是否会有volatile读或写，为了安全起见，编译器常常会在这里插入一个StoreLoad屏障。</p><p>上面的优化是针对任意处理器平台，由于不同的处理器有不同“松紧度”的处理器内存模型，内存屏障的插入还可以根据具体的处理器内存模型继续优化。以x86处理器为例，上图中除最后的StoreLoad屏障外，其它的屏障都会被省略。</p><p>前面保守策略下的volatile读和写，在 x86处理器平台可以优化成：</p><p><img src="https://res.infoq.com/articles/java-memory-model-4/zh/resources/7.png" alt=""></p><p>前文提到过，x86处理器仅会对写-读操作做重排序。X86不会对读-读，读-写和写-写操作做重排序，因此在x86处理器中会省略掉这三种操作类型对应的内存屏障。在x86中，JMM仅需在volatile写后面插入一个StoreLoad屏障即可正确实现volatile写-读的内存语义。这意味着在x86处理器中，volatile写的开销比volatile读的开销会大很多（因为执行StoreLoad屏障开销会比较大）。</p><h2 id="JSR-133为什么要增强volatile的内存语义"><a href="#JSR-133为什么要增强volatile的内存语义" class="headerlink" title="JSR-133为什么要增强volatile的内存语义"></a>JSR-133为什么要增强volatile的内存语义</h2><p>在JSR-133之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但旧的Java内存模型允许volatile变量与普通变量之间重排序。在旧的内存模型中，VolatileExample示例程序可能被重排序成下列时序来执行：</p><p><img src="https://res.infoq.com/articles/java-memory-model-4/zh/resources/8.png" alt=""></p><p>在旧的内存模型中，当1和2之间没有数据依赖关系时，1和2之间就可能被重排序（3和4类似）。其结果就是：读线程B执行4时，不一定能看到写线程A在执行1时对共享变量的修改。</p><p>因此在旧的内存模型中 ，volatile的写-读没有监视器的释放-获所具有的内存语义。为了提供一种比监视器锁更轻量级的线程之间通信的机制，JSR-133专家组决定增强volatile的内存语义：严格限制编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和监视器的释放-获取一样，具有相同的内存语义。从编译器重排序规则和处理器内存屏障插入策略来看，只要volatile变量与普通变量之间的重排序可能会破坏volatile的内存语意，这种重排序就会被编译器重排序规则和处理器内存屏障插入策略禁止。</p><p>由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而监视器锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。在功能上，监视器锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。如果读者想在程序中用volatile代替监视器锁，请一定谨慎。</p><h1 id="CAS操作详解"><a href="#CAS操作详解" class="headerlink" title="CAS操作详解"></a>CAS操作详解</h1><p>本文属于作者原创，原文发表于InfoQ：<a href="http://www.infoq.com/cn/articles/atomic-operation" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/atomic-operation</a></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>原子（atom）本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。在多处理器上实现原子操作就变得有点复杂。本文让我们一起来聊一聊在Inter处理器和Java里是如何实现原子操作的。</p><h2 id="术语定义"><a href="#术语定义" class="headerlink" title="术语定义"></a>术语定义</h2><table><thead><tr><th><strong>术语名称</strong></th><th><strong>英文</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>缓存行</td><td>Cache line</td><td>缓存的最小操作单位</td></tr><tr><td>比较并交换</td><td>Compare and Swap</td><td>CAS操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间先<strong>比较</strong>下在旧值有没有发生变化，如果没有发生变化，才<strong>交换</strong>成新值，发生了变化则不交换。</td></tr><tr><td>CPU流水线</td><td>CPU pipeline</td><td>CPU流水线的工作方式就象工业生产上的装配流水线，在CPU中由5~6个不同功能的电路单元组成一条指令处理流水线，然后将一条X86指令分成5~6步后再由这些电路单元分别执行，这样就能实现在一个CPU时钟周期完成一条指令，因此提高CPU的运算速度。</td></tr><tr><td>内存顺序冲突</td><td><strong>Memory order violation</strong></td><td>内存顺序冲突一般是由假共享引起，假共享是指多个CPU同时修改同一个缓存行的不同部分而引起其中一个CPU的操作无效，当出现这个内存顺序冲突时，CPU必须清空流水线。</td></tr></tbody></table><h2 id="处理器如何实现原子操作"><a href="#处理器如何实现原子操作" class="headerlink" title="处理器如何实现原子操作"></a>处理器如何实现原子操作</h2><p>32位IA-32处理器使用<strong>基于对缓存加锁或总线加锁</strong>的方式来实现多处理器之间的原子操作。</p><h3 id="处理器自动保证基本内存操作的原子性"><a href="#处理器自动保证基本内存操作的原子性" class="headerlink" title="处理器自动保证基本内存操作的原子性"></a>处理器自动保证基本内存操作的原子性</h3><p><strong>首先处理器会自动保证基本的内存操作的原子性</strong>。处理器保证从系统内存当中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。奔腾6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的，但是复杂的内存操作处理器不能自动保证其原子性，比如跨总线宽度，跨多个缓存行，跨页表的访问。但是处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p><h3 id="使用总线锁保证原子性"><a href="#使用总线锁保证原子性" class="headerlink" title="使用总线锁保证原子性"></a>使用总线锁保证原子性</h3><p><strong>第一个机制是通过总线锁保证原子性</strong>。如果多个处理器同时对共享变量进行读改写（i++就是经典的读改写操作）操作，那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的，操作完之后共享变量的值会和期望的不一致，举个例子：如果i=1,我们进行两次i++操作，我们期望的结果是3，但是有可能结果是2。如下图<br><a href="http://ifeve.com/atomic_operation/attachment/1/" target="_blank" rel="noopener"><img src="http://ifeve.com/wp-content/uploads/2012/12/1.png" alt="1"></a></p><p>（例1）</p><p>原因是有可能多个处理器同时从各自的缓存中读取变量i，分别进行加一操作，然后分别写入系统内存当中。那么想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。</p><p><strong>处理器使用总线锁就是来解决这个问题的</strong>。所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住,那么该处理器可以独占使用共享内存。</p><h3 id="使用缓存锁保证原子性"><a href="#使用缓存锁保证原子性" class="headerlink" title="使用缓存锁保证原子性"></a>使用缓存锁保证原子性</h3><p><strong>第二个机制是通过缓存锁定保证原子性</strong>。在同一时刻我们只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，最近的处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。</p><p>频繁使用的内存会缓存在处理器的L1，L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁，在奔腾6和最近的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。所谓“缓存锁定”就是如果缓存在处理器缓存行中内存区域在LOCK操作期间被锁定，当它执行锁操作回写内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时会起缓存行无效，在例1中，当CPU1修改缓存行中的i时使用缓存锁定，那么CPU2就不能同时缓存了i的缓存行。</p><p><strong>但是有两种情况下处理器不会使用缓存锁定</strong>。第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line），则处理器会调用总线锁定。第二种情况是：有些处理器不支持缓存锁定。对于Inter486和奔腾处理器,就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。</p><p>以上两个机制我们可以通过Inter处理器提供了很多LOCK前缀的指令来实现。比如位测试和修改指令BTS，BTR，BTC，交换指令XADD，CMPXCHG和其他一些操作数和逻辑指令，比如ADD（加），OR（或）等，被这些指令操作的内存区域就会加锁，导致其他处理器不能同时访问它。</p><h2 id="JAVA如何实现原子操作"><a href="#JAVA如何实现原子操作" class="headerlink" title="JAVA如何实现原子操作"></a>JAVA如何实现原子操作</h2><p>在java中可以通过<strong>锁</strong>和<strong>循环CAS</strong>的方式来实现原子操作。</p><h3 id="使用循环CAS实现原子操作"><a href="#使用循环CAS实现原子操作" class="headerlink" title="使用循环CAS实现原子操作"></a>使用循环CAS实现原子操作</h3><p>JVM中的CAS操作正是利用了上一节中提到的处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止，以下代码实现了一个基于CAS线程安全的计数器方法safeCount和一个非线程安全的计数器count。</p><pre><code>001        private AtomicInteger atomicI = newAtomicInteger(0);002  003        private int i = 0;004  005        public static void main(String[] args) {006  007               final Counter cas = new Counter();008  009               List&lt;Thread&gt; ts = new ArrayList&lt;Thread&gt;(600);010  011               long start = System.currentTimeMillis();012  013               for (int j = 0; j &lt; 100; j++) {014  015                      Thread t = new Thread(new Runnable() {016  017                             @Override018  019                             public void run() {020  021                                    for (int i = 0; i &lt; 10000; i++) {022  023                                           cas.count();024  025                                           cas.safeCount();026  027                                    }028  029                             }030  031                      });032  033                      ts.add(t);034  035               }036  037               for (Thread t : ts) {038  039                      t.start();040  041               }042  043        // 等待所有线程执行完成044  045               for (Thread t : ts) {046  047                      try {048  049                             t.join();050  051                      } catch (InterruptedException e) {052  053                             e.printStackTrace();054  055                      }056  057               }058  059               System.out.println(cas.i);060  061               System.out.println(cas.atomicI.get());062  063               System.out.println(System.currentTimeMillis() - start);064  065        }066  067        /**068  069         * 使用CAS实现线程安全计数器070  071         */072  073        private void safeCount() {074  075               for (;;) {076  077                      int i = atomicI.get();078  079                      boolean suc = atomicI.compareAndSet(i, ++i);080  081                      if (suc) {082  083                             break;084  085                      }086  087               }088  089        }090  091        /**092  093         * 非线程安全计数器094  095         */096  097        private void count() {098  099               i++;100  101        }102  103 }</code></pre><p>从Java1.5开始JDK的并发包里提供了一些类来支持原子操作，如<a href="http://www.cjsdn.net/doc/jdk60/java/util/concurrent/atomic/AtomicBoolean.html" target="_blank" rel="noopener"><strong>AtomicBoolean</strong></a>（用原子方式更新的 boolean 值），<a href="http://www.cjsdn.net/doc/jdk60/java/util/concurrent/atomic/AtomicInteger.html" target="_blank" rel="noopener"><strong>AtomicInteger</strong></a>（用原子方式更新的 int 值），<a href="http://www.cjsdn.net/doc/jdk60/java/util/concurrent/atomic/AtomicLong.html" target="_blank" rel="noopener"><strong>AtomicLong</strong></a>（用原子方式更新的 long 值），这些原子包装类还提供了有用的工具方法，比如以原子的方式将当前值自增1和自减1。</p><p>在Java并发包中有一些并发框架也使用了自旋CAS的方式来实现原子操作，比如LinkedTransferQueue类的Xfer方法。CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作。</p><ol><li><strong>ABA问题</strong>。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。</li></ol><p><strong>从Java1</strong>.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><pre><code>1   public boolean compareAndSet(2                  V      expectedReference,//预期引用3    4                  V      newReference,//更新后的引用5    6                 int    expectedStamp, //预期标志7    8                 int    newStamp //更新后的标志9   )</code></pre><ol><li><strong>循环时间长开销大</strong>。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</li><li><strong>只能保证一个共享变量的原子操作</strong>。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了<strong>AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</strong></li></ol><h3 id="使用锁机制实现原子操作"><a href="#使用锁机制实现原子操作" class="headerlink" title="使用锁机制实现原子操作"></a>使用锁机制实现原子操作</h3><p>锁机制保证了只有获得锁的线程能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁，轻量级锁和互斥锁，有意思的是除了偏向锁，JVM实现锁的方式都用到的循环CAS，当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。详细说明可以参见文章<a href="http://www.infoq.com/cn/articles/java-se-16-synchronized" target="_blank" rel="noopener">Java SE1.6中的Synchronized</a>。</p><h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5      参考资料"></a>5      参考资料</h2><ol><li><a href="http://www.infoq.com/cn/articles/java-se-16-synchronized" target="_blank" rel="noopener">Java SE1.6中的Synchronized</a></li><li><a href="http://www.intel.com/products/processor/manuals/" target="_blank" rel="noopener">Intel 64和IA-32架构软件开发人员手册</a></li><li><a href="http://www.infoq.com/cn/articles/ftf-java-volatile" target="_blank" rel="noopener">深入分析Volatile的实现原理</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java并发指南&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/21961.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21961.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java并发" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发原理" scheme="http://h2pl.github.io/tags/Java%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java并发指南2：深入理解Java内存模型JMM</title>
    <link href="http://h2pl.github.io/2018/05/17/concurrent2/"/>
    <id>http://h2pl.github.io/2018/05/17/concurrent2/</id>
    <published>2018-05-17T15:05:29.000Z</published>
    <updated>2018-06-11T13:43:19.839Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java并发指南<br><a href="https://blog.csdn.net/column/details/21961.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21961.html</a></p><p>相关代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><h1 id="JMM基础与happens-before"><a href="#JMM基础与happens-before" class="headerlink" title="JMM基础与happens-before"></a>JMM基础与happens-before</h1><h2 id="并发编程模型的分类"><a href="#并发编程模型的分类" class="headerlink" title="并发编程模型的分类"></a>并发编程模型的分类</h2><p>在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。</p><p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</p><p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p><p>Java内存模型的抽象</p><p>Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p><p>在java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量（Local variables），方法定义参数（java语言规范称之为formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p><p>Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下：</p><p><img src="https://res.infoq.com/articles/java-memory-model-1/zh/resources/11.png" alt=""></p><p>从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：</p><ol><li>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。</li><li>然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</li></ol><p>下面通过示意图来说明这两个步骤：</p><p><img src="https://res.infoq.com/articles/java-memory-model-1/zh/resources/22.png" alt=""></p><p>如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。</p><p>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。</p><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p><ol><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ol><p>从java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p><p><img src="https://res.infoq.com/articles/java-memory-model-1/zh/resources/33.png" alt=""></p><p>上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel称之为memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p><p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><h2 id="处理器重排序与内存屏障指令"><a href="#处理器重排序与内存屏障指令" class="headerlink" title="处理器重排序与内存屏障指令"></a>处理器重排序与内存屏障指令</h2><p>现代的处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！为了具体说明，请看下面示例：</p><table><thead><tr><th>Processor A</th><th>Processor B</th></tr></thead><tbody><tr><td>a = 1; //A1x = b; //A2</td><td>b = 2; //B1y = a; //B2</td></tr><tr><td>初始状态：a = b = 0处理器允许执行后得到结果：x = y = 0</td></tr></tbody></table><p>假设处理器A和处理器B按程序的顺序并行执行内存访问，最终却可能得到x = y = 0的结果。具体的原因如下图所示：</p><p><img src="https://res.infoq.com/articles/java-memory-model-1/zh/resources/44.png" alt=""></p><p>这里处理器A和处理器B可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到x = y = 0的结果。</p><p>从内存操作实际发生的顺序来看，直到处理器A执行A3来刷新自己的写缓存区，写操作A1才算真正执行了。虽然处理器A执行内存操作的顺序为：A1-&gt;A2，但内存操作实际发生的顺序却是：A2-&gt;A1。此时，处理器A的内存操作顺序被重排序了（处理器B的情况和处理器A一样，这里就不赘述了）。</p><p>这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写-读操做重排序。</p><p>下面是常见处理器允许的重排序类型的列表：</p><table><thead><tr><th></th><th>Load-Load</th><th>Load-Store</th><th>Store-Store</th><th>Store-Load</th><th>数据依赖</th></tr></thead><tbody><tr><td>sparc-TSO</td><td>N</td><td>N</td><td>N</td><td>Y</td><td>N</td></tr><tr><td>x86</td><td>N</td><td>N</td><td>N</td><td>Y</td><td>N</td></tr><tr><td>ia64</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>PowerPC</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr></tbody></table><p>上表单元格中的“N”表示处理器不允许两个操作重排序，“Y”表示允许重排序。</p><p>从上表我们可以看出：常见的处理器都允许Store-Load重排序；常见的处理器都不允许对存在数据依赖的操作做重排序。sparc-TSO和x86拥有相对较强的处理器内存模型，它们仅允许对写-读操作做重排序（因为它们都使用了写缓冲区）。</p><p>※注1：sparc-TSO是指以TSO(Total Store Order)内存模型运行时，sparc处理器的特性。</p><p>※注2：上表中的x86包括x64及AMD64。</p><p>※注3：由于ARM处理器的内存模型与PowerPC处理器的内存模型非常类似，本文将忽略它。</p><p>※注4：数据依赖性后文会专门说明。</p><p>为了保证内存可见性，java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为下列四类：</p><table><thead><tr><th>屏障类型</th><th>指令示例</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoad Barriers</td><td>Load1; LoadLoad; Load2</td><td>确保Load1数据的装载，之前于Load2及所有后续装载指令的装载。</td></tr><tr><td>StoreStore Barriers</td><td>Store1; StoreStore; Store2</td><td>确保Store1数据对其他处理器可见（刷新到内存），之前于Store2及所有后续存储指令的存储。</td></tr><tr><td>LoadStore Barriers</td><td>Load1; LoadStore; Store2</td><td>确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存。</td></tr><tr><td>StoreLoad Barriers</td><td>Store1; StoreLoad; Load2</td><td>确保Store1数据对其他处理器变得可见（指刷新到内存），之前于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</td></tr></tbody></table><p>StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>从JDK5开始，java使用新的JSR -133内存模型（本文除非特别说明，针对的都是JSR- 133内存模型）。JSR-133提出了happens-before的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。 与程序员密切相关的happens-before规则如下：</p><ul><li>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</li><li>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</li><li>volatile变量规则：对一个volatile域的写，happens- before 于任意后续对这个volatile域的读。</li><li>传递性：如果A happens- before B，且B happens- before C，那么A happens- before C。</li></ul><p>注意，两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。happens- before的定义很微妙，后文会具体说明happens-before为什么要这么定义。</p><p>happens-before与JMM的关系如下图所示：</p><p><img src="https://res.infoq.com/articles/java-memory-model-1/zh/resources/55.png" alt=""></p><p>如上图所示，一个happens-before规则通常对应于多个编译器重排序规则和处理器重排序规则。对于java程序员来说，happens-before规则简单易懂，它避免程序员为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。</p><h1 id="二：重排序与JMM的as-if-serial"><a href="#二：重排序与JMM的as-if-serial" class="headerlink" title="二：重排序与JMM的as-if-serial"></a>二：重排序与JMM的as-if-serial</h1><h2 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h2><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型：</p><table><thead><tr><th>名称</th><th>代码示例</th><th>说明</th></tr></thead><tbody><tr><td>写后读</td><td>a = 1;b = a;</td><td>写一个变量之后，再读这个位置。</td></tr><tr><td>写后写</td><td>a = 1;a = 2;</td><td>写一个变量之后，再写这个变量。</td></tr><tr><td>读后写</td><td>a = b;b = 1;</td><td>读一个变量之后，再写这个变量。</td></tr></tbody></table><p>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p><p>注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p><h2 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h2><p>as-if-serial语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守as-if-serial语义。</p><p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例：</p><pre>double pi  = 3.14;    //Adouble r   = 1.0;     //Bdouble area = pi * r * r; //C</pre><p>上面三个操作的数据依赖关系如下图所示：</p><p><img src="https://res.infoq.com/articles/java-memory-model-2/zh/resources/11.png" alt=""></p><p>如上图所示，A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面（C排到A和B的前面，程序的结果将会被改变）。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。下图是该程序的两种执行顺序：</p><p><img src="https://res.infoq.com/articles/java-memory-model-2/zh/resources/22.png" alt=""></p><p>as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p><h2 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h2><p>根据happens- before的程序顺序规则，上面计算圆的面积的示例代码存在三个happens- before关系：</p><ol><li>A happens- before B；</li><li>B happens- before C；</li><li>A happens- before C；</li></ol><p>这里的第3个happens- before关系，是根据happens- before的传递性推导出来的。</p><p>这里A happens- before B，但实际执行时B却可以排在A之前执行（看上面的重排序后的执行顺序）。在第一章提到过，如果A happens- before B，JMM并不要求A一定要在B之前执行。JMM仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。这里操作A的执行结果不需要对操作B可见；而且重排序操作A和操作B后的执行结果，与操作A和操作B按happens- before顺序执行的结果一致。在这种情况下，JMM会认为这种重排序并不非法（not illegal），JMM允许这种重排序。</p><p>在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器遵从这一目标，从happens- before的定义我们可以看出，JMM同样遵从这一目标。</p><h2 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h2><p>现在让我们来看看，重排序是否会改变多线程程序的执行结果。请看下面的示例代码：</p><pre>class ReorderExample {int a = 0;boolean flag = false;public void writer() {    a = 1;                   //1    flag = true;             //2}Public void reader() {    if (flag) {                //3        int i =  a * a;        //4        ……    }}}</pre><p>flag变量是个标记，用来标识变量a是否已被写入。这里假设有两个线程A和B，A首先执行writer()方法，随后B线程接着执行reader()方法。线程B在执行操作4时，能否看到线程A在操作1对共享变量a的写入？</p><p>答案是：不一定能看到。</p><p>由于操作1和操作2没有数据依赖关系，编译器和处理器可以对这两个操作重排序；同样，操作3和操作4没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。让我们先来看看，当操作1和操作2重排序时，可能会产生什么效果？请看下面的程序执行时序图：</p><p><img src="https://res.infoq.com/articles/java-memory-model-2/zh/resources/33.png" alt=""></p><p>如上图所示，操作1和操作2做了重排序。程序执行时，线程A首先写标记变量flag，随后线程B读这个变量。由于条件判断为真，线程B将读取变量a。此时，变量a还根本没有被线程A写入，在这里多线程程序的语义被重排序破坏了！</p><p>※注：本文统一用红色的虚箭线表示错误的读操作，用绿色的虚箭线表示正确的读操作。</p><p>下面再让我们看看，当操作3和操作4重排序时会产生什么效果（借助这个重排序，可以顺便说明控制依赖性）。下面是操作3和操作4重排序后，程序的执行时序图：</p><p><img src="https://res.infoq.com/articles/java-memory-model-2/zh/resources/44.png" alt=""></p><p>在程序中，操作3和操作4存在控制依赖关系。当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程B的处理器可以提前读取并计算a*a，然后把计算结果临时保存到一个名为重排序缓冲（reorder buffer ROB）的硬件缓存中。当接下来操作3的条件判断为真时，就把该计算结果写入变量i中。</p><p>从图中我们可以看出，猜测执行实质上对操作3和4做了重排序。重排序在这里破坏了多线程程序的语义！</p><p>在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p><h1 id="三：顺序一致性内存模型与JMM"><a href="#三：顺序一致性内存模型与JMM" class="headerlink" title="三：顺序一致性内存模型与JMM"></a>三：顺序一致性内存模型与JMM</h1><h2 id="数据竞争与顺序一致性保证"><a href="#数据竞争与顺序一致性保证" class="headerlink" title="数据竞争与顺序一致性保证"></a>数据竞争与顺序一致性保证</h2><p>当程序未正确同步时，就会存在数据竞争。java内存模型规范对数据竞争的定义如下：</p><ul><li>在一个线程中写一个变量，</li><li>在另一个线程读同一个变量，</li><li>而且写和读没有通过同步来排序。</li></ul><p>当代码中包含数据竞争时，程序的执行往往产生违反直觉的结果（前一章的示例正是如此）。如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序。</p><p>JMM对正确同步的多线程程序的内存一致性做了如下保证：</p><ul><li>如果程序是正确同步的，程序的执行将具有顺序一致性（sequentially consistent）–即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同（马上我们将会看到，这对于程序员来说是一个极强的保证）。这里的同步是指广义上的同步，包括对常用同步原语（lock，volatile和final）的正确使用。</li></ul><h2 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h2><p>顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：</p><ul><li>一个线程中的所有操作必须按照程序的顺序来执行。</li><li>（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li></ul><p>顺序一致性内存模型为程序员提供的视图如下：</p><p><img src="https://res.infoq.com/articles/java-memory-model-3/zh/resources/1.png" alt=""></p><p>在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程。同时，每一个线程必须按程序的顺序来执行内存读/写操作。从上图我们可以看出，在任意时间点最多只能有一个线程可以连接到内存。当多个线程并发执行时，图中的开关装置能把所有线程的所有内存读/写操作串行化。</p><p>为了更好的理解，下面我们通过两个示意图来对顺序一致性模型的特性做进一步的说明。</p><p>假设有两个线程A和B并发执行。其中A线程有三个操作，它们在程序中的顺序是：A1-&gt;A2-&gt;A3。B线程也有三个操作，它们在程序中的顺序是：B1-&gt;B2-&gt;B3。</p><p>假设这两个线程使用监视器来正确同步：A线程的三个操作执行后释放监视器，随后B线程获取同一个监视器。那么程序在顺序一致性模型中的执行效果将如下图所示：</p><p><img src="https://res.infoq.com/articles/java-memory-model-3/zh/resources/2.png" alt=""></p><p>现在我们再假设这两个线程没有做同步，下面是这个未同步程序在顺序一致性模型中的执行示意图：</p><p><img src="https://res.infoq.com/articles/java-memory-model-3/zh/resources/3.png" alt=""></p><p>未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序。以上图为例，线程A和B看到的执行顺序都是：B1-&gt;A1-&gt;A2-&gt;B2-&gt;A3-&gt;B3。之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见。</p><p>但是，在JMM中就没有这个保证。未同步程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。比如，在当前线程把写过的数据缓存在本地内存中，且还没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，会认为这个写操作根本还没有被当前线程执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才能对其他线程可见。在这种情况下，当前线程和其它线程看到的操作执行顺序将不一致。</p><h2 id="同步程序的顺序一致性效果"><a href="#同步程序的顺序一致性效果" class="headerlink" title="同步程序的顺序一致性效果"></a>同步程序的顺序一致性效果</h2><p>下面我们对前面的示例程序ReorderExample用监视器来同步，看看正确同步的程序如何具有顺序一致性。</p><p>请看下面的示例代码：</p><pre>class SynchronizedExample {int a = 0;boolean flag = false;public synchronized void writer() {    a = 1;    flag = true;}public synchronized void reader() {    if (flag) {        int i = a;        ……    }}}</pre><p>上面示例代码中，假设A线程执行writer()方法后，B线程执行reader()方法。这是一个正确同步的多线程程序。根据JMM规范，该程序的执行结果将与该程序在顺序一致性模型中的执行结果相同。下面是该程序在两个内存模型中的执行时序对比图：</p><p><img src="https://res.infoq.com/articles/java-memory-model-3/zh/resources/4.png" alt=""></p><p>在顺序一致性模型中，所有操作完全按程序的顺序串行执行。而在JMM中，临界区内的代码可以重排序（但JMM不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。JMM会在退出监视器和进入监视器这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图（具体细节后文会说明）。虽然线程A在临界区内做了重排序，但由于监视器的互斥执行的特性，这里的线程B根本无法“观察”到线程A在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</p><p>从这里我们可以看到JMM在具体实现上的基本方针：在不改变（正确同步的）程序执行结果的前提下，尽可能的为编译器和处理器的优化打开方便之门。</p><h2 id="未同步程序的执行特性"><a href="#未同步程序的执行特性" class="headerlink" title="未同步程序的执行特性"></a>未同步程序的执行特性</h2><p>对于未同步或未正确同步的多线程程序，JMM只提供最小安全性：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false），JMM保证线程读操作读取到的值不会无中生有（out of thin air）的冒出来。为了实现最小安全性，JVM在堆上分配对象时，首先会清零内存空间，然后才会在上面分配对象（JVM内部会同步这两个操作）。因此，在以清零的内存空间（pre-zeroed memory）分配对象时，域的默认初始化已经完成了。</p><p>JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。因为未同步程序在顺序一致性模型中执行时，整体上是无序的，其执行结果无法预知。保证未同步程序在两个模型中的执行结果一致毫无意义。</p><p>和顺序一致性模型一样，未同步程序在JMM中的执行时，整体上也是无序的，其执行结果也无法预知。同时，未同步程序在这两个模型中的执行特性有下面几个差异：</p><ol><li>顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）。这一点前面已经讲过了，这里就不再赘述。</li><li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。这一点前面也已经讲过，这里就不再赘述。</li><li>JMM不保证对64位的long型和double型变量的读/写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。</li></ol><p>第3个差异与处理器总线的工作机制密切相关。在计算机中，数据通过总线在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步骤称之为总线事务（bus transaction）。总线事务包括读事务（read transaction）和写事务（write transaction）。读事务从内存传送数据到处理器，写事务从处理器传送数据到内存，每个事务会读/写内存中一个或多个物理上连续的字。这里的关键是，总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，总线会禁止其它所有的处理器和I/O设备执行内存的读/写。下面让我们通过一个示意图来说明总线的工作机制：</p><p><img src="https://res.infoq.com/articles/java-memory-model-3/zh/resources/5.png" alt=""></p><p>如上图所示，假设处理器A，B和C同时向总线发起总线事务，这时总线仲裁（bus arbitration）会对竞争作出裁决，这里我们假设总线在仲裁后判定处理器A在竞争中获胜（总线仲裁会确保所有处理器都能公平的访问内存）。此时处理器A继续它的总线事务，而其它两个处理器则要等待处理器A的总线事务完成后才能开始再次执行内存访问。假设在处理器A执行总线事务期间（不管这个总线事务是读事务还是写事务），处理器D向总线发起了总线事务，此时处理器D的这个请求会被总线禁止。</p><p>总线的这些工作机制可以把所有处理器对内存的访问以串行化的方式来执行；在任意时间点，最多只能有一个处理器能访问内存。这个特性确保了单个总线事务之中的内存读/写操作具有原子性。</p><p>在一些32位的处理器上，如果要求对64位数据的读/写操作具有原子性，会有比较大的开销。为了照顾这种处理器，java语言规范鼓励但不强求JVM对64位的long型变量和double型变量的读/写具有原子性。当JVM在这种处理器上运行时，会把一个64位long/ double型变量的读/写操作拆分为两个32位的读/写操作来执行。这两个32位的读/写操作可能会被分配到不同的总线事务中执行，此时对这个64位变量的读/写将不具有原子性。</p><p>当单个内存操作不具有原子性，将可能会产生意想不到后果。请看下面示意图：</p><p><img src="https://res.infoq.com/articles/java-memory-model-3/zh/resources/6.png" alt=""></p><p>如上图所示，假设处理器A写一个long型变量，同时处理器B要读这个long型变量。处理器A中64位的写操作被拆分为两个32位的写操作，且这两个32位的写操作被分配到不同的写事务中执行。同时处理器B中64位的读操作被拆分为两个32位的读操作，且这两个32位的读操作被分配到同一个的读事务中执行。当处理器A和B按上图的时序来执行时，处理器B将看到仅仅被处理器A“写了一半“的无效值。</p><p><em>转载自</em><a href="http://ifeve.com/" target="_blank" rel="noopener">并发编程网 – ifeve.com</a><em>本文链接地址:</em><a href="http://ifeve.com/java-memory-model-1/" target="_blank" rel="noopener">深入理解Java内存模型（一）——基础</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java并发指南&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/21961.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21961.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java并发" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发原理" scheme="http://h2pl.github.io/tags/Java%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java并发指南1：并发基础与Java多线程</title>
    <link href="http://h2pl.github.io/2018/05/16/concurrent1/"/>
    <id>http://h2pl.github.io/2018/05/16/concurrent1/</id>
    <published>2018-05-16T15:05:11.000Z</published>
    <updated>2018-05-24T08:22:54.540Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>欢迎阅览我的CSDN专栏：Java并发指南<br><a href="https://blog.csdn.net/column/details/21961.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21961.html</a></p><p>相关代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><a id="more"></a><h1 id="什么是并发"><a href="#什么是并发" class="headerlink" title="什么是并发"></a>什么是并发</h1><p>在过去单CPU时代，单任务在一个时间点只能执行单一程序。之后发展到多任务阶段，计算机能在同一时间点并行执行多任务或多进程。虽然并不是真正意义上的“同一时间点”，而是多个任务或进程共享一个CPU，并交由操作系统来完成多任务间对CPU的运行切换，以使得每个任务都有机会获得一定的时间片运行。</p><p>随着多任务对软件开发者带来的新挑战，程序不在能假设独占所有的CPU时间、所有的内存和其他计算机资源。一个好的程序榜样是在其不再使用这些资源时对其进行释放，以使得其他程序能有机会使用这些资源。</p><p>再后来发展到多线程技术，使得在一个程序内部能拥有多个线程并行执行。一个线程的执行可以被认为是一个CPU在执行该程序。当一个程序运行在多线程下，就好像有多个CPU在同时执行该程序。</p><p>多线程比多任务更加有挑战。多线程是在同一个程序内部并行执行，因此会对相同的内存空间进行并发读写操作。这可能是在单线程程序中从来不会遇到的问题。其中的一些错误也未必会在单CPU机器上出现，因为两个线程从来不会得到真正的并行执行。然而，更现代的计算机伴随着多核CPU的出现，也就意味着不同的线程能被不同的CPU核得到真正意义的并行执行。</p><p>如果一个线程在读一个内存时，另一个线程正向该内存进行写操作，那进行读操作的那个线程将获得什么结果呢？是写操作之前旧的值？还是写操作成功之后的新值？或是一半新一半旧的值？或者，如果是两个线程同时写同一个内存，在操作完成后将会是什么结果呢？是第一个线程写入的值？还是第二个线程写入的值？还是两个线程写入的一个混合值？因此如没有合适的预防措施，任何结果都是可能的。而且这种行为的发生甚至不能预测，所以结果也是不确定性的。</p><h2 id="Java的多线程和并发性"><a href="#Java的多线程和并发性" class="headerlink" title="Java的多线程和并发性"></a>Java的多线程和并发性</h2><p>Java是最先支持多线程的开发的语言之一，Java从一开始就支持了多线程能力，因此Java开发者能常遇到上面描述的问题场景。这也是我想为Java并发技术而写这篇系列的原因。作为对自己的笔记，和对其他Java开发的追随者都可获益的。</p><p>该系列主要关注Java多线程，但有些在多线程中出现的问题会和多任务以及分布式系统中出现的存在类似，因此该系列会将多任务和分布式系统方面作为参考，所以叫法上称为“并发性”，而不是“多线程”。</p><h1 id="多线程的优点"><a href="#多线程的优点" class="headerlink" title="多线程的优点"></a>多线程的优点</h1><p>尽管面临很多挑战，多线程有一些优点使得它一直被使用。这些优点是：</p><ul><li>资源利用率更好</li><li>程序设计在某些情况下更简单</li><li>程序响应更快</li></ul><h2 id="资源利用率更好"><a href="#资源利用率更好" class="headerlink" title="资源利用率更好"></a>资源利用率更好</h2><p>想象一下，一个应用程序需要从本地文件系统中读取和处理文件的情景。比方说，从磁盘读取一个文件需要5秒，处理一个文件需要2秒。处理两个文件则需要：</p><table><thead><tr><th><code>1</code></th><th><code>5`</code>秒读取文件A`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>2</code></th><th><code>2`</code>秒处理文件A`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>3</code></th><th><code>5`</code>秒读取文件B`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>4</code></th><th><code>2`</code>秒处理文件B`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>5</code></th><th><code>---------------------</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>6</code></th><th><code>总共需要`</code>14<code></code>秒`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>从磁盘中读取文件的时候，大部分的CPU时间用于等待磁盘去读取数据。在这段时间里，CPU非常的空闲。它可以做一些别的事情。通过改变操作的顺序，就能够更好的使用CPU资源。看下面的顺序：</p><table><thead><tr><th><code>1</code></th><th><code>5`</code>秒读取文件A`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>2</code></th><th><code>5`</code>秒读取文件B + <code>2</code>秒处理文件A`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>3</code></th><th><code>2`</code>秒处理文件B`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>4</code></th><th><code>---------------------</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>5</code></th><th><code>总共需要`</code>12<code></code>秒`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>CPU等待第一个文件被读取完。然后开始读取第二个文件。当第二文件在被读取的时候，CPU会去处理第一个文件。记住，在等待磁盘读取文件的时候，CPU大部分时间是空闲的。</p><p>总的说来，CPU能够在等待IO的时候做一些其他的事情。这个不一定就是磁盘IO。它也可以是网络的IO，或者用户输入。通常情况下，网络和磁盘的IO比CPU和内存的IO慢的多。</p><h2 id="程序设计更简单"><a href="#程序设计更简单" class="headerlink" title="程序设计更简单"></a>程序设计更简单</h2><p>在单线程应用程序中，如果你想编写程序手动处理上面所提到的读取和处理的顺序，你必须记录每个文件读取和处理的状态。相反，你可以启动两个线程，每个线程处理一个文件的读取和操作。线程会在等待磁盘读取文件的过程中被阻塞。在等待的时候，其他的线程能够使用CPU去处理已经读取完的文件。其结果就是，磁盘总是在繁忙地读取不同的文件到内存中。这会带来磁盘和CPU利用率的提升。而且每个线程只需要记录一个文件，因此这种方式也很容易编程实现。</p><h2 id="程序响应更快"><a href="#程序响应更快" class="headerlink" title="程序响应更快"></a>程序响应更快</h2><p>将一个单线程应用程序变成多线程应用程序的另一个常见的目的是实现一个响应更快的应用程序。设想一个服务器应用，它在某一个端口监听进来的请求。当一个请求到来时，它去处理这个请求，然后再返回去监听。</p><p>服务器的流程如下所述：</p><table><thead><tr><th><code>1</code></th><th><code>while`</code>(server is active){`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>2</code></th><th><code>listen `</code>for<code></code>request`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>3</code></th><th><code>process request</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>4</code></th><th><code>}</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>如果一个请求需要占用大量的时间来处理，在这段时间内新的客户端就无法发送请求给服务端。只有服务器在监听的时候，请求才能被接收。另一种设计是，监听线程把请求传递给工作者线程(worker thread)，然后立刻返回去监听。而工作者线程则能够处理这个请求并发送一个回复给客户端。这种设计如下所述：</p><table><thead><tr><th><code>1</code></th><th><code>while`</code>(server is active){`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>2</code></th><th><code>listen `</code>for<code></code>request`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>3</code></th><th><code>hand request to worker thread</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>4</code></th><th><code>}</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>这种方式，服务端线程迅速地返回去监听。因此，更多的客户端能够发送请求给服务端。这个服务也变得响应更快。</p><p>桌面应用也是同样如此。如果你点击一个按钮开始运行一个耗时的任务，这个线程既要执行任务又要更新窗口和按钮，那么在任务执行的过程中，这个应用程序看起来好像没有反应一样。相反，任务可以传递给工作者线程（word thread)。当工作者线程在繁忙地处理任务的时候，窗口线程可以自由地响应其他用户的请求。当工作者线程完成任务的时候，它发送信号给窗口线程。窗口线程便可以更新应用程序窗口，并显示任务的结果。对用户而言，这种具有工作者线程设计的程序显得响应速度更快。</p><h1 id="多线程的代价"><a href="#多线程的代价" class="headerlink" title="多线程的代价"></a>多线程的代价</h1><p>从一个单线程的应用到一个多线程的应用并不仅仅带来好处，它也会有一些代价。不要仅仅为了使用多线程而使用多线程。而应该明确在使用多线程时能多来的好处比所付出的代价大的时候，才使用多线程。如果存在疑问，应该尝试测量一下应用程序的性能和响应能力，而不只是猜测。</p><h2 id="设计更复杂"><a href="#设计更复杂" class="headerlink" title="设计更复杂"></a>设计更复杂</h2><p>虽然有一些多线程应用程序比单线程的应用程序要简单，但其他的一般都更复杂。在多线程访问共享数据的时候，这部分代码需要特别的注意。线程之间的交互往往非常复杂。不正确的线程同步产生的错误非常难以被发现，并且重现以修复。</p><h2 id="上下文切换的开销"><a href="#上下文切换的开销" class="headerlink" title="上下文切换的开销"></a>上下文切换的开销</h2><p>当CPU从执行一个线程切换到执行另外一个线程的时候，它需要先存储当前线程的本地的数据，程序指针等，然后载入另一个线程的本地数据，程序指针等，最后才开始执行。这种切换称为“上下文切换”(“context switch”)。CPU会在一个上下文中执行一个线程，然后切换到另外一个上下文中执行另外一个线程。</p><p>上下文切换并不廉价。如果没有必要，应该减少上下文切换的发生。</p><p>你可以通过维基百科阅读更多的关于上下文切换相关的内容：</p><p><a href="http://en.wikipedia.org/wiki/Context_switch" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Context_switch</a></p><h2 id="增加资源消耗"><a href="#增加资源消耗" class="headerlink" title="增加资源消耗"></a>增加资源消耗</h2><p>线程在运行的时候需要从计算机里面得到一些资源。除了CPU，线程还需要一些内存来维持它本地的堆栈。它也需要占用操作系统中一些资源来管理线程。我们可以尝试编写一个程序，让它创建100个线程，这些线程什么事情都不做，只是在等待，然后看看这个程序在运行的时候占用了多少内存。</p><h2 id="竞态条件与临界区"><a href="#竞态条件与临界区" class="headerlink" title="竞态条件与临界区"></a>竞态条件与临界区</h2><p>在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。如，同一内存区（变量，数组，或对象）、系统（数据库，web services等）或文件。实际上，这些问题只有在一或多个线程向这些资源做了写操作时才有可能发生，只要资源没有发生变化,多个线程读取相同的资源就是安全的。</p><p>多线程同时执行下面的代码可能会出错：</p><table><thead><tr><th><code>1</code></th><th><code>public</code> <code>class</code> <code>Counter {</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>2</code></th><th><code>protected</code> <code>long</code> <code>count = `</code>0<code></code>;`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>3</code></th><th><code>public</code> <code>void</code> <code>add(`</code>long<code></code>value){`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>4</code></th><th><code>this`</code>.count = <code>this</code>.count + value;  `</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>5</code></th><th><code>}</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>6</code></th><th><code>}</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>想象下线程A和B同时执行同一个Counter对象的add()方法，我们无法知道操作系统何时会在两个线程之间切换。JVM并不是将这段代码视为单条指令来执行的，而是按照下面的顺序：</p><pre>从内存获取 this.count 的值放到寄存器将寄存器中的值增加value将寄存器中的值写回内存</pre><p>观察线程A和B交错执行会发生什么：</p><pre>    this.count = 0;   A:    读取 this.count 到一个寄存器 (0)   B:    读取 this.count 到一个寄存器 (0)   B:     将寄存器的值加2   B:    回写寄存器值(2)到内存. this.count 现在等于 2   A:    将寄存器的值加3   A:    回写寄存器值(3)到内存. this.count 现在等于 3</pre><p>两个线程分别加了2和3到count变量上，两个线程执行结束后count变量的值应该等于5。然而由于两个线程是交叉执行的，两个线程从内存中读出的初始值都是0。然后各自加了2和3，并分别写回内存。最终的值并不是期望的5，而是最后写回内存的那个线程的值，上面例子中最后写回内存的是线程A，但实际中也可能是线程B。如果没有采用合适的同步机制，线程间的交叉执行情况就无法预料。</p><h2 id="竞态条件-amp-临界区"><a href="#竞态条件-amp-临界区" class="headerlink" title="竞态条件&amp;临界区"></a>竞态条件&amp;临界区</h2><p>当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。上例中add()方法就是一个临界区,它会产生竞态条件。在临界区中使用适当的同步就可以避免竞态条件。</p><h1 id="线程安全与共享资源"><a href="#线程安全与共享资源" class="headerlink" title="线程安全与共享资源"></a>线程安全与共享资源</h1><p>允许被多个线程同时执行的代码称作线程安全的代码。线程安全的代码不包含竞态条件。当多个线程同时更新共享资源时会引发竞态条件。因此，了解Java线程执行时共享了什么资源很重要。</p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>局部变量存储在线程自己的栈中。也就是说，局部变量永远也不会被多个线程共享。所以，基础类型的局部变量是线程安全的。下面是基础类型的局部变量的一个例子：</p><table><thead><tr><th><code>1</code></th><th><code>public</code> <code>void</code> <code>someMethod(){</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>2</code></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>3</code></th><th><code>long</code> <code>threadSafeInt = `</code>0<code></code>;`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>4</code></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>5</code></th><th><code>threadSafeInt++;</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>6</code></th><th><code>}</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><h2 id="局部的对象引用"><a href="#局部的对象引用" class="headerlink" title="局部的对象引用"></a>局部的对象引用</h2><p>对象的局部引用和基础类型的局部变量不太一样。尽管引用本身没有被共享，但引用所指的对象并没有存储在线程的栈内。所有的对象都存在共享堆中。如果在某个方法中创建的对象不会逃逸出（<em>译者注：即该对象不会被其它方法获得，也不会被非局部变量引用到</em>）该方法，那么它就是线程安全的。实际上，哪怕将这个对象作为参数传给其它方法，只要别的线程获取不到这个对象，那它仍是线程安全的。下面是一个线程安全的局部引用样例：</p><table><thead><tr><th><code>01</code></th><th><code>public</code> <code>void</code> <code>someMethod(){</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>02</code></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>03</code></th><th><code>LocalObject localObject = `</code>new<code></code>LocalObject();`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>04</code></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>05</code></th><th><code>localObject.callMethod();</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>06</code></th><th><code>method2(localObject);</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>07</code></th><th><code>}</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>08</code></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>09</code></th><th><code>public</code> <code>void</code> <code>method2(LocalObject localObject){</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>10</code></th><th><code>localObject.setValue(`</code>“value”<code></code>);`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>11</code></th><th><code>}</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>样例中LocalObject对象没有被方法返回，也没有被传递给someMethod()方法外的对象。每个执行someMethod()的线程都会创建自己的LocalObject对象，并赋值给localObject引用。因此，这里的LocalObject是线程安全的。事实上，整个someMethod()都是线程安全的。即使将LocalObject作为参数传给同一个类的其它方法或其它类的方法时，它仍然是线程安全的。当然，如果LocalObject通过某些方法被传给了别的线程，那它就不再是线程安全的了。</p><h2 id="对象成员"><a href="#对象成员" class="headerlink" title="对象成员"></a>对象成员</h2><p>对象成员存储在堆上。如果两个线程同时更新同一个对象的同一个成员，那这个代码就不是线程安全的。下面是一个样例：</p><table><thead><tr><th><code>1</code></th><th><code>public</code> <code>class</code> <code>NotThreadSafe{</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>2</code></th><th><code>StringBuilder builder = `</code>new<code></code>StringBuilder();`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>3</code></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>4</code></th><th><code>public</code> <code>add(String text){</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>5</code></th><th><code>this`</code>.builder.append(text);`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>6</code></th><th><code>}</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>7</code></th><th><code>}</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>如果两个线程同时调用同一个<code>NotThreadSafe</code>实例上的add()方法，就会有竞态条件问题。例如：</p><table><thead><tr><th><code>01</code></th><th><code>NotThreadSafe sharedInstance = `</code>new<code></code>NotThreadSafe();`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>02</code></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>03</code></th><th><code>new</code> <code>Thread(`</code>new<code></code>MyRunnable(sharedInstance)).start();`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>04</code></th><th><code>new</code> <code>Thread(`</code>new<code></code>MyRunnable(sharedInstance)).start();`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>05</code></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>06</code></th><th><code>public</code> <code>class</code> <code>MyRunnable `</code>implements<code></code>Runnable{`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>07</code></th><th><code>NotThreadSafe instance = `</code>null<code></code>;`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>08</code></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>09</code></th><th><code>public</code> <code>MyRunnable(NotThreadSafe instance){</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>10</code></th><th><code>this`</code>.instance = instance;`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>11</code></th><th><code>}</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>12</code></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>13</code></th><th><code>public</code> <code>void</code> <code>run(){</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>14</code></th><th><code>this`</code>.instance.add(<code>&quot;some text&quot;</code>);`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>15</code></th><th><code>}</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>16</code></th><th><code>}</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>注意两个MyRunnable共享了同一个NotThreadSafe对象。因此，当它们调用add()方法时会造成竞态条件。</p><p>当然，如果这两个线程在不同的NotThreadSafe实例上调用call()方法，就不会导致竞态条件。下面是稍微修改后的例子：</p><table><thead><tr><th><code>1</code></th><th><code>new</code> <code>Thread(`</code>new<code></code>MyRunnable(<code></code>new<code></code>NotThreadSafe())).start();`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>2</code></th><th><code>new</code> <code>Thread(`</code>new<code></code>MyRunnable(<code></code>new<code></code>NotThreadSafe())).start();`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>现在两个线程都有自己单独的NotThreadSafe对象，调用add()方法时就会互不干扰，再也不会有竞态条件问题了。所以非线程安全的对象仍可以通过某种方式来消除竞态条件。</p><h2 id="线程控制逃逸规则"><a href="#线程控制逃逸规则" class="headerlink" title="线程控制逃逸规则"></a>线程控制逃逸规则</h2><p>线程控制逃逸规则可以帮助你判断代码中对某些资源的访问是否是线程安全的。</p><pre>如果一个资源的创建，使用，销毁都在同一个线程内完成，且永远不会脱离该线程的控制，则该资源的使用就是线程安全的。</pre><p>资源可以是对象，数组，文件，数据库连接，套接字等等。Java中你无需主动销毁对象，所以“销毁”指不再有引用指向对象。</p><p>即使对象本身线程安全，但如果该对象中包含其他资源（文件，数据库连接），整个应用也许就不再是线程安全的了。比如2个线程都创建了各自的数据库连接，每个连接自身是线程安全的，但它们所连接到的同一个数据库也许不是线程安全的。比如，2个线程执行如下代码：</p><pre>检查记录X是否存在，如果不存在，插入X</pre><p>如果两个线程同时执行，而且碰巧检查的是同一个记录，那么两个线程最终可能都插入了记录：</p><pre>线程1检查记录X是否存在。检查结果：不存在线程2检查记录X是否存在。检查结果：不存在线程1插入记录X线程2插入记录X</pre><p>同样的问题也会发生在文件或其他共享资源上。因此，区分某个线程控制的对象是资源本身，还是仅仅到某个资源的引用很重要。</p><h1 id="线程安全及不可变性"><a href="#线程安全及不可变性" class="headerlink" title="线程安全及不可变性"></a>线程安全及不可变性</h1><p>当多个线程同时访问同一个资源，并且其中的一个或者多个线程对这个资源进行了写操作，才会产生<strong>竞态条件</strong>。多个线程同时读同一个资源不会产生竞态条件。</p><p>我们可以通过创建不可变的共享对象来保证对象在线程间共享时不会被修改，从而实现线程安全。如下示例：</p><table><thead><tr><th><code>01</code></th><th><code>public</code> <code>class</code> <code>ImmutableValue{</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>02</code></th><th><code>private</code> <code>int</code> <code>value = `</code>0<code></code>;`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>03</code></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>04</code></th><th><code>public</code> <code>ImmutableValue(`</code>int<code></code>value){`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>05</code></th><th><code>this`</code>.value = value;`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>06</code></th><th><code>}</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>07</code></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>08</code></th><th><code>public</code> <code>int</code> <code>getValue(){</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>09</code></th><th><code>return</code> <code>this`</code>.value;`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>10</code></th><th><code>}</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>11</code></th><th><code>}</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>请注意ImmutableValue类的成员变量<code>value</code>是通过构造函数赋值的，并且在类中没有set方法。这意味着一旦ImmutableValue实例被创建，<code>value</code>变量就不能再被修改，这就是不可变性。但你可以通过getValue()方法读取这个变量的值。</p><p>（<em>译者注：注意，“不变”（Immutable）和“只读”（Read Only）是不同的。当一个变量是“只读”时，变量的值不能直接改变，但是可以在其它变量发生改变的时候发生改变。比如，一个人的出生年月日是“不变”属性，而一个人的年龄便是“只读”属性，但是不是“不变”属性。随着时间的变化，一个人的年龄会随之发生变化，而一个人的出生年月日则不会变化。这就是“不变”和“只读”的区别。（摘自《Java与模式》第34章）</em>）</p><p>如果你需要对ImmutableValue类的实例进行操作，可以通过得到value变量后创建一个新的实例来实现，下面是一个对value变量进行加法操作的示例：</p><table><thead><tr><th><code>01</code></th><th><code>public</code> <code>class</code> <code>ImmutableValue{</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>02</code></th><th><code>private</code> <code>int</code> <code>value = `</code>0<code></code>;`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>03</code></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>04</code></th><th><code>public</code> <code>ImmutableValue(`</code>int<code></code>value){`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>05</code></th><th><code>this`</code>.value = value;`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>06</code></th><th><code>}</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>07</code></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>08</code></th><th><code>public</code> <code>int</code> <code>getValue(){</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>09</code></th><th><code>return</code> <code>this`</code>.value;`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>10</code></th><th><code>}</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>11</code></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>12</code></th><th><code>public</code> <code>ImmutableValue add(`</code>int<code></code>valueToAdd){`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>13</code></th><th><code>return</code> <code>new</code> <code>ImmutableValue(`</code>this<code></code>.value + valueToAdd);`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>14</code></th><th><code>}</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>15</code></th><th><code>}</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>请注意add()方法以加法操作的结果作为一个新的ImmutableValue类实例返回，而不是直接对它自己的value变量进行操作。</p><h2 id="引用不是线程安全的！"><a href="#引用不是线程安全的！" class="headerlink" title="引用不是线程安全的！"></a>引用不是线程安全的！</h2><p>重要的是要记住，即使一个对象是线程安全的不可变对象，指向这个对象的引用也可能不是线程安全的。看这个例子：</p><table><thead><tr><th><code>01</code></th><th><code>public</code> <code>void</code> <code>Calculator{</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>02</code></th><th><code>private</code> <code>ImmutableValue currentValue = `</code>null<code></code>;`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>03</code></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>04</code></th><th><code>public</code> <code>ImmutableValue getValue(){</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>05</code></th><th><code>return</code> <code>currentValue;</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>06</code></th><th><code>}</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>07</code></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>08</code></th><th><code>public</code> <code>void</code> <code>setValue(ImmutableValue newValue){</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>09</code></th><th><code>this`</code>.currentValue = newValue;`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>10</code></th><th><code>}</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>11</code></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>12</code></th><th><code>public</code> <code>void</code> <code>add(`</code>int<code></code>newValue){`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>13</code></th><th><code>this`</code>.currentValue = <code>this</code>.currentValue.add(newValue);`</th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>14</code></th><th><code>}</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><code>15</code></th><th><code>}</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>Calculator类持有一个指向ImmutableValue实例的引用。注意，通过setValue()方法和add()方法可能会改变这个引用。因此，即使Calculator类内部使用了一个不可变对象，但Calculator类本身还是可变的，因此Calculator类不是线程安全的。换句话说：ImmutableValue类是线程安全的，但使用它的类不是。当尝试通过不可变性去获得线程安全时，这点是需要牢记的。</p><p>要使Calculator类实现线程安全，将getValue()、setValue()和add()方法都声明为同步方法即可。</p><h1 id="Java多线程基础"><a href="#Java多线程基础" class="headerlink" title="Java多线程基础"></a>Java多线程基础</h1><h2 id="1-线程与多线程"><a href="#1-线程与多线程" class="headerlink" title="1 线程与多线程"></a>1 线程与多线程</h2><p>线程是什么？<br>线程（Thread）是一个对象（Object）。用来干什么？Java 线程（也称 JVM 线程）是 Java 进程内允许多个同时进行的任务。该进程内并发的任务成为线程（Thread），一个进程里至少一个线程。</p><p>Java 程序采用多线程方式来支持大量的并发请求处理，程序如果在多线程方式执行下，其复杂度远高于单线程串行执行。那么多线程：指的是这个程序（一个进程）运行时产生了不止一个线程。</p><p>为啥使用多线程？</p><ul><li>适合多核处理器。一个线程运行在一个处理器核心上，那么多线程可以分配到多个处理器核心上，更好地利用多核处理器。</li><li>防止阻塞。将数据一致性不强的操作使用多线程技术（或者消息队列）加快代码逻辑处理，缩短响应时间。</li></ul><p>聊到多线程，多半会聊并发与并行，咋理解并区分这两个的区别呢？</p><ul><li>类似单个 CPU ，通过 CPU 调度算法等，处理多个任务的能力，叫并发</li><li>类似多个 CPU ，同时并且处理相同多个任务的能力，叫做并行</li></ul><h2 id="2-线程的运行与创建"><a href="#2-线程的运行与创建" class="headerlink" title="2 线程的运行与创建"></a>2 线程的运行与创建</h2><h3 id="2-1-线程的创建"><a href="#2-1-线程的创建" class="headerlink" title="2.1 线程的创建"></a>2.1 线程的创建</h3><p>Java 创建线程对象有两种方法：</p><ul><li>继承 Thread 类创建线程对象</li><li>实现 Runnable 接口类创建线程对象</li></ul><p>新建 MyThread 对象，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承 Thread 类创建线程对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Jeff Lee @ bysocket.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018年01月27日21:03:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 可以省略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyThread 的线程对象正在执行任务"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">            thread.start();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"MyThread 的线程对象 "</span> + thread.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyThread 类继承了 Thread 对象，并重写（Override）了 run 方法，实现线程里面的逻辑。main 函数是使用 for 语句，循环创建了 10 个线程，调用 start 方法启动线程，最后打印当前线程对象的 ID。</p><p>run 方法和 start 方法的区别是什么呢？<br>run 方法就是跑的意思，线程启动后，会调用 run 方法。<br>start 方法就是启动的意思，就是启动新线程实例。启动线程后，才会调线程的 run 方法。</p><p>执行 main 方法后，控制台打印如下：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MyThread 的线程对象正在执行任务</span><br><span class="line">MyThread 的线程对象 <span class="number">10</span></span><br><span class="line">MyThread 的线程对象正在执行任务</span><br><span class="line">MyThread 的线程对象 <span class="number">11</span></span><br><span class="line">MyThread 的线程对象正在执行任务</span><br><span class="line">MyThread 的线程对象 <span class="number">12</span></span><br><span class="line">MyThread 的线程对象正在执行任务</span><br><span class="line">MyThread 的线程对象 <span class="number">13</span></span><br><span class="line">MyThread 的线程对象正在执行任务</span><br><span class="line">MyThread 的线程对象 <span class="number">14</span></span><br><span class="line">MyThread 的线程对象正在执行任务</span><br><span class="line">MyThread 的线程对象 <span class="number">15</span></span><br><span class="line">MyThread 的线程对象正在执行任务</span><br><span class="line">MyThread 的线程对象 <span class="number">16</span></span><br><span class="line">MyThread 的线程对象正在执行任务</span><br><span class="line">MyThread 的线程对象 <span class="number">17</span></span><br><span class="line">MyThread 的线程对象正在执行任务</span><br><span class="line">MyThread 的线程对象 <span class="number">18</span></span><br><span class="line">MyThread 的线程对象正在执行任务</span><br><span class="line">MyThread 的线程对象 <span class="number">19</span></span><br></pre></td></tr></table></figure><p>可见，线程的 ID 是线程唯一标识符，每个线程 ID 都是不一样的。</p><p>start 方法和 run 方法的关系如图所示：<br><img src="http://upload-images.jianshu.io/upload_images/1483536-c52b04e3ae79a99a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>同理，实现 Runnable 接口类创建线程对象也很简单，只是不同的形式。新建 MyThreadBrother 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现 Runnable 接口类创建线程对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Jeff Lee @ bysocket.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018年01月27日21:22:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadBrother</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 可以省略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyThreadBrother 的线程对象正在执行任务"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThreadBrother());</span><br><span class="line">            thread.start();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"MyThreadBrother 的线程对象 "</span> + thread.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体代码：「java-concurrency-core-learning」<br><a href="https://github.com/JeffLi1993/java-concurrency-core-learning" target="_blank" rel="noopener">https://github.com/JeffLi1993/java-concurrency-core-learning</a></p><h3 id="2-1-线程的运行"><a href="#2-1-线程的运行" class="headerlink" title="2.1 线程的运行"></a>2.1 线程的运行</h3><p>在运行上面两个小 demo 后，JVM 执行了 main 函数线程，然后在主线程中执行创建了新的线程。正常情况下，所有线程执行到运行结束为止。除非某个线程中调用了 System.exit(1) 则被终止。</p><p>在实际开发中，一个请求到响应式是一个线程。但在这个线程中可以使用线程池创建新的线程，去执行任务。</p><p><img src="http://upload-images.jianshu.io/upload_images/1483536-4c54f3f145fb77c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="3-线程的状态"><a href="#3-线程的状态" class="headerlink" title="3 线程的状态"></a>3 线程的状态</h2><p>新建 MyThreadInfo 类，打印线程对象属性，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程实例对象的属性值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Jeff Lee @ bysocket.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018年01月27日21:24:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadInfo</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 可以省略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyThreadInfo 的线程实例正在执行任务"</span>);</span><br><span class="line"><span class="comment">//        System.exit(1);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThreadInfo thread = <span class="keyword">new</span> MyThreadInfo();</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"MyThreadInfo 的线程对象 \n"</span></span><br><span class="line">                + <span class="string">"线程唯一标识符："</span> + thread.getId() + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"线程名称："</span> + thread.getName() + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"线程状态："</span> + thread.getState() + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"线程优先级："</span> + thread.getPriority());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行代码打印如下：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyThreadInfo 的线程实例正在执行任务</span><br><span class="line">MyThreadInfo 的线程对象 </span><br><span class="line">线程唯一标识符：<span class="number">10</span></span><br><span class="line">线程名称：Thread<span class="number">-0</span></span><br><span class="line">线程状态：NEW</span><br><span class="line">线程优先级：<span class="number">5</span></span><br></pre></td></tr></table></figure><p>线程是一个对象，它有唯一标识符 ID、名称、状态、优先级等属性。线程只能修改其优先级和名称等属性 ，无法修改 ID 、状态。ID 是 JVM 分配的，名字默认也为 Thread-XX，XX是一组数字。线程初始状态为 NEW。</p><p>线程优先级的范围是 1 到 10 ，其中 1 是最低优先级，10 是最高优先级。不推荐改变线程的优先级，如果业务需要，自然可以修改线程优先级到最高，或者最低。</p><p>线程的状态实现通过 Thread.State 常量类实现，有 6 种线程状态：new（新建）、runnnable（可运行）、blocked（阻塞）、waiting（等待）、time waiting （定时等待）和 terminated（终止）。状态转换图如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1483536-d8214781072e129f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>线程状态流程大致如下：</p><ul><li>线程创建后，进入 new 状态</li><li>调用 start 或者 run 方法，进入 runnable 状态</li><li>JVM 按照线程优先级及时间分片等执行 runnable 状态的线程。开始执行时，进入 running 状态</li><li>如果线程执行 sleep、wait、join，或者进入 IO 阻塞等。进入 wait 或者 blocked 状态</li><li>线程执行完毕后，线程被线程队列移除。最后为 terminated 状态。</li></ul><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4 小结"></a>4 小结</h2><p>本文介绍了线程与多线程的基础篇，包括了线程启动及线程状态等。下一篇我们聊下线程的具体操作。包括中断、终止等</p><h2 id="线程中断和终止"><a href="#线程中断和终止" class="headerlink" title="线程中断和终止"></a>线程中断和终止</h2><h3 id="1-线程中断"><a href="#1-线程中断" class="headerlink" title="1 线程中断"></a>1 线程中断</h3><h4 id="1-1-什么是线程中断？"><a href="#1-1-什么是线程中断？" class="headerlink" title="1.1 什么是线程中断？"></a>1.1 什么是线程中断？</h4><p>线程中断是线程的标志位属性。而不是真正终止线程，和线程的状态无关。线程中断过程表示一个运行中的线程，通过其他线程调用了该线程的 <code>interrupt()</code> 方法，使得该线程中断标志位属性改变。</p><p>深入思考下，线程中断不是去中断了线程，恰恰是用来通知该线程应该被中断了。具体是一个标志位属性，到底该线程生命周期是去终止，还是继续运行，由线程根据标志位属性自行处理。</p><h4 id="1-2-线程中断操作"><a href="#1-2-线程中断操作" class="headerlink" title="1.2 线程中断操作"></a>1.2 线程中断操作</h4><p>调用线程的 <code>interrupt()</code> 方法，根据线程不同的状态会有不同的结果。</p><p>下面新建 InterruptedThread 对象，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一直运行的线程，中断状态为 true</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Jeff Lee @ bysocket.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018年02月23日19:03:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptedThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 可以省略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一直 run</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread interruptedThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> InterruptedThread(), <span class="string">"InterruptedThread"</span>);</span><br><span class="line">        interruptedThread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        interruptedThread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"InterruptedThread interrupted is "</span> + interruptedThread.isInterrupted());</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main 函数，结果如下：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InterruptedThread interrupted <span class="keyword">is</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li>线程一直在运行状态，没有停止或者阻塞等</li><li>调用了 <code>interrupt()</code> 方法，中断状态置为 true，但不会影响线程的继续运行</li></ul><p>另一种情况，新建 InterruptedException 对象，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抛出 InterruptedException 的线程，中断状态被重置为默认状态 false</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Jeff Lee @ bysocket.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018年02月23日19:03:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptedException</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 可以省略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一直 sleep</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.lang.InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread interruptedThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> InterruptedException(), <span class="string">"InterruptedThread"</span>);</span><br><span class="line">        interruptedThread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中断被阻塞状态（sleep、wait、join 等状态）的线程，会抛出异常 InterruptedException</span></span><br><span class="line">        <span class="comment">// 在抛出异常 InterruptedException 前，JVM 会先将中断状态重置为默认状态 false</span></span><br><span class="line">        interruptedThread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"InterruptedThread interrupted is "</span> + interruptedThread.isInterrupted());</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main 函数，结果如下：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InterruptedThread interrupted <span class="keyword">is</span> <span class="keyword">false</span></span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native <span class="function"><span class="keyword">Method</span>)</span></span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li>中断被阻塞状态（sleep、wait、join 等状态）的线程，会抛出异常 InterruptedException</li><li>抛出异常 InterruptedException 前，JVM 会先将中断状态重置为默认状态 false</li></ul><p>小结下线程中断：</p><ul><li>线程中断，不是停止线程，只是一个线程的标志位属性</li><li>如果线程状态为被阻塞状态（sleep、wait、join 等状态），线程状态退出被阻塞状态，抛出异常 InterruptedException，并重置中断状态为默认状态 false</li><li>如果线程状态为运行状态，线程状态不变，继续运行，中断状态置为 true</li></ul><p>代码：<a href="https://github.com/JeffLi1993/java-concurrency-core-learning" target="_blank" rel="noopener">https://github.com/JeffLi1993/java-concurrency-core-learning</a></p><h3 id="2-线程终止"><a href="#2-线程终止" class="headerlink" title="2 线程终止"></a>2 线程终止</h3><p>比如在 IDEA 中强制关闭程序，立即停止程序，不给程序释放资源等操作，肯定是不正确的。线程终止也存在类似的问题，所以需要考虑如何终止线程？</p><p>上面聊到了线程中断，可以利用线程中断标志位属性来安全终止线程。同理也可以使用 boolean 变量来控制是否需要终止线程。</p><p>新建 ，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 安全终止线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Jeff Lee @ bysocket.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018年02月23日19:03:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeStop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Runner one = <span class="keyword">new</span> Runner();</span><br><span class="line">        Thread countThread = <span class="keyword">new</span> Thread(one, <span class="string">"CountThread"</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line">        <span class="comment">// 睡眠 1 秒，通知 CountThread 中断，并终止线程</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        countThread.interrupt();</span><br><span class="line"></span><br><span class="line">        Runner two = <span class="keyword">new</span> Runner();</span><br><span class="line">        countThread = <span class="keyword">new</span> Thread(two,<span class="string">"CountThread"</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line">        <span class="comment">// 睡眠 1 秒，然后设置线程停止状态，并终止线程</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        two.stopSafely();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 终止状态</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> on = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (on &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                <span class="comment">// 线程执行具体逻辑</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Count i = "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            on = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，通过 <code>while (on &amp;&amp; !Thread.currentThread().isInterrupted())</code> 代码来实现线程是否跳出执行逻辑，并终止。但是疑问点就来了，为啥需要 <code>on</code> 和 <code>isInterrupted()</code> 两项一起呢？用其中一个方式不就行了吗？答案在下面</p><ul><li>线程成员变量 <code>on</code> 通过 volatile 关键字修饰，达到线程之间可见，从而实现线程的终止。但当线程状态为被阻塞状态（sleep、wait、join 等状态）时，对成员变量操作也阻塞，进而无法执行安全终止线程</li><li>为了处理上面的问题，引入了 <code>isInterrupted();</code> 只去解决阻塞状态下的线程安全终止。</li><li>两者结合是真的没问题了吗？不是的，如果是网络 io 阻塞，比如一个 websocket 一直再等待响应，那么直接使用底层的 close 。</li></ul><h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h3><p>很多好友介绍，如果用 Spring 栈开发到使用线程或者线程池，那么尽量使用框架这块提供的线程操作及框架提供的终止等</p><h1 id="Threadlocal介绍"><a href="#Threadlocal介绍" class="headerlink" title="Threadlocal介绍"></a><strong>Threadlocal介绍</strong></h1><blockquote><p>原文出处<a href="http://cmsblogs.com/" target="_blank" rel="noopener">http://cmsblogs.com/</a> 『chenssy』</p></blockquote><h2 id="ThreadLoacal是什么？"><a href="#ThreadLoacal是什么？" class="headerlink" title="ThreadLoacal是什么？"></a>ThreadLoacal是什么？</h2><p>ThreadLocal是啥？以前面试别人时就喜欢问这个，有些伙伴喜欢把它和线程同步机制混为一谈，事实上ThreadLocal与线程同步无关。ThreadLocal虽然提供了一种解决多线程环境下成员变量的问题，但是它并不是解决多线程共享变量的问题。那么ThreadLocal到底是什么呢？</p><p>API是这样介绍它的：<br>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g.,a user ID or Transaction ID).</p><blockquote><p>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其<code>get</code> 或 <code>set</code> 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。<code>ThreadLocal</code>实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。</p></blockquote><p>所以ThreadLocal与线程同步机制不同，线程同步机制是多个线程共享同一个变量，而ThreadLocal是为每一个线程创建一个单独的变量副本，故而每个线程都可以独立地改变自己所拥有的变量副本，而不会影响其他线程所对应的副本。可以说ThreadLocal为多线程环境下变量问题提供了另外一种解决思路。</p><p>ThreadLocal定义了四个方法：</p><ul><li>get()：返回此线程局部变量的当前线程副本中的值。</li><li>initialValue()：返回此线程局部变量的当前线程的“初始值”。</li><li>remove()：移除此线程局部变量当前线程的值。</li><li>set(T value)：将此线程局部变量的当前线程副本中的值设置为指定值。</li></ul><p>除了这四个方法，ThreadLocal内部还有一个静态内部类ThreadLocalMap，该内部类才是实现线程隔离机制的关键，get()、set()、remove()都是基于该内部类操作。ThreadLocalMap提供了一种用键值对方式存储每一个线程的变量副本的方法，key为当前ThreadLocal对象，value则是对应线程的变量副本。</p><p>对于ThreadLocal需要注意的有两点：<br>1. ThreadLocal实例本身是不存储值，它只是提供了一个在当前线程中找到副本值得key。<br>2. 是ThreadLocal包含在Thread中，而不是Thread包含在ThreadLocal中，有些小伙伴会弄错他们的关系。</p><p>下图是Thread、ThreadLocal、ThreadLocalMap的关系（<a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/" target="_blank" rel="noopener">http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/</a>）</p><p><img src="https://img-blog.csdn.net/20171005154736367?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hlbnNzeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Thread、ThreadLocal、ThreadLocalMap的关系"></p><h2 id="ThreadLocal使用示例"><a href="#ThreadLocal使用示例" class="headerlink" title="ThreadLocal使用示例"></a>ThreadLocal使用示例</h2><p>示例如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SeqCount</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; seqCount = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="comment">// 实现initialValue()</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">initialValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextSeq</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        seqCount.<span class="keyword">set</span>(seqCount.<span class="keyword">get</span>() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> seqCount.<span class="keyword">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</span><br><span class="line">        SeqCount seqCount = <span class="keyword">new</span> SeqCount();</span><br><span class="line"></span><br><span class="line">        SeqThread thread1 = <span class="keyword">new</span> SeqThread(seqCount);</span><br><span class="line">        SeqThread thread2 = <span class="keyword">new</span> SeqThread(seqCount);</span><br><span class="line">        SeqThread thread3 = <span class="keyword">new</span> SeqThread(seqCount);</span><br><span class="line">        SeqThread thread4 = <span class="keyword">new</span> SeqThread(seqCount);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SeqThread</span> <span class="title">extends</span> <span class="title">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> SeqCount seqCount;</span><br><span class="line"></span><br><span class="line">        SeqThread(SeqCount seqCount)&#123;</span><br><span class="line">            <span class="keyword">this</span>.seqCount = seqCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i++)&#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" seqCount :"</span> + seqCount.nextSeq());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://img-blog.csdn.net/20171005154820871?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hlbnNzeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="运行结果"></p><p>从运行结果可以看出，ThreadLocal确实是可以达到线程隔离机制，确保变量的安全性。这里我们想一个问题，在上面的代码中ThreadLocal的initialValue()方法返回的是0，加入该方法返回得是一个对象呢，会产生什么后果呢？例如：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> <span class="type">A</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;A&gt; seqCount = <span class="keyword">new</span> <span class="type">ThreadLocal</span>&lt;A&gt;()&#123;</span><br><span class="line">    <span class="comment">// 实现initialValue()</span></span><br><span class="line">    <span class="keyword">public</span> A initialValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体过程请参考：<a href="http://www.jianshu.com/p/ee8c9dccc953" target="_blank" rel="noopener">对ThreadLocal实现原理的一点思考</a></p><h2 id="ThreadLocal源码解析"><a href="#ThreadLocal源码解析" class="headerlink" title="ThreadLocal源码解析"></a>ThreadLocal源码解析</h2><p>ThreadLocal虽然解决了这个多线程变量的复杂问题，但是它的源码实现却是比较简单的。ThreadLocalMap是实现ThreadLocal的关键，我们先从它入手。</p><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p>ThreadLocalMap其内部利用Entry来实现key-value的存储，如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</span> </span>&#123;</span><br><span class="line">     <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">     <span class="type">Object</span> value;</span><br><span class="line"></span><br><span class="line">     <span class="type">Entry</span>(<span class="type">ThreadLocal</span>&lt;?&gt; k, <span class="type">Object</span> v) &#123;</span><br><span class="line">         <span class="keyword">super</span>(k);</span><br><span class="line">         value = v;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从上面代码中可以看出Entry的key就是ThreadLocal，而value就是值。同时，Entry也继承WeakReference，所以说Entry所对应key（ThreadLocal实例）的引用为一个弱引用（关于弱引用这里就不多说了，感兴趣的可以关注这篇博客：<a href="https://www.ibm.com/developerworks/cn/java/j-jtp11225/" target="_blank" rel="noopener">Java 理论与实践: 用弱引用堵住内存泄漏</a>）</p><p>ThreadLocalMap的源码稍微多了点，我们就看两个最核心的方法getEntry()、set(ThreadLocal&gt; key, Object value)方法。</p><p><strong>set(ThreadLocal&gt; key, Object value)</strong></p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="built_in">set</span>(ThreadLocal&lt;?&gt; <span class="built_in">key</span>, <span class="keyword">Object</span> value) &#123;</span><br><span class="line"></span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class="line">    <span class="built_in">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 ThreadLocal 的散列值，查找对应元素在数组中的位置</span></span><br><span class="line">    <span class="built_in">int</span> i = <span class="built_in">key</span>.threadLocalHashCode &amp; (len<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采用“线性探测法”，寻找合适位置</span></span><br><span class="line">    <span class="keyword">for</span> (ThreadLocal.ThreadLocalMap.Entry e = tab[i];</span><br><span class="line">        e != <span class="keyword">null</span>;</span><br><span class="line">        e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line"></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key 存在，直接覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="built_in">key</span>) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key == null，但是存在值（因为此处的e != null），说明之前的ThreadLocal对象已经被回收了</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 用新元素替换陈旧的元素</span></span><br><span class="line">            replaceStaleEntry(<span class="built_in">key</span>, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ThreadLocal对应的key实例不存在也没有陈旧元素，new 一个</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap.Entry(<span class="built_in">key</span>, value);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> sz = ++<span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cleanSomeSlots 清楚陈旧的Entry（key == null）</span></span><br><span class="line">    <span class="comment">// 如果没有清理陈旧的 Entry 并且数组中的元素大于了阈值，则进行 rehash</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个set()操作和我们在集合了解的put()方式有点儿不一样，虽然他们都是key-value结构，不同在于他们解决散列冲突的方式不同。集合Map的put()采用的是拉链法，而ThreadLocalMap的set()则是采用开放定址法（具体请参考<a href="http://www.nowamagic.net/academy/detail/3008015" target="_blank" rel="noopener">散列冲突处理系列博客</a>）。掌握了开放地址法该方法就一目了然了。</p><p>set()操作除了存储元素外，还有一个很重要的作用，就是replaceStaleEntry()和cleanSomeSlots()，这两个方法可以清除掉key == null 的实例，防止内存泄漏。在set()方法中还有一个变量很重要：threadLocalHashCode，定义如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br></pre></td></tr></table></figure><p>从名字上面我们可以看出threadLocalHashCode应该是ThreadLocal的散列值，定义为final，表示ThreadLocal一旦创建其散列值就已经确定了，生成过程则是调用nextHashCode()：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> nextHashCode.<span class="title">getAndAdd</span><span class="params">(HASH_INCREMENT)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nextHashCode表示分配下一个ThreadLocal实例的threadLocalHashCode的值，HASH_INCREMENT则表示分配两个ThradLocal实例的threadLocalHashCode的增量，从nextHashCode就可以看出他们的定义。</p><p>getEntry()</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry getEntry(ThreadLocal&lt;?&gt; <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="built_in">key</span>.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.<span class="built_in">get</span>() == <span class="built_in">key</span>)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(<span class="built_in">key</span>, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于采用了开放定址法，所以当前key的散列值和元素在数组的索引并不是完全对应的，首先取一个探测数（key的散列值），如果所对应的key就是我们所要找的元素，则返回，否则调用getEntryAfterMiss()，如下：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; <span class="built_in">key</span>, int i, Entry e) &#123;</span><br><span class="line">    Entry[] <span class="built_in">tab</span> = table;</span><br><span class="line">    int len = <span class="built_in">tab</span>.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="built_in">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="built_in">key</span>)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="built_in">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = <span class="built_in">nextIndex</span>(i, len);</span><br><span class="line">        e = <span class="built_in">tab</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个重要的地方，当key == null时，调用了expungeStaleEntry()方法，该方法用于处理key == null，有利于GC回收，能够有效地避免内存泄漏。</p><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><blockquote><p>返回当前线程所对应的线程变量</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程的成员变量 threadLocal</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从当前线程的ThreadLocalMap获取相对应的Entry</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(<span class="meta-string">"unchecked"</span>)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取目标值        </span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过当前线程获取所对应的成员变量ThreadLocalMap，然后通过ThreadLocalMap获取当前ThreadLocal的Entry，最后通过所获取的Entry获取目标值result。</p><p>getMap()方法可以获取当前线程所对应的ThreadLocalMap，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set-T-value"><a href="#set-T-value" class="headerlink" title="set(T value)"></a>set(T value)</h3><blockquote><p>设置当前线程的线程局部变量的值。</p></blockquote><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="literal">void</span> <span class="built_in">set</span>(T value) &#123;</span><br><span class="line">    <span class="keyword">Thread</span> t = <span class="keyword">Thread</span>.currentThread();</span><br><span class="line">    ThreadLocalMap <span class="built_in">map</span> = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span> != <span class="built_in">null</span>)</span><br><span class="line">        <span class="built_in">map</span>.<span class="built_in">set</span>(this, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取当前线程所对应的ThreadLocalMap，如果不为空，则调用ThreadLocalMap的set()方法，key就是当前ThreadLocal，如果不存在，则调用createMap()方法新建一个，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="initialValue"><a href="#initialValue" class="headerlink" title="initialValue()"></a>initialValue()</h3><blockquote><p>返回该线程局部变量的初始值。</p></blockquote><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function">T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法定义为protected级别且返回为null，很明显是要子类实现它的，所以我们在使用ThreadLocal的时候一般都应该覆盖该方法。该方法不能显示调用，只有在第一次调用get()或者set()方法时才会被执行，并且仅执行1次。</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><blockquote><p>将当前线程局部变量的值删除。</p></blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">        m.<span class="keyword">remove</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的目的是减少内存的占用。当然，我们不需要显示调用该方法，因为一个线程结束后，它所对应的局部变量就会被垃圾回收。</p><h2 id="ThreadLocal为什么会内存泄漏"><a href="#ThreadLocal为什么会内存泄漏" class="headerlink" title="ThreadLocal为什么会内存泄漏"></a>ThreadLocal为什么会内存泄漏</h2><p>前面提到每个Thread都有一个ThreadLocal.ThreadLocalMap的map，该map的key为ThreadLocal实例，它为一个弱引用，我们知道弱引用有利于GC回收。当ThreadLocal的key == null时，GC就会回收这部分空间，但是value却不一定能够被回收，因为他还与Current Thread存在一个强引用关系，如下（图片来自<a href="http://www.jianshu.com/p/ee8c9dccc953" target="_blank" rel="noopener">http://www.jianshu.com/p/ee8c9dccc953</a>）：</p><p><img src="https://img-blog.csdn.net/20171005154856389?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hlbnNzeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>由于存在这个强引用关系，会导致value无法回收。如果这个线程对象不会销毁那么这个强引用关系则会一直存在，就会出现内存泄漏情况。所以说只要这个线程对象能够及时被GC回收，就不会出现内存泄漏。如果碰到线程池，那就更坑了。</p><p>那么要怎么避免这个问题呢？</p><p>在前面提过，在ThreadLocalMap中的setEntry()、getEntry()，如果遇到key == null的情况，会对value设置为null。当然我们也可以显示调用ThreadLocal的remove()方法进行处理。</p><p>下面再对ThreadLocal进行简单的总结：</p><blockquote><ul><li>ThreadLocal 不是用于解决共享变量的问题的，也不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制。这点至关重要。</li><li>每个Thread内部都有一个ThreadLocal.ThreadLocalMap类型的成员变量，该成员变量用来存储实际的ThreadLocal变量副本。</li><li>ThreadLocal并不是为线程保存对象的副本，它仅仅只起到一个索引的作用。它的主要木得视为每一个线程隔离一个类的实例，这个实例的作用范围仅限于线程内部。</li></ul></blockquote><p>有关于JMM内存模型的详细介绍将在下一章讲述。</p><p>本文<em>转载自</em><a href="http://ifeve.com/" target="_blank" rel="noopener">并发编程网 – ifeve.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎阅览我的CSDN专栏：Java并发指南&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/21961.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21961.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java并发" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://h2pl.github.io/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java并发指南开篇：Java并发编程学习大纲</title>
    <link href="http://h2pl.github.io/2018/05/15/concurrent/"/>
    <id>http://h2pl.github.io/2018/05/15/concurrent/</id>
    <published>2018-05-15T15:05:25.000Z</published>
    <updated>2018-05-27T15:00:55.275Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>更多关于Java并发的文章请参阅我的CSDN专栏：Java并发指南<br><a href="https://blog.csdn.net/column/details/21961.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21961.html</a></p><p>相关代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p><p>Java并发编程一直是Java程序员必须懂但又是很难懂的技术内容。</p><p>这里不仅仅是指使用简单的多线程编程，或者使用juc的某个类。当然这些都是并发编程的基本知识，除了使用这些工具以外，Java并发编程中涉及到的技术原理十分丰富。为了更好地把并发知识形成一个体系，也鉴于本人没有能力写出这类文章，于是参考几位并发编程专家的博客和书籍，做一个简单的整理和复习。</p><p>本文只是简要的介绍和总结。详细的内容欢迎来我的专栏阅读，会有更多的系列文章。</p><a id="more"></a><h2 id="并发基础和多线程"><a href="#并发基础和多线程" class="headerlink" title="并发基础和多线程"></a>并发基础和多线程</h2><p>首先需要学习的就是并发的基础知识，什么是并发，为什么要并发，多线程的概念，线程安全的概念等。</p><p>然后学会使用Java中的Thread或是其他线程实现方法，了解线程的状态转换，线程的方法，线程的通信方式等。</p><h2 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h2><p>任何语言最终都是运行在处理器上，JVM虚拟机为了给开发者一个一致的编程内存模型，需要制定一套规则，这套规则可以在不同架构的机器上有不同实现，并且向上为程序员提供统一的JMM内存模型。</p><p>所以了解JMM内存模型也是了解Java并发原理的一个重点，其中了解指令重排，内存屏障，以及可见性原理尤为重要。</p><p>JMM只保证happens-before和as-if-serial规则，所以在多线程并发时，可能出现原子性，可见性以及有序性这三大问题。</p><p>下面的内容则会讲述Java是如何解决这三大问题的。</p><h2 id="synchronized，volatile，final等关键字"><a href="#synchronized，volatile，final等关键字" class="headerlink" title="synchronized，volatile，final等关键字"></a>synchronized，volatile，final等关键字</h2><p>对于并发的三大问题，volatile可以保证原子性和可见性，synchronized三种特性都可以保证（允许指令重排）。</p><p>synchronized是基于操作系统的mutex lock指令实现的，volatile和final则是根据JMM实现其内存语义。</p><p>此处还要了解CAS操作，它不仅提供了类似volatile的内存语义，并且保证操作原子性，因为它是由硬件实现的。</p><p>JUC中的Lock底层就是使用volatile加上CAS的方式实现的。synchronized也会尝试用cas操作来优化器重量级锁。</p><p>了解这些关键字是很有必要的。</p><h2 id="JUC包"><a href="#JUC包" class="headerlink" title="JUC包"></a>JUC包</h2><p>在了解完上述内容以后，就可以看看JUC的内容了。</p><p>JUC提供了包括Lock，原子操作类，线程池，同步容器，工具类等内容。</p><p>这些类的基础都是AQS，所以了解AQS的原理是很重要的。</p><p>除此之外，还可以了解一下Fork/Join，以及JUC的常用场景，比如生产者消费者，阻塞队列，以及读写容器等。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>上述这些内容，除了JMM部分的内容比较不好实现之外，像是多线程基本使用，JUC的使用都可以在代码实践中更好地理解其原理。多尝试一些场景，或者在网上找一些比较经典的并发场景，或者参考别人的例子，在实践中加深理解，还是很有必要的。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>由于很多Java新手可能对并发编程没什么概念，在这里放一篇不错的总结，简要地提几个并发编程中比要重要的点，也是比较基本的点吗，算是抛砖引玉，开个好头，在大致了解了这些基础内容以后，才能更好地开展后面详细内容的学习。</p><p><img src="https://upload-images.jianshu.io/upload_images/623504-3856f8a1e75a85c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p><h3 id="1-并发编程三要素"><a href="#1-并发编程三要素" class="headerlink" title="1.并发编程三要素"></a>1.并发编程三要素</h3><ul><li>原子性<br>原子，即一个不可再被分割的颗粒。在Java中原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。</li><li>有序性<br>程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）</li><li>可见性<br>当多个线程访问同一个变量时，如果其中一个线程对其作了修改，其他线程能立即获取到最新的值。</li></ul><h3 id="2-线程的五大状态"><a href="#2-线程的五大状态" class="headerlink" title="2. 线程的五大状态"></a>2. 线程的五大状态</h3><ul><li>创建状态<br>当用 new 操作符创建一个线程的时候</li><li>就绪状态<br>调用 start 方法，处于就绪状态的线程并不一定马上就会执行 run 方法，还需要等待CPU的调度</li><li>运行状态<br>CPU 开始调度线程，并开始执行 run 方法</li><li>阻塞状态<br>线程的执行过程中由于一些原因进入阻塞状态<br>比如：调用 sleep 方法、尝试去得到一个锁等等​​</li><li>死亡状态<br>run 方法执行完 或者 执行过程中遇到了一个异常</li></ul><h3 id="3-悲观锁与乐观锁"><a href="#3-悲观锁与乐观锁" class="headerlink" title="3.悲观锁与乐观锁"></a>3.悲观锁与乐观锁</h3><ul><li>悲观锁：每次操作都会加锁，会造成线程阻塞。</li><li>乐观锁：每次操作不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止，不会造成线程阻塞。​</li></ul><h3 id="4-线程之间的协作"><a href="#4-线程之间的协作" class="headerlink" title="4.线程之间的协作"></a>4.线程之间的协作</h3><h4 id="4-1-wait-notify-notifyAll"><a href="#4-1-wait-notify-notifyAll" class="headerlink" title="4.1 wait/notify/notifyAll"></a>4.1 wait/notify/notifyAll</h4><p>这一组是 Object 类的方法<br>需要注意的是：这三个方法都必须在同步的范围内调用​</p><ul><li><p>wait<br>阻塞当前线程，直到 notify 或者 notifyAll 来唤醒​​​​</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">wait有三种方式的调用</span><br><span class="line">wait()</span><br><span class="line">必要要由 notify 或者 notifyAll 来唤醒​​​​</span><br><span class="line">wait(<span class="keyword">long</span> timeout)</span><br><span class="line">在指定时间内，如果没有notify或notifAll方法的唤醒，也会自动唤醒。</span><br><span class="line">wait(<span class="keyword">long</span> timeout,<span class="keyword">long</span> nanos)</span><br><span class="line">本质上还是调用一个参数的方法</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">      <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">             <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             timeout++;</span><br><span class="line">       &#125;</span><br><span class="line">       wait(timeout);</span><br><span class="line">&#125;</span><br><span class="line">              ​</span><br></pre></td></tr></table></figure><ul><li>notify<br>只能唤醒一个处于 wait 的线程</li><li>notifyAll<br>唤醒全部处于 wait 的线程<br>​</li></ul></li></ul><h4 id="4-2-sleep-yield-join"><a href="#4-2-sleep-yield-join" class="headerlink" title="4.2 sleep/yield/join"></a>4.2 sleep/yield/join</h4><p>这一组是 Thread 类的方法</p><ul><li><p>sleep<br>让当前线程暂停指定时间，只是让出CPU的使用权，并不释放锁</p></li><li><p>yield<br>暂停当前线程的执行，也就是当前CPU的使用权，让其他线程有机会执行，不能指定时间。会让当前线程从运行状态转变为就绪状态，此方法在生产环境中很少会使用到，​​​官方在其注释中也有相关的说明</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* A hint <span class="keyword">to</span> <span class="keyword">the</span> scheduler <span class="keyword">that</span> <span class="keyword">the</span> current thread <span class="keyword">is</span> willing <span class="keyword">to</span> yield</span><br><span class="line">* <span class="keyword">its</span> current use <span class="keyword">of</span> a processor. The scheduler <span class="keyword">is</span> free <span class="keyword">to</span> ignore this</span><br><span class="line">* hint.</span><br><span class="line">*</span><br><span class="line">* &lt;p&gt; Yield <span class="keyword">is</span> a heuristic attempt <span class="keyword">to</span> improve relative progression</span><br><span class="line">* <span class="keyword">between</span> threads <span class="keyword">that</span> would otherwise <span class="keyword">over</span>-utilise a CPU. Its use</span><br><span class="line">* should be combined <span class="keyword">with</span> detailed profiling <span class="keyword">and</span> benchmarking <span class="keyword">to</span></span><br><span class="line">* ensure <span class="keyword">that</span> <span class="keyword">it</span> actually has <span class="keyword">the</span> desired effect.</span><br><span class="line">*</span><br><span class="line">* &lt;p&gt; It <span class="keyword">is</span> rarely appropriate <span class="keyword">to</span> use this method. It may be useful</span><br><span class="line">* <span class="keyword">for</span> debugging <span class="keyword">or</span> testing purposes, <span class="keyword">where</span> <span class="keyword">it</span> may help <span class="keyword">to</span> reproduce</span><br><span class="line">* bugs due <span class="keyword">to</span> race conditions. It may also be useful when designing</span><br><span class="line">* concurrency control constructs such <span class="keyword">as</span> <span class="keyword">the</span> ones <span class="keyword">in</span> <span class="keyword">the</span></span><br><span class="line">* &#123;@link java.util.concurrent.locks&#125; package.</span><br><span class="line">*/​​</span><br><span class="line">​​​​</span><br></pre></td></tr></table></figure></li><li><p>join<br>等待调用 join 方法的线程执行结束，才执行后面的代码<br>其调用一定要在 start 方法之后（看源码可知）​<br>使用场景：当父线程需要等待子线程执行结束才执行后面内容或者需要某个子线程的执行结果会用到 join 方法​</p></li></ul><h3 id="5-valitate-关键字"><a href="#5-valitate-关键字" class="headerlink" title="5.valitate 关键字"></a>5.valitate 关键字</h3><h4 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h4><p>java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p><blockquote><p>valitate是轻量级的synchronized，不会引起线程上下文的切换和调度，执行开销更小。</p></blockquote><h4 id="5-2-原理"><a href="#5-2-原理" class="headerlink" title="5.2 原理"></a>5.2 原理</h4><p>1. 使用volitate修饰的变量在汇编阶段，会多出一条lock前缀指令<br>2. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成<br>3. 它会强制将对缓存的修改操作立即写入主存<br>4. 如果是写操作，它会导致其他CPU里缓存了该内存地址的数据无效</p><h4 id="5-3-作用"><a href="#5-3-作用" class="headerlink" title="5.3 作用"></a>5.3 作用</h4><p>内存可见性<br>多线程操作的时候，一个线程修改了一个变量的值 ，其他线程能立即看到修改后的值<br>防止重排序<br>即程序的执行顺序按照代码的顺序执行（处理器为了提高代码的执行效率可能会对代码进行重排序）</p><blockquote><p>并不能保证操作的原子性（比如下面这段代码的执行结果一定不是100000）</p></blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">testValitate</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     inc = inc + <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">     final testValitate test = <span class="keyword">new</span> testValitate();</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                 <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++)</span><br><span class="line">                     test.increase();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;.start();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) &#123;  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">         Thread.<span class="keyword">yield</span>();</span><br><span class="line">     &#125;</span><br><span class="line">     System.<span class="keyword">out</span>.println(test.inc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-synchronized-关键字"><a href="#6-synchronized-关键字" class="headerlink" title="6. synchronized 关键字"></a>6. synchronized 关键字</h3><blockquote><p>确保线程互斥的访问同步代码</p></blockquote><h4 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h4><p>synchronized 是JVM实现的一种锁，其中锁的获取和释放分别是<br>monitorenter 和 monitorexit 指令，该锁在实现上分为了偏向锁、轻量级锁和重量级锁，其中偏向锁在 java1.6 是默认开启的，轻量级锁在多线程竞争的情况下会膨胀成重量级锁，有关锁的数据都保存在对象头中</p><h4 id="6-2-原理"><a href="#6-2-原理" class="headerlink" title="6.2 原理"></a>6.2 原理</h4><p>加了 synchronized 关键字的代码段，生成的字节码文件会多出 monitorenter 和 monitorexit 两条指令（利用javap -verbose 字节码文件可看到关，关于这两条指令的文档如下：</p><ul><li><p>monitorenter<br>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:<br>• If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.<br>• If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.<br>• If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership.​</p></li><li><p>monitorexit<br>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.<br>The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.​​</p></li></ul><p>加了 synchronized 关键字的方法，生成的字节码文件中会多一个 ACC_SYNCHRONIZED 标志位，当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。</p><h4 id="6-3-关于使用"><a href="#6-3-关于使用" class="headerlink" title="6.3 关于使用"></a>6.3 关于使用</h4><ul><li>修饰普通方法<br>同步对象是实例对象</li><li>修饰静态方法<br>同步对象是类本身</li><li>修饰代码块<br>可以自己设置同步对象​</li></ul><h4 id="6-4-缺点"><a href="#6-4-缺点" class="headerlink" title="6.4 缺点"></a>6.4 缺点</h4><p>会让没有得到锁的资源进入Block状态，争夺到资源之后又转为Running状态，这个过程涉及到操作系统用户模式和内核模式的切换，代价比较高。Java1.6为 synchronized 做了优化，增加了从偏向锁到轻量级锁再到重量级锁的过度，但是在最终转变为重量级锁之后，性能仍然较低。</p><h3 id="7-CAS"><a href="#7-CAS" class="headerlink" title="7. CAS"></a>7. CAS</h3><blockquote><p>AtomicBoolean，AtomicInteger，AtomicLong以及 Lock 相关类等底层就是用 CAS实现的，在一定程度上性能比 synchronized 更高。</p></blockquote><h4 id="7-1-什么是CAS"><a href="#7-1-什么是CAS" class="headerlink" title="7.1 什么是CAS"></a>7.1 什么是CAS</h4><p>CAS全称是Compare And Swap，即比较替换，是实现并发应用到的一种技术。操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。</p><h4 id="7-2-为什么会有CAS"><a href="#7-2-为什么会有CAS" class="headerlink" title="7.2 为什么会有CAS"></a>7.2 为什么会有CAS</h4><p>如果只是用 synchronized 来保证同步会存在以下问题<br>synchronized 是一种悲观锁，在使用上会造成一定的性能问题。在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。一个线程持有锁会导致其它所有需要此锁的线程挂起。</p><h4 id="7-3-实现原理"><a href="#7-3-实现原理" class="headerlink" title="7.3 实现原理"></a>7.3 实现原理</h4><p>Java不能直接的访问操作系统底层，是通过native方法（JNI）来访问。CAS底层通过Unsafe类实现原子性操作。</p><h4 id="7-4-存在的问题"><a href="#7-4-存在的问题" class="headerlink" title="7.4 存在的问题"></a>7.4 存在的问题</h4><ul><li>ABA问题<br>什么是ABA问题？比如有一个 int 类型的值 N 是 1<br>此时有三个线程想要去改变它：<br>线程A ​​：希望给 N 赋值为 2<br>线程B： 希望给 N 赋值为 2<br>线程C： 希望给 N 赋值为 1​​<br>此时线程A和线程B同时获取到N的值1，线程A率先得到系统资源，将 N 赋值为 2，线程 B 由于某种原因被阻塞住，线程C在线程A执行完后得到 N 的当前值2<br>此时的线程状态<br>线程A成功给 N 赋值为2<br>线程B获取到 N 的当前值 1 希望给他赋值为 2，处于阻塞状态<br>线程C获取当好 N 的当前值 2 ​​​​​希望给他赋值为1<br>​​<br>然后线程C成功给N赋值为1<br>​最后线程B得到了系统资源，又重新恢复了运行状态，​在阻塞之前线程B获取到的N的值是1，执行compare操作发现当前N的值与获取到的值相同（均为1），成功将N赋值为了2。<br>​<br>在这个过程中线程B获取到N的值是一个旧值​​，虽然和当前N的值相等，但是实际上N的值已经经历了一次 1到2到1的改变<br>上面这个例子就是典型的ABA问题​<br>怎样去解决ABA问题<br>给变量加一个版本号即可，在比较的时候不仅要比较当前变量的值 还需要比较当前变量的版本号。Java中AtomicStampedReference 就解决了这个问题</li><li>循环时间长开销大<br>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</li></ul><blockquote><p>CAS只能保证一个共享变量的原子操作</p></blockquote><h3 id="8-AbstractQueuedSynchronizer-AQS"><a href="#8-AbstractQueuedSynchronizer-AQS" class="headerlink" title="8. AbstractQueuedSynchronizer(AQS)"></a>8. AbstractQueuedSynchronizer(AQS)</h3><p>AQS抽象的队列式同步器，是一种基于状态（state）的链表管理方式。state 是用CAS去修改的。它是 java.util.concurrent 包中最重要的基石，要学习想学习 java.util.concurrent 包里的内容这个类是关键。 ReentrantLock​、CountDownLatcher、Semaphore 实现的原理就是基于AQS。想知道他怎么实现以及实现原理 可以参看这篇文章<a href="https://link.jianshu.com/?t=https%3A%2F%2Fwww.cnblogs.com%2Fwaterystone%2Fp%2F4920797.html" target="_blank" rel="noopener">https://www.cnblogs.com/waterystone/p/4920797.html</a></p><h3 id="9-Future"><a href="#9-Future" class="headerlink" title="9. Future"></a>9. Future</h3><p>在并发编程我们一般使用Runable去执行异步任务，然而这样做我们是不能拿到异步任务的返回值的，但是使用Future 就可以。使用Future很简单，只需把Runable换成FutureTask即可。使用上比较简单，这里不多做介绍。</p><h3 id="10-线程池"><a href="#10-线程池" class="headerlink" title="10. 线程池"></a>10. 线程池</h3><blockquote><p>如果我们使用线程的时候就去创建一个线程，虽然简单，但是存在很大的问题。如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。线程池通过复用可以大大减少线程频繁创建与销毁带来的性能上的损耗。</p></blockquote><p>Java中线程池的实现类 ThreadPoolExecutor，其构造函数的每一个参数的含义在注释上已经写得很清楚了，这里几个关键参数可以再简单说一下</p><ul><li>corePoolSize ：核心线程数即一直保留在线程池中的线程数量，即使处于闲置状态也不会被销毁。要设置 allowCoreThreadTimeOut 为 true，才会被销毁。</li><li>maximumPoolSize：线程池中允许存在的最大线程数</li><li>keepAliveTime ：非核心线程允许的最大闲置时间，超过这个时间就会本地销毁。</li><li>workQueue：用来存放任务的队列。<ul><li>SynchronousQueue：这个队列会让新添加的任务立即得到执行，如果线程池中所有的线程都在执行，那么就会去创建一个新的线程去执行这个任务。当使用这个队列的时候，maximumPoolSizes一般都会设置一个最大值 Integer.MAX_VALUE</li><li>LinkedBlockingQueue：这个队列是一个无界队列。怎么理解呢，就是有多少任务来我们就会执行多少任务，如果线程池中的线程小于corePoolSize ,我们就会创建一个新的线程去执行这个任务，如果线程池中的线程数等于corePoolSize，就会将任务放入队列中等待，由于队列大小没有限制所以也被称为无界队列。当使用这个队列的时候 maximumPoolSizes 不生效（线程池中线程的数量不会超过corePoolSize），所以一般都会设置为0。</li><li>ArrayBlockingQueue：这个队列是一个有界队列。可以设置队列的最大容量。当线程池中线程数大于或者等于 maximumPoolSizes 的时候，就会把任务放到这个队列中，当当前队列中的任务大于队列的最大容量就会丢弃掉该任务交由 RejectedExecutionHandler 处理。</li></ul></li></ul><p>最后，本文主要对Java并发编程开发需要的知识点作了简单的讲解，这里每一个知识点都可以用一篇文章去讲解，由于篇幅原因不能对每一个知识点都详细介绍，我相信通过本文你会对Java的并发编程会有更近一步的了解。如果您发现还有缺漏或者有错误的地方，可以在评论区补充，谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多关于Java并发的文章请参阅我的CSDN专栏：Java并发指南&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/21961.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21961.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关代码会放在我的的Github：&lt;a href=&quot;https://github.com/h2pl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Java并发编程一直是Java程序员必须懂但又是很难懂的技术内容。&lt;/p&gt;
&lt;p&gt;这里不仅仅是指使用简单的多线程编程，或者使用juc的某个类。当然这些都是并发编程的基本知识，除了使用这些工具以外，Java并发编程中涉及到的技术原理十分丰富。为了更好地把并发知识形成一个体系，也鉴于本人没有能力写出这类文章，于是参考几位并发编程专家的博客和书籍，做一个简单的整理和复习。&lt;/p&gt;
&lt;p&gt;本文只是简要的介绍和总结。详细的内容欢迎来我的专栏阅读，会有更多的系列文章。&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java并发" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://h2pl.github.io/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java集合详解8：Java集合类细节精讲</title>
    <link href="http://h2pl.github.io/2018/05/13/collection8/"/>
    <id>http://h2pl.github.io/2018/05/13/collection8/</id>
    <published>2018-05-12T16:03:42.000Z</published>
    <updated>2018-05-12T16:05:21.239Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来探索一下Java集合类中的一些技术细节。主要是对一些比较容易被遗漏和误解的知识点做一些讲解和补充。可能不全面，还请谅解。</p><p>本文参考：<a href="http://cmsblogs.com/?cat=5" target="_blank" rel="noopener">http://cmsblogs.com/?cat=5</a></p><p>具体代码在我的GitHub中可以找到</p><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p><p>文章首发于我的个人博客：</p><p><a href="https://h2pl.github.io/2018/05/13/collection8">https://h2pl.github.io/2018/05/13/collection8</a></p><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：</p><p><a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a></p><p>我的个人博客主要发原创文章，也欢迎浏览<br><a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><a id="more"></a><h1 id="初始容量"><a href="#初始容量" class="headerlink" title="初始容量"></a>初始容量</h1><p>集合是我们在Java编程中使用非常广泛的，它就像大海，海纳百川，像万能容器，盛装万物，而且这个大海，万能容器还可以无限变大（如果条件允许）。当这个海、容器的量变得非常大的时候，它的初始容量就会显得很重要了，因为挖海、扩容是需要消耗大量的人力物力财力的。</p><p>同样的道理，Collection的初始容量也显得异常重要。所以：对于已知的情景，请为集合指定初始容量。</p><pre><code>public static void main(String[] args) {    StudentVO student = null;    long begin1 = System.currentTimeMillis();    List&lt;StudentVO&gt; list1 = new ArrayList&lt;&gt;();    for(int i = 0 ; i &lt; 1000000; i++){        student = new StudentVO(i,&quot;chenssy_&quot;+i,i);        list1.add(student);    }    long end1 = System.currentTimeMillis();    System.out.println(&quot;list1 time：&quot; + (end1 - begin1));    long begin2 = System.currentTimeMillis();    List&lt;StudentVO&gt; list2 = new ArrayList&lt;&gt;(1000000);    for(int i = 0 ; i &lt; 1000000; i++){        student = new StudentVO(i,&quot;chenssy_&quot;+i,i);        list2.add(student);    }    long end2 = System.currentTimeMillis();    System.out.println(&quot;list2 time：&quot; + (end2 - begin2));}</code></pre><p>上面代码两个list都是插入1000000条数据，只不过list1没有没有申请初始化容量，而list2初始化容量1000000。那运行结果如下：</p><pre><code>list1 time：1638list2 time：921</code></pre><p>从上面的运行结果我们可以看出list2的速度是list1的两倍左右。在前面LZ就提过，ArrayList的扩容机制是比较消耗资源的。我们先看ArrayList的add方法：</p><pre><code>public boolean add(E e) {          ensureCapacity(size + 1);           elementData[size++] = e;          return true;      }  public void ensureCapacity(int minCapacity) {      modCount++;         //修改计数器    int oldCapacity = elementData.length;        //当前需要的长度超过了数组长度，进行扩容处理    if (minCapacity &gt; oldCapacity) {          Object oldData[] = elementData;          //新的容量 = 旧容量 * 1.5 + 1        int newCapacity = (oldCapacity * 3)/2 + 1;              if (newCapacity &lt; minCapacity)                  newCapacity = minCapacity;        //数组拷贝，生成新的数组       elementData = Arrays.copyOf(elementData, newCapacity);      }  }</code></pre><p>ArrayList每次新增一个元素，就会检测ArrayList的当前容量是否已经到达临界点，如果到达临界点则会扩容1.5倍。然而ArrayList的扩容以及数组的拷贝生成新的数组是相当耗资源的。所以若我们事先已知集合的使用场景，知道集合的大概范围，我们最好是指定初始化容量，这样对资源的利用会更加好，尤其是大数据量的前提下，效率的提升和资源的利用会显得更加具有优势。</p><h1 id="asList的缺陷"><a href="#asList的缺陷" class="headerlink" title="asList的缺陷"></a>asList的缺陷</h1><p>在实际开发过程中我们经常使用asList讲数组转换为List，这个方法使用起来非常方便，但是asList方法存在几个缺陷：</p><h2 id="避免使用基本数据类型数组转换为列表"><a href="#避免使用基本数据类型数组转换为列表" class="headerlink" title="避免使用基本数据类型数组转换为列表"></a>避免使用基本数据类型数组转换为列表</h2><p>使用8个基本类型数组转换为列表时会存在一个比较有味的缺陷。先看如下程序：</p><pre><code>public static void main(String[] args) {        int[] ints = {1,2,3,4,5};        List list = Arrays.asList(ints);        System.out.println(&quot;list&apos;size：&quot; + list.size());    }------------------------------------outPut：list&apos;size：1</code></pre><p>程序的运行结果并没有像我们预期的那样是5而是逆天的1，这是什么情况？先看源码：</p><pre><code>public static &lt;T&gt; List&lt;T&gt; asList(T... a) {        return new ArrayList&lt;&gt;(a);    }</code></pre><p>asList接受的参数是一个泛型的变长参数，我们知道基本数据类型是无法发型化的，也就是说8个基本类型是无法作为asList的参数的， 要想作为泛型参数就必须使用其所对应的包装类型。但是这个这个实例中为什么没有出错呢？</p><p>因为该实例是将int类型的数组当做其参数，而在Java中数组是一个对象，它是可以泛型化的。所以该例子是不会产生错误的。既然例子是将整个int类型的数组当做泛型参数，那么经过asList转换就只有一个int 的列表了。如下：</p><pre><code>public static void main(String[] args) {    int[] ints = {1,2,3,4,5};    List list = Arrays.asList(ints);    System.out.println(&quot;list 的类型:&quot; + list.get(0).getClass());    System.out.println(&quot;list.get(0) == ints：&quot; + list.get(0).equals(ints));}</code></pre><hr><p>outPut:<br>list 的类型:class [I<br>list.get(0) == ints：true<br>从这个运行结果我们可以充分证明list里面的元素就是int数组。弄清楚这点了，那么修改方法也就一目了然了：将int 改变为Integer。</p><pre><code>public static void main(String[] args) {        Integer[] ints = {1,2,3,4,5};        List list = Arrays.asList(ints);        System.out.println(&quot;list&apos;size：&quot; + list.size());        System.out.println(&quot;list.get(0) 的类型:&quot; + list.get(0).getClass());        System.out.println(&quot;list.get(0) == ints[0]：&quot; + list.get(0).equals(ints[0]));    }----------------------------------------outPut:list&apos;size：5list.get(0) 的类型:class java.lang.Integerlist.get(0) == ints[0]：true</code></pre><h2 id="asList产生的列表不可操作"><a href="#asList产生的列表不可操作" class="headerlink" title="asList产生的列表不可操作"></a>asList产生的列表不可操作</h2><p>对于上面的实例我们再做一个小小的修改：</p><pre><code>public static void main(String[] args) {        Integer[] ints = {1,2,3,4,5};        List list = Arrays.asList(ints);        list.add(6);    }</code></pre><p>该实例就是讲ints通过asList转换为list 类别，然后再通过add方法加一个元素，这个实例简单的不能再简单了，但是运行结果呢？打出我们所料：</p><pre><code>Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException    at java.util.AbstractList.add(Unknown Source)    at java.util.AbstractList.add(Unknown Source)    at com.chenssy.test.arrayList.AsListTest.main(AsListTest.java:10)</code></pre><p>运行结果尽然抛出UnsupportedOperationException异常，该异常表示list不支持add方法。这就让我们郁闷了，list怎么可能不支持add方法呢？难道jdk脑袋堵塞了？我们再看asList的源码：</p><pre><code>public static &lt;T&gt; List&lt;T&gt; asList(T... a) {        return new ArrayList&lt;&gt;(a);    }</code></pre><p>asList接受参数后，直接new 一个ArrayList，到这里看应该是没有错误的啊？别急，再往下看:</p><pre><code>private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;    implements RandomAccess, java.io.Serializable{        private static final long serialVersionUID = -2764017481108945198L;        private final E[] a;        ArrayList(E[] array) {            if (array==null)                throw new NullPointerException();            a = array;        }        //.................    }</code></pre><p>这是ArrayList的源码,从这里我们可以看出,此ArrayList不是java.util.ArrayList，他是Arrays的内部类。</p><p>该内部类提供了size、toArray、get、set、indexOf、contains方法，而像add、remove等改变list结果的方法从AbstractList父类继承过来，同时这些方法也比较奇葩，它直接抛出UnsupportedOperationException异常：</p><pre><code>public boolean add(E e) {        add(size(), e);        return true;    }    public E set(int index, E element) {        throw new UnsupportedOperationException();    }    public void add(int index, E element) {        throw new UnsupportedOperationException();    }    public E remove(int index) {        throw new UnsupportedOperationException();    }</code></pre><p>通过这些代码可以看出asList返回的列表只不过是一个披着list的外衣，它并没有list的基本特性（变长）。该list是一个长度不可变的列表，传入参数的数组有多长，其返回的列表就只能是多长。所以：：不要试图改变asList返回的列表，否则你会自食苦果。</p><h1 id="subList的缺陷"><a href="#subList的缺陷" class="headerlink" title="subList的缺陷"></a>subList的缺陷</h1><p>我们经常使用subString方法来对String对象进行分割处理，同时我们也可以使用subList、subMap、subSet来对List、Map、Set进行分割处理，但是这个分割存在某些瑕疵。</p><h2 id="subList返回仅仅只是一个视图"><a href="#subList返回仅仅只是一个视图" class="headerlink" title="subList返回仅仅只是一个视图"></a>subList返回仅仅只是一个视图</h2><p>首先我们先看如下实例：</p><p>public static void main(String[] args) {<br>        List<integer> list1 = new ArrayList<integer>();<br>        list1.add(1);<br>        list1.add(2);</integer></integer></p><pre><code>    //通过构造函数新建一个包含list1的列表 list2    List&lt;Integer&gt; list2 = new ArrayList&lt;Integer&gt;(list1);    //通过subList生成一个与list1一样的列表 list3    List&lt;Integer&gt; list3 = list1.subList(0, list1.size());    //修改list3    list3.add(3);    System.out.println(&quot;list1 == list2：&quot; + list1.equals(list2));    System.out.println(&quot;list1 == list3：&quot; + list1.equals(list3));}</code></pre><p>这个例子非常简单，无非就是通过构造函数、subList重新生成一个与list1一样的list，然后修改list3，最后比较list1 == list2?、list1 == list3?。</p><p>按照我们常规的思路应该是这样的：因为list3通过add新增了一个元素，那么它肯定与list1不等，而list2是通过list1构造出来的，所以应该相等，所以结果应该是：</p><pre><code>list1 == list2：truelist1 == list3: false</code></pre><p>首先我们先不论结果的正确与否，我们先看subList的源码：</p><pre><code>public List&lt;E&gt; subList(int fromIndex, int toIndex) {        subListRangeCheck(fromIndex, toIndex, size);        return new SubList(this, 0, fromIndex, toIndex);}</code></pre><p>subListRangeCheck方式是判断fromIndex、toIndex是否合法，如果合法就直接返回一个subList对象，注意在产生该new该对象的时候传递了一个参数 this ，该参数非常重要，因为他代表着原始list。</p><p>/**</p><pre><code> * 继承AbstractList类，实现RandomAccess接口 */private class SubList extends AbstractList&lt;E&gt; implements RandomAccess {    private final AbstractList&lt;E&gt; parent;    //列表    private final int parentOffset;       private final int offset;    int size;    //构造函数    SubList(AbstractList&lt;E&gt; parent,            int offset, int fromIndex, int toIndex) {        this.parent = parent;        this.parentOffset = fromIndex;        this.offset = offset + fromIndex;        this.size = toIndex - fromIndex;        this.modCount = ArrayList.this.modCount;    }    //set方法    public E set(int index, E e) {        rangeCheck(index);        checkForComodification();        E oldValue = ArrayList.this.elementData(offset + index);        ArrayList.this.elementData[offset + index] = e;        return oldValue;    }    //get方法    public E get(int index) {        rangeCheck(index);        checkForComodification();        return ArrayList.this.elementData(offset + index);    }    //add方法    public void add(int index, E e) {        rangeCheckForAdd(index);        checkForComodification();        parent.add(parentOffset + index, e);        this.modCount = parent.modCount;        this.size++;    }    //remove方法    public E remove(int index) {        rangeCheck(index);        checkForComodification();        E result = parent.remove(parentOffset + index);        this.modCount = parent.modCount;        this.size--;        return result;    }}</code></pre><p>该SubLsit是ArrayList的内部类，它与ArrayList一样，都是继承AbstractList和实现RandomAccess接口。同时也提供了get、set、add、remove等list常用的方法。但是它的构造函数有点特殊，在该构造函数中有两个地方需要注意：</p><p>1、this.parent = parent;而parent就是在前面传递过来的list，也就是说this.parent就是原始list的引用。</p><p>2、this.offset = offset + fromIndex;this.parentOffset = fromIndex;。同时在构造函数中它甚至将modCount（fail-fast机制）传递过来了。</p><p>我们再看get方法，在get方法中return ArrayList.this.elementData(offset + index);</p><p>这段代码可以清晰表明get所返回就是原列表offset + index位置的元素。同样的道理还有add方法里面的：</p><p>parent.add(parentOffset + index, e);<br>this.modCount = parent.modCount;<br>remove方法里面的</p><p>E result = parent.remove(parentOffset + index);<br>this.modCount = parent.modCount;</p><p>诚然，到了这里我们可以判断subList返回的SubList同样也是AbstractList的子类，同时它的方法如get、set、add、remove等都是在原列表上面做操作，它并没有像subString一样生成一个新的对象。</p><p>所以subList返回的只是原列表的一个视图，它所有的操作最终都会作用在原列表上。</p><p>那么从这里的分析我们可以得出上面的结果应该恰恰与我们上面的答案相反：</p><p>list1 == list2：false<br>list1 == list3：true</p><h2 id="subList生成子列表后，不要试图去操作原列表"><a href="#subList生成子列表后，不要试图去操作原列表" class="headerlink" title="subList生成子列表后，不要试图去操作原列表"></a>subList生成子列表后，不要试图去操作原列表</h2><p>从上面我们知道subList生成的子列表只是原列表的一个视图而已，如果我们操作子列表它产生的作用都会在原列表上面表现，但是如果我们操作原列表会产生什么情况呢？</p><p>public static void main(String[] args) {<br>        List<integer> list1 = new ArrayList<integer>();<br>        list1.add(1);<br>        list1.add(2);</integer></integer></p><pre><code>    //通过subList生成一个与list1一样的列表 list3    List&lt;Integer&gt; list3 = list1.subList(0, list1.size());    //修改list1    list1.add(3);    System.out.println(&quot;list1&apos;size：&quot; + list1.size());    System.out.println(&quot;list3&apos;size：&quot; + list3.size());}</code></pre><p>该实例如果不产生意外，那么他们两个list的大小都应该都是3，但是偏偏事与愿违，事实上我们得到的结果是这样的：</p><pre><code>list1&apos;size：3Exception in thread &quot;main&quot; java.util.ConcurrentModificationException    at java.util.ArrayList$SubList.checkForComodification(Unknown Source)    at java.util.ArrayList$SubList.size(Unknown Source)    at com.chenssy.test.arrayList.SubListTest.main(SubListTest.java:17)</code></pre><p>list1正常输出，但是list3就抛出ConcurrentModificationException异常，看过我另一篇博客的同仁肯定对这个异常非常，fail-fast？不错就是fail-fast机制，在fail-fast机制中，LZ花了很多力气来讲述这个异常，所以这里LZ就不对这个异常多讲了。我们再看size方法：</p><pre><code>public int size() {            checkForComodification();            return this.size;        }</code></pre><p>size方法首先会通过checkForComodification验证，然后再返回this.size。</p><pre><code>private void checkForComodification() {            if (ArrayList.this.modCount != this.modCount)                throw new ConcurrentModificationException();        }</code></pre><p>该方法表明当原列表的modCount与this.modCount不相等时就会抛出ConcurrentModificationException。</p><p>同时我们知道modCount 在new的过程中 “继承”了原列表modCount，只有在修改该列表（子列表）时才会修改该值（先表现在原列表后作用于子列表）。</p><p>而在该实例中我们是操作原列表，原列表的modCount当然不会反应在子列表的modCount上啦，所以才会抛出该异常。</p><p>对于子列表视图，它是动态生成的，生成之后就不要操作原列表了，否则必然都导致视图的不稳定而抛出异常。最好的办法就是将原列表设置为只读状态，要操作就操作子列表：</p><p>//通过subList生成一个与list1一样的列表 list3</p><pre><code>List&lt;Integer&gt; list3 = list1.subList(0, list1.size());</code></pre><p>//对list1设置为只读状态</p><pre><code>list1 = Collections.unmodifiableList(list1);</code></pre><h2 id="推荐使用subList处理局部列表"><a href="#推荐使用subList处理局部列表" class="headerlink" title="推荐使用subList处理局部列表"></a>推荐使用subList处理局部列表</h2><p>在开发过程中我们一定会遇到这样一个问题：获取一堆数据后，需要删除某段数据。例如，有一个列表存在1000条记录，我们需要删除100-200位置处的数据，可能我们会这样处理：</p><pre><code>for(int i = 0 ; i &lt; list1.size() ; i++){   if(i &gt;= 100 &amp;&amp; i &lt;= 200){       list1.remove(i);       /*        * 当然这段代码存在问题，list remove之后后面的元素会填充上来，         * 所以需要对i进行简单的处理，当然这个不是这里讨论的问题。         */   }}</code></pre><p>这个应该是我们大部分人的处理方式吧，其实还有更好的方法，利用subList。在前面LZ已经讲过，子列表的操作都会反映在原列表上。所以下面一行代码全部搞定：</p><pre><code>list1.subList(100, 200).clear();</code></pre><p>简单而不失华丽！！！！！</p><h1 id="保持compareTo和equals同步"><a href="#保持compareTo和equals同步" class="headerlink" title="保持compareTo和equals同步"></a>保持compareTo和equals同步</h1><p>在Java中我们常使用Comparable接口来实现排序，其中compareTo是实现该接口方法。我们知道compareTo返回0表示两个对象相等，返回正数表示大于，返回负数表示小于。同时我们也知道equals也可以判断两个对象是否相等，那么他们两者之间是否存在关联关系呢？</p><pre><code>public class Student implements Comparable&lt;Student&gt;{    private String id;    private String name;    private int age;    public Student(String id,String name,int age){        this.id = id;        this.name = name;        this.age = age;    }    public boolean equals(Object obj){        if(obj == null){            return false;        }        if(this == obj){            return true;        }        if(obj.getClass() != this.getClass()){            return false;        }        Student student = (Student)obj;        if(!student.getName().equals(getName())){            return false;        }        return true;    }    public int compareTo(Student student) {        return this.age - student.age;    }    /** 省略getter、setter方法 */}</code></pre><p>Student类实现Comparable接口和实现equals方法，其中compareTo是根据age来比对的，equals是根据name来比对的。</p><pre><code>public static void main(String[] args){        List&lt;Student&gt; list = new ArrayList&lt;&gt;();        list.add(new Student(&quot;1&quot;, &quot;chenssy1&quot;, 24));        list.add(new Student(&quot;2&quot;, &quot;chenssy1&quot;, 26));        Collections.sort(list);   //排序        Student student = new Student(&quot;2&quot;, &quot;chenssy1&quot;, 26);        //检索student在list中的位置        int index1 = list.indexOf(student);        int index2 = Collections.binarySearch(list, student);        System.out.println(&quot;index1 = &quot; + index1);        System.out.println(&quot;index2 = &quot; + index2);    }</code></pre><p>按照常规思路来说应该两者index是一致的，因为他们检索的是同一个对象，但是非常遗憾，其运行结果：</p><p>index1 = 0<br>index2 = 1</p><blockquote><p>为什么会产生这样不同的结果呢？这是因为indexOf和binarySearch的实现机制不同。</p><p>indexOf是基于equals来实现的只要equals返回TRUE就认为已经找到了相同的元素。</p><p>而binarySearch是基于compareTo方法的，当compareTo返回0 时就认为已经找到了该元素。</p></blockquote><p>在我们实现的Student类中我们覆写了compareTo和equals方法，但是我们的compareTo、equals的比较依据不同，一个是基于age、一个是基于name。</p><p>比较依据不同那么得到的结果很有可能会不同。所以知道了原因，我们就好修改了：将两者之间的比较依据保持一致即可。</p><p>对于compareTo和equals两个方法我们可以总结为：compareTo是判断元素在排序中的位置是否相等，equals是判断元素是否相等，既然一个决定排序位置，一个决定相等，所以我们非常有必要确保当排序位置相同时，其equals也应该相等。</p><p>使其相等的方式就是两者应该依附于相同的条件。当compareto相等时equals也应该相等，而compareto不相等时equals不应该相等，并且compareto依据某些属性来决定排序。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们来探索一下Java集合类中的一些技术细节。主要是对一些比较容易被遗漏和误解的知识点做一些讲解和补充。可能不全面，还请谅解。&lt;/p&gt;
&lt;p&gt;本文参考：&lt;a href=&quot;http://cmsblogs.com/?cat=5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cmsblogs.com/?cat=5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/05/13/collection8&quot;&gt;https://h2pl.github.io/2018/05/13/collection8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的个人博客主要发原创文章，也欢迎浏览&lt;br&gt;&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java集合类" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
    
      <category term="Java集合框架" scheme="http://h2pl.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java集合详解7：HashSet，TreeSet与LinkedHashSet</title>
    <link href="http://h2pl.github.io/2018/05/12/collection7/"/>
    <id>http://h2pl.github.io/2018/05/12/collection7/</id>
    <published>2018-05-12T13:49:31.000Z</published>
    <updated>2018-05-12T13:58:34.705Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来探索一下HashSet，TreeSet与LinkedHashSet的基本原理与源码实现，由于这三个set都是基于之前文章的三个map进行实现的，所以推荐大家先看一下前面有关map的文章，结合使用味道更佳。</p><p>具体代码在我的GitHub中可以找到</p><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p><p>文章首发于我的个人博客：</p><p><a href="https://h2pl.github.io/2018/05/12/collection7">https://h2pl.github.io/2018/05/12/collection7</a></p><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：</p><p><a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a></p><p>我的个人博客主要发原创文章，也欢迎浏览<br><a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>本文参考<br><a href="http://cmsblogs.com/?p=599" target="_blank" rel="noopener">http://cmsblogs.com/?p=599</a></p><a id="more"></a><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><pre><code>public class HashSet&lt;E&gt;    extends AbstractSet&lt;E&gt;    implements Set&lt;E&gt;, Cloneable, java.io.Serializable</code></pre><p>HashSet继承AbstractSet类，实现Set、Cloneable、Serializable接口。其中AbstractSet提供 Set 接口的骨干实现，从而最大限度地减少了实现此接口所需的工作。<br>==Set接口是一种不包括重复元素的Collection，它维持它自己的内部排序，所以随机访问没有任何意义。==</p><p>本文基于1.8jdk进行源码分析。</p><p> 基本属性</p><p>基于HashMap实现，底层使用HashMap保存所有元素</p><pre><code>private transient HashMap&lt;E,Object&gt; map;//定义一个Object对象作为HashMap的valueprivate static final Object PRESENT = new Object();</code></pre><p> 构造函数</p><pre><code>/**     * 默认构造函数     * 初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。     */    public HashSet() {        map = new HashMap&lt;&gt;();    }    /**     * 构造一个包含指定 collection 中的元素的新 set。     */    public HashSet(Collection&lt;? extends E&gt; c) {        map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16));        addAll(c);    }    /**     * 构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和指定的加载因子     */    public HashSet(int initialCapacity, float loadFactor) {        map = new HashMap&lt;&gt;(initialCapacity, loadFactor);    }    /**     * 构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和默认的加载因子（0.75）。     */    public HashSet(int initialCapacity) {       map = new HashMap&lt;&gt;(initialCapacity);    }    /**     * 在API中我没有看到这个构造函数，今天看源码才发现（原来访问权限为包权限，不对外公开的）     * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。     * dummy 为标识 该构造函数主要作用是对LinkedHashSet起到一个支持作用     */    HashSet(int initialCapacity, float loadFactor, boolean dummy) {       map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);    } 从构造函数中可以看出HashSet所有的构造都是构造出一个新的HashMap，其中最后一个构造函数，为包访问权限是不对外公开，仅仅只在使用LinkedHashSet时才会发生作用。</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p> 既然HashSet是基于HashMap，那么对于HashSet而言，其方法的实现过程是非常简单的。</p><pre><code>public Iterator&lt;E&gt; iterator() {        return map.keySet().iterator();    }</code></pre><blockquote><p>iterator()方法返回对此 set 中元素进行迭代的迭代器。返回元素的顺序并不是特定的。</p><p>底层调用HashMap的keySet返回所有的key，这点反应了HashSet中的所有元素都是保存在HashMap的key中，value则是使用的PRESENT对象，该对象为static final。</p></blockquote><pre><code>public int size() {        return map.size();    }   size()返回此 set 中的元素的数量（set 的容量）。底层调用HashMap的size方法，返回HashMap容器的大小。public boolean isEmpty() {        return map.isEmpty();    }    isEmpty()，判断HashSet()集合是否为空，为空返回 true，否则返回false。public boolean contains(Object o) {        return map.containsKey(o);}public boolean containsKey(Object key) {    return getNode(hash(key), key) != null;}//最终调用该方法进行节点查找final Node&lt;K,V&gt; getNode(int hash, Object key) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;    //先检查桶的头结点是否存在    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (first = tab[(n - 1) &amp; hash]) != null) {        if (first.hash == hash &amp;&amp; // always check first node            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))            return first;            //不是头结点，则遍历链表，如果是树节点则使用树节点的方法遍历，直到找到，或者为null        if ((e = first.next) != null) {            if (first instanceof TreeNode)                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            do {                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    return e;            } while ((e = e.next) != null);        }    }    return null;}</code></pre><p>contains()，判断某个元素是否存在于HashSet()中，存在返回true，否则返回false。更加确切的讲应该是要满足这种关系才能返回true：(o==null ? e==null : o.equals(e))。底层调用containsKey判断HashMap的key值是否为空。</p><pre><code>public boolean add(E e) {        return map.put(e, PRESENT)==null;}public V put(K key, V value) {    return putVal(hash(key), key, value, false, true);}map的put方法：final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    //确认初始化    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length;    //如果桶为空，直接插入新元素，也就是entry    if ((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null);    else {        Node&lt;K,V&gt; e; K k;        //如果冲突，分为三种情况        //key相等时让旧entry等于新entry即可        if (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            e = p;        //红黑树情况        else if (p instanceof TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        else {            //如果key不相等，则连成链表            for (int binCount = 0; ; ++binCount) {                if ((e = p.next) == null) {                    p.next = newNode(hash, key, value, null);                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        treeifyBin(tab, hash);                    break;                }                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    break;                p = e;            }        }        if (e != null) { // existing mapping for key            V oldValue = e.value;            if (!onlyIfAbsent || oldValue == null)                e.value = value;            afterNodeAccess(e);            return oldValue;        }    }    ++modCount;    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;}</code></pre><blockquote><p>这里注意一点，hashset只是不允许重复的元素加入，而不是不允许元素连成链表，因为只要key的equals方法判断为true时它们是相等的，此时会发生value的替换，因为所有entry的value一样，所以和没有插入时一样的。</p><p>而当两个hashcode相同但key不相等的entry插入时，仍然会连成一个链表，长度超过8时依然会和hashmap一样扩展成红黑树，看完源码之后笔者才明白自己之前理解错了。所以看源码还是蛮有好处的。hashset基本上就是使用hashmap的方法再次实现了一遍而已，只不过value全都是同一个object，让你以为相同元素没有插入，事实上只是value替换成和原来相同的值而已。</p></blockquote><p>当add方法发生冲突时，如果key相同，则替换value，如果key不同，则连成链表。       </p><p>add()如果此 set 中尚未包含指定元素，则添加指定元素。如果此Set没有包含满足(e==null ? e2==null : e.equals(e2)) 的e2时，则将e2添加到Set中，否则不添加且返回false。</p><p>由于底层使用HashMap的put方法将key = e，value=PRESENT构建成key-value键值对，当此e存在于HashMap的key中，则value将会覆盖原有value，但是key保持不变，所以如果将一个已经存在的e元素添加中HashSet中，新添加的元素是不会保存到HashMap中，所以这就满足了HashSet中元素不会重复的特性。</p><pre><code>public boolean remove(Object o) {    return map.remove(o)==PRESENT;}</code></pre><p>remove如果指定元素存在于此 set 中，则将其移除。底层使用HashMap的remove方法删除指定的Entry。</p><pre><code>public void clear() {    map.clear();}</code></pre><p>clear从此 set 中移除所有元素。底层调用HashMap的clear方法清除所有的Entry。</p><pre><code>public Object clone() {        try {            HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone();            newSet.map = (HashMap&lt;E, Object&gt;) map.clone();            return newSet;        } catch (CloneNotSupportedException e) {            throw new InternalError();        }    }</code></pre><p>clone返回此 HashSet 实例的浅表副本：并没有复制这些元素本身。</p><p>后记：</p><blockquote><p>由于HashSet底层使用了HashMap实现，使其的实现过程变得非常简单，如果你对HashMap比较了解，那么HashSet简直是小菜一碟。有两个方法对HashMap和HashSet而言是非常重要的，下篇将详细讲解hashcode和equals。</p></blockquote><h1 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h1><p>与HashSet是基于HashMap实现一样，TreeSet同样是基于TreeMap实现的。在《Java提高篇（二七）—–TreeMap》中LZ详细讲解了TreeMap实现机制，如果客官详情看了这篇博文或者多TreeMap有比较详细的了解，那么TreeSet的实现对您是喝口水那么简单。</p><h2 id="TreeSet定义"><a href="#TreeSet定义" class="headerlink" title="TreeSet定义"></a>TreeSet定义</h2><p>我们知道TreeMap是一个有序的二叉树，那么同理TreeSet同样也是一个有序的，它的作用是提供有序的Set集合。通过源码我们知道TreeSet基础AbstractSet，实现NavigableSet、Cloneable、Serializable接口。</p><p>其中AbstractSet提供 Set 接口的骨干实现，从而最大限度地减少了实现此接口所需的工作。</p><p>NavigableSet是扩展的 SortedSet，具有了为给定搜索目标报告最接近匹配项的导航方法，这就意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。Cloneable支持克隆，Serializable支持序列化。</p><pre><code>public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;    implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable</code></pre><p>同时在TreeSet中定义了如下几个变量。</p><pre><code>private transient NavigableMap&lt;E,Object&gt; m;//PRESENT会被当做Map的value与key构建成键值对 private static final Object PRESENT = new Object();</code></pre><p>其构造方法：</p><pre><code>//默认构造方法，根据其元素的自然顺序进行排序public TreeSet() {    this(new TreeMap&lt;E,Object&gt;());}//构造一个包含指定 collection 元素的新 TreeSet，它按照其元素的自然顺序进行排序。public TreeSet(Comparator&lt;? super E&gt; comparator) {        this(new TreeMap&lt;&gt;(comparator));}//构造一个新的空 TreeSet，它根据指定比较器进行排序。public TreeSet(Collection&lt;? extends E&gt; c) {    this();    addAll(c);}//构造一个与指定有序 set 具有相同映射关系和相同排序的新 TreeSet。public TreeSet(SortedSet&lt;E&gt; s) {    this(s.comparator());    addAll(s);}TreeSet(NavigableMap&lt;E,Object&gt; m) {    this.m = m;}</code></pre><p>二、TreeSet主要方法</p><p>1、add：将指定的元素添加到此 set（如果该元素尚未存在于 set 中）。</p><pre><code>public boolean add(E e) {        return m.put(e, PRESENT)==null;    }public V put(K key, V value) {    Entry&lt;K,V&gt; t = root;    if (t == null) {    //空树时，判断节点是否为空        compare(key, key); // type (and possibly null) check        root = new Entry&lt;&gt;(key, value, null);        size = 1;        modCount++;        return null;    }    int cmp;    Entry&lt;K,V&gt; parent;    // split comparator and comparable paths    Comparator&lt;? super K&gt; cpr = comparator;    //非空树，根据传入比较器进行节点的插入位置查找    if (cpr != null) {        do {            parent = t;            //节点比根节点小，则找左子树，否则找右子树            cmp = cpr.compare(key, t.key);            if (cmp &lt; 0)                t = t.left;            else if (cmp &gt; 0)                t = t.right;                //如果key的比较返回值相等，直接更新值（一般compareto相等时equals方法也相等）            else                return t.setValue(value);        } while (t != null);    }    else {    //如果没有传入比较器，则按照自然排序        if (key == null)            throw new NullPointerException();        @SuppressWarnings(&quot;unchecked&quot;)            Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;        do {            parent = t;            cmp = k.compareTo(t.key);            if (cmp &lt; 0)                t = t.left;            else if (cmp &gt; 0)                t = t.right;            else                return t.setValue(value);        } while (t != null);    }    //查找的节点为空，直接插入，默认为红节点    Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);    if (cmp &lt; 0)        parent.left = e;    else        parent.right = e;        //插入后进行红黑树调整    fixAfterInsertion(e);    size++;    modCount++;    return null;}    </code></pre><p>2、get：获取元素</p><pre><code>public V get(Object key) {    Entry&lt;K,V&gt; p = getEntry(key);    return (p==null ? null : p.value);}</code></pre><p>该方法与put的流程类似，只不过是把插入换成了查找</p><p>3、ceiling：返回此 set 中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 null。</p><pre><code>public E ceiling(E e) {        return m.ceilingKey(e);    }</code></pre><p>4、clear：移除此 set 中的所有元素。</p><pre><code>public void clear() {        m.clear();    }</code></pre><p>5、clone：返回 TreeSet 实例的浅表副本。属于浅拷贝。</p><pre><code>public Object clone() {        TreeSet&lt;E&gt; clone = null;        try {            clone = (TreeSet&lt;E&gt;) super.clone();        } catch (CloneNotSupportedException e) {            throw new InternalError();        }        clone.m = new TreeMap&lt;&gt;(m);        return clone;    }</code></pre><p>6、comparator：返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的自然顺序，则返回 null。</p><pre><code>public Comparator&lt;? super E&gt; comparator() {        return m.comparator();    }</code></pre><p>7、contains：如果此 set 包含指定的元素，则返回 true。</p><pre><code>public boolean contains(Object o) {        return m.containsKey(o);    }</code></pre><p>8、descendingIterator：返回在此 set 元素上按降序进行迭代的迭代器。</p><pre><code>public Iterator&lt;E&gt; descendingIterator() {        return m.descendingKeySet().iterator();    }</code></pre><p>9、descendingSet：返回此 set 中所包含元素的逆序视图。</p><pre><code>public NavigableSet&lt;E&gt; descendingSet() {        return new TreeSet&lt;&gt;(m.descendingMap());    }</code></pre><p>10、first：返回此 set 中当前第一个（最低）元素。</p><pre><code>public E first() {        return m.firstKey();    }</code></pre><p>11、floor：返回此 set 中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 null。</p><pre><code>public E floor(E e) {        return m.floorKey(e);    }</code></pre><p>12、headSet：返回此 set 的部分视图，其元素严格小于 toElement。</p><pre><code>public SortedSet&lt;E&gt; headSet(E toElement) {        return headSet(toElement, false);    }</code></pre><p>13、higher：返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。</p><pre><code>public E higher(E e) {        return m.higherKey(e);    }</code></pre><p>14、isEmpty：如果此 set 不包含任何元素，则返回 true。</p><pre><code>public boolean isEmpty() {        return m.isEmpty();    }</code></pre><p>15、iterator：返回在此 set 中的元素上按升序进行迭代的迭代器。</p><pre><code>public Iterator&lt;E&gt; iterator() {        return m.navigableKeySet().iterator();    }</code></pre><p>16、last：返回此 set 中当前最后一个（最高）元素。</p><pre><code>public E last() {        return m.lastKey();    }</code></pre><p>17、lower：返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。</p><pre><code>public E lower(E e) {        return m.lowerKey(e);    }</code></pre><p>18、pollFirst：获取并移除第一个（最低）元素；如果此 set 为空，则返回 null。</p><pre><code>public E pollFirst() {        Map.Entry&lt;E,?&gt; e = m.pollFirstEntry();        return (e == null) ? null : e.getKey();    }</code></pre><p>19、pollLast：获取并移除最后一个（最高）元素；如果此 set 为空，则返回 null。</p><pre><code>public E pollLast() {        Map.Entry&lt;E,?&gt; e = m.pollLastEntry();        return (e == null) ? null : e.getKey();    }</code></pre><p>20、remove：将指定的元素从 set 中移除（如果该元素存在于此 set 中）。</p><pre><code>public boolean remove(Object o) {        return m.remove(o)==PRESENT;    }</code></pre><p>该方法与put类似，只不过把插入换成了删除，并且要进行删除后调整</p><p>21、size：返回 set 中的元素数（set 的容量）。</p><pre><code>public int size() {        return m.size();    }</code></pre><p>22、subSet：返回此 set 的部分视图</p><pre><code>/**     * 返回此 set 的部分视图，其元素范围从 fromElement 到 toElement。     */     public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive,             E toElement,   boolean toInclusive) {             return new TreeSet&lt;&gt;(m.subMap(fromElement, fromInclusive,                  toElement,   toInclusive));     }     /**      * 返回此 set 的部分视图，其元素从 fromElement（包括）到 toElement（不包括）。      */     public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) {         return subSet(fromElement, true, toElement, false);     }</code></pre><p>23、tailSet：返回此 set 的部分视图</p><pre><code>/**     * 返回此 set 的部分视图，其元素大于（或等于，如果 inclusive 为 true）fromElement。     */    public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) {        return new TreeSet&lt;&gt;(m.tailMap(fromElement, inclusive));    }    /**     * 返回此 set 的部分视图，其元素大于等于 fromElement。     */    public SortedSet&lt;E&gt; tailSet(E fromElement) {        return tailSet(fromElement, true);    }</code></pre><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>由于TreeSet是基于TreeMap实现的，所以如果我们对treeMap有了一定的了解，对TreeSet那是小菜一碟，我们从TreeSet中的源码可以看出，其实现过程非常简单，几乎所有的方法实现全部都是基于TreeMap的。</p><h1 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h1><h2 id="LinkedHashSet内部是如何工作的"><a href="#LinkedHashSet内部是如何工作的" class="headerlink" title="LinkedHashSet内部是如何工作的"></a>LinkedHashSet内部是如何工作的</h2><p>LinkedHashSet是HashSet的一个“扩展版本”，HashSet并不管什么顺序，不同的是LinkedHashSet会维护“插入顺序”。HashSet内部使用HashMap对象来存储它的元素，而LinkedHashSet内部使用LinkedHashMap对象来存储和处理它的元素。这篇文章，我们将会看到LinkedHashSet内部是如何运作的及如何维护插入顺序的。</p><p>我们首先着眼LinkedHashSet的构造函数。在LinkedHashSet类中一共有4个构造函数。这些构造函数都只是简单地调用父类构造函数（如HashSet类的构造函数）。<br>下面看看LinkedHashSet的构造函数是如何定义的。</p><pre><code>//Constructor - 1public LinkedHashSet(int initialCapacity, float loadFactor){      super(initialCapacity, loadFactor, true);              //Calling super class constructor}//Constructor - 2public LinkedHashSet(int initialCapacity){        super(initialCapacity, .75f, true);             //Calling super class constructor}//Constructor - 3public LinkedHashSet(){        super(16, .75f, true);                //Calling super class constructor}//Constructor - 4public LinkedHashSet(Collection&lt;? extends E&gt; c){        super(Math.max(2*c.size(), 11), .75f, true);          //Calling super class constructor        addAll(c);}</code></pre><p>在上面的代码片段中，你可能注意到4个构造函数调用的是同一个父类的构造函数。这个构造函数（父类的，译者注）是一个包内私有构造函数（见下面的代码，HashSet的构造函数没有使用public公开，译者注），它只能被LinkedHashSet使用。</p><p>这个构造函数需要初始容量，负载因子和一个boolean类型的哑值（没有什么用处的参数，作为标记，译者注）等参数。这个哑参数只是用来区别这个构造函数与HashSet的其他拥有初始容量和负载因子参数的构造函数，下面是这个构造函数的定义，</p><pre><code>HashSet(int initialCapacity, float loadFactor, boolean dummy){        map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);}</code></pre><p>显然，这个构造函数内部初始化了一个LinkedHashMap对象，这个对象恰好被LinkedHashSet用来存储它的元素。</p><p>LinkedHashSet并没有自己的方法，所有的方法都继承自它的父类HashSet，因此，对LinkedHashSet的所有操作方式就好像对HashSet操作一样。</p><p>唯一的不同是内部使用不同的对象去存储元素。在HashSet中，插入的元素是被当做HashMap的键来保存的，而在LinkedHashSet中被看作是LinkedHashMap的键。</p><p>这些键对应的值都是常量PRESENT（PRESENT是HashSet的静态成员变量，译者注）。</p><h2 id="LinkedHashSet是如何维护插入顺序的"><a href="#LinkedHashSet是如何维护插入顺序的" class="headerlink" title="LinkedHashSet是如何维护插入顺序的"></a>LinkedHashSet是如何维护插入顺序的</h2><blockquote><p>LinkedHashSet使用LinkedHashMap对象来存储它的元素，插入到LinkedHashSet中的元素实际上是被当作LinkedHashMap的键保存起来的。</p><p>LinkedHashMap的每一个键值对都是通过内部的静态类Entry&lt;K, V&gt;实例化的。这个 Entry&lt;K, V&gt;类继承了HashMap.Entry类。</p><p>这个静态类增加了两个成员变量，before和after来维护LinkedHasMap元素的插入顺序。这两个成员变量分别指向前一个和后一个元素，这让LinkedHashMap也有类似双向链表的表现。</p></blockquote><pre><code>private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt;{        // These fields comprise the doubly linked list used for iteration.        Entry&lt;K,V&gt; before, after;        Entry(int hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) {            super(hash, key, value, next);        }}</code></pre><p>从上面代码看到的LinkedHashMap内部类的前面两个成员变量——before和after负责维护LinkedHashSet的插入顺序。LinkedHashMap定义的成员变量header保存的是<br>这个双向链表的头节点。header的定义就像下面这样，</p><p>接下来看一个例子就知道LinkedHashSet内部是如何工作的了。</p><pre><code>public class LinkedHashSetExample{    public static void main(String[] args)    {        //Creating LinkedHashSet        LinkedHashSet&lt;String&gt; set = new LinkedHashSet&lt;String&gt;();        //Adding elements to LinkedHashSet        set.add(&quot;BLUE&quot;);        set.add(&quot;RED&quot;);        set.add(&quot;GREEN&quot;);            set.add(&quot;BLACK&quot;);    }}</code></pre><p>下面的图片展示了这个程序是如何运行的。</p><p><img src="https://segmentfault.com/img/remote/1460000004854595" alt="image"></p><p>如果你知道LinkedHashMap内部是如何工作的，就非常容易明白LinkedHashSet内部是如何工作的。看一遍LinkedHashSet和LinkedHashMap的源码，<br>你就能够准确地理解在Java中LinkedHashSet内部是如何工作的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们来探索一下HashSet，TreeSet与LinkedHashSet的基本原理与源码实现，由于这三个set都是基于之前文章的三个map进行实现的，所以推荐大家先看一下前面有关map的文章，结合使用味道更佳。&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/05/12/collection7&quot;&gt;https://h2pl.github.io/2018/05/12/collection7&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的个人博客主要发原创文章，也欢迎浏览&lt;br&gt;&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文参考&lt;br&gt;&lt;a href=&quot;http://cmsblogs.com/?p=599&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cmsblogs.com/?p=599&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java集合类" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
    
      <category term="Java集合框架" scheme="http://h2pl.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java集合详解6：TreeMap和红黑树</title>
    <link href="http://h2pl.github.io/2018/05/11/collection6/"/>
    <id>http://h2pl.github.io/2018/05/11/collection6/</id>
    <published>2018-05-11T15:26:05.000Z</published>
    <updated>2018-05-12T13:58:29.761Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来深入探索一下TreeMap和红黑树原理，并使用treemap的使用实例来模拟红黑树的插入删除和调整的操作。</p><p>具体代码在我的GitHub中可以找到</p><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p><p>文章首发于我的个人博客：</p><p><a href="https://h2pl.github.io/2018/05/11/collection5">https://h2pl.github.io/2018/05/11/collection5</a></p><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：</p><p><a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a></p><p>我的个人博客主要发原创文章，也欢迎浏览<br><a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>本来想写一下TreeMap的源码分析，无奈水平不够，谈到红黑树还是力不从心，于是转一篇五月仓颉的博文，加以学习。</p><p>原文地址<br><a href="http://www.cnblogs.com/xrq730/p/6867924.html。" target="_blank" rel="noopener">http://www.cnblogs.com/xrq730/p/6867924.html。</a></p><p>Java集合详解专栏地址：<br><a href="https://blog.csdn.net/column/details/21877.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21877.html</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们来深入探索一下TreeMap和红黑树原理，并使用treemap的使用实例来模拟红黑树的插入删除和调整的操作。&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/05/11/collection5&quot;&gt;https://h2pl.github.io/2018/05/11/collection5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的个人博客主要发原创文章，也欢迎浏览&lt;br&gt;&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本来想写一下TreeMap的源码分析，无奈水平不够，谈到红黑树还是力不从心，于是转一篇五月仓颉的博文，加以学习。&lt;/p&gt;
&lt;p&gt;原文地址&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/xrq730/p/6867924.html。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cnblogs.com/xrq730/p/6867924.html。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Java集合详解专栏地址：&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/21877.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/column/details/21877.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java集合类" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
    
      <category term="Java集合框架" scheme="http://h2pl.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java集合详解5：深入理解LinkedHashMap和LRU缓存</title>
    <link href="http://h2pl.github.io/2018/05/11/collection5/"/>
    <id>http://h2pl.github.io/2018/05/11/collection5/</id>
    <published>2018-05-11T13:58:17.000Z</published>
    <updated>2018-05-12T13:58:23.594Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来深入探索一下LinkedHashMap的底层原理，并且使用linkedhashmap来实现LRU缓存。</p><p>具体代码在我的GitHub中可以找到</p><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p><p>文章首发于我的个人博客：</p><p><a href="https://h2pl.github.io/2018/05/11/collection5">https://h2pl.github.io/2018/05/11/collection5</a></p><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：<a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a></p><p>我的个人博客主要发原创文章，也欢迎浏览<br><a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><a id="more"></a><p>摘要：</p><blockquote><p>HashMap和双向链表合二为一即是LinkedHashMap。所谓LinkedHashMap，其落脚点在HashMap，因此更准确地说，它是一个将所有Entry节点链入一个双向链表的HashMap。</p></blockquote><blockquote><p>由于LinkedHashMap是HashMap的子类，所以LinkedHashMap自然会拥有HashMap的所有特性。比如，LinkedHashMap的元素存取过程基本与HashMap基本类似，只是在细节实现上稍有不同。当然，这是由LinkedHashMap本身的特性所决定的，因为它额外维护了一个双向链表用于保持迭代顺序。</p></blockquote><blockquote><p>此外，LinkedHashMap可以很好的支持LRU算法，笔者在第七节便在LinkedHashMap的基础上实现了一个能够很好支持LRU的结构。</p></blockquote><p>友情提示：</p><blockquote><p>　　本文所有关于 LinkedHashMap 的源码都是基于 JDK 1.6 的，不同 JDK 版本之间也许会有些许差异，但不影响我们对 LinkedHashMap 的数据结构、原理等整体的把握和了解。后面会讲解1.8对于LinkedHashMap的改动。</p><p>　　由于 LinkedHashMap 是 HashMap 的子类，所以其具有HashMap的所有特性，这一点在源码共用上体现的尤为突出。因此，读者在阅读本文之前，最好对 HashMap 有一个较为深入的了解和回顾，否则很可能会导致事倍功半。可以参考我之前关于hashmap的文章。</p></blockquote><h2 id="LinkedHashMap-概述"><a href="#LinkedHashMap-概述" class="headerlink" title="LinkedHashMap 概述"></a>LinkedHashMap 概述</h2><blockquote><p>　　笔者曾提到，HashMap 是 Java Collection Framework 的重要成员，也是Map族(如下图所示)中我们最为常用的一种。不过遗憾的是，HashMap是无序的，也就是说，迭代HashMap所得到的元素顺序并不是它们最初放置到HashMap的顺序。</p></blockquote><blockquote><p>　　<br>　　HashMap的这一缺点往往会造成诸多不便，因为在有些场景中，我们确需要用到一个可以保持插入顺序的Map。庆幸的是，JDK为我们解决了这个问题，它为HashMap提供了一个子类 —— LinkedHashMap。虽然LinkedHashMap增加了时间和空间上的开销，但是它通过维护一个额外的双向链表保证了迭代顺序。　　</p></blockquote><blockquote><p>　　特别地，该迭代顺序可以是插入顺序，也可以是访问顺序。因此，根据链表中元素的顺序可以将LinkedHashMap分为：保持插入顺序的LinkedHashMap和保持访问顺序的LinkedHashMap，其中LinkedHashMap的默认实现是按插入顺序排序的。</p></blockquote><p>　　　　　<img src="https://img-blog.csdn.net/20170317181610752?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image">　　　　　　</p><blockquote><p>　 本质上，HashMap和双向链表合二为一即是LinkedHashMap。所谓LinkedHashMap，其落脚点在HashMap，因此更准确地说，它是一个将所有Entry节点链入一个双向链表双向链表的HashMap。</p></blockquote><blockquote><p>　 在LinkedHashMapMap中，所有put进来的Entry都保存在如下面第一个图所示的哈希表中，但由于它又额外定义了一个以head为头结点的双向链表(如下面第二个图所示)，因此对于每次put进来Entry，除了将其保存到哈希表中对应的位置上之外，还会将其插入到双向链表的尾部。</p></blockquote><p><img src="https://img-blog.csdn.net/20170317181650025?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p><p>　　更直观地，下图很好地还原了LinkedHashMap的原貌：HashMap和双向链表的密切配合和分工合作造就了LinkedHashMap。特别需要注意的是，next用于维护HashMap各个桶中的Entry链，before、after用于维护LinkedHashMap的双向链表，虽然它们的作用对象都是Entry，但是各自分离，是两码事儿。</p><p><img src="https://img-blog.csdn.net/20170512160734275?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>　　<br>　　其中，HashMap与LinkedHashMap的Entry结构示意图如下图所示：</p><p><img src="https://img-blog.csdn.net/20170512155609530?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>　　特别地，由于LinkedHashMap是HashMap的子类，所以LinkedHashMap自然会拥有HashMap的所有特性。比如，==LinkedHashMap也最多只允许一条Entry的键为Null(多条会覆盖)，但允许多条Entry的值为Null。==<br>　　<br>　　此外，LinkedHashMap 也是 Map 的一个非同步的实现。此外，LinkedHashMap还可以用来实现LRU (Least recently used, 最近最少使用)算法，这个问题会在下文的特别谈到。</p><h2 id="LinkedHashMap-在-JDK-中的定义"><a href="#LinkedHashMap-在-JDK-中的定义" class="headerlink" title="LinkedHashMap 在 JDK 中的定义"></a>LinkedHashMap 在 JDK 中的定义</h2><h3 id="类结构定义"><a href="#类结构定义" class="headerlink" title="类结构定义"></a>类结构定义</h3><p>　　LinkedHashMap继承于HashMap，其在JDK中的定义为：</p><pre><code>public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt;    implements Map&lt;K,V&gt; {    ...}</code></pre><h3 id="成员变量定义"><a href="#成员变量定义" class="headerlink" title="成员变量定义"></a>成员变量定义</h3><p>　　与HashMap相比，LinkedHashMap增加了两个属性用于保证迭代顺序，分别是 双向链表头结点header 和 标志位accessOrder (值为true时，表示按照访问顺序迭代；值为false时，表示按照插入顺序迭代)。</p><pre><code>/** * The head of the doubly linked list. */private transient Entry&lt;K,V&gt; header;  // 双向链表的表头元素/** * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt; * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order. * * @serial */private final boolean accessOrder;  //true表示按照访问顺序迭代，false时表示按照插入顺序 </code></pre><h3 id="成员方法定义"><a href="#成员方法定义" class="headerlink" title="成员方法定义"></a>成员方法定义</h3><p>　　从下图我们可以看出，LinkedHashMap中并增加没有额外方法。也就是说，LinkedHashMap与HashMap在操作上大致相同，只是在实现细节上略有不同罢了。</p><p><img src="http://static.zybuluo.com/Rico123/nvojgv4s0o0ciieibz1tbakc/LinkedHashMap_Outline.png" alt="LinkedHashMap_Outline.png-37.5kB"></p><h3 id="基本元素-Entry"><a href="#基本元素-Entry" class="headerlink" title="基本元素 Entry"></a>基本元素 Entry</h3><p>　　LinkedHashMap采用的hash算法和HashMap相同，但是它重新定义了Entry。LinkedHashMap中的Entry增加了两个指针 before 和 after，它们分别用于维护双向链接列表。特别需要注意的是，next用于维护HashMap各个桶中Entry的连接顺序，before、after用于维护Entry插入的先后顺序的，源代码如下：</p><pre><code>private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt; {    // These fields comprise the doubly linked list used for iteration.    Entry&lt;K,V&gt; before, after;    Entry(int hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) {        super(hash, key, value, next);    }    ...}</code></pre><p>　　形象地，HashMap与LinkedHashMap的Entry结构示意图如下图所示：</p><p><img src="https://img-blog.csdn.net/20170512155609530?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="LinkedHashMap-的构造函数"><a href="#LinkedHashMap-的构造函数" class="headerlink" title="LinkedHashMap 的构造函数"></a>LinkedHashMap 的构造函数</h2><p>　　LinkedHashMap 一共提供了五个构造函数，它们都是在HashMap的构造函数的基础上实现的，除了默认空参数构造方法，下面这个构造函数包含了大部分其他构造方法使用的参数，就不一一列举了。</p><h3 id="LinkedHashMap-int-initialCapacity-float-loadFactor-boolean-accessOrder"><a href="#LinkedHashMap-int-initialCapacity-float-loadFactor-boolean-accessOrder" class="headerlink" title="LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)"></a>LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)</h3><p>　　该构造函数意在构造一个指定初始容量和指定负载因子的具有指定迭代顺序的LinkedHashMap，其源码如下：</p><p>/**</p><pre><code> * Constructs an empty &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with the * specified initial capacity, load factor and ordering mode. * * @param  initialCapacity the initial capacity * @param  loadFactor      the load factor * @param  accessOrder     the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for *         access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order * @throws IllegalArgumentException if the initial capacity is negative *         or the load factor is nonpositive */public LinkedHashMap(int initialCapacity,         float loadFactor,                     boolean accessOrder) {    super(initialCapacity, loadFactor);   // 调用HashMap对应的构造函数    this.accessOrder = accessOrder;    // 迭代顺序的默认值}</code></pre><p>初始容量 和负载因子是影响HashMap性能的两个重要参数。同样地，它们也是影响LinkedHashMap性能的两个重要参数。此外，LinkedHashMap 增加了双向链表头结点 header和标志位 accessOrder两个属性用于保证迭代顺序。　　</p><h3 id="LinkedHashMap-Map-lt-extends-K-extends-V-gt-m"><a href="#LinkedHashMap-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m)"></a>LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m)</h3><p>　　该构造函数意在构造一个与指定 Map 具有相同映射的 LinkedHashMap，其 初始容量不小于 16 (具体依赖于指定Map的大小)，负载因子是 0.75，是 Java Collection Framework 规范推荐提供的，其源码如下：</p><pre><code>/** * Constructs an insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with * the same mappings as the specified map.  The &lt;tt&gt;LinkedHashMap&lt;/tt&gt; * instance is created with a default load factor (0.75) and an initial * capacity sufficient to hold the mappings in the specified map. * * @param  m the map whose mappings are to be placed in this map * @throws NullPointerException if the specified map is null */public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m) {    super(m);       // 调用HashMap对应的构造函数    accessOrder = false;    // 迭代顺序的默认值}</code></pre><h3 id="init-方法"><a href="#init-方法" class="headerlink" title="init 方法"></a>init 方法</h3><p>　　从上面的五种构造函数我们可以看出，无论采用何种方式创建LinkedHashMap，其都会调用HashMap相应的构造函数。事实上，不管调用HashMap的哪个构造函数，HashMap的构造函数都会在最后调用一个init()方法进行初始化，只不过这个方法在HashMap中是一个空实现，而在LinkedHashMap中重写了它用于初始化它所维护的双向链表。例如，HashMap的参数为空的构造函数以及init方法的源码如下：</p><pre><code>/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). */public HashMap() {    this.loadFactor = DEFAULT_LOAD_FACTOR;    threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);    table = new Entry[DEFAULT_INITIAL_CAPACITY];    init();}</code></pre><p>   /**</p><pre><code> * Initialization hook for subclasses. This method is called * in all constructors and pseudo-constructors (clone, readObject) * after HashMap has been initialized but before any entries have * been inserted.  (In the absence of this method, readObject would * require explicit knowledge of subclasses.) */void init() {}</code></pre><p>　　在LinkedHashMap中，它重写了init方法以便初始化双向列表，源码如下：</p><p> /**</p><pre><code> * Called by superclass constructors and pseudoconstructors (clone, * readObject) before any entries are inserted into the map.  Initializes * the chain. */void init() {    header = new Entry&lt;K,V&gt;(-1, null, null, null);    header.before = header.after = header;}</code></pre><p>　　因此，我们在创建LinkedHashMap的同时就会不知不觉地对双向链表进行初始化。</p><h2 id="LinkedHashMap-的数据结构"><a href="#LinkedHashMap-的数据结构" class="headerlink" title="LinkedHashMap 的数据结构"></a>LinkedHashMap 的数据结构</h2><blockquote><p>本质上，LinkedHashMap = HashMap + 双向链表，也就是说，HashMap和双向链表合二为一即是LinkedHashMap。</p></blockquote><blockquote><p>也可以这样理解，LinkedHashMap 在不对HashMap做任何改变的基础上，给HashMap的任意两个节点间加了两条连线(before指针和after指针)，使这些节点形成一个双向链表。</p></blockquote><blockquote><p>在LinkedHashMapMap中，所有put进来的Entry都保存在HashMap中，但由于它又额外定义了一个以head为头结点的空的双向链表，因此对于每次put进来Entry还会将其插入到双向链表的尾部。</p></blockquote><p>　　　　　　　　　　　　<img src="https://img-blog.csdn.net/20170512160734275?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="LinkedHashMap-的快速存取"><a href="#LinkedHashMap-的快速存取" class="headerlink" title="LinkedHashMap 的快速存取"></a>LinkedHashMap 的快速存取</h2><p>　　我们知道，在HashMap中最常用的两个操作就是：put(Key,Value) 和 get(Key)。同样地，在 LinkedHashMap 中最常用的也是这两个操作。</p><p>对于put(Key,Value)方法而言，LinkedHashMap完全继承了HashMap的 put(Key,Value) 方法，只是对put(Key,Value)方法所调用的recordAccess方法和addEntry方法进行了重写；对于get(Key)方法而言，LinkedHashMap则直接对它进行了重写。</p><p>下面我们结合JDK源码看 LinkedHashMap 的存取实现。</p><h3 id="LinkedHashMap-的存储实现-put-key-vlaue"><a href="#LinkedHashMap-的存储实现-put-key-vlaue" class="headerlink" title="LinkedHashMap 的存储实现 : put(key, vlaue)"></a>LinkedHashMap 的存储实现 : put(key, vlaue)</h3><p>　　上面谈到，LinkedHashMap没有对 put(key,vlaue) 方法进行任何直接的修改，完全继承了HashMap的 put(Key,Value) 方法，其源码如下：</p><pre><code>public V put(K key, V value) {    //当key为null时，调用putForNullKey方法，并将该键值对保存到table的第一个位置     if (key == null)        return putForNullKey(value);     //根据key的hashCode计算hash值    int hash = hash(key.hashCode());               //计算该键值对在数组中的存储位置（哪个桶）    int i = indexFor(hash, table.length);                  //在table的第i个桶上进行迭代，寻找 key 保存的位置    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {              Object k;        //判断该条链上是否存在hash值相同且key值相等的映射，若存在，则直接覆盖 value，并返回旧value        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {            V oldValue = e.value;            e.value = value;            e.recordAccess(this); // LinkedHashMap重写了Entry中的recordAccess方法--- (1)                return oldValue;    // 返回旧值        }    }    modCount++; //修改次数增加1，快速失败机制    //原Map中无该映射，将该添加至该链的链头    addEntry(hash, key, value, i);  // LinkedHashMap重写了HashMap中的createEntry方法 ---- (2)        return null;}</code></pre><p>　　上述源码反映了LinkedHashMap与HashMap保存数据的过程。特别地，在LinkedHashMap中，它对addEntry方法和Entry的recordAccess方法进行了重写。下面我们对比地看一下LinkedHashMap 和HashMap的addEntry方法的具体实现：</p><pre><code>/** * This override alters behavior of superclass put method. It causes newly * allocated entry to get inserted at the end of the linked list and * removes the eldest entry if appropriate. * * LinkedHashMap中的addEntry方法 */void addEntry(int hash, K key, V value, int bucketIndex) {       //创建新的Entry，并插入到LinkedHashMap中      createEntry(hash, key, value, bucketIndex);  // 重写了HashMap中的createEntry方法    //双向链表的第一个有效节点（header后的那个节点）为最近最少使用的节点，这是用来支持LRU算法的    Entry&lt;K,V&gt; eldest = header.after;      //如果有必要，则删除掉该近期最少使用的节点，      //这要看对removeEldestEntry的覆写,由于默认为false，因此默认是不做任何处理的。      if (removeEldestEntry(eldest)) {          removeEntryForKey(eldest.key);      } else {          //扩容到原来的2倍          if (size &gt;= threshold)              resize(2 * table.length);      }  } -------------------------------我是分割线------------------------------------ /** * Adds a new entry with the specified key, value and hash code to * the specified bucket.  It is the responsibility of this * method to resize the table if appropriate. * * Subclass overrides this to alter the behavior of put method. *  * HashMap中的addEntry方法 */void addEntry(int hash, K key, V value, int bucketIndex) {    //获取bucketIndex处的Entry    Entry&lt;K,V&gt; e = table[bucketIndex];    //将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry     table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);    //若HashMap中元素的个数超过极限了，则容量扩大两倍    if (size++ &gt;= threshold)        resize(2 * table.length);}</code></pre><p>　　由于LinkedHashMap本身维护了插入的先后顺序，因此其可以用来做缓存，14~19行的操作就是用来支持LRU算法的，这里暂时不用去关心它。此外，在LinkedHashMap的addEntry方法中，它重写了HashMap中的createEntry方法，我们接着看一下createEntry方法：</p><pre><code>void createEntry(int hash, K key, V value, int bucketIndex) {     // 向哈希表中插入Entry，这点与HashMap中相同     //创建新的Entry并将其链入到数组对应桶的链表的头结点处，     HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];      Entry&lt;K,V&gt; e = new Entry&lt;K,V&gt;(hash, key, value, old);      table[bucketIndex] = e;         //在每次向哈希表插入Entry的同时，都会将其插入到双向链表的尾部，      //这样就按照Entry插入LinkedHashMap的先后顺序来迭代元素(LinkedHashMap根据双向链表重写了迭代器)    //同时，新put进来的Entry是最近访问的Entry，把其放在链表末尾 ，也符合LRU算法的实现      e.addBefore(header);      size++;  }  </code></pre><p>　　由以上源码我们可以知道，在LinkedHashMap中向哈希表中插入新Entry的同时，还会通过Entry的addBefore方法将其链入到双向链表中。其中，addBefore方法本质上是一个双向链表的插入操作，其源码如下：</p><pre><code>//在双向链表中，将当前的Entry插入到existingEntry(header)的前面  private void addBefore(Entry&lt;K,V&gt; existingEntry) {      after  = existingEntry;      before = existingEntry.before;      before.after = this;      after.before = this;  }  </code></pre><p>　　到此为止，我们分析了在LinkedHashMap中put一条键值对的完整过程。总的来说，相比HashMap而言，LinkedHashMap在向哈希表添加一个键值对的同时，也会将其链入到它所维护的双向链表中，以便设定迭代顺序。</p><h3 id="LinkedHashMap-的扩容操作-resize"><a href="#LinkedHashMap-的扩容操作-resize" class="headerlink" title="LinkedHashMap 的扩容操作 : resize()"></a>LinkedHashMap 的扩容操作 : resize()</h3><p>在HashMap中，我们知道随着HashMap中元素的数量越来越多，发生碰撞的概率将越来越大，所产生的子链长度就会越来越长，这样势必会影响HashMap的存取速度。</p><p>为了保证HashMap的效率，系统必须要在某个临界点进行扩容处理，该临界点就是HashMap中元素的数量在数值上等于threshold（table数组长度*加载因子）。</p><p>但是，不得不说，扩容是一个非常耗时的过程，因为它需要重新计算这些元素在新table数组中的位置并进行复制处理。所以，如果我们能够提前预知HashMap中元素的个数，那么在构造HashMap时预设元素的个数能够有效的提高HashMap的性能。 </p><p>同样的问题也存在于LinkedHashMap中，因为LinkedHashMap本来就是一个HashMap，只是它还将所有Entry节点链入到了一个双向链表中。LinkedHashMap完全继承了HashMap的resize()方法，只是对它所调用的transfer方法进行了重写。我们先看resize()方法源码：</p><pre><code>void resize(int newCapacity) {    Entry[] oldTable = table;    int oldCapacity = oldTable.length;    // 若 oldCapacity 已达到最大值，直接将 threshold 设为 Integer.MAX_VALUE    if (oldCapacity == MAXIMUM_CAPACITY) {          threshold = Integer.MAX_VALUE;        return;             // 直接返回    }    // 否则，创建一个更大的数组    Entry[] newTable = new Entry[newCapacity];    //将每条Entry重新哈希到新的数组中    transfer(newTable);  //LinkedHashMap对它所调用的transfer方法进行了重写    table = newTable;    threshold = (int)(newCapacity * loadFactor);  // 重新设定 threshold}</code></pre><p>　　从上面代码中我们可以看出，Map扩容操作的核心在于重哈希。所谓重哈希是指重新计算原HashMap中的元素在新table数组中的位置并进行复制处理的过程。鉴于性能和LinkedHashMap自身特点的考量，LinkedHashMap对重哈希过程(transfer方法)进行了重写，源码如下：</p><pre><code>/** * Transfers all entries to new table array.  This method is called * by superclass resize.  It is overridden for performance, as it is * faster to iterate using our linked list. */void transfer(HashMap.Entry[] newTable) {    int newCapacity = newTable.length;    // 与HashMap相比，借助于双向链表的特点进行重哈希使得代码更加简洁    for (Entry&lt;K,V&gt; e = header.after; e != header; e = e.after) {        int index = indexFor(e.hash, newCapacity);   // 计算每个Entry所在的桶        // 将其链入桶中的链表        e.next = newTable[index];        newTable[index] = e;       }}</code></pre><p>　　如上述源码所示，LinkedHashMap借助于自身维护的双向链表轻松地实现了重哈希操作。 </p><h3 id="LinkedHashMap-的读取实现-：get-Object-key"><a href="#LinkedHashMap-的读取实现-：get-Object-key" class="headerlink" title="LinkedHashMap 的读取实现 ：get(Object key)"></a>LinkedHashMap 的读取实现 ：get(Object key)</h3><p>　　相对于LinkedHashMap的存储而言，读取就显得比较简单了。LinkedHashMap中重写了HashMap中的get方法，源码如下：</p><pre><code>public V get(Object key) {    // 根据key获取对应的Entry，若没有这样的Entry，则返回null    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);     if (e == null)      // 若不存在这样的Entry，直接返回        return null;    e.recordAccess(this);    return e.value;}/**     * Returns the entry associated with the specified key in the     * HashMap.  Returns null if the HashMap contains no mapping     * for the key.     *      * HashMap 中的方法     *          */    final Entry&lt;K,V&gt; getEntry(Object key) {        if (size == 0) {            return null;        }        int hash = (key == null) ? 0 : hash(key);        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];             e != null;             e = e.next) {            Object k;            if (e.hash == hash &amp;&amp;                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                return e;        }        return null;    }</code></pre><p>　　在LinkedHashMap的get方法中，通过HashMap中的getEntry方法获取Entry对象。注意这里的recordAccess方法，如果链表中元素的排序规则是按照插入的先后顺序排序的话，该方法什么也不做；如果链表中元素的排序规则是按照访问的先后顺序排序的话，则将e移到链表的末尾处，笔者会在后文专门阐述这个问题。</p><p>另外，同样地，调用LinkedHashMap的get(Object key)方法后，若返回值是 NULL，则也存在如下两种可能：</p><p>该 key 对应的值就是 null;<br>HashMap 中不存在该 key。</p><h3 id="LinkedHashMap-存取小结"><a href="#LinkedHashMap-存取小结" class="headerlink" title="LinkedHashMap 存取小结"></a>LinkedHashMap 存取小结</h3><blockquote><p>LinkedHashMap的存取过程基本与HashMap基本类似，只是在细节实现上稍有不同，这是由LinkedHashMap本身的特性所决定的，因为它要额外维护一个双向链表用于保持迭代顺序。</p><p>在put操作上，虽然LinkedHashMap完全继承了HashMap的put操作，但是在细节上还是做了一定的调整，比如，在LinkedHashMap中向哈希表中插入新Entry的同时，还会通过Entry的addBefore方法将其链入到双向链表中。</p><p>在扩容操作上，虽然LinkedHashMap完全继承了HashMap的resize操作，但是鉴于性能和LinkedHashMap自身特点的考量，LinkedHashMap对其中的重哈希过程(transfer方法)进行了重写。在读取操作上，LinkedHashMap中重写了HashMap中的get方法，通过HashMap中的getEntry方法获取Entry对象。在此基础上，进一步获取指定键对应的值。</p></blockquote><h2 id="LinkedHashMap-与-LRU-Least-recently-used，最近最少使用-算法"><a href="#LinkedHashMap-与-LRU-Least-recently-used，最近最少使用-算法" class="headerlink" title="LinkedHashMap 与 LRU(Least recently used，最近最少使用)算法"></a>LinkedHashMap 与 LRU(Least recently used，最近最少使用)算法</h2><p>　　到此为止，我们已经分析完了LinkedHashMap的存取实现，这与HashMap大体相同。LinkedHashMap区别于HashMap最大的一个不同点是，前者是有序的，而后者是无序的。为此，LinkedHashMap增加了两个属性用于保证顺序，分别是双向链表头结点header和标志位accessOrder。</p><p>我们知道，header是LinkedHashMap所维护的双向链表的头结点，而accessOrder用于决定具体的迭代顺序。实际上，accessOrder标志位的作用可不像我们描述的这样简单，我们接下来仔细分析一波~ </p><blockquote><p>我们知道，当accessOrder标志位为true时，表示双向链表中的元素按照访问的先后顺序排列，可以看到，虽然Entry插入链表的顺序依然是按照其put到LinkedHashMap中的顺序，但put和get方法均有调用recordAccess方法（put方法在key相同时会调用）。</p><p>recordAccess方法判断accessOrder是否为true，如果是，则将当前访问的Entry（put进来的Entry或get出来的Entry）移到双向链表的尾部（key不相同时，put新Entry时，会调用addEntry，它会调用createEntry，该方法同样将新插入的元素放入到双向链表的尾部，既符合插入的先后顺序，又符合访问的先后顺序，因为这时该Entry也被访问了）；</p><p>当标志位accessOrder的值为false时，表示双向链表中的元素按照Entry插入LinkedHashMap到中的先后顺序排序，即每次put到LinkedHashMap中的Entry都放在双向链表的尾部，这样遍历双向链表时，Entry的输出顺序便和插入的顺序一致，这也是默认的双向链表的存储顺序。</p></blockquote><p>因此，当标志位accessOrder的值为false时，虽然也会调用recordAccess方法，但不做任何操作。</p><h3 id="put操作与标志位accessOrder"><a href="#put操作与标志位accessOrder" class="headerlink" title="put操作与标志位accessOrder"></a>put操作与标志位accessOrder</h3><pre><code>/ 将key/value添加到LinkedHashMap中      public V put(K key, V value) {          // 若key为null，则将该键值对添加到table[0]中。          if (key == null)              return putForNullKey(value);          // 若key不为null，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。          int hash = hash(key.hashCode());          int i = indexFor(hash, table.length);          for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {              Object k;              // 若key对已经存在，则用新的value取代旧的value             if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {                  V oldValue = e.value;                  e.value = value;                  e.recordAccess(this);                  return oldValue;              }          }          // 若key不存在，则将key/value键值对添加到table中          modCount++;        //将key/value键值对添加到table[i]处        addEntry(hash, key, value, i);          return null;      }      </code></pre><p>　　从上述源码我们可以看到，当要put进来的Entry的key在哈希表中已经在存在时，会调用Entry的recordAccess方法；当该key不存在时，则会调用addEntry方法将新的Entry插入到对应桶的单链表的头部。我们先来看recordAccess方法：</p><pre><code>/*** This method is invoked by the superclass whenever the value* of a pre-existing entry is read by Map.get or modified by Map.set.* If the enclosing Map is access-ordered, it moves the entry* to the end of the list; otherwise, it does nothing.*/void recordAccess(HashMap&lt;K,V&gt; m) {      LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;      //如果链表中元素按照访问顺序排序，则将当前访问的Entry移到双向循环链表的尾部，      //如果是按照插入的先后顺序排序，则不做任何事情。      if (lm.accessOrder) {          lm.modCount++;          //移除当前访问的Entry          remove();          //将当前访问的Entry插入到链表的尾部          addBefore(lm.header);        }    } </code></pre><p>　　LinkedHashMap重写了HashMap中的recordAccess方法（HashMap中该方法为空），当调用父类的put方法时，在发现key已经存在时，会调用该方法；当调用自己的get方法时，也会调用到该方法。</p><p>该方法提供了LRU算法的实现，它将最近使用的Entry放到双向循环链表的尾部。也就是说，当accessOrder为true时，get方法和put方法都会调用recordAccess方法使得最近使用的Entry移到双向链表的末尾；当accessOrder为默认值false时，从源码中可以看出recordAccess方法什么也不会做。我们反过头来，再看一下addEntry方法：</p><p>   /**</p><pre><code> * This override alters behavior of superclass put method. It causes newly * allocated entry to get inserted at the end of the linked list and * removes the eldest entry if appropriate. * * LinkedHashMap中的addEntry方法 */void addEntry(int hash, K key, V value, int bucketIndex) {       //创建新的Entry，并插入到LinkedHashMap中      createEntry(hash, key, value, bucketIndex);  // 重写了HashMap中的createEntry方法    //双向链表的第一个有效节点（header后的那个节点）为最近最少使用的节点，这是用来支持LRU算法的    Entry&lt;K,V&gt; eldest = header.after;      //如果有必要，则删除掉该近期最少使用的节点，      //这要看对removeEldestEntry的覆写,由于默认为false，因此默认是不做任何处理的。      if (removeEldestEntry(eldest)) {          removeEntryForKey(eldest.key);      } else {          //扩容到原来的2倍          if (size &gt;= threshold)              resize(2 * table.length);      }  } void createEntry(int hash, K key, V value, int bucketIndex) {     // 向哈希表中插入Entry，这点与HashMap中相同     //创建新的Entry并将其链入到数组对应桶的链表的头结点处，     HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];      Entry&lt;K,V&gt; e = new Entry&lt;K,V&gt;(hash, key, value, old);      table[bucketIndex] = e;         //在每次向哈希表插入Entry的同时，都会将其插入到双向链表的尾部，      //这样就按照Entry插入LinkedHashMap的先后顺序来迭代元素(LinkedHashMap根据双向链表重写了迭代器)    //同时，新put进来的Entry是最近访问的Entry，把其放在链表末尾 ，也符合LRU算法的实现      e.addBefore(header);      size++;  }</code></pre><p>　　同样是将新的Entry链入到table中对应桶中的单链表中，但可以在createEntry方法中看出，同时也会把新put进来的Entry插入到了双向链表的尾部。<br>　　<br>从插入顺序的层面来说，新的Entry插入到双向链表的尾部可以实现按照插入的先后顺序来迭代Entry，而从访问顺序的层面来说，新put进来的Entry又是最近访问的Entry，也应该将其放在双向链表的尾部。在上面的addEntry方法中还调用了removeEldestEntry方法，该方法源码如下：</p><pre><code>/** * Returns &lt;tt&gt;true&lt;/tt&gt; if this map should remove its eldest entry. * This method is invoked by &lt;tt&gt;put&lt;/tt&gt; and &lt;tt&gt;putAll&lt;/tt&gt; after * inserting a new entry into the map.  It provides the implementor * with the opportunity to remove the eldest entry each time a new one * is added.  This is useful if the map represents a cache: it allows * the map to reduce memory consumption by deleting stale entries. * * &lt;p&gt;Sample use: this override will allow the map to grow up to 100 * entries and then delete the eldest entry each time a new entry is * added, maintaining a steady state of 100 entries. * &lt;pre&gt; *     private static final int MAX_ENTRIES = 100; * *     protected boolean removeEldestEntry(Map.Entry eldest) { *        return size() &gt; MAX_ENTRIES; *     } * &lt;/pre&gt; * * &lt;p&gt;This method typically does not modify the map in any way, * instead allowing the map to modify itself as directed by its * return value.  It &lt;i&gt;is&lt;/i&gt; permitted for this method to modify * the map directly, but if it does so, it &lt;i&gt;must&lt;/i&gt; return * &lt;tt&gt;false&lt;/tt&gt; (indicating that the map should not attempt any * further modification).  The effects of returning &lt;tt&gt;true&lt;/tt&gt; * after modifying the map from within this method are unspecified. * * &lt;p&gt;This implementation merely returns &lt;tt&gt;false&lt;/tt&gt; (so that this * map acts like a normal map - the eldest element is never removed). * * @param    eldest The least recently inserted entry in the map, or if *           this is an access-ordered map, the least recently accessed *           entry.  This is the entry that will be removed it this *           method returns &lt;tt&gt;true&lt;/tt&gt;.  If the map was empty prior *           to the &lt;tt&gt;put&lt;/tt&gt; or &lt;tt&gt;putAll&lt;/tt&gt; invocation resulting *           in this invocation, this will be the entry that was just *           inserted; in other words, if the map contains a single *           entry, the eldest entry is also the newest. * @return   &lt;tt&gt;true&lt;/tt&gt; if the eldest entry should be removed *           from the map; &lt;tt&gt;false&lt;/tt&gt; if it should be retained. */protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) {    return false;}</code></pre><p>}</p><p>　　该方法是用来被重写的，一般地，如果用LinkedHashmap实现LRU算法，就要重写该方法。比如可以将该方法覆写为如果设定的内存已满，则返回true，这样当再次向LinkedHashMap中putEntry时，在调用的addEntry方法中便会将近期最少使用的节点删除掉（header后的那个节点）。在第七节，笔者便重写了该方法并实现了一个名副其实的LRU结构。</p><h3 id="get操作与标志位accessOrder"><a href="#get操作与标志位accessOrder" class="headerlink" title="get操作与标志位accessOrder"></a>get操作与标志位accessOrder</h3><pre><code>public V get(Object key) {    // 根据key获取对应的Entry，若没有这样的Entry，则返回null    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);     if (e == null)      // 若不存在这样的Entry，直接返回        return null;    e.recordAccess(this);    return e.value;}</code></pre><p>　　在LinkedHashMap中进行读取操作时，一样也会调用recordAccess方法。上面笔者已经表述的很清楚了，此不赘述。</p><h3 id="LinkedListMap与LRU小结"><a href="#LinkedListMap与LRU小结" class="headerlink" title="LinkedListMap与LRU小结"></a>LinkedListMap与LRU小结</h3><p>　　使用LinkedHashMap实现LRU的必要前提是将accessOrder标志位设为true以便开启按访问顺序排序的模式。我们可以看到，无论是put方法还是get方法，都会导致目标Entry成为最近访问的Entry，因此就把该Entry加入到了双向链表的末尾：get方法通过调用recordAccess方法来实现；</p><p>put方法在覆盖已有key的情况下，也是通过调用recordAccess方法来实现，在插入新的Entry时，则是通过createEntry中的addBefore方法来实现。这样，我们便把最近使用的Entry放入到了双向链表的后面。多次操作后，双向链表前面的Entry便是最近没有使用的，这样当节点个数满的时候，删除最前面的Entry(head后面的那个Entry)即可，因为它就是最近最少使用的Entry。</p><h2 id="使用LinkedHashMap实现LRU算法"><a href="#使用LinkedHashMap实现LRU算法" class="headerlink" title="使用LinkedHashMap实现LRU算法"></a>使用LinkedHashMap实现LRU算法</h2><p>　　如下所示，笔者使用LinkedHashMap实现一个符合LRU算法的数据结构，该结构最多可以缓存6个元素，但元素多余六个时，会自动删除最近最久没有被使用的元素，如下所示：</p><pre><code>public class LRU&lt;K,V&gt; extends LinkedHashMap&lt;K, V&gt; implements Map&lt;K, V&gt;{    private static final long serialVersionUID = 1L;    public LRU(int initialCapacity,             float loadFactor,                        boolean accessOrder) {        super(initialCapacity, loadFactor, accessOrder);    }    /**      * @description 重写LinkedHashMap中的removeEldestEntry方法，当LRU中元素多余6个时，     *              删除最不经常使用的元素     * @author rico            * @created 2017年5月12日 上午11:32:51           * @param eldest     * @return          * @see java.util.LinkedHashMap#removeEldestEntry(java.util.Map.Entry)          */      @Override    protected boolean removeEldestEntry(java.util.Map.Entry&lt;K, V&gt; eldest) {        // TODO Auto-generated method stub        if(size() &gt; 6){            return true;        }        return false;    }    public static void main(String[] args) {        LRU&lt;Character, Integer&gt; lru = new LRU&lt;Character, Integer&gt;(                16, 0.75f, true);        String s = &quot;abcdefghijkl&quot;;        for (int i = 0; i &lt; s.length(); i++) {            lru.put(s.charAt(i), i);        }        System.out.println(&quot;LRU中key为h的Entry的值为： &quot; + lru.get(&apos;h&apos;));        System.out.println(&quot;LRU的大小 ：&quot; + lru.size());        System.out.println(&quot;LRU ：&quot; + lru);    }}</code></pre><p>　　下图是程序的运行结果：<br><img src="http://static.zybuluo.com/Rico123/gjz8mjvhkkhwjlzr5o8b27yv/LRU.png" alt="LRU.png-13.2kB"></p><h2 id="LinkedHashMap-有序性原理分析"><a href="#LinkedHashMap-有序性原理分析" class="headerlink" title="LinkedHashMap 有序性原理分析"></a>LinkedHashMap 有序性原理分析</h2><p>如前文所述，LinkedHashMap 增加了双向链表头结点header 和 标志位accessOrder两个属性用于保证迭代顺序。但是要想真正实现其有序性，还差临门一脚，那就是重写HashMap 的迭代器，其源码实现如下：</p><pre><code>private abstract class LinkedHashIterator&lt;T&gt; implements Iterator&lt;T&gt; {    Entry&lt;K,V&gt; nextEntry    = header.after;    Entry&lt;K,V&gt; lastReturned = null;    /**     * The modCount value that the iterator believes that the backing     * List should have.  If this expectation is violated, the iterator     * has detected concurrent modification.     */    int expectedModCount = modCount;    public boolean hasNext() {         // 根据双向列表判断             return nextEntry != header;    }    public void remove() {        if (lastReturned == null)        throw new IllegalStateException();        if (modCount != expectedModCount)        throw new ConcurrentModificationException();            LinkedHashMap.this.remove(lastReturned.key);            lastReturned = null;            expectedModCount = modCount;    }    Entry&lt;K,V&gt; nextEntry() {        // 迭代输出双向链表各节点        if (modCount != expectedModCount)        throw new ConcurrentModificationException();            if (nextEntry == header)                throw new NoSuchElementException();            Entry&lt;K,V&gt; e = lastReturned = nextEntry;            nextEntry = e.after;            return e;    }}// Key 迭代器，KeySetprivate class KeyIterator extends LinkedHashIterator&lt;K&gt; {       public K next() { return nextEntry().getKey(); }}   // Value 迭代器，Values(Collection)private class ValueIterator extends LinkedHashIterator&lt;V&gt; {    public V next() { return nextEntry().value; }}// Entry 迭代器，EntrySetprivate class EntryIterator extends LinkedHashIterator&lt;Map.Entry&lt;K,V&gt;&gt; {    public Map.Entry&lt;K,V&gt; next() { return nextEntry(); }}</code></pre><p>　 从上述代码中我们可以知道，LinkedHashMap重写了HashMap 的迭代器，它使用其维护的双向链表进行迭代输出。　 </p><h2 id="JDK1-8的改动"><a href="#JDK1-8的改动" class="headerlink" title="JDK1.8的改动"></a>JDK1.8的改动</h2><p>原文是基于JDK1.6的实现，实际上JDK1.8对其进行了改动。<br>首先它删除了addentry，createenrty等方法（事实上是hashmap的改动影响了它而已）。</p><p>linkedhashmap同样使用了大部分hashmap的增删改查方法。<br>新版本linkedhashmap主要是通过对hashmap内置几个方法重写来实现lru的。</p><p>hashmap不提供实现：</p><pre><code>void afterNodeAccess(Node&lt;K,V&gt; p) { }   void afterNodeInsertion(boolean evict) { }   void afterNodeRemoval(Node&lt;K,V&gt; p) { }</code></pre><p>linkedhashmap的实现：</p><p>处理元素被访问后的情况</p><pre><code>void afterNodeAccess(Node&lt;K,V&gt; e) { // move node to last        LinkedHashMap.Entry&lt;K,V&gt; last;        if (accessOrder &amp;&amp; (last = tail) != e) {            LinkedHashMap.Entry&lt;K,V&gt; p =                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;            p.after = null;            if (b == null)                head = a;            else                b.after = a;            if (a != null)                a.before = b;            else                last = b;            if (last == null)                head = p;            else {                p.before = last;                last.after = p;            }            tail = p;            ++modCount;        }    }</code></pre><p>处理元素插入后的情况</p><pre><code>void afterNodeInsertion(boolean evict) { // possibly remove eldestLinkedHashMap.Entry&lt;K,V&gt; first;if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) {    K key = first.key;    removeNode(hash(key), key, null, false, true);}</code></pre><p>处理元素被删除后的情况</p><pre><code>     void afterNodeRemoval(Node&lt;K,V&gt; e) { // unlink    LinkedHashMap.Entry&lt;K,V&gt; p =        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;    p.before = p.after = null;    if (b == null)        head = a;    else        b.after = a;    if (a == null)        tail = b;    else        a.before = b;}}</code></pre><p>另外1.8的hashmap在链表长度超过8时自动转为红黑树，会按顺序插入链表中的元素，可以自定义比较器来定义节点的插入顺序。</p><p>1.8的linkedhashmap同样会使用这一特性，当变为红黑树以后，节点的先后顺序同样是插入红黑树的顺序，其双向链表的性质没有改表，只是原来hashmap的链表变成了红黑树而已，在此不要混淆。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从linkedhashmap的数据结构，以及源码分析，到最后的LRU缓存实现，比较深入地剖析了linkedhashmap的底层原理。<br>总结以下几点：</p><p>1 linkedhashmap在hashmap的数组加链表结构的基础上，将所有节点连成了一个双向链表。</p><p>2 当主动传入的accessOrder参数为false时, 使用put方法时，新加入元素不会被加入双向链表，get方法使用时也不会把元素放到双向链表尾部。</p><p>3 当主动传入的accessOrder参数为true时，使用put方法新加入的元素，如果遇到了哈希冲突，并且对key值相同的元素进行了替换，就会被放在双向链表的尾部，当元素超过上限且removeEldestEntry方法返回true时，直接删除最早元素以便新元素插入。如果没有冲突直接放入，同样加入到链表尾部。使用get方法时会把get到的元素放入双向链表尾部。</p><p>4 linkedhashmap的扩容比hashmap来的方便，因为hashmap需要将原来的每个链表的元素分别在新数组进行反向插入链化，而linkedhashmap的元素都连在一个链表上，可以直接迭代然后插入。</p><p>5 linkedhashmap的removeEldestEntry方法默认返回false，要实现lru很重要的一点就是集合满时要将最久未访问的元素删除，在linkedhashmap中这个元素就是头指针指向的元素。实现LRU可以直接实现继承linkedhashmap并重写removeEldestEntry方法来设置缓存大小。jdk中实现了LRUCache也可以直接使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们来深入探索一下LinkedHashMap的底层原理，并且使用linkedhashmap来实现LRU缓存。&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/05/11/collection5&quot;&gt;https://h2pl.github.io/2018/05/11/collection5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的个人博客主要发原创文章，也欢迎浏览&lt;br&gt;&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java集合类" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
    
      <category term="Java集合框架" scheme="http://h2pl.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java集合详解4：HashMap和HashTable</title>
    <link href="http://h2pl.github.io/2018/05/10/collection4/"/>
    <id>http://h2pl.github.io/2018/05/10/collection4/</id>
    <published>2018-05-10T15:34:08.000Z</published>
    <updated>2018-05-11T01:38:03.384Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来探索一下HashMap和HashTable机制与比较器的源码。</p><p>具体代码在我的GitHub中可以找到</p><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p><p>喜欢的话麻烦star一下哈</p><p>文章首发于我的个人博客：</p><p><a href="https://h2pl.github.io/2018/05/10/collection4">https://h2pl.github.io/2018/05/10/collection4</a></p><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：<a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a></p><p>我的个人博客主要发原创文章，也欢迎浏览<br><a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><a id="more"></a><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p> HashMap也是我们使用非常多的Collection，它是基于哈希表的 Map 接口的实现，以key-value的形式存在。在HashMap中，key-value总是会当做一个整体来处理，系统会根据hash算法来来计算key-value的存储位置，我们总是可以通过key快速地存、取value。下面就来分析HashMap的存取。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>  HashMap实现了Map接口，继承AbstractMap。其中Map接口定义了键映射到值的规则，而AbstractMap类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作，其实AbstractMap类已经实现了Map，这里标注Map LZ觉得应该是更加清晰吧！</p><pre><code>public class HashMap&lt;K,V&gt;    extends AbstractMap&lt;K,V&gt;    implements Map&lt;K,V&gt;, Cloneable, Serializable</code></pre><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre><code>HashMap提供了三个构造函数：HashMap()：构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。HashMap(int initialCapacity)：构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。HashMap(int initialCapacity, float loadFactor)：构造一个带指定初始容量和加载因子的空 HashMap。</code></pre><p>  在这里提到了两个参数：初始容量，加载因子。</p><blockquote><p>  这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中桶的数量，初始容量是创建哈希表时的容量，加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。</p><p>  对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为0.75，一般情况下我们是无需修改的。</p></blockquote><p>  HashMap是一种支持快速存取的数据结构，要了解它的性能必须要了解它的数据结构。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><blockquote><p>  我们知道在Java中最常用的两种结构是数组和模拟指针(引用)，几乎所有的数据结构都可以利用这两种来组合实现，HashMap也是如此。实际上HashMap是一个“链表散列”，如下是它的数据结构：</p></blockquote><p>HashMap数据结构图</p><p>下图的table数组的每个格子都是一个桶。负载因子就是map中的元素占用的容量百分比。比如负载因子是0.75，初始容量（桶数量）为16时，那么允许装填的元素最大个数就是16*0.75 = 12，这个最大个数也被成为阈值，就是map中定义的threshold。超过这个阈值时，map就会自动扩容。</p><p><img src="http://cmsblogs.com/wp-content/uploads/2014/01/HashMap.png" alt="image"></p><blockquote><p>  从上图我们可以看出HashMap底层实现还是数组，只是数组的每一项都是一条链。其中参数initialCapacity就代表了该数组的长度。下面为HashMap构造函数的源码：</p></blockquote><pre><code>public HashMap(int initialCapacity, float loadFactor) {        //初始容量不能&lt;0        if (initialCapacity &lt; 0)            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot;                    + initialCapacity);        //初始容量不能 &gt; 最大容量值，HashMap的最大容量值为2^30        if (initialCapacity &gt; MAXIMUM_CAPACITY)            initialCapacity = MAXIMUM_CAPACITY;        //负载因子不能 &lt; 0        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))            throw new IllegalArgumentException(&quot;Illegal load factor: &quot;                    + loadFactor);        // 计算出大于 initialCapacity 的最小的 2 的 n 次方值。        int capacity = 1;        while (capacity &lt; initialCapacity)            capacity &lt;&lt;= 1;        this.loadFactor = loadFactor;        //设置HashMap的容量极限，当HashMap的容量达到该极限时就会进行扩容操作        threshold = (int) (capacity * loadFactor);        //初始化table数组，也就是桶数组。        table = new Entry[capacity];        init();    }      从源码中可以看出，每次新建一个HashMap时，都会初始化一个table数组。table数组的元素为Entry节点。static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {        final K key;        V value;        Entry&lt;K,V&gt; next;        final int hash;        /**         * Creates new entry.         */        Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {            value = v;            next = n;            key = k;            hash = h;        }        .......    }      其中Entry为HashMap的内部类，它包含了键key、值value、下一个节点next，以及hash值，这是非常重要的，正是由于Entry才构成了table数组的项为链表。      上面简单分析了HashMap的数据结构，下面将探讨HashMap是如何实现快速存取的。</code></pre><h2 id="存储实现：put-key-vlaue"><a href="#存储实现：put-key-vlaue" class="headerlink" title="存储实现：put(key,vlaue)"></a>存储实现：put(key,vlaue)</h2><pre><code>  首先我们先看源码public V put(K key, V value) {        //当key为null，调用putForNullKey方法，保存null与table第一个位置中，这是HashMap允许为null的原因        if (key == null)            return putForNullKey(value);        //计算key的hash值，此处对原来元素的hashcode进行了再次hash        int hash = hash(key.hashCode());                  ------(1)        //计算key hash 值在 table 数组中的位置        int i = indexFor(hash, table.length);             ------(2)        //从i出开始迭代 e,找到 key 保存的位置        for (Entry&lt;K, V&gt; e = table[i]; e != null; e = e.next) {            Object k;            //判断该条链上是否有hash值相同的(key相同)            //若存在相同，则直接覆盖value，返回旧value            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {                V oldValue = e.value;    //旧值 = 新值                e.value = value;                e.recordAccess(this);                return oldValue;     //返回旧值            }        }        //修改次数增加1        modCount++;        //将key、value添加至i位置处        addEntry(hash, key, value, i);        return null;    }</code></pre><p>  通过源码我们可以清晰看到HashMap保存数据的过程为：首先判断key是否为null，若为null，则直接调用putForNullKey方法。</p><p>  若不为空则先计算key的hash值，然后根据hash值搜索在table数组中的索引位置，如果table数组在该位置处有元素，则通过比较是否存在相同的key，若存在则覆盖原来key的value，==否则将该元素保存在链头（最先保存的元素放在链尾）==。</p><p>  若table在该处没有元素，则直接保存。这个过程看似比较简单，其实深有内幕。有如下几点：</p><blockquote><p>  1、 先看迭代处。此处迭代原因就是为了防止存在相同的key值，若发现两个hash值（key）相同时，HashMap的处理方式是用新value替换旧value，这里并没有处理key，这就解释了HashMap中没有两个相同的key。</p><p>  2、 在看（1）、（2）处。这里是HashMap的精华所在。首先是hash方法，该方法为一个纯粹的数学计算，就是计算h的hash值。</p></blockquote><pre><code>static int hash(int h) {        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);    }</code></pre><p>  我们知道对于HashMap的table而言，数据分布需要均匀（最好每项都只有一个元素，这样就可以直接找到），不能太紧也不能太松，太紧会导致查询速度慢，太松则浪费空间。计算hash值后，怎么才能保证table元素分布均与呢？我们会想到取模，但是由于取模的消耗较大，HashMap是这样处理的：调用indexFor方法。</p><pre><code>static int indexFor(int h, int length) {        return h &amp; (length-1);    }</code></pre><p>  HashMap的底层数组长度总是2的n次方，在构造函数中存在：capacity &lt;&lt;= 1;这样做总是能够保证HashMap的底层数组长度为2的n次方。当length为2的n次方时，h&amp;(length - 1)就相当于对length取模，而且速度比直接取模快得多，这是HashMap在速度上的一个优化。至于为什么是2的n次方下面解释。</p><p> ==对length取模来得到hash是常用的hash索引方法，这里采用位运算的话效率更高。==</p><p>  我们回到indexFor方法，该方法仅有一条语句：h&amp;(length - 1)，这句话除了上面的取模运算外还有一个非常重要的责任：均匀分布table数据和充分利用空间。</p><p>  这里我们假设length为16(2^n)和15，h为5、6、7。</p><p>table1</p><p><img src="http://cmsblogs.com/wp-content/uploads/2014/01/table1_thumb.jpg" alt="image"></p><p>  当n=15时，6和7的结果一样，这样表示他们在table存储的位置是相同的，也就是产生了碰撞，6、7就会在一个位置形成链表，这样就会导致查询速度降低。诚然这里只分析三个数字不是很多，那么我们就看0-15。</p><p>table2</p><p><img src="http://cmsblogs.com/wp-content/uploads/2014/01/table2_thumb.jpg" alt="image"></p><p>  从上面的图表中我们看到总共发生了8次碰撞，同时发现浪费的空间非常大，有1、3、5、7、9、11、13、15处没有记录，也就是没有存放数据。</p><p>  这是因为他们在与14进行&amp;运算时，得到的结果最后一位永远都是0，即0001、0011、0101、0111、1001、1011、1101、1111位置处是不可能存储数据的，空间减少，进一步增加碰撞几率，这样就会导致查询速度慢。</p><blockquote><p>  而当length = 16时，length – 1 = 15 即1111，那么进行低位&amp;运算时，值总是与原来hash值相同，而进行高位运算时，其值等于其低位值。所以说当length = 2^n时，不同的hash值发生碰撞的概率比较小，这样就会使得数据在table数组中分布较均匀，查询速度也较快。</p><p>  这里我们再来复习put的流程：当我们想一个HashMap中添加一对key-value时，系统首先会计算key的hash值，然后根据hash值确认在table中存储的位置。若该位置没有元素，则直接插入。否则迭代该处元素链表并依此比较其key的hash值。</p><p>  如果两个hash值相等且key值相等(e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))),则用新的Entry的value覆盖原来节点的value。如果两个hash值相等但key值不等 ，则将该节点插入该链表的链头。具体的实现过程见addEntry方法，如下：</p></blockquote><pre><code>void addEntry(int hash, K key, V value, int bucketIndex) {        //获取bucketIndex处的Entry        Entry&lt;K, V&gt; e = table[bucketIndex];        //将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry         table[bucketIndex] = new Entry&lt;K, V&gt;(hash, key, value, e);        //若HashMap中元素的个数超过极限了，则容量扩大两倍        if (size++ &gt;= threshold)            resize(2 * table.length);    }</code></pre><p>  这个方法中有两点需要注意：</p><pre><code>后面添加的entry反而会接到前面。</code></pre><p>  一、是链的产生。</p><p>  这是一个非常优雅的设计。系统总是将新的Entry对象添加到bucketIndex处。如果bucketIndex处已经有了对象，那么新添加的Entry对象将指向原有的Entry对象，形成一条Entry链，但是若bucketIndex处没有Entry对象，也就是e==null,那么新添加的Entry对象指向null，也就不会产生Entry链了。</p><p>  二、扩容问题。</p><p>  随着HashMap中元素的数量越来越多，发生碰撞的概率就越来越大，所产生的链表长度就会越来越长，这样势必会影响HashMap的速度，为了保证HashMap的效率，系统必须要在某个临界点进行扩容处理。</p><p>  该临界点在当HashMap中元素的数量等于table数组长度*加载因子。但是扩容是一个非常耗时的过程，因为它需要重新计算这些数据在新table数组中的位置并进行复制处理。所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</p><h2 id="JDK1-8的hashmap：put方法"><a href="#JDK1-8的hashmap：put方法" class="headerlink" title="JDK1.8的hashmap：put方法"></a>JDK1.8的hashmap：put方法</h2><pre><code>final V putVal(int hash, K key, V value, boolean onlyIfAbsent,                   boolean evict) {        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;        if ((tab = table) == null || (n = tab.length) == 0)            n = (tab = resize()).length;        if ((p = tab[i = (n - 1) &amp; hash]) == null)            tab[i] = newNode(hash, key, value, null);        else {            Node&lt;K,V&gt; e; K k;            if (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))                e = p;                //如果p是红黑树节点，则用另外的处理方法            else if (p instanceof TreeNode)                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);            else {                for (int binCount = 0; ; ++binCount) {                    if ((e = p.next) == null) {                        p.next = newNode(hash, key, value, null);                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        //当链表节点数超过8个，则直接进行红黑树化。                            treeifyBin(tab, hash);                        break;                    }                    if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                        break;                    p = e;                }            }            if (e != null) { // existing mapping for key                V oldValue = e.value;                if (!onlyIfAbsent || oldValue == null)                    e.value = value;                afterNodeAccess(e);                return oldValue;            }        }        ++modCount;        if (++size &gt; threshold)            resize();        afterNodeInsertion(evict);        return null;    }</code></pre><p>JDK1.8在链表长度超过8时会转换为红黑树。<br>转换方法如下：</p><pre><code>final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {        int n, index; Node&lt;K,V&gt; e;        if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)        //如果节点数变小小于红黑树的节点数阈值时，调整空间            resize();        else if ((e = tab[index = (n - 1) &amp; hash]) != null) {            TreeNode&lt;K,V&gt; hd = null, tl = null;            do {            //该方法直接返回一个红黑树结点。                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);                if (tl == null)                    hd = p;                else {                //从链表头开始依次插入红黑树                    p.prev = tl;                    tl.next = p;                }                tl = p;            } while ((e = e.next) != null);            if ((tab[index] = hd) != null)                hd.treeify(tab);        }    }        // For treeifyBinTreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) {    return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next);}</code></pre><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><pre><code>final Node&lt;K,V&gt;[] resize() {        Node&lt;K,V&gt;[] oldTab = table;        int oldCap = (oldTab == null) ? 0 : oldTab.length;        int oldThr = threshold;        int newCap, newThr = 0;        if (oldCap &gt; 0) {            //如果原容量大于最大空间，则让阈值为最大值。因为不能再扩容了，最大容量就是整数最大值。            if (oldCap &gt;= MAXIMUM_CAPACITY) {                threshold = Integer.MAX_VALUE;                return oldTab;            }            //两倍扩容，阈值也跟着变为两倍            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)                newThr = oldThr &lt;&lt; 1; // double threshold        }        else if (oldThr &gt; 0) // initial capacity was placed in threshold            newCap = oldThr;        else {               // zero initial threshold signifies using defaults            newCap = DEFAULT_INITIAL_CAPACITY;            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);        }        if (newThr == 0) {            float ft = (float)newCap * loadFactor;            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                      (int)ft : Integer.MAX_VALUE);        }        threshold = newThr;        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];        table = newTab;        if (oldTab != null) {            for (int j = 0; j &lt; oldCap; ++j) {                Node&lt;K,V&gt; e;                if ((e = oldTab[j]) != null) {                    oldTab[j] = null;                    if (e.next == null)                        //当后面没有节点时，直接插入即可 //每个元素重新计算索引位置，此处的hash值并没有变，只是改变索引值                        newTab[e.hash &amp; (newCap - 1)] = e;                    else if (e instanceof TreeNode)                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                    else { // preserve order                    //否则，就从头到尾依次将节点进行索引然后插入新数组，这样插入后的链表顺序会和原来的顺序相反。                        Node&lt;K,V&gt; loHead = null, loTail = null;                        Node&lt;K,V&gt; hiHead = null, hiTail = null;                        Node&lt;K,V&gt; next;                        do {                            next = e.next;                            if ((e.hash &amp; oldCap) == 0) {                                if (loTail == null)                                    loHead = e;                                else                                    loTail.next = e;                                loTail = e;                            }                            else {                                if (hiTail == null)                                    hiHead = e;                                else                                    hiTail.next = e;                                hiTail = e;                            }                        } while ((e = next) != null);                        if (loTail != null) {                            loTail.next = null;                            newTab[j] = loHead;                        }                        if (hiTail != null) {                            hiTail.next = null;                            newTab[j + oldCap] = hiHead;                        }                    }                }            }        }        return newTab;    }</code></pre><h2 id="读取实现：get-key"><a href="#读取实现：get-key" class="headerlink" title="读取实现：get(key)"></a>读取实现：get(key)</h2><pre><code>        相对于HashMap的存而言，取就显得比较简单了。通过key的hash值找到在table数组中的索引处的Entry，然后返回该key对应的value即可。public V get(Object key) {        // 若为null，调用getForNullKey方法返回相对应的value        if (key == null)            return getForNullKey();        // 根据该 key 的 hashCode 值计算它的 hash 码          int hash = hash(key.hashCode());        // 取出 table 数组中指定索引处的值        for (Entry&lt;K, V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) {            Object k;            //若搜索的key与查找的key相同，则返回相对应的value            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))                return e.value;        }        return null;    }</code></pre><blockquote><p>在这里能够根据key快速的取到value除了和HashMap的数据结构密不可分外，还和Entry有莫大的关系，在前面就提到过，HashMap在存储过程中并没有将key，value分开来存储，而是当做一个整体key-value来处理的，这个整体就是Entry对象。</p><p>同时value也只相当于key的附属而已。在存储的过程中，系统根据key的hashcode来决定Entry在table数组中的存储位置，在取的过程中同样根据key的hashcode取出相对应的Entry对象。</p><p>在java中与有两个类都提供了一个多种用途的hashTable机制，他们都可以将可以key和value结合起来构成键值对通过put(key,value)方法保存起来，然后通过get(key)方法获取相对应的value值。</p></blockquote><h1 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h1><p>一个是前面提到的HashMap，还有一个就是马上要讲解的HashTable。对于HashTable而言，它在很大程度上和HashMap的实现差不多，如果我们对HashMap比较了解的话，对HashTable的认知会提高很大的帮助。他们两者之间只存在几点的不同，这个后面会阐述。</p><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><pre><code>  HashTable在Java中的定义如下：public class Hashtable&lt;K,V&gt;    extends Dictionary&lt;K,V&gt;    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable      从中可以看出HashTable继承Dictionary类，实现Map接口。其中Dictionary类是任何可将键映射到相应值的类（如 Hashtable）的抽象父类。每个键和每个值都是一个对象。在任何一个 Dictionary 对象中，每个键至多与一个值相关联。Map是&quot;key-value键值对&quot;接口。  HashTable采用&quot;拉链法&quot;实现哈希表，它定义了几个重要的参数：table、count、threshold、loadFactor、modCount。  table：为一个Entry[]数组类型，Entry代表了“拉链”的节点，每一个Entry代表了一个键值对，哈希表的&quot;key-value键值对&quot;都是存储在Entry数组中的。  count：HashTable的大小，注意这个大小并不是HashTable的容器大小，而是他所包含Entry键值对的数量。  threshold：Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=&quot;容量*加载因子&quot;。  loadFactor：加载因子。  modCount：用来实现“fail-fast”机制的（也就是快速失败）。所谓快速失败就是在并发集合中，其进行迭代操作时，若有其他线程对其进行结构性的修改，这时迭代器会立马感知到，并且立即抛出ConcurrentModificationException异常，而不是等到迭代完成之后才告诉你（你已经出错了）。</code></pre><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><pre><code>  在HashTabel中存在5个构造函数。通过这5个构造函数我们构建出一个我想要的HashTable。public Hashtable() {        this(11, 0.75f);    }      默认构造函数，容量为11，加载因子为0.75。public Hashtable(int initialCapacity) {        this(initialCapacity, 0.75f);    }      用指定初始容量和默认的加载因子 (0.75) 构造一个新的空哈希表。public Hashtable(int initialCapacity, float loadFactor) {        //验证初始容量        if (initialCapacity &lt; 0)            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+                                               initialCapacity);        //验证加载因子        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))            throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);        if (initialCapacity==0)            initialCapacity = 1;        this.loadFactor = loadFactor;        //初始化table，获得大小为initialCapacity的table数组        table = new Entry[initialCapacity];        //计算阀值        threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);        //初始化HashSeed值        initHashSeedAsNeeded(initialCapacity);    }</code></pre><blockquote><p> 用指定初始容量和指定加载因子构造一个新的空哈希表。其中initHashSeedAsNeeded方法用于初始化hashSeed参数，其中hashSeed用于计算key的hash值，它与key的hashCode进行按位异或运算。这个hashSeed是一个与实例相关的随机值，主要用于解决hash冲突。</p></blockquote><pre><code>private int hash(Object k) {        return hashSeed ^ k.hashCode();    }</code></pre><p>  构造一个与给定的 Map 具有相同映射关系的新哈希表。</p><pre><code>public Hashtable(Map&lt;? extends K, ? extends V&gt; t) {        //设置table容器大小，其值==t.size * 2 + 1        this(Math.max(2*t.size(), 11), 0.75f);        putAll(t);    }</code></pre><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><p>HashTable的API对外提供了许多方法，这些方法能够很好帮助我们操作HashTable，但是这里我只介绍两个最根本的方法：put、get。</p><pre><code>  首先我们先看put方法：将指定 key 映射到此哈希表中的指定 value。注意这里键key和值value都不可为空。public synchronized V put(K key, V value) {        // 确保value不为null        if (value == null) {            throw new NullPointerException();        }        /*         * 确保key在table[]是不重复的         * 处理过程：         * 1、计算key的hash值，确认在table[]中的索引位置         * 2、迭代index索引位置，如果该位置处的链表中存在一个一样的key，则替换其value，返回旧值         */        Entry tab[] = table;        int hash = hash(key);    //计算key的hash值        int index = (hash &amp; 0x7FFFFFFF) % tab.length;     //确认该key的索引位置        //迭代，寻找该key，替换        for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) {            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {                V old = e.value;                e.value = value;                return old;            }        }        modCount++;        if (count &gt;= threshold) {  //如果容器中的元素数量已经达到阀值，则进行扩容操作            rehash();            tab = table;            hash = hash(key);            index = (hash &amp; 0x7FFFFFFF) % tab.length;        }        // 在索引位置处插入一个新的节点        Entry&lt;K,V&gt; e = tab[index];        tab[index] = new Entry&lt;&gt;(hash, key, value, e);        //容器中元素+1        count++;        return null;    }</code></pre><blockquote><p>  put方法的整个处理流程是：计算key的hash值，根据hash值获得key在table数组中的索引位置，然后迭代该key处的Entry链表（我们暂且理解为链表），若该链表中存在一个这个的key对象，那么就直接替换其value值即可，否则在将改key-value节点插入该index索引位置处。如下：</p></blockquote><p>首先我们假设一个容量为5的table，存在8、10、13、16、17、21。他们在table中位置如下：</p><p><img src="http://cmsblogs.com/wp-content/uploads/2014/04/1_thumb.png" alt=""></p><p>然后我们插入一个数：put(16,22)，key=16在table的索引位置为1，同时在1索引位置有两个数，程序对该“链表”进行迭代，发现存在一个key=16,这时要做的工作就是用newValue=22替换oldValue16，并将oldValue=16返回。</p><p><img src="http://cmsblogs.com/wp-content/uploads/2014/04/2014040302_thumb.png" alt="image"></p><p> 在put(33,33)，key=33所在的索引位置为3，并且在该链表中也没有存在某个key=33的节点，所以就将该节点插入该链表的第一个位置。</p><p><img src="http://cmsblogs.com/wp-content/uploads/2014/04/2014040303vsd_thumb.png" alt="image"></p><p> 在HashTabled的put方法中有两个地方需要注意：</p><p>1、HashTable的扩容操作，在put方法中，如果需要向table[]中添加Entry元素，会首先进行容量校验，如果容量已经达到了阀值，HashTable就会进行扩容处理rehash()，如下:</p><pre><code>protected void rehash() {        int oldCapacity = table.length;        //元素        Entry&lt;K,V&gt;[] oldMap = table;        //新容量=旧容量 * 2 + 1        int newCapacity = (oldCapacity &lt;&lt; 1) + 1;        if (newCapacity - MAX_ARRAY_SIZE &gt; 0) {            if (oldCapacity == MAX_ARRAY_SIZE)                return;            newCapacity = MAX_ARRAY_SIZE;        }        //新建一个size = newCapacity 的HashTable        Entry&lt;K,V&gt;[] newMap = new Entry[];        modCount++;        //重新计算阀值        threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);        //重新计算hashSeed        boolean rehash = initHashSeedAsNeeded(newCapacity);        table = newMap;        //将原来的元素拷贝到新的HashTable中        for (int i = oldCapacity ; i-- &gt; 0 ;) {            for (Entry&lt;K,V&gt; old = oldMap[i] ; old != null ; ) {                Entry&lt;K,V&gt; e = old;                old = old.next;                if (rehash) {                    e.hash = hash(e.key);                }                int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;                e.next = newMap[index];                newMap[index] = e;            }        }    }</code></pre><p> 在这个rehash()方法中我们可以看到容量扩大两倍+1，同时需要将原来HashTable中的元素一一复制到新的HashTable中，这个过程是比较消耗时间的，同时还需要重新计算hashSeed的，毕竟容量已经变了。</p><p> 这里对阀值啰嗦一下：比如初始值11、加载因子默认0.75，那么这个时候阀值threshold=8，当容器中的元素达到8时，HashTable进行一次扩容操作，容量 = 8 <em> 2 + 1 =17，而阀值threshold=17</em>0.75 = 13，当容器元素再一次达到阀值时，HashTable还会进行扩容操作，依次类推。</p><p>下面是计算key的hash值，这里hashSeed发挥了作用。</p><pre><code>private int hash(Object k) {        return hashSeed ^ k.hashCode();    }</code></pre><p> 相对于put方法，get方法就会比较简单，处理过程就是计算key的hash值，判断在table数组中的索引位置，然后迭代链表，匹配直到找到相对应key的value,若没有找到返回null。</p><pre><code>public synchronized V get(Object key) {        Entry tab[] = table;        int hash = hash(key);        int index = (hash &amp; 0x7FFFFFFF) % tab.length;        for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) {            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {                return e.value;            }        }        return null;    }</code></pre><p>四、HashTable与HashMap的区别</p><p>  HashTable和HashMap存在很多的相同点，但是他们还是有几个比较重要的不同点。</p><blockquote><p>  第一：我们从他们的定义就可以看出他们的不同，HashTable基于Dictionary类，而HashMap是基于AbstractMap。Dictionary是什么？它是任何可将键映射到相应值的类的抽象父类，而AbstractMap是基于Map接口的骨干实现，它以最大限度地减少实现此接口所需的工作。</p><p>  第二：HashMap可以允许存在一个为null的key和任意个为null的value，但是HashTable中的key和value都不允许为null。如下：</p><p>  当HashMap遇到为null的key时，它会调用putForNullKey方法来进行处理。对于value没有进行任何处理，只要是对象都可以。</p></blockquote><pre><code>if (key == null)            return putForNullKey(value);      而当HashTable遇到null时，他会直接抛出NullPointerException异常信息。if (value == null) {    throw new NullPointerException();}</code></pre><blockquote><p>  第三：Hashtable的方法是同步的，而HashMap的方法不是。所以有人一般都建议如果是涉及到多线程同步时采用HashTable，没有涉及就采用HashMap，但是在Collections类中存在一个静态方法：synchronizedMap()，该方法创建了一个线程安全的Map对象，并把它作为一个封装的对象来返回，所以通过Collections类的synchronizedMap方法是可以我们你同步访问潜在的HashMap。这样君该如何选择呢？？？</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们来探索一下HashMap和HashTable机制与比较器的源码。&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;喜欢的话麻烦star一下哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/05/10/collection4&quot;&gt;https://h2pl.github.io/2018/05/10/collection4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的个人博客主要发原创文章，也欢迎浏览&lt;br&gt;&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java集合类" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
    
      <category term="Java集合框架" scheme="http://h2pl.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java集合详解3：Iterator，fail-fast机制与比较器</title>
    <link href="http://h2pl.github.io/2018/05/09/collection3/"/>
    <id>http://h2pl.github.io/2018/05/09/collection3/</id>
    <published>2018-05-09T15:49:41.000Z</published>
    <updated>2018-05-11T01:37:59.665Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来探索一下LIterator，fail-fast机制与比较器的源码。</p><p>具体代码在我的GitHub中可以找到</p><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p><p>喜欢的话麻烦star一下哈</p><p>文章首发于我的个人博客：</p><p><a href="https://h2pl.github.io/2018/05/9/collection3">https://h2pl.github.io/2018/05/9/collection3</a></p><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：<a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a></p><p>我的个人博客主要发原创文章，也欢迎浏览<br><a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><a id="more"></a><h1 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h1><p>本文参考 <a href="http://cmsblogs.com/?p=1185" target="_blank" rel="noopener">http://cmsblogs.com/?p=1185</a></p><p>迭代对于我们搞Java的来说绝对不陌生。我们常常使用JDK提供的迭代接口进行Java集合的迭代。</p><pre><code>Iterator iterator = list.iterator();        while(iterator.hasNext()){            String string = iterator.next();            //do something        }</code></pre><p>迭代其实我们可以简单地理解为遍历，是一个标准化遍历各类容器里面的所有对象的方法类，它是一个很典型的设计模式。Iterator模式是用于遍历集合类的标准访问方法。</p><p>它可以把访问逻辑从不同类型的集合类中抽象出来，从而避免向客户端暴露集合的内部结构。 在没有迭代器时我们都是这么进行处理的。如下：</p><p>对于数组我们是使用下标来进行处理的:</p><pre><code>int[] arrays = new int[10];   for(int i = 0 ; i &lt; arrays.length ; i++){       int a = arrays[i];       //do something   }</code></pre><p>对于ArrayList是这么处理的:</p><pre><code>List&lt;String&gt; list = new ArrayList&lt;String&gt;();   for(int i = 0 ; i &lt; list.size() ;  i++){      String string = list.get(i);      //do something   }</code></pre><p>对于这两种方式，我们总是都事先知道集合的内部结构，访问代码和集合本身是紧密耦合的，无法将访问逻辑从集合类和客户端代码中分离出来。同时每一种集合对应一种遍历方法，客户端代码无法复用。</p><p>在实际应用中如何需要将上面将两个集合进行整合是相当麻烦的。所以为了解决以上问题，Iterator模式腾空出世，它总是用同一种逻辑来遍历集合。</p><p>使得客户端自身不需要来维护集合的内部结构，所有的内部状态都由Iterator来维护。客户端从不直接和集合类打交道，它总是控制Iterator，向它发送”向前”，”向后”，”取当前元素”的命令，就可以间接遍历整个集合。</p><p>上面只是对Iterator模式进行简单的说明，下面我们看看Java中Iterator接口，看他是如何来进行实现的。</p><h2 id="java-util-Iterator"><a href="#java-util-Iterator" class="headerlink" title="java.util.Iterator"></a>java.util.Iterator</h2><p>在Java中Iterator为一个接口，它只提供了迭代了基本规则，在JDK中他是这样定义的：对 collection 进行迭代的迭代器。迭代器取代了 Java Collections Framework 中的 Enumeration。迭代器与枚举有两点不同：</p><pre><code>1、迭代器允许调用者利用定义良好的语义在迭代期间从迭代器所指向的 collection 移除元素。2、方法名称得到了改进。</code></pre><p>其接口定义如下：</p><pre><code>public interface Iterator {　　boolean hasNext();　　Object next();　　void remove();}</code></pre><p>其中：</p><pre><code>Object next()：返回迭代器刚越过的元素的引用，返回值是Object，需要强制转换成自己需要的类型boolean hasNext()：判断容器内是否还有可供访问的元素void remove()：删除迭代器刚越过的元素</code></pre><p>对于我们而言，我们只一般只需使用next()、hasNext()两个方法即可完成迭代。如下：</p><pre><code>for(Iterator it = c.iterator(); it.hasNext(); ) {　　Object o = it.next();　　 //do something}</code></pre><p>==前面阐述了Iterator有一个很大的优点,就是我们不必知道集合的内部结果,集合的内部结构、状态由Iterator来维持，通过统一的方法hasNext()、next()来判断、获取下一个元素，至于具体的内部实现我们就不用关心了。==</p><p>但是作为一个合格的程序员我们非常有必要来弄清楚Iterator的实现。下面就ArrayList的源码进行分析分析。</p><h2 id="各个集合的Iterator的实现"><a href="#各个集合的Iterator的实现" class="headerlink" title="各个集合的Iterator的实现"></a>各个集合的Iterator的实现</h2><p>下面就ArrayList的Iterator实现来分析，其实如果我们理解了ArrayList、Hashset、TreeSet的数据结构，内部实现，对于他们是如何实现Iterator也会胸有成竹的。因为ArrayList的内部实现采用数组，所以我们只需要记录相应位置的索引即可，其方法的实现比较简单。</p><p>ArrayList的Iterator实现</p><p>在ArrayList内部首先是定义一个内部类Itr，该内部类实现Iterator接口，如下：</p><pre><code>private class Itr implements Iterator&lt;E&gt; {    //do something}而ArrayList的iterator()方法实现：public Iterator&lt;E&gt; iterator() {        return new Itr();    }</code></pre><p>所以通过使用ArrayList.iterator()方法返回的是Itr()内部类，所以现在我们需要关心的就是Itr()内部类的实现：</p><p>在Itr内部定义了三个int型的变量：cursor、lastRet、expectedModCount。其中cursor表示下一个元素的索引位置，lastRet表示上一个元素的索引位置</p><pre><code>int cursor;             int lastRet = -1;     int expectedModCount = modCount;</code></pre><p>从cursor、lastRet定义可以看出，lastRet一直比cursor少一所以hasNext()实现方法异常简单，只需要判断cursor和lastRet是否相等即可。</p><pre><code>public boolean hasNext() {    return cursor != size;}</code></pre><p>对于next()实现其实也是比较简单的，只要返回cursor索引位置处的元素即可，然后修改cursor、lastRet即可。</p><pre><code>public E next() {    checkForComodification();    int i = cursor;    //记录索引位置    if (i &gt;= size)    //如果获取元素大于集合元素个数，则抛出异常        throw new NoSuchElementException();    Object[] elementData = ArrayList.this.elementData;    if (i &gt;= elementData.length)        throw new ConcurrentModificationException();    cursor = i + 1;      //cursor + 1    return (E) elementData[lastRet = i];  //lastRet + 1 且返回cursor处元素}</code></pre><blockquote><p>checkForComodification()主要用来判断集合的修改次数是否合法，即用来判断遍历过程中集合是否被修改过。</p><p>。modCount用于记录ArrayList集合的修改次数，初始化为0，，每当集合被修改一次（结构上面的修改，内部update不算），如add、remove等方法，modCount + 1，所以如果modCount不变，则表示集合内容没有被修改。</p><p>该机制主要是用于实现ArrayList集合的快速失败机制，在Java的集合中，较大一部分集合是存在快速失败机制的，这里就不多说，后面会讲到。</p><p>所以要保证在遍历过程中不出错误，我们就应该保证在遍历过程中不会对集合产生结构上的修改（当然remove方法除外），出现了异常错误，我们就应该认真检查程序是否出错而不是catch后不做处理。</p></blockquote><pre><code>final void checkForComodification() {            if (modCount != expectedModCount)                throw new ConcurrentModificationException();        }对于remove()方法的是实现，它是调用ArrayList本身的remove()方法删除lastRet位置元素，然后修改modCount即可。public void remove() {    if (lastRet &lt; 0)        throw new IllegalStateException();    checkForComodification();    try {        ArrayList.this.remove(lastRet);        cursor = lastRet;        lastRet = -1;        expectedModCount = modCount;    } catch (IndexOutOfBoundsException ex) {        throw new ConcurrentModificationException();    }}</code></pre><p>这里就对ArrayList的Iterator实现讲解到这里，对于Hashset、TreeSet等集合的Iterator实现，各位如果感兴趣可以继续研究，个人认为在研究这些集合的源码之前，有必要对该集合的数据结构有清晰的认识，这样会达到事半功倍的效果！！！！</p><h1 id="fail-fast机制"><a href="#fail-fast机制" class="headerlink" title="fail-fast机制"></a>fail-fast机制</h1><p>这部分参考<a href="http://cmsblogs.com/?p=1220" target="_blank" rel="noopener">http://cmsblogs.com/?p=1220</a></p><p>在JDK的Collection中我们时常会看到类似于这样的话：</p><p>例如，ArrayList:</p><blockquote><p>注意，迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败迭代器会尽最大努力抛出ConcurrentModificationException。<br>因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误的做法：迭代器的快速失败行为应该仅用于检测 bug。</p></blockquote><p>HashMap中：</p><blockquote><p>注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</p></blockquote><p>在这两段话中反复地提到”快速失败”。那么何为”快速失败”机制呢？</p><blockquote><p>“快速失败”也就是fail-fast，它是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。</p><p>记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException异常，从而产生fail-fast机制。</p></blockquote><h2 id="fail-fast示例"><a href="#fail-fast示例" class="headerlink" title="fail-fast示例"></a>fail-fast示例</h2><pre><code>public class FailFastTest {    private static List&lt;Integer&gt; list = new ArrayList&lt;&gt;();    /**     * @desc:线程one迭代list     * @Project:test     * @file:FailFastTest.java     * @Authro:chenssy     * @data:2014年7月26日     */    private static class threadOne extends Thread{        public void run() {            Iterator&lt;Integer&gt; iterator = list.iterator();            while(iterator.hasNext()){                int i = iterator.next();                System.out.println(&quot;ThreadOne 遍历:&quot; + i);                try {                    Thread.sleep(10);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }    /**     * @desc:当i == 3时，修改list     * @Project:test     * @file:FailFastTest.java     * @Authro:chenssy     * @data:2014年7月26日     */    private static class threadTwo extends Thread{        public void run(){            int i = 0 ;             while(i &lt; 6){                System.out.println(&quot;ThreadTwo run：&quot; + i);                if(i == 3){                    list.remove(i);                }                i++;            }        }    }    public static void main(String[] args) {        for(int i = 0 ; i &lt; 10;i++){            list.add(i);        }        new threadOne().start();        new threadTwo().start();    }}</code></pre><p>运行结果：</p><pre><code>ThreadOne 遍历:0ThreadTwo run：0ThreadTwo run：1ThreadTwo run：2ThreadTwo run：3ThreadTwo run：4ThreadTwo run：5Exception in thread &quot;Thread-0&quot; java.util.ConcurrentModificationException    at java.util.ArrayList$Itr.checkForComodification(Unknown Source)    at java.util.ArrayList$Itr.next(Unknown Source)    at test.ArrayListTest$threadOne.run(ArrayListTest.java:23)</code></pre><h2 id="fail-fast产生原因"><a href="#fail-fast产生原因" class="headerlink" title="fail-fast产生原因"></a>fail-fast产生原因</h2><p>通过上面的示例和讲解，我初步知道fail-fast产生的原因就在于程序在对 collection 进行迭代时，某个线程对该 collection 在结构上对其做了修改，这时迭代器就会抛出 ConcurrentModificationException 异常信息，从而产生 fail-fast。</p><blockquote><p>要了解fail-fast机制，我们首先要对ConcurrentModificationException 异常有所了解。当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。同时需要注意的是，该异常不会始终指出对象已经由不同线程并发修改，如果单线程违反了规则，同样也有可能会抛出改异常。</p></blockquote><p>诚然，迭代器的快速失败行为无法得到保证，它不能保证一定会出现该错误，但是快速失败操作会尽最大努力抛出ConcurrentModificationException异常，所以因此，为提高此类操作的正确性而编写一个依赖于此异常的程序是错误的做法，正确做法是：ConcurrentModificationException 应该仅用于检测 bug。下面我将以ArrayList为例进一步分析fail-fast产生的原因。</p><blockquote><p>从前面我们知道fail-fast是在操作迭代器时产生的。现在我们来看看ArrayList中迭代器的源代码：</p></blockquote><pre><code>private class Itr implements Iterator&lt;E&gt; {        int cursor;        int lastRet = -1;        int expectedModCount = ArrayList.this.modCount;        public boolean hasNext() {            return (this.cursor != ArrayList.this.size);        }        public E next() {            checkForComodification();            /** 省略此处代码 */        }        public void remove() {            if (this.lastRet &lt; 0)                throw new IllegalStateException();            checkForComodification();            /** 省略此处代码 */        }        final void checkForComodification() {            if (ArrayList.this.modCount == this.expectedModCount)                return;            throw new ConcurrentModificationException();        }    }</code></pre><p>从上面的源代码我们可以看出，迭代器在调用next()、remove()方法时都是调用checkForComodification()方法，该方法主要就是检测modCount == expectedModCount ? 若不等则抛出ConcurrentModificationException 异常，从而产生fail-fast机制。所以要弄清楚为什么会产生fail-fast机制我们就必须要用弄明白为什么modCount != expectedModCount ，他们的值在什么时候发生改变的。</p><p>expectedModCount 是在Itr中定义的：int expectedModCount = ArrayList.this.modCount;所以他的值是不可能会修改的，所以会变的就是modCount。modCount是在 AbstractList 中定义的，为全局变量：</p><p>protected transient int modCount = 0;<br>那么他什么时候因为什么原因而发生改变呢？请看ArrayList的源码：</p><pre><code>public boolean add(E paramE) {    ensureCapacityInternal(this.size + 1);    /** 省略此处代码 */}private void ensureCapacityInternal(int paramInt) {    if (this.elementData == EMPTY_ELEMENTDATA)        paramInt = Math.max(10, paramInt);    ensureExplicitCapacity(paramInt);}private void ensureExplicitCapacity(int paramInt) {    this.modCount += 1;    //修改modCount    /** 省略此处代码 */}</code></pre><p>   public boolean remove(Object paramObject) {<br>        int i;<br>        if (paramObject == null)<br>            for (i = 0; i &lt; this.size; ++i) {<br>                if (this.elementData[i] != null)<br>                    continue;<br>                fastRemove(i);<br>                return true;<br>            }<br>        else<br>            for (i = 0; i &lt; this.size; ++i) {<br>                if (!(paramObject.equals(this.elementData[i])))<br>                    continue;<br>                fastRemove(i);<br>                return true;<br>            }<br>        return false;<br>    }</p><pre><code>private void fastRemove(int paramInt) {    this.modCount += 1;   //修改modCount    /** 省略此处代码 */}public void clear() {    this.modCount += 1;    //修改modCount    /** 省略此处代码 */}</code></pre><blockquote><p>从上面的源代码我们可以看出，ArrayList中无论add、remove、clear方法只要是涉及了改变ArrayList元素的个数的方法都会导致modCount的改变。</p></blockquote><p>所以我们这里可以初步判断由于expectedModCount 得值与modCount的改变不同步，导致两者之间不等从而产生fail-fast机制。知道产生fail-fast产生的根本原因了，我们可以有如下场景：</p><p>有两个线程（线程A，线程B），其中线程A负责遍历list、线程B修改list。线程A在遍历list过程的某个时候（此时expectedModCount = modCount=N），线程启动，同时线程B增加一个元素，这是modCount的值发生改变（modCount + 1 = N + 1）。</p><p>线程A继续遍历执行next方法时，通告checkForComodification方法发现expectedModCount  = N  ，而modCount = N + 1，两者不等，这时就抛出ConcurrentModificationException 异常，从而产生fail-fast机制。</p><p>所以，直到这里我们已经完全了解了fail-fast产生的根本原因了。知道了原因就好找解决办法了。</p><p>三、fail-fast解决办法</p><p>通过前面的实例、源码分析，我想各位已经基本了解了fail-fast的机制，下面我就产生的原因提出解决方案。这里有两种解决方案：</p><blockquote><p>方案一：在遍历过程中所有涉及到改变modCount值得地方全部加上synchronized或者直接使用Collections.synchronizedList，这样就可以解决。但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作。</p><p>方案二：使用CopyOnWriteArrayList来替换ArrayList。推荐使用该方案。</p></blockquote><p>CopyOnWriteArrayList为何物？ArrayList 的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。 该类产生的开销比较大，但是在两种情况下，它非常适合使用。</p><blockquote><p>1：在不能或不想进行同步遍历，但又需要从并发线程中排除冲突时。</p><p>2：当遍历操作的数量大大超过可变操作的数量时。遇到这两种情况使用CopyOnWriteArrayList来替代ArrayList再适合不过了。那么为什么CopyOnWriterArrayList可以替代ArrayList呢？</p></blockquote><p>第一、CopyOnWriterArrayList的无论是从数据结构、定义都和ArrayList一样。它和ArrayList一样，同样是实现List接口，底层使用数组实现。在方法上也包含add、remove、clear、iterator等方法。</p><p>第二、CopyOnWriterArrayList根本就不会产生ConcurrentModificationException异常，也就是它使用迭代器完全不会产生fail-fast机制。请看：</p><p>private static class COWIterator<e> implements ListIterator<e> {<br>        /*<em> 省略此处代码 </em>/<br>        public E next() {<br>            if (!(hasNext()))<br>                throw new NoSuchElementException();<br>            return this.snapshot[(this.cursor++)];<br>        }</e></e></p><pre><code>    /** 省略此处代码 */}</code></pre><p>CopyOnWriterArrayList的方法根本就没有像ArrayList中使用checkForComodification方法来判断expectedModCount 与 modCount 是否相等。它为什么会这么做，凭什么可以这么做呢？我们以add方法为例：</p><pre><code>public boolean add(E paramE) {        ReentrantLock localReentrantLock = this.lock;        localReentrantLock.lock();        try {            Object[] arrayOfObject1 = getArray();            int i = arrayOfObject1.length;            Object[] arrayOfObject2 = Arrays.copyOf(arrayOfObject1, i + 1);            arrayOfObject2[i] = paramE;            setArray(arrayOfObject2);            int j = 1;            return j;        } finally {            localReentrantLock.unlock();        }    }    final void setArray(Object[] paramArrayOfObject) {        this.array = paramArrayOfObject;    }</code></pre><p>CopyOnWriterArrayList的add方法与ArrayList的add方法有一个最大的不同点就在于，下面三句代码：</p><pre><code>Object[] arrayOfObject2 = Arrays.copyOf(arrayOfObject1, i + 1);arrayOfObject2[i] = paramE;setArray(arrayOfObject2);</code></pre><p>就是这三句代码使得CopyOnWriterArrayList不会抛ConcurrentModificationException异常。他们所展现的魅力就在于copy原来的array，再在copy数组上进行add操作，这样做就完全不会影响COWIterator中的array了。</p><blockquote><p>所以CopyOnWriterArrayList所代表的核心概念就是：任何对array在结构上有所改变的操作（add、remove、clear等），CopyOnWriterArrayList都会copy现有的数据，再在copy的数据上修改，这样就不会影响COWIterator中的数据了，修改完成之后改变原有数据的引用即可。同时这样造成的代价就是产生大量的对象，同时数组的copy也是相当有损耗的。</p></blockquote><h1 id="Comparable-和-Comparator"><a href="#Comparable-和-Comparator" class="headerlink" title="Comparable 和 Comparator"></a>Comparable 和 Comparator</h1><p>Java 中为我们提供了两种比较机制：Comparable 和 Comparator，他们之间有什么区别呢？今天来了解一下。</p><h2 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h2><p>Comparable 在 java.lang包下，是一个接口，内部只有一个方法 compareTo()：</p><pre><code>public interface Comparable&lt;T&gt; {    public int compareTo(T o);}</code></pre><p>Comparable 可以让实现它的类的对象进行比较，具体的比较规则是按照 compareTo 方法中的规则进行。这种顺序称为 自然顺序。</p><p>compareTo 方法的返回值有三种情况：</p><pre><code>e1.compareTo(e2) &gt; 0 即 e1 &gt; e2e1.compareTo(e2) = 0 即 e1 = e2e1.compareTo(e2) &lt; 0 即 e1 &lt; e2</code></pre><p>注意：</p><blockquote><p>1.由于 null 不是一个类，也不是一个对象，因此在重写 compareTo 方法时应该注意 e.compareTo(null) 的情况，即使 e.equals(null) 返回 false，compareTo 方法也应该主动抛出一个空指针异常 NullPointerException。</p><p>2.Comparable 实现类重写 compareTo 方法时一般要求 e1.compareTo(e2) == 0 的结果要和 e1.equals(e2) 一致。这样将来使用 SortedSet 等根据类的自然排序进行排序的集合容器时可以保证保存的数据的顺序和想象中一致。<br>有人可能好奇上面的第二点如果违反了会怎样呢？</p></blockquote><p>举个例子，如果你往一个 SortedSet 中先后添加两个对象 a 和 b，a b 满足 (!a.equals(b) &amp;&amp; a.compareTo(b) == 0)，同时也没有另外指定个 Comparator，那当你添加完 a 再添加 b 时会添加失败返回 false, SortedSet 的 size 也不会增加，因为在 SortedSet 看来它们是相同的，而 SortedSet 中是不允许重复的。</p><blockquote><p>实际上所有实现了 Comparable 接口的 Java 核心类的结果都和 equlas 方法保持一致。<br>实现了 Comparable 接口的 List 或则数组可以使用 Collections.sort() 或者 Arrays.sort() 方法进行排序。</p></blockquote><blockquote><p>实现了 Comparable 接口的对象才能够直接被用作 SortedMap (SortedSet) 的 key，要不然得在外边指定 Comparator 排序规则。</p></blockquote><p>因此自己定义的类如果想要使用有序的集合类，需要实现 Comparable 接口，比如：</p><p>**</p><ul><li>description: 测试用的实体类 书, 实现了 Comparable 接口，自然排序</li><li><br></li><li>author: shixinzhang</li><li><br></li><li>data: 10/5/2016<br>*/<br>public class BookBean implements Serializable, Comparable {<br> private String name;<br> private int count;</li></ul><pre><code>public BookBean(String name, int count) {    this.name = name;    this.count = count;}public String getName() {    return name;}public void setName(String name) {    this.name = name;}public int getCount() {    return count;}public void setCount(int count) {    this.count = count;}/** * 重写 equals * @param o * @return */@Overridepublic boolean equals(Object o) {    if (this == o) return true;    if (!(o instanceof BookBean)) return false;    BookBean bean = (BookBean) o;    if (getCount() != bean.getCount()) return false;    return getName().equals(bean.getName());}/** * 重写 hashCode 的计算方法 * 根据所有属性进行 迭代计算，避免重复 * 计算 hashCode 时 计算因子 31 见得很多，是一个质数，不能再被除 * @return */@Overridepublic int hashCode() {    //调用 String 的 hashCode(), 唯一表示一个字符串内容    int result = getName().hashCode();    //乘以 31, 再加上 count    result = 31 * result + getCount();    return result;}@Overridepublic String toString() {    return &quot;BookBean{&quot; +            &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +            &quot;, count=&quot; + count +            &apos;}&apos;;}/** * 当向 TreeSet 中添加 BookBean 时，会调用这个方法进行排序 * @param another * @return */@Overridepublic int compareTo(Object another) {    if (another instanceof BookBean){        BookBean anotherBook = (BookBean) another;        int result;        //比如这里按照书价排序        result = getCount() - anotherBook.getCount();           //或者按照 String 的比较顺序      //result = getName().compareTo(anotherBook.getName());        if (result == 0){   //当书价一致时，再对比书名。 保证所有属性比较一遍            result = getName().compareTo(anotherBook.getName());        }        return result;    }    // 一样就返回 0    return 0;}</code></pre><p>上述代码还重写了 equlas(), hashCode() 方法，自定义的类将来可能会进行比较时，建议重写这些方法。</p><blockquote><p>这里我想表达的是在有些场景下 equals 和 compareTo 结果要保持一致，这时候不重写 equals，使用 Object.equals 方法得到的结果会有问题，比如说 HashMap.put() 方法，会先调用 key 的 equals 方法进行比较，然后才调用 compareTo。</p><p>后面重写 compareTo 时，要判断某个相同时对比下一个属性，把所有属性都比较一次。</p></blockquote><h2 id="Comparable-1"><a href="#Comparable-1" class="headerlink" title="Comparable"></a>Comparable</h2><p>Comparable 接口属于 Java 集合框架的一部分。</p><p>Comparator 定制排序</p><p>Comparator 在 java.util 包下，也是一个接口，JDK 1.8 以前只有两个方法：</p><pre><code>public interface Comparator&lt;T&gt; {    public int compare(T lhs, T rhs);    public boolean equals(Object object);}</code></pre><p>JDK 1.8 以后又新增了很多方法：</p><p>基本上都是跟 Function 相关的，这里暂不介绍 1.8 新增的。</p><blockquote><p>从上面内容可知使用自然排序需要类实现 Comparable，并且在内部重写 comparaTo 方法。</p><p>而 Comparator 则是在外部制定排序规则，然后作为排序策略参数传递给某些类，比如 Collections.sort(), Arrays.sort(), 或者一些内部有序的集合（比如 SortedSet，SortedMap 等）。</p></blockquote><p>Comparator的使用方法<br>使用方式主要分三步：</p><p>创建一个 Comparator 接口的实现类，并赋值给一个对象<br>在 compare 方法中针对自定义类写排序规则<br>将 Comparator 对象作为参数传递给 排序类的某个方法<br>向排序类中添加 compare 方法中使用的自定义类<br>举个例子：</p><pre><code>// 1.创建一个实现 Comparator 接口的对象Comparator comparator = new Comparator() {    @Override    public int compare(Object object1, Object object2) {        if (object1 instanceof NewBookBean &amp;&amp; object2 instanceof NewBookBean){            NewBookBean newBookBean = (NewBookBean) object1;            NewBookBean newBookBean1 = (NewBookBean) object2;            //具体比较方法参照 自然排序的 compareTo 方法，这里只举个栗子            return newBookBean.getCount() - newBookBean1.getCount();        }        return 0;    }};//2.将此对象作为形参传递给 TreeSet 的构造器中TreeSet treeSet = new TreeSet(comparator);//3.向 TreeSet 中添加 步骤 1 中 compare 方法中设计的类的对象treeSet.add(new NewBookBean(&quot;A&quot;,34));treeSet.add(new NewBookBean(&quot;S&quot;,1));treeSet.add( new NewBookBean(&quot;V&quot;,46));treeSet.add( new NewBookBean(&quot;Q&quot;,26));</code></pre><p>其实可以看到，Comparator 的使用是一种策略模式。<br>排序类中持有一个 Comparator 接口的引用：</p><pre><code>Comparator&lt;? super K&gt; comparator;</code></pre><p>而我们可以传入各种自定义排序规则的 Comparator 实现类，对同样的类制定不同的排序策略。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java 中的两种排序方式：</p><pre><code>Comparable 自然排序。（实体类实现）Comparator 是定制排序。（无法修改实体类时，直接在调用方创建）同时存在时采用 Comparator（定制排序）的规则进行比较。</code></pre><p>对于一些普通的数据类型（比如 String, Integer, Double…），它们默认实现了Comparable 接口，实现了 compareTo 方法，我们可以直接使用。</p><p>而对于一些自定义类，它们可能在不同情况下需要实现不同的比较策略，我们可以新创建 Comparator 接口，然后使用特定的 Comparator 实现进行比较。</p><p>这就是 Comparable 和 Comparator 的区别。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们来探索一下LIterator，fail-fast机制与比较器的源码。&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;喜欢的话麻烦star一下哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/05/9/collection3&quot;&gt;https://h2pl.github.io/2018/05/9/collection3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的个人博客主要发原创文章，也欢迎浏览&lt;br&gt;&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java集合类" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
    
      <category term="Java集合框架" scheme="http://h2pl.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java集合详解2：LinkedList和Queue</title>
    <link href="http://h2pl.github.io/2018/05/09/collection2/"/>
    <id>http://h2pl.github.io/2018/05/09/collection2/</id>
    <published>2018-05-09T14:31:36.000Z</published>
    <updated>2018-05-11T01:38:17.025Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来探索一下LinkedList和Queue，以及Stack的源码。</p><p>具体代码在我的GitHub中可以找到</p><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p><p>喜欢的话麻烦star一下哈</p><p>文章首发于我的个人博客：</p><p><a href="https://h2pl.github.io/2018/05/09/collection2">https://h2pl.github.io/2018/05/09/collection2</a></p><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：<a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a></p><p>我的个人博客主要发原创文章，也欢迎浏览<br><a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>本文参考 <a href="http://cmsblogs.com/?p=155" target="_blank" rel="noopener">http://cmsblogs.com/?p=155</a><br>和<br><a href="https://www.jianshu.com/p/0e84b8d3606c" target="_blank" rel="noopener">https://www.jianshu.com/p/0e84b8d3606c</a></p><a id="more"></a><h1 id="LinkedList概述"><a href="#LinkedList概述" class="headerlink" title="LinkedList概述"></a>LinkedList概述</h1><blockquote><p>  LinkedList与ArrayList一样实现List接口，只是ArrayList是List接口的大小可变数组的实现，LinkedList是List接口链表的实现。基于链表实现的方式使得LinkedList在插入和删除时更优于ArrayList，而随机访问则比ArrayList逊色些。</p><p>  LinkedList实现所有可选的列表操作，并允许所有的元素包括null。</p><p>  除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。</p><p>  此类实现 Deque 接口，为 add、poll 提供先进先出队列操作，以及其他堆栈和双端队列操作。</p><p>  所有操作都是按照双重链接列表的需要执行的。在列表中编索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。</p><p>  同时，与ArrayList一样此实现不是同步的。</p><p>  （以上摘自JDK 6.0 API）。</p></blockquote><p>源码分析</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>  首先我们先看LinkedList的定义：</p><pre><code>public class LinkedList&lt;E&gt;    extends AbstractSequentialList&lt;E&gt;    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable      从这段代码中我们可以清晰地看出LinkedList继承AbstractSequentialList，实现List、Deque、Cloneable、Serializable。其中AbstractSequentialList提供了 List 接口的骨干实现，从而最大限度地减少了实现受“连续访问”数据存储（如链接列表）支持的此接口所需的工作,从而以减少实现List接口的复杂度。Deque一个线性 collection，支持在两端插入和移除元素，定义了双端队列的操作。</code></pre><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>在LinkedList中提供了两个基本属性size、header。</p><p>private transient Entry<e> header = new Entry<e>(null, null, null);<br>private transient int size = 0;<br>其中size表示的LinkedList的大小，header表示链表的表头，Entry为节点对象。</e></e></p><pre><code>private static class Entry&lt;E&gt; {    E element;        //元素节点    Entry&lt;E&gt; next;    //下一个元素    Entry&lt;E&gt; previous;  //上一个元素    Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) {        this.element = element;        this.next = next;        this.previous = previous;    }}  上面为Entry对象的源代码，Entry为LinkedList的内部类，它定义了存储的元素。该元素的前一个元素、后一个元素，这是典型的双向链表定义方式。</code></pre><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>LinkedList提供了两个构造方法：LinkedList()和LinkedList(Collection&lt;? extends E&gt; c)。</p><pre><code>/**     *  构造一个空列表。     */    public LinkedList() {        header.next = header.previous = header;    }    /**     *  构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。     */    public LinkedList(Collection&lt;? extends E&gt; c) {        this();        addAll(c);    }</code></pre><p>  LinkedList()构造一个空列表。里面没有任何元素，仅仅只是将header节点的前一个元素、后一个元素都指向自身。</p><p>  LinkedList(Collection&lt;? extends E&gt; c)： 构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。该构造函数首先会调用LinkedList()，构造一个空列表，然后调用了addAll()方法将Collection中的所有元素添加到列表中。以下是addAll()的源代码：</p><pre><code>/**     *  添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。     */    public boolean addAll(Collection&lt;? extends E&gt; c) {        return addAll(size, c);    }/** * 将指定 collection 中的所有元素从指定位置开始插入此列表。其中index表示在其中插入指定collection中第一个元素的索引 */public boolean addAll(int index, Collection&lt;? extends E&gt; c) {    //若插入的位置小于0或者大于链表长度，则抛出IndexOutOfBoundsException异常    if (index &lt; 0 || index &gt; size)        throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot; + size);    Object[] a = c.toArray();    int numNew = a.length;    //插入元素的个数    //若插入的元素为空，则返回false    if (numNew == 0)        return false;    //modCount:在AbstractList中定义的，表示从结构上修改列表的次数    modCount++;    //获取插入位置的节点，若插入的位置在size处，则是头节点，否则获取index位置处的节点    Entry&lt;E&gt; successor = (index == size ? header : entry(index));    //插入位置的前一个节点，在插入过程中需要修改该节点的next引用：指向插入的节点元素    Entry&lt;E&gt; predecessor = successor.previous;    //执行插入动作    for (int i = 0; i &lt; numNew; i++) {        //构造一个节点e，这里已经执行了插入节点动作同时修改了相邻节点的指向引用        //        Entry&lt;E&gt; e = new Entry&lt;E&gt;((E) a[i], successor, predecessor);        //将插入位置前一个节点的下一个元素引用指向当前元素        predecessor.next = e;        //修改插入位置的前一个节点，这样做的目的是将插入位置右移一位，保证后续的元素是插在该元素的后面，确保这些元素的顺序        predecessor = e;    }    successor.previous = predecessor;    //修改容量大小    size += numNew;    return true;}  在addAll()方法中，涉及到了两个方法，一个是entry(int index)，该方法为LinkedList的私有方法，主要是用来查找index位置的节点元素。/**     * 返回指定位置(若存在)的节点元素     */    private Entry&lt;E&gt; entry(int index) {        if (index &lt; 0 || index &gt;= size)            throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot;                    + size);        //头部节点        Entry&lt;E&gt; e = header;        //判断遍历的方向        if (index &lt; (size &gt;&gt; 1)) {            for (int i = 0; i &lt;= index; i++)                e = e.next;        } else {            for (int i = size; i &gt; index; i--)                e = e.previous;        }        return e;    }</code></pre><p>  从该方法有两个遍历方向中我们也可以看出LinkedList是双向链表，这也是在构造方法中为什么需要将header的前、后节点均指向自己。</p><p>  如果对数据结构有点了解，对上面所涉及的内容应该问题，我们只需要清楚一点：LinkedList是双向链表，其余都迎刃而解。</p><p>  由于篇幅有限，下面将就LinkedList中几个常用的方法进行源码分析。</p><h2 id="增加方法"><a href="#增加方法" class="headerlink" title="增加方法"></a>增加方法</h2><pre><code>  add(E e): 将指定元素添加到此列表的结尾。public boolean add(E e) {    addBefore(e, header);        return true;    }      该方法调用addBefore方法，然后直接返回true，对于addBefore()而已，它为LinkedList的私有方法。private Entry&lt;E&gt; addBefore(E e, Entry&lt;E&gt; entry) {        //利用Entry构造函数构建一个新节点 newEntry，        Entry&lt;E&gt; newEntry = new Entry&lt;E&gt;(e, entry, entry.previous);        //修改newEntry的前后节点的引用，确保其链表的引用关系是正确的        newEntry.previous.next = newEntry;        newEntry.next.previous = newEntry;        //容量+1        size++;        //修改次数+1        modCount++;        return newEntry;    }</code></pre><p>  在addBefore方法中无非就是做了这件事：构建一个新节点newEntry，然后修改其前后的引用。</p><p>  LinkedList还提供了其他的增加方法：</p><pre><code>add(int index, E element)：在此列表中指定的位置插入指定的元素。addAll(Collection&lt;? extends E&gt; c)：添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。addAll(int index, Collection&lt;? extends E&gt; c)：将指定 collection 中的所有元素从指定位置开始插入此列表。AddFirst(E e): 将指定元素插入此列表的开头。addLast(E e): 将指定元素添加到此列表的结尾。</code></pre><h2 id="移除方法"><a href="#移除方法" class="headerlink" title="移除方法"></a>移除方法</h2><pre><code>  remove(Object o)：从此列表中移除首次出现的指定元素（如果存在）。该方法的源代码如下：public boolean remove(Object o) {        if (o==null) {            for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) {                if (e.element==null) {                    remove(e);                    return true;                }            }        } else {            for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) {                if (o.equals(e.element)) {                    remove(e);                    return true;                }            }        }        return false;    }</code></pre><p>  该方法首先会判断移除的元素是否为null，然后迭代这个链表找到该元素节点，最后调用remove(Entry<e> e)，remove(Entry<e> e)为私有方法，是LinkedList中所有移除方法的基础方法，如下：</e></e></p><pre><code>private E remove(Entry&lt;E&gt; e) {        if (e == header)            throw new NoSuchElementException();        //保留被移除的元素：要返回        E result = e.element;        //将该节点的前一节点的next指向该节点后节点        e.previous.next = e.next;        //将该节点的后一节点的previous指向该节点的前节点        //这两步就可以将该节点从链表从除去：在该链表中是无法遍历到该节点的        e.next.previous = e.previous;        //将该节点归空        e.next = e.previous = null;        e.element = null;        size--;        modCount++;        return result;    }</code></pre><p>其他的移除方法：</p><pre><code>clear()： 从此列表中移除所有元素。remove()：获取并移除此列表的头（第一个元素）。remove(int index)：移除此列表中指定位置处的元素。remove(Objec o)：从此列表中移除首次出现的指定元素（如果存在）。removeFirst()：移除并返回此列表的第一个元素。removeFirstOccurrence(Object o)：从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。removeLast()：移除并返回此列表的最后一个元素。removeLastOccurrence(Object o)：从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。</code></pre><h2 id="查找方法"><a href="#查找方法" class="headerlink" title="查找方法"></a>查找方法</h2><pre><code>对于查找方法的源码就没有什么好介绍了，无非就是迭代，比对，然后就是返回当前值。get(int index)：返回此列表中指定位置处的元素。getFirst()：返回此列表的第一个元素。getLast()：返回此列表的最后一个元素。indexOf(Object o)：返回此列表中首次出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。lastIndexOf(Object o)：返回此列表中最后出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。</code></pre><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>Queue接口定义了队列数据结构，元素是有序的(按插入顺序)，先进先出。Queue接口相关的部分UML类图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/195193-bcff191213cf126a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/578" alt="image"></p><h2 id="DeQueue"><a href="#DeQueue" class="headerlink" title="DeQueue"></a>DeQueue</h2><blockquote><p>DeQueue(Double-ended queue)为接口，继承了Queue接口，创建双向队列，灵活性更强，可以前向或后向迭代，在队头队尾均可心插入或删除元素。它的两个主要实现类是ArrayDeque和LinkedList。</p></blockquote><h2 id="ArrayDeque-（底层使用循环数组实现双向队列）"><a href="#ArrayDeque-（底层使用循环数组实现双向队列）" class="headerlink" title="ArrayDeque （底层使用循环数组实现双向队列）"></a>ArrayDeque （底层使用循环数组实现双向队列）</h2><p>创建</p><pre><code>public ArrayDeque() {   // 默认容量为16   elements = new Object[16];}public ArrayDeque(int numElements) {   // 指定容量的构造函数   allocateElements(numElements);}private void allocateElements(int numElements) {        int initialCapacity = MIN_INITIAL_CAPACITY;// 最小容量为8        // Find the best power of two to hold elements.        // Tests &quot;&lt;=&quot; because arrays aren&apos;t kept full.        // 如果要分配的容量大于等于8，扩大成2的幂（是为了维护头、尾下标值）；否则使用最小容量8        if (numElements &gt;= initialCapacity) {            initialCapacity = numElements;            initialCapacity |= (initialCapacity &gt;&gt;&gt;  1);            initialCapacity |= (initialCapacity &gt;&gt;&gt;  2);            initialCapacity |= (initialCapacity &gt;&gt;&gt;  4);            initialCapacity |= (initialCapacity &gt;&gt;&gt;  8);            initialCapacity |= (initialCapacity &gt;&gt;&gt; 16);            initialCapacity++;            if (initialCapacity &lt; 0)   // Too many elements, must back off                initialCapacity &gt;&gt;&gt;= 1;// Good luck allocating 2 ^ 30 elements        }        elements = new Object[initialCapacity];    }</code></pre><p>add操作</p><pre><code>add(E e) 调用 addLast(E e) 方法：public void addLast(E e) {   if (e == null)      throw new NullPointerException(&quot;e == null&quot;);   elements[tail] = e; // 根据尾索引，添加到尾端   // 尾索引+1，并与数组（length - 1）进行取‘&amp;’运算，因为length是2的幂，所以（length-1）转换为2进制全是1，   // 所以如果尾索引值 tail 小于等于（length - 1），那么‘&amp;’运算后仍为 tail 本身；如果刚好比（length - 1）大1时，   // ‘&amp;’运算后 tail 便为0（即回到了数组初始位置）。正是通过与（length - 1）进行取‘&amp;’运算来实现数组的双向循环。   // 如果尾索引和头索引重合了，说明数组满了，进行扩容。   if ((tail = (tail + 1) &amp; (elements.length - 1)) == head)      doubleCapacity();// 扩容为原来的2倍}addFirst(E e) 的实现：public void addFirst(E e) {   if (e == null)      throw new NullPointerException(&quot;e == null&quot;);   // 此处如果head为0，则-1（1111 1111 1111 1111 1111 1111 1111 1111）与（length - 1）进行取‘&amp;’运算，结果必然是（length - 1），即回到了数组的尾部。   elements[head = (head - 1) &amp; (elements.length - 1)] = e;   // 如果尾索引和头索引重合了，说明数组满了，进行扩容   if (head == tail)      doubleCapacity();}</code></pre><p>remove操作</p><pre><code>remove()方法最终都会调对应的poll()方法：    public E poll() {        return pollFirst();    }    public E pollFirst() {        int h = head;        @SuppressWarnings(&quot;unchecked&quot;) E result = (E) elements[h];        // Element is null if deque empty        if (result == null)            return null;        elements[h] = null;     // Must null out slot        // 头索引 + 1        head = (h + 1) &amp; (elements.length - 1);        return result;    }    public E pollLast() {        // 尾索引 - 1        int t = (tail - 1) &amp; (elements.length - 1);        @SuppressWarnings(&quot;unchecked&quot;) E result = (E) elements[t];        if (result == null)            return null;        elements[t] = null;        tail = t;        return result;    }</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/195193-e36436dd0c750c3c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="image"></p><h2 id="PriorityQueue（底层用数组实现堆的结构）"><a href="#PriorityQueue（底层用数组实现堆的结构）" class="headerlink" title="PriorityQueue（底层用数组实现堆的结构）"></a>PriorityQueue（底层用数组实现堆的结构）</h2><blockquote><p>优先队列跟普通的队列不一样，普通队列是一种遵循FIFO规则的队列，拿数据的时候按照加入队列的顺序拿取。 而优先队列每次拿数据的时候都会拿出优先级最高的数据。</p><p>优先队列内部维护着一个堆，每次取数据的时候都从堆顶拿数据（堆顶的优先级最高），这就是优先队列的原理。</p></blockquote><p>add，添加方法</p><pre><code>public boolean add(E e) {    return offer(e); // add方法内部调用offer方法}public boolean offer(E e) {    if (e == null) // 元素为空的话，抛出NullPointerException异常        throw new NullPointerException();    modCount++;    int i = size;    if (i &gt;= queue.length) // 如果当前用堆表示的数组已经满了，调用grow方法扩容        grow(i + 1); // 扩容    size = i + 1; // 元素个数+1    if (i == 0) // 堆还没有元素的情况        queue[0] = e; // 直接给堆顶赋值元素    else // 堆中已有元素的情况        siftUp(i, e); // 重新调整堆，从下往上调整，因为新增元素是加到最后一个叶子节点    return true;}private void siftUp(int k, E x) {    if (comparator != null)  // 比较器存在的情况下        siftUpUsingComparator(k, x); // 使用比较器调整    else // 比较器不存在的情况下        siftUpComparable(k, x); // 使用元素自身的比较器调整}private void siftUpUsingComparator(int k, E x) {    while (k &gt; 0) { // 一直循环直到父节点还存在        int parent = (k - 1) &gt;&gt;&gt; 1; // 找到父节点索引，等同于（k - 1）/ 2        Object e = queue[parent]; // 获得父节点元素        // 新元素与父元素进行比较，如果满足比较器结果，直接跳出，否则进行调整        if (comparator.compare(x, (E) e) &gt;= 0)             break;        queue[k] = e; // 进行调整，新位置的元素变成了父元素        k = parent; // 新位置索引变成父元素索引，进行递归操作    }    queue[k] = x; // 新添加的元素添加到堆中}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/195193-be988ac1a1a415d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/670" alt="image"><br>poll，出队方法</p><pre><code>public E poll() {    if (size == 0)        return null;    int s = --size; // 元素个数-1    modCount++;    E result = (E) queue[0]; // 得到堆顶元素    E x = (E) queue[s]; // 最后一个叶子节点    queue[s] = null; // 最后1个叶子节点置空    if (s != 0)        siftDown(0, x); // 从上往下调整，因为删除元素是删除堆顶的元素    return result;}private void siftDown(int k, E x) {    if (comparator != null) // 比较器存在的情况下        siftDownUsingComparator(k, x); // 使用比较器调整    else // 比较器不存在的情况下        siftDownComparable(k, x); // 使用元素自身的比较器调整}private void siftDownUsingComparator(int k, E x) {    int half = size &gt;&gt;&gt; 1; // 只需循环节点个数的一般即可    while (k &lt; half) {        int child = (k &lt;&lt; 1) + 1; // 得到父节点的左子节点索引，即（k * 2）+ 1        Object c = queue[child]; // 得到左子元素        int right = child + 1; // 得到父节点的右子节点索引        if (right &lt; size &amp;&amp;            comparator.compare((E) c, (E) queue[right]) &gt; 0) // 左子节点跟右子节点比较，取更大的值            c = queue[child = right];        if (comparator.compare(x, (E) c) &lt;= 0)  // 然后这个更大的值跟最后一个叶子节点比较            break;        queue[k] = c; // 新位置使用更大的值        k = child; // 新位置索引变成子元素索引，进行递归操作    }    queue[k] = x; // 最后一个叶子节点添加到合适的位置}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/195193-c88e7314648144da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/680" alt="image"><br>remove，删除队列元素</p><pre><code>public boolean remove(Object o) {    int i = indexOf(o); // 找到数据对应的索引    if (i == -1) // 不存在的话返回false        return false;    else { // 存在的话调用removeAt方法，返回true        removeAt(i);        return true;    }}private E removeAt(int i) {    modCount++;    int s = --size; // 元素个数-1    if (s == i) // 如果是删除最后一个叶子节点        queue[i] = null; // 直接置空，删除即可，堆还是保持特质，不需要调整    else { // 如果是删除的不是最后一个叶子节点        E moved = (E) queue[s]; // 获得最后1个叶子节点元素        queue[s] = null; // 最后1个叶子节点置空        siftDown(i, moved); // 从上往下调整        if (queue[i] == moved) { // 如果从上往下调整完毕之后发现元素位置没变，从下往上调整            siftUp(i, moved); // 从下往上调整            if (queue[i] != moved)                return moved;        }    }    return null;}</code></pre><p>先执行 siftDown() 下滤过程：</p><p><img src="https://upload-images.jianshu.io/upload_images/195193-a64dbb5508a9c668.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/642" alt="image"></p><p>再执行 siftUp() 上滤过程：</p><p><img src="https://upload-images.jianshu.io/upload_images/195193-e9ad437213e69b07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/633" alt="image"></p><h2 id="总结和同步的问题"><a href="#总结和同步的问题" class="headerlink" title="总结和同步的问题"></a>总结和同步的问题</h2><p>1、jdk内置的优先队列PriorityQueue内部使用一个堆维护数据，每当有数据add进来或者poll出去的时候会对堆做从下往上的调整和从上往下的调整。</p><p>2、PriorityQueue不是一个线程安全的类，如果要在多线程环境下使用，可以使用 PriorityBlockingQueue 这个优先阻塞队列。其中add、poll、remove方法都使用 ReentrantLock 锁来保持同步，take() 方法中如果元素为空，则会一直保持阻塞。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们来探索一下LinkedList和Queue，以及Stack的源码。&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;喜欢的话麻烦star一下哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/05/09/collection2&quot;&gt;https://h2pl.github.io/2018/05/09/collection2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的个人博客主要发原创文章，也欢迎浏览&lt;br&gt;&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文参考 &lt;a href=&quot;http://cmsblogs.com/?p=155&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cmsblogs.com/?p=155&lt;/a&gt;&lt;br&gt;和&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/p/0e84b8d3606c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/0e84b8d3606c&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java集合类" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
    
      <category term="Java集合框架" scheme="http://h2pl.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java集合详解1：ArrayList,Vector与Stack</title>
    <link href="http://h2pl.github.io/2018/05/08/collection1/"/>
    <id>http://h2pl.github.io/2018/05/08/collection1/</id>
    <published>2018-05-08T15:57:43.000Z</published>
    <updated>2018-06-01T03:51:56.599Z</updated>
    
    <content type="html"><![CDATA[<p>本文非常详尽地介绍了Java中的三个集合类<br>ArrayList,Vector与Stack</p><p>”Java集合详解系列“是我在完成Java基础篇的系列博客后准备开始写的新系列。</p><p>之前的Java基础系列博客首发于我的个人博客：<a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><p>在这个分类中，将会写写Java中的集合。集合是Java中非常重要而且基础的内容，因为任何数据必不可少的就是该数据是如何存储的，集合的作用就是以一定的方式组织、存储数据。</p><p>之所以把这三个集合类放在一起讲解，是因为这三个集合类的底层都是数组实现（Stack继承自vector)并且比较常用。<br>后面还会另外讲底层是链表实现的linkedlist和queue；</p><p>今天我们来探索一下ArrayList和Vector，以及Stack的源码</p><p>具体代码在我的GitHub中可以找到</p><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p><p>喜欢的话麻烦star一下哈</p><p>文章首发于我的个人博客：</p><p><a href="https://h2pl.github.io/2018/05/08/collection1">https://h2pl.github.io/2018/05/08/collection1</a></p><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：<a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a></p><p>我的个人博客主要发原创文章，也欢迎浏览<br><a href="https://h2pl.github.io/">https://h2pl.github.io/</a></p><a id="more"></a><pre><code>//一般讨论集合类无非就是。这里的两种数组类型更是如此// 1底层数据结构// 2增删改查方式// 3初始容量，扩容方式，扩容时机。// 4线程安全与否// 5是否允许空，是否允许重复，是否有序 </code></pre><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>ArrayList概述</p><p>  ArrayList是实现List接口的动态数组，所谓动态就是它的大小是可变的。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。</p><p>  每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。默认初始容量为10。随着ArrayList中元素的增加，它的容量也会不断的自动增长。</p><p>  在每次添加新的元素时，ArrayList都会检查是否需要进行扩容操作，扩容操作带来数据向新数组的重新拷贝，所以如果我们知道具体业务数据量，在构造ArrayList时可以给ArrayList指定一个初始容量，这样就会减少扩容时数据的拷贝问题。当然在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。</p><p>  注意，ArrayList实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。所以为了保证同步，最好的办法是在创建时完成，以防止意外对列表进行不同步的访问：</p><pre><code>List list = Collections.synchronizedList(new ArrayList(...)); </code></pre><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><p> ArrayList的底层是一个object数组，并且由trasient修饰。</p><pre><code>//transient Object[] elementData; //</code></pre><p>non-private to simplify nested class access<br>//ArrayList底层数组不会参与序列化，而是使用另外的序列化方式。</p><p>//使用writeobject方法进行序列化,具体为什么这么做欢迎查看我之前的关于序列化的文章</p><p>//总结一下就是只复制数组中有值的位置，其他未赋值的位置不进行序列化，可以节省空间。</p><pre><code>//        private void writeObject(java.io.ObjectOutputStream s)//        throws java.io.IOException{//            // Write out element count, and any hidden stuff//            int expectedModCount = modCount;//            s.defaultWriteObject();////            // Write out size as capacity for behavioural compatibility with clone()//            s.writeInt(size);////            // Write out all elements in the proper order.//            for (int i=0; i&lt;size; i++) {//                s.writeObject(elementData[i]);//            }////            if (modCount != expectedModCount) {//                throw new ConcurrentModificationException();//            }//        }</code></pre><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><pre><code>//增删改查</code></pre><p>添加元素时，首先判断索引是否合法，然后检测是否需要扩容，最后使用System.arraycopy方法来完成数组的复制。</p><p>这个方法无非就是使用System.arraycopy()方法将C集合(先准换为数组)里面的数据复制到elementData数组中。这里就稍微介绍下System.arraycopy()，因为下面还将大量用到该方法</p><p>。该方法的原型为：</p><pre><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)。</code></pre><p>它的根本目的就是进行数组元素的复制。即从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。</p><p>将源数组src从srcPos位置开始复制到dest数组中，复制长度为length，数据从dest的destPos位置开始粘贴。</p><pre><code>//        public void add(int index, E element) {//            rangeCheckForAdd(index);////            ensureCapacityInternal(size + 1);  // Increments modCount!!//            System.arraycopy(elementData, index, elementData, index + 1,//                    size - index);//            elementData[index] = element;//            size++;//        }//</code></pre><p>删除元素时，同样判断索引是否和法，删除的方式是把被删除元素右边的元素左移，方法同样是使用System.arraycopy进行拷贝。</p><pre><code>//        public E remove(int index) {//            rangeCheck(index);////            modCount++;//            E oldValue = elementData(index);////            int numMoved = size - index - 1;//            if (numMoved &gt; 0)//                System.arraycopy(elementData, index+1, elementData, index,//                        numMoved);//            elementData[--size] = null; // clear to let GC do its work////            return oldValue;//        }</code></pre><p>ArrayList提供一个清空数组的办法，方法是将所有元素置为null，这样就可以让GC自动回收掉没有被引用的元素了。</p><pre><code>////        /**//         * Removes all of the elements from this list.  The list will//         * be empty after this call returns.//         *///        public void clear() {//            modCount++;////            // clear to let GC do its work//            for (int i = 0; i &lt; size; i++)//                elementData[i] = null;////            size = 0;//        }</code></pre><p>修改元素时，只需要检查下标即可进行修改操作。</p><pre><code>//        public E set(int index, E element) {//            rangeCheck(index);////            E oldValue = elementData(index);//            elementData[index] = element;//            return oldValue;//        }////        public E get(int index) {//            rangeCheck(index);////            return elementData(index);//        }//</code></pre><p>上述方法都使用了rangeCheck方法，其实就是简单地检查下标而已。</p><pre><code>//        private void rangeCheck(int index) {//            if (index &gt;= size)//                throw new IndexOutOfBoundsException(outOfBoundsMsg(index));//        }</code></pre><h2 id="modCount"><a href="#modCount" class="headerlink" title="modCount"></a>modCount</h2><pre><code>//        protected transient int modCount = 0;</code></pre><p>由以上代码可以看出，在一个迭代器初始的时候会赋予它调用这个迭代器的对象的mCount，如何在迭代器遍历的过程中，一旦发现这个对象的mcount和迭代器中存储的mcount不一样那就抛异常 </p><blockquote><p>好的，下面是这个的完整解释<br>Fail-Fast 机制<br>我们知道 java.util.ArrayList 不是线程安全的，ArrayList，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。</p><p>这一策略在源码中的实现是通过 modCount 域，modCount 顾名思义就是修改次数，对ArrayList 内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的 expectedModCount。</p><p>在迭代过程中，判断 modCount 跟 expectedModCount 是否相等，如果不相等就表示已经有其他线程修改了 ArrayList。</p><p>所以在这里和大家建议，当大家遍历那些非线程安全的数据结构时，尽量使用迭代器</p></blockquote><h2 id="初始容量和扩容方式"><a href="#初始容量和扩容方式" class="headerlink" title="初始容量和扩容方式"></a>初始容量和扩容方式</h2><p>初始容量是10，下面是扩容方法。<br>首先先取</p><pre><code>//        private static final int DEFAULT_CAPACITY = 10;扩容发生在add元素时，传入当前元素容量加一   public boolean add(E e) {    ensureCapacityInternal(size + 1);  // Increments modCount!!    elementData[size++] = e;    return true;}这里给出初始化时的数组private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};这说明：如果数组还是初始数组，那么最小的扩容大小就是size+1和初始容量中较大的一个，初始容量为10。因为addall方法也会调用该函数，所以此时需要做判断。private void ensureCapacityInternal(int minCapacity) {    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);    }    ensureExplicitCapacity(minCapacity);}//开始精确地扩容private void ensureExplicitCapacity(int minCapacity) {    modCount++;    // overflow-conscious code        如果此时扩容容量大于数组长度吗，执行grow，否则不执行。    if (minCapacity - elementData.length &gt; 0)        grow(minCapacity);}</code></pre><p>真正执行扩容的方法grow</p><p>扩容方式是让新容量等于旧容量的1.5被。</p><p>当新容量大于最大数组容量时，执行大数扩容</p><pre><code>//        private void grow(int minCapacity) {//            // overflow-conscious code//            int oldCapacity = elementData.length;//            int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//            if (newCapacity - minCapacity &lt; 0)//                newCapacity = minCapacity;//            if (newCapacity - MAX_ARRAY_SIZE &gt; 0)//                newCapacity = hugeCapacity(minCapacity);//            // minCapacity is usually close to size, so this is a win://            elementData = Arrays.copyOf(elementData, newCapacity);//        }</code></pre><p>当新容量大于最大数组长度，有两种情况，一种是溢出，抛异常，一种是没溢出，返回整数的最大值。</p><pre><code>private static int hugeCapacity(int minCapacity) {    if (minCapacity &lt; 0) // overflow        throw new OutOfMemoryError();    return (minCapacity &gt; MAX_ARRAY_SIZE) ?        Integer.MAX_VALUE :        MAX_ARRAY_SIZE;}</code></pre><p>在这里有一个疑问，为什么每次扩容处理会是1.5倍，而不是2.5、3、4倍呢？通过google查找，发现1.5倍的扩容是最好的倍数。因为一次性扩容太大(例如2.5倍)可能会浪费更多的内存(1.5倍最多浪费33%，而2.5被最多会浪费60%，3.5倍则会浪费71%……)。但是一次性扩容太小，需要多次对数组重新分配内存，对性能消耗比较严重。所以1.5倍刚刚好，既能满足性能需求，也不会造成很大的内存消耗。</p><p>  处理这个ensureCapacity()这个扩容数组外，ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimToSize()方法来实现。该方法可以最小化ArrayList实例的存储量。</p><pre><code>public void trimToSize() {    modCount++;    int oldCapacity = elementData.length;    if (size &lt; oldCapacity) {        elementData = Arrays.copyOf(elementData, size);    }}</code></pre><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>ArrayList是线程不安全的。在其迭代器iteator中，如果有多线程操作导致modcount改变，会执行fastfail。抛出异常。</p><pre><code>final void checkForComodification() {    if (modCount != expectedModCount)        throw new ConcurrentModificationException();}</code></pre><h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><p>Vector简介</p><p>Vector可以实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。不过，Vector的大小是可以增加或者减小的，以便适应创建Vector后进行添加或者删除操作。</p><p>Vector实现List接口，继承AbstractList类，所以我们可以将其看做队列，支持相关的添加、删除、修改、遍历等功能。</p><p>Vector实现RandmoAccess接口，即提供了随机访问功能，提供提供快速访问功能。在Vector我们可以直接访问元素。</p><p>Vector 实现了Cloneable接口，支持clone()方法，可以被克隆。</p><p>vector底层数组不加transient，序列化时会全部复制</p><pre><code> protected Object[] elementData;//        private void writeObject(java.io.ObjectOutputStream s)//            throws java.io.IOException {//            final java.io.ObjectOutputStream.PutField fields = s.putFields();//            final Object[] data;//            synchronized (this) {//                fields.put(&quot;capacityIncrement&quot;, capacityIncrement);//                fields.put(&quot;elementCount&quot;, elementCount);//                data = elementData.clone();//            }//            fields.put(&quot;elementData&quot;, data);//            s.writeFields();//        }</code></pre><p>Vector除了iterator外还提供Enumeration枚举方法，不过现在比较过时。</p><pre><code>//        public Enumeration&lt;E&gt; elements() {//            return new Enumeration&lt;E&gt;() {//                int count = 0;////                public boolean hasMoreElements() {//                    return count &lt; elementCount;//                }////                public E nextElement() {//                    synchronized (Vector.this) {//                        if (count &lt; elementCount) {//                            return elementData(count++);//                        }//                    }//                    throw new NoSuchElementException(&quot;Vector Enumeration&quot;);//                }//            };//        }//</code></pre><h2 id="增删改查-1"><a href="#增删改查-1" class="headerlink" title="增删改查"></a>增删改查</h2><p>vector的增删改查既提供了自己的实现，也继承了abstractList抽象类的部分方法。<br>下面的方法是vector自己实现的。</p><pre><code>////    public synchronized E elementAt(int index) {//        if (index &gt;= elementCount) {//            throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount);//        }////        return elementData(index);//    }//////    public synchronized void setElementAt(E obj, int index) {//        if (index &gt;= elementCount) {//            throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; +//                    elementCount);//        }//        elementData[index] = obj;//    }////    public synchronized void removeElementAt(int index) {//        modCount++;//        if (index &gt;= elementCount) {//            throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; +//                    elementCount);//        }//        else if (index &lt; 0) {//            throw new ArrayIndexOutOfBoundsException(index);//        }//        int j = elementCount - index - 1;//        if (j &gt; 0) {//            System.arraycopy(elementData, index + 1, elementData, index, j);//        }//        elementCount--;//        elementData[elementCount] = null; /* to let gc do its work *///    }//    public synchronized void insertElementAt(E obj, int index) {//        modCount++;//        if (index &gt; elementCount) {//            throw new ArrayIndexOutOfBoundsException(index//                    + &quot; &gt; &quot; + elementCount);//        }//        ensureCapacityHelper(elementCount + 1);//        System.arraycopy(elementData, index, elementData, index + 1, elementCount - index);//        elementData[index] = obj;//        elementCount++;//    }////    public synchronized void addElement(E obj) {//        modCount++;//        ensureCapacityHelper(elementCount + 1);//        elementData[elementCount++] = obj;//    }</code></pre><h2 id="初始容量和扩容"><a href="#初始容量和扩容" class="headerlink" title="初始容量和扩容"></a>初始容量和扩容</h2><p>扩容方式与ArrayList基本一样，但是扩容时不是1.5倍扩容，而是有一个扩容增量。</p><pre><code>//    protected int elementCount;//    protected int capacityIncrement;//////    }//    public Vector() {//        this(10);//    }</code></pre><p>capacityIncrement：向量的大小大于其容量时，容量自动增加的量。如果在创建Vector时，指定了capacityIncrement的大小；则，每次当Vector中动态数组容量增加时&gt;，增加的大小都是capacityIncrement。如果容量的增量小于等于零，则每次需要增大容量时，向量的容量将增大一倍。</p><pre><code>//        public synchronized void ensureCapacity(int minCapacity) {//            if (minCapacity &gt; 0) {//                modCount++;//                ensureCapacityHelper(minCapacity);//            }//        }//        private void ensureCapacityHelper(int minCapacity) {//            // overflow-conscious code//            if (minCapacity - elementData.length &gt; 0)//                grow(minCapacity);//        }////        private void grow(int minCapacity) {//            // overflow-conscious code//            int oldCapacity = elementData.length;//            int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?//                    capacityIncrement : oldCapacity);//            if (newCapacity - minCapacity &lt; 0)//                newCapacity = minCapacity;//            if (newCapacity - MAX_ARRAY_SIZE &gt; 0)//                newCapacity = hugeCapacity(minCapacity);//            elementData = Arrays.copyOf(elementData, newCapacity);//        }</code></pre><h2 id="线程安全-1"><a href="#线程安全-1" class="headerlink" title="线程安全"></a>线程安全</h2><p>vector大部分方法都使用了synchronized修饰符，所以他是线层安全的集合类。</p><h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><p>在Java中Stack类表示后进先出（LIFO）的对象堆栈。栈是一种非常常见的数据结构，它采用典型的先进后出的操作方式完成的。每一个栈都包含一个栈顶，每次出栈是将栈顶的数据取出，如下：</p><p><img src="https://images0.cnblogs.com/blog/381060/201407/091242265826653.jpg" alt="image"></p><p>Stack通过五个操作对Vector进行扩展，允许将向量视为堆栈。这个五个操作如下：</p><blockquote><p>empty()</p><p>测试堆栈是否为空。</p><p>peek()</p><p>查看堆栈顶部的对象，但不从堆栈中移除它。</p><p>pop()</p><p>移除堆栈顶部的对象，并作为此函数的值返回该对象。</p><p>push(E item)</p><p>把项压入堆栈顶部。</p><p>search(Object o)</p><p>返回对象在堆栈中的位置，以 1 为基数。</p></blockquote><p>Stack继承Vector，他对Vector进行了简单的扩展：</p><p>public class Stack<e> extends Vector<e><br>  Stack的实现非常简单，仅有一个构造方法，五个实现方法（从Vector继承而来的方法不算与其中），同时其实现的源码非常简单</e></e></p><pre><code>/** * 构造函数 */public Stack() {}/** *  push函数：将元素存入栈顶 */public E push(E item) {    // 将元素存入栈顶。    // addElement()的实现在Vector.java中    addElement(item);    return item;}/** * pop函数：返回栈顶元素，并将其从栈中删除 */public synchronized E pop() {    E    obj;    int    len = size();    obj = peek();    // 删除栈顶元素，removeElementAt()的实现在Vector.java中    removeElementAt(len - 1);    return obj;}/** * peek函数：返回栈顶元素，不执行删除操作 */public synchronized E peek() {    int    len = size();    if (len == 0)        throw new EmptyStackException();    // 返回栈顶元素，elementAt()具体实现在Vector.java中    return elementAt(len - 1);}/** * 栈是否为空 */public boolean empty() {    return size() == 0;}/** *  查找“元素o”在栈中的位置：由栈底向栈顶方向数 */public synchronized int search(Object o) {    // 获取元素索引，elementAt()具体实现在Vector.java中    int i = lastIndexOf(o);    if (i &gt;= 0) {        return size() - i;    }    return -1;}</code></pre><p>Stack的源码很多都是基于Vector，所以这里不再累述</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>ArrayList的优缺点</p><p>从上面的几个过程总结一下ArrayList的优缺点。ArrayList的优点如下：</p><blockquote><p>1、ArrayList底层以数组实现，是一种随机访问模式，再加上它实现了RandomAccess接口，因此查找也就是get的时候非常快</p><p>2、ArrayList在顺序添加一个元素的时候非常方便，只是往数组里面添加了一个元素而已</p></blockquote><p>不过ArrayList的缺点也十分明显：</p><blockquote><p>1、删除元素的时候，涉及到一次元素复制，如果要复制的元素很多，那么就会比较耗费性能</p><p>2、插入元素的时候，涉及到一次元素复制，如果要复制的元素很多，那么就会比较耗费性能</p><p>因此，ArrayList比较适合顺序添加、随机访问的场景。</p></blockquote><p>ArrayList和Vector的区别</p><blockquote><p>ArrayList是线程非安全的，这很明显，因为ArrayList中所有的方法都不是同步的，在并发下一定会出现线程安全问题。那么我们想要使用ArrayList并且让它线程安全怎么办？一个方法是用Collections.synchronizedList方法把你的ArrayList变成一个线程安全的List，比如：</p></blockquote><pre><code>List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);synchronizedList.add(&quot;aaa&quot;);synchronizedList.add(&quot;bbb&quot;);for (int i = 0; i &lt; synchronizedList.size(); i++){    System.out.println(synchronizedList.get(i));}</code></pre><p>另一个方法就是Vector，它是ArrayList的线程安全版本，其实现90%和ArrayList都完全一样，区别在于：</p><blockquote><p>1、Vector是线程安全的，ArrayList是线程非安全的</p><p>2、Vector可以指定增长因子，如果该增长因子指定了，那么扩容的时候会每次新的数组大小会在原数组的大小基础上加上增长因子；如果不指定增长因子，那么就给原数组大小*2，源代码是这样的：</p></blockquote><pre><code>int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?                                 capacityIncrement : oldCapacity);</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文非常详尽地介绍了Java中的三个集合类&lt;br&gt;ArrayList,Vector与Stack&lt;/p&gt;
&lt;p&gt;”Java集合详解系列“是我在完成Java基础篇的系列博客后准备开始写的新系列。&lt;/p&gt;
&lt;p&gt;之前的Java基础系列博客首发于我的个人博客：&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在这个分类中，将会写写Java中的集合。集合是Java中非常重要而且基础的内容，因为任何数据必不可少的就是该数据是如何存储的，集合的作用就是以一定的方式组织、存储数据。&lt;/p&gt;
&lt;p&gt;之所以把这三个集合类放在一起讲解，是因为这三个集合类的底层都是数组实现（Stack继承自vector)并且比较常用。&lt;br&gt;后面还会另外讲底层是链表实现的linkedlist和queue；&lt;/p&gt;
&lt;p&gt;今天我们来探索一下ArrayList和Vector，以及Stack的源码&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;喜欢的话麻烦star一下哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/05/08/collection1&quot;&gt;https://h2pl.github.io/2018/05/08/collection1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的个人博客主要发原创文章，也欢迎浏览&lt;br&gt;&lt;a href=&quot;https://h2pl.github.io/&quot;&gt;https://h2pl.github.io/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java集合类" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
    
      <category term="Java集合框架" scheme="http://h2pl.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java基础20：Java8新特性终极指南</title>
    <link href="http://h2pl.github.io/2018/05/07/javase20/"/>
    <id>http://h2pl.github.io/2018/05/07/javase20/</id>
    <published>2018-05-07T02:42:43.000Z</published>
    <updated>2018-06-01T03:51:35.021Z</updated>
    
    <content type="html"><![CDATA[<p>毫无疑问，Java 8发行版是自Java 5（发行于2004，已经过了相当一段时间了）以来最具革命性的版本。Java 8 为Java语言、编译器、类库、开发工具与JVM（Java虚拟机）带来了大量新特性。在这篇教程中，我们将一一探索这些变化，并用真实的例子说明它们适用的场景。</p><p>本文由以下几部分组成，它们分别涉及到Java平台某一特定方面的内容：</p><p>Java语言<br>编译器<br>类库<br>工具<br>Java运行时（JVM）</p><p>本文参考<a href="http://www.importnew.com/11908.html" target="_blank" rel="noopener">http://www.importnew.com/11908.html</a></p><p>具体代码在我的GitHub中可以找到</p><blockquote><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p></blockquote><p>喜欢的话麻烦点一下星哈谢谢。</p><p>文章首发于我的个人博客：</p><blockquote><p><a href="https://h2pl.github.io/2018/05/06/javase20">https://h2pl.github.io/2018/05/06/javase20</a></p></blockquote><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：</p><blockquote><p><a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a></p></blockquote><a id="more"></a><p>这是一个Java8新增特性的总结图。接下来让我们一次实践一下这些新特性吧</p><p><img src="http://7xsskq.com1.z0.glb.clouddn.com/blog/Java8-features.png" alt="image"></p><h1 id="Java语言新特性"><a href="#Java语言新特性" class="headerlink" title="Java语言新特性"></a>Java语言新特性</h1><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda表达式（也称为闭包）是整个Java 8发行版中最受期待的在Java语言层面上的改变，Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中），或者把代码看成数据：函数式程序员对这一概念非常熟悉。在JVM平台上的很多语言（Groovy，Scala，……）从一开始就有Lambda，但是Java程序员不得不使用毫无新意的匿名类来代替lambda。</p><p>关于Lambda设计的讨论占用了大量的时间与社区的努力。可喜的是，最终找到了一个平衡点，使得可以使用一种即简洁又紧凑的新方式来构造Lambdas。在最简单的形式中，一个lambda可以由用逗号分隔的参数列表、–&gt;符号与函数体三部分表示。例如：</p><pre><code>Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( e -&gt; System.out.println( e ) );</code></pre><p>请注意参数e的类型是由编译器推测出来的。同时，你也可以通过把参数类型与参数包括在括号中的形式直接给出参数的类型：</p><pre><code>Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( ( String e ) -&gt; System.out.println( e ) );</code></pre><p>在某些情况下lambda的函数体会更加复杂，这时可以把函数体放到在一对花括号中，就像在Java中定义普通函数一样。例如：</p><pre><code>Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( e -&gt; {    System.out.print( e );    System.out.print( e );} );</code></pre><p>Lambda可以引用类的成员变量与局部变量（如果这些变量不是final的话，它们会被隐含的转为final，这样效率更高）。例如，下面两个代码片段是等价的：</p><pre><code>String separator = &quot;,&quot;;Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach(     ( String e ) -&gt; System.out.print( e + separator ) );</code></pre><p>和：</p><pre><code>final String separator = &quot;,&quot;;Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach(     ( String e ) -&gt; System.out.print( e + separator ) );</code></pre><p>Lambda可能会返回一个值。返回值的类型也是由编译器推测出来的。如果lambda的函数体只有一行的话，那么没有必要显式使用return语句。下面两个代码片段是等价的：</p><pre><code>Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).sort( ( e1, e2 ) -&gt; e1.compareTo( e2 ) );</code></pre><p>和：</p><pre><code>Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).sort( ( e1, e2 ) -&gt; {    int result = e1.compareTo( e2 );    return result;} );</code></pre><p>语言设计者投入了大量精力来思考如何使现有的函数友好地支持lambda。</p><p>最终采取的方法是：增加函数式接口的概念。函数式接口就是一个具有一个方法的普通接口。像这样的接口，可以被隐式转换为lambda表达式。</p><p>java.lang.Runnable与java.util.concurrent.Callable是函数式接口最典型的两个例子。</p><p>在实际使用过程中，函数式接口是容易出错的：如有某个人在接口定义中增加了另一个方法，这时，这个接口就不再是函数式的了，并且编译过程也会失败。</p><p>为了克服函数式接口的这种脆弱性并且能够明确声明接口作为函数式接口的意图，Java8增加了一种特殊的注解@FunctionalInterface（Java8中所有类库的已有接口都添加了@FunctionalInterface注解）。让我们看一下这种函数式接口的定义：</p><p>@FunctionalInterface<br>public interface Functional {<br>    void method();<br>}<br>需要记住的一件事是：默认方法与静态方法并不影响函数式接口的契约，可以任意使用：</p><p>@FunctionalInterface<br>public interface FunctionalDefaultMethods {<br>    void method();</p><pre><code>default void defaultMethod() {            }        </code></pre><p>}<br>Lambda是Java 8最大的卖点。它具有吸引越来越多程序员到Java平台上的潜力，并且能够在纯Java语言环境中提供一种优雅的方式来支持函数式编程。更多详情可以参考官方文档。</p><p>下面看一个例子：</p><pre><code>public class lambda和函数式编程 {    @Test    public void test1() {        List names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);        Collections.sort(names, new Comparator&lt;String&gt;() {            @Override            public int compare(String a, String b) {                return b.compareTo(a);            }        });        System.out.println(Arrays.toString(names.toArray()));    }    @Test    public void test2() {        List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);        Collections.sort(names, (String a, String b) -&gt; {            return b.compareTo(a);        });        Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));        Collections.sort(names, (a, b) -&gt; b.compareTo(a));        System.out.println(Arrays.toString(names.toArray()));    }}    static void add(double a,String b) {        System.out.println(a + b);    }    @Test    public void test5() {        D d = (a,b) -&gt; add(a,b);//        interface D {//            void get(int i,String j);//        }        //这里要求，add的两个参数和get的两个参数吻合并且返回类型也要相等，否则报错//        static void add(double a,String b) {//            System.out.println(a + b);//        }    }    @FunctionalInterface    interface D {        void get(int i,String j);    }</code></pre><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>所谓的函数式接口就是只有一个抽象方法的接口，注意这里说的是抽象方法，因为Java8中加入了默认方法的特性，但是函数式接口是不关心接口中有没有默认方法的。 一般函数式接口可以使用@FunctionalInterface注解的形式来标注表示这是一个函数式接口，该注解标注与否对函数式接口没有实际的影响， 不过一般还是推荐使用该注解，就像使用@Override注解一样。</p><p>lambda表达式是如何符合 Java 类型系统的？每个lambda对应于一个给定的类型，用一个接口来说明。而这个被称为函数式接口（functional interface）的接口必须仅仅包含一个抽象方法声明。每个那个类型的lambda表达式都将会被匹配到这个抽象方法上。因此默认的方法并不是抽象的，你可以给你的函数式接口自由地增加默认的方法。</p><p>我们可以使用任意的接口作为lambda表达式，只要这个接口只包含一个抽象方法。为了保证你的接口满足需求，你需要增加@FunctionalInterface注解。编译器知道这个注解，一旦你试图给这个接口增加第二个抽象方法声明时，它将抛出一个编译器错误。</p><p>下面举几个例子</p><pre><code>public class 函数式接口使用 {    @FunctionalInterface    interface A {        void say();        default void talk() {        }    }    @Test    public void test1() {        A a = () -&gt; System.out.println(&quot;hello&quot;);        a.say();    }    @FunctionalInterface    interface B {        void say(String i);    }    public void test2() {        //下面两个是等价的，都是通过B接口来引用一个方法，而方法可以直接使用::来作为方法引用        B b = System.out::println;        B b1 = a -&gt; Integer.parseInt(&quot;s&quot;);//这里的a其实换成别的也行，只是将方法传给接口作为其方法实现        B b2 = Integer::valueOf;//i与方法传入参数的变量类型一直时，可以直接替换        B b3 = String::valueOf;        //B b4 = Integer::parseInt;类型不符，无法使用    }    @FunctionalInterface    interface C {        int say(String i);    }    public void test3() {        C c = Integer::parseInt;//方法参数和接口方法的参数一样，可以替换。        int i = c.say(&quot;1&quot;);        //当我把C接口的int替换为void时就会报错，因为返回类型不一致。        System.out.println(i);        //综上所述，lambda表达式提供了一种简便的表达方式，可以将一个方法传到接口中。        //函数式接口是只提供一个抽象方法的接口，其方法由lambda表达式注入，不需要写实现类，        //也不需要写匿名内部类，可以省去很多代码，比如实现runnable接口。        //函数式编程就是指把方法当做一个参数或引用来进行操作。除了普通方法以外，静态方法，构造方法也是可以这样操作的。    }}</code></pre><p>请记住如果@FunctionalInterface 这个注解被遗漏，此代码依然有效。</p><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>Lambda表达式和方法引用</p><p>有了函数式接口之后，就可以使用Lambda表达式和方法引用了。其实函数式接口的表中的函数描述符就是Lambda表达式，在函数式接口中Lambda表达式相当于匿名内部类的效果。 举个简单的例子：</p><p>public class TestLambda {</p><pre><code>public static void execute(Runnable runnable) {    runnable.run();}public static void main(String[] args) {    //Java8之前    execute(new Runnable() {        @Override        public void run() {            System.out.println(&quot;run&quot;);        }    });    //使用Lambda表达式    execute(() -&gt; System.out.println(&quot;run&quot;));}</code></pre><p>}</p><p>可以看到，相比于使用匿名内部类的方式，Lambda表达式可以使用更少的代码但是有更清晰的表述。注意，Lambda表达式也不是完全等价于匿名内部类的， 两者的不同点在于this的指向和本地变量的屏蔽上。</p><p>方法引用可以看作Lambda表达式的更简洁的一种表达形式，使用::操作符，方法引用主要有三类：</p><pre><code>指向静态方法的方法引用(例如Integer的parseInt方法，写作Integer::parseInt)；指向任意类型实例方法的方法引用(例如String的length方法，写作String::length)；指向现有对象的实例方法的方法引用(例如假设你有一个本地变量localVariable用于存放Variable类型的对象，它支持实例方法getValue，那么可以写成localVariable::getValue)。</code></pre><p>举个方法引用的简单的例子：</p><pre><code>Function&lt;String, Integer&gt; stringToInteger = (String s) -&gt; Integer.parseInt(s);</code></pre><p>//使用方法引用</p><pre><code>Function&lt;String, Integer&gt; stringToInteger = Integer::parseInt;</code></pre><p>方法引用中还有一种特殊的形式，构造函数引用，假设一个类有一个默认的构造函数，那么使用方法引用的形式为：</p><pre><code>Supplier&lt;SomeClass&gt; c1 = SomeClass::new;SomeClass s1 = c1.get();</code></pre><p>//等价于</p><pre><code>Supplier&lt;SomeClass&gt; c1 = () -&gt; new SomeClass();SomeClass s1 = c1.get();</code></pre><p>如果是构造函数有一个参数的情况：</p><pre><code>Function&lt;Integer, SomeClass&gt; c1 = SomeClass::new;SomeClass s1 = c1.apply(100);</code></pre><p>//等价于</p><pre><code>Function&lt;Integer, SomeClass&gt; c1 = i -&gt; new SomeClass(i);SomeClass s1 = c1.apply(100);</code></pre><h2 id="接口的默认方法"><a href="#接口的默认方法" class="headerlink" title="接口的默认方法"></a>接口的默认方法</h2><p>Java 8 使我们能够使用default 关键字给接口增加非抽象的方法实现。这个特性也被叫做 扩展方法（Extension Methods）。如下例所示：</p><pre><code>public class 接口的默认方法 {    class B implements A {//        void a(){}实现类方法不能重名    }    interface A {        //可以有多个默认方法        public default void a(){            System.out.println(&quot;a&quot;);        }        public default void b(){            System.out.println(&quot;b&quot;);        }        //报错static和default不能同时使用//        public static default void c(){//            System.out.println(&quot;c&quot;);//        }    }    public void test() {        B b = new B();        b.a();    }}</code></pre><p>默认方法出现的原因是为了对原有接口的扩展，有了默认方法之后就不怕因改动原有的接口而对已经使用这些接口的程序造成的代码不兼容的影响。 在Java8中也对一些接口增加了一些默认方法，比如Map接口等等。一般来说，使用默认方法的场景有两个：可选方法和行为的多继承。</p><p>默认方法的使用相对来说比较简单，唯一要注意的点是如何处理默认方法的冲突。关于如何处理默认方法的冲突可以参考以下三条规则：</p><p>类中的方法优先级最高。类或父类中声明的方法的优先级高于任何声明为默认方法的优先级。</p><p>如果无法依据第一条规则进行判断，那么子接口的优先级更高：函数签名相同时，优先选择拥有最具体实现的默认方法的接口。即如果B继承了A，那么B就比A更具体。</p><p>最后，如果还是无法判断，继承了多个接口的类必须通过显式覆盖和调用期望的方法，显式地选择使用哪一个默认方法的实现。那么如何显式地指定呢:</p><pre><code>public class C implements B, A {    public void hello() {        B.super().hello();        }}</code></pre><p>使用X.super.m(..)显式地调用希望调用的方法。</p><p>Java 8用默认方法与静态方法这两个新概念来扩展接口的声明。默认方法使接口有点像Traits（Scala中特征(trait)类似于Java中的Interface，但它可以包含实现代码，也就是目前Java8新增的功能），但与传统的接口又有些不一样，它允许在已有的接口中添加新方法，而同时又保持了与旧版本代码的兼容性。</p><p>默认方法与抽象方法不同之处在于抽象方法必须要求实现，但是默认方法则没有这个要求。相反，每个接口都必须提供一个所谓的默认实现，这样所有的接口实现者将会默认继承它（如果有必要的话，可以覆盖这个默认实现）。让我们看看下面的例子：</p><pre><code>private interface Defaulable {    // Interfaces now allow default methods, the implementer may or     // may not implement (override) them.    default String notRequired() {         return &quot;Default implementation&quot;;     }        }private static class DefaultableImpl implements Defaulable {}private static class OverridableImpl implements Defaulable {    @Override    public String notRequired() {        return &quot;Overridden implementation&quot;;    }}</code></pre><p>Defaulable接口用关键字default声明了一个默认方法notRequired()，Defaulable接口的实现者之一DefaultableImpl实现了这个接口，并且让默认方法保持原样。Defaulable接口的另一个实现者OverridableImpl用自己的方法覆盖了默认方法。</p><p>Java 8带来的另一个有趣的特性是接口可以声明（并且可以提供实现）静态方法。例如：</p><pre><code>private interface DefaulableFactory {    // Interfaces now allow static methods    static Defaulable create( Supplier&lt; Defaulable &gt; supplier ) {        return supplier.get();    }}</code></pre><p>下面的一小段代码片段把上面的默认方法与静态方法黏合到一起。</p><pre><code>public static void main( String[] args ) {    Defaulable defaulable = DefaulableFactory.create( DefaultableImpl::new );    System.out.println( defaulable.notRequired() );    defaulable = DefaulableFactory.create( OverridableImpl::new );    System.out.println( defaulable.notRequired() );}</code></pre><p>这个程序的控制台输出如下：</p><p>Default implementation<br>Overridden implementation<br>在JVM中，默认方法的实现是非常高效的，并且通过字节码指令为方法调用提供了支持。默认方法允许继续使用现有的Java接口，而同时能够保障正常的编译过程。这方面好的例子是大量的方法被添加到java.util.Collection接口中去：stream()，parallelStream()，forEach()，removeIf()，……</p><p>尽管默认方法非常强大，但是在使用默认方法时我们需要小心注意一个地方：在声明一个默认方法前，请仔细思考是不是真的有必要使用默认方法，因为默认方法会带给程序歧义，并且在复杂的继承体系中容易产生编译错误。更多详情请参考官方文档</p><h2 id="重复注解"><a href="#重复注解" class="headerlink" title="重复注解"></a>重复注解</h2><p>自从Java 5引入了注解机制，这一特性就变得非常流行并且广为使用。然而，使用注解的一个限制是相同的注解在同一位置只能声明一次，不能声明多次。Java 8打破了这条规则，引入了重复注解机制，这样相同的注解可以在同一地方声明多次。</p><p>重复注解机制本身必须用@Repeatable注解。事实上，这并不是语言层面上的改变，更多的是编译器的技巧，底层的原理保持不变。让我们看一个快速入门的例子：</p><pre><code>package com.javacodegeeks.java8.repeatable.annotations;import java.lang.annotation.ElementType;import java.lang.annotation.Repeatable;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;public class RepeatingAnnotations {    @Target( ElementType.TYPE )    @Retention( RetentionPolicy.RUNTIME )    public @interface Filters {        Filter[] value();    }    @Target( ElementType.TYPE )    @Retention( RetentionPolicy.RUNTIME )    @Repeatable( Filters.class )    public @interface Filter {        String value();    };    @Filter( &quot;filter1&quot; )    @Filter( &quot;filter2&quot; )    public interface Filterable {            }    public static void main(String[] args) {        for( Filter filter: Filterable.class.getAnnotationsByType( Filter.class ) ) {            System.out.println( filter.value() );        }    }}</code></pre><p>正如我们看到的，这里有个使用@Repeatable( Filters.class )注解的注解类Filter，Filters仅仅是Filter注解的数组，但Java编译器并不想让程序员意识到Filters的存在。这样，接口Filterable就拥有了两次Filter（并没有提到Filter）注解。</p><p>同时，反射相关的API提供了新的函数getAnnotationsByType()来返回重复注解的类型（请注意Filterable.class.getAnnotation( Filters.class )经编译器处理后将会返回Filters的实例）。</p><p>程序输出结果如下：</p><p>filter1<br>filter2<br>更多详情请参考官方文档</p><h1 id="Java编译器的新特性"><a href="#Java编译器的新特性" class="headerlink" title="Java编译器的新特性"></a>Java编译器的新特性</h1><h2 id="方法参数名字可以反射获取"><a href="#方法参数名字可以反射获取" class="headerlink" title="方法参数名字可以反射获取"></a>方法参数名字可以反射获取</h2><p>很长一段时间里，Java程序员一直在发明不同的方式使得方法参数的名字能保留在Java字节码中，并且能够在运行时获取它们（比如，Paranamer类库）。最终，在Java 8中把这个强烈要求的功能添加到语言层面（通过反射API与Parameter.getName()方法）与字节码文件（通过新版的javac的–parameters选项）中。</p><p>package com.javacodegeeks.java8.parameter.names;</p><p>import java.lang.reflect.Method;<br>import java.lang.reflect.Parameter;</p><p>public class ParameterNames {<br>    public static void main(String[] args) throws Exception {<br>        Method method = ParameterNames.class.getMethod( “main”, String[].class );<br>        for( final Parameter parameter: method.getParameters() ) {<br>            System.out.println( “Parameter: “ + parameter.getName() );<br>        }<br>    }<br>}<br>如果不使用–parameters参数来编译这个类，然后运行这个类，会得到下面的输出：</p><p>Parameter: arg0<br>如果使用–parameters参数来编译这个类，程序的结构会有所不同（参数的真实名字将会显示出来）：</p><p>Parameter: args</p><h1 id="Java-类库的新特性"><a href="#Java-类库的新特性" class="headerlink" title="Java 类库的新特性"></a>Java 类库的新特性</h1><p>Java 8 通过增加大量新类，扩展已有类的功能的方式来改善对并发编程、函数式编程、日期/时间相关操作以及其他更多方面的支持。</p><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。</p><p>Optional实际上是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。更多详情请参考官方文档。</p><p>我们下面用两个小例子来演示如何使用Optional类：一个允许为空值，一个不允许为空值。</p><pre><code>public class 空指针Optional {    public static void main(String[] args) {        //使用of方法，仍然会报空指针异常//        Optional optional = Optional.of(null);//        System.out.println(optional.get());        //抛出没有该元素的异常        //Exception in thread &quot;main&quot; java.util.NoSuchElementException: No value present//        at java.util.Optional.get(Optional.java:135)//        at com.javase.Java8.空指针Optional.main(空指针Optional.java:14)//        Optional optional1 = Optional.ofNullable(null);//        System.out.println(optional1.get());        Optional optional = Optional.ofNullable(null);        System.out.println(optional.isPresent());        System.out.println(optional.orElse(0));//当值为空时给与初始值        System.out.println(optional.orElseGet(() -&gt; new String[]{&quot;a&quot;}));//使用回调函数设置默认值        //即使传入Optional容器的元素为空，使用optional.isPresent()方法也不会报空指针异常        //所以通过optional.orElse这种方式就可以写出避免空指针异常的代码了        //输出Optional.empty。    }}</code></pre><p>如果Optional类的实例为非空值的话，isPresent()返回true，否从返回false。为了防止Optional为空值，orElseGet()方法通过回调函数来产生一个默认值。map()函数对当前Optional的值进行转化，然后返回一个新的Optional实例。orElse()方法和orElseGet()方法类似，但是orElse接受一个默认值而不是一个回调函数。下面是这个程序的输出：</p><p>Full Name is set? false<br>Full Name: [none]<br>Hey Stranger!<br>让我们来看看另一个例子：</p><pre><code>Optional&lt; String &gt; firstName = Optional.of( &quot;Tom&quot; );System.out.println( &quot;First Name is set? &quot; + firstName.isPresent() );        System.out.println( &quot;First Name: &quot; + firstName.orElseGet( () -&gt; &quot;[none]&quot; ) ); System.out.println( firstName.map( s -&gt; &quot;Hey &quot; + s + &quot;!&quot; ).orElse( &quot;Hey Stranger!&quot; ) );System.out.println();</code></pre><p>下面是程序的输出：</p><p>First Name is set? true<br>First Name: Tom<br>Hey Tom!</p><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>最新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p><p>Stream API极大简化了集合框架的处理（但它的处理的范围不仅仅限于集合框架的处理，这点后面我们会看到）。让我们以一个简单的Task类为例进行介绍：</p><p>Task类有一个分数的概念（或者说是伪复杂度），其次是还有一个值可以为OPEN或CLOSED的状态.让我们引入一个Task的小集合作为演示例子：</p><pre><code>final Collection&lt; Task &gt; tasks = Arrays.asList(    new Task( Status.OPEN, 5 ),    new Task( Status.OPEN, 13 ),    new Task( Status.CLOSED, 8 ) );</code></pre><p>我们下面要讨论的第一个问题是所有状态为OPEN的任务一共有多少分数？在Java 8以前，一般的解决方式用foreach循环，但是在Java 8里面我们可以使用stream：一串支持连续、并行聚集操作的元素。</p><pre><code>// Calculate total points of all active tasks using sum()final long totalPointsOfOpenTasks = tasks    .stream()    .filter( task -&gt; task.getStatus() == Status.OPEN )    .mapToInt( Task::getPoints )    .sum();System.out.println( &quot;Total points: &quot; + totalPointsOfOpenTasks );</code></pre><p>程序在控制台上的输出如下：</p><p>Total points: 18</p><p>这里有几个注意事项。</p><p>第一，task集合被转换化为其相应的stream表示。然后，filter操作过滤掉状态为CLOSED的task。</p><p>下一步，mapToInt操作通过Task::getPoints这种方式调用每个task实例的getPoints方法把Task的stream转化为Integer的stream。最后，用sum函数把所有的分数加起来，得到最终的结果。</p><p>在继续讲解下面的例子之前，关于stream有一些需要注意的地方（详情在这里）.stream操作被分成了中间操作与最终操作这两种。</p><p>中间操作返回一个新的stream对象。中间操作总是采用惰性求值方式，运行一个像filter这样的中间操作实际上没有进行任何过滤，相反它在遍历元素时会产生了一个新的stream对象，这个新的stream对象包含原始stream<br>中符合给定谓词的所有元素。</p><p>像forEach、sum这样的最终操作可能直接遍历stream，产生一个结果或副作用。当最终操作执行结束之后，stream管道被认为已经被消耗了，没有可能再被使用了。在大多数情况下，最终操作都是采用及早求值方式，及早完成底层数据源的遍历。</p><p>stream另一个有价值的地方是能够原生支持并行处理。让我们来看看这个算task分数和的例子。</p><p>stream另一个有价值的地方是能够原生支持并行处理。让我们来看看这个算task分数和的例子。</p><pre><code>// Calculate total points of all tasksfinal double totalPoints = tasks   .stream()   .parallel()   .map( task -&gt; task.getPoints() ) // or map( Task::getPoints )    .reduce( 0, Integer::sum );System.out.println( &quot;Total points (all tasks): &quot; + totalPoints );</code></pre><p>这个例子和第一个例子很相似，但这个例子的不同之处在于这个程序是并行运行的，其次使用reduce方法来算最终的结果。<br>下面是这个例子在控制台的输出：</p><p>Total points (all tasks): 26.0<br>经常会有这个一个需求：我们需要按照某种准则来对集合中的元素进行分组。Stream也可以处理这样的需求，下面是一个例子：</p><pre><code>// Group tasks by their statusfinal Map&lt; Status, List&lt; Task &gt; &gt; map = tasks    .stream()    .collect( Collectors.groupingBy( Task::getStatus ) );System.out.println( map );</code></pre><p>这个例子的控制台输出如下：</p><p>{CLOSED=[[CLOSED, 8]], OPEN=[[OPEN, 5], [OPEN, 13]]}<br>让我们来计算整个集合中每个task分数（或权重）的平均值来结束task的例子。</p><pre><code>// Calculate the weight of each tasks (as percent of total points) final Collection&lt; String &gt; result = tasks    .stream()                                        // Stream&lt; String &gt;    .mapToInt( Task::getPoints )                     // IntStream    .asLongStream()                                  // LongStream    .mapToDouble( points -&gt; points / totalPoints )   // DoubleStream    .boxed()                                         // Stream&lt; Double &gt;    .mapToLong( weigth -&gt; ( long )( weigth * 100 ) ) // LongStream    .mapToObj( percentage -&gt; percentage + &quot;%&quot; )      // Stream&lt; String&gt;     .collect( Collectors.toList() );                 // List&lt; String &gt; System.out.println( result );</code></pre><p>下面是这个例子的控制台输出：</p><p>[19%, 50%, 30%]<br>最后，就像前面提到的，Stream API不仅仅处理Java集合框架。像从文本文件中逐行读取数据这样典型的I/O操作也很适合用Stream API来处理。下面用一个例子来应证这一点。</p><pre><code>final Path path = new File( filename ).toPath();try( Stream&lt; String &gt; lines = Files.lines( path, StandardCharsets.UTF_8 ) ) {    lines.onClose( () -&gt; System.out.println(&quot;Done!&quot;) ).forEach( System.out::println );}</code></pre><p>对一个stream对象调用onClose方法会返回一个在原有功能基础上新增了关闭功能的stream对象，当对stream对象调用close()方法时，与关闭相关的处理器就会执行。</p><p>Stream API、Lambda表达式与方法引用在接口默认方法与静态方法的配合下是Java 8对现代软件开发范式的回应。更多详情请参考官方文档。</p><h2 id="Date-Time-API-JSR-310"><a href="#Date-Time-API-JSR-310" class="headerlink" title="Date/Time API (JSR 310)"></a>Date/Time API (JSR 310)</h2><p>Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。对日期与时间的操作一直是Java程序员最痛苦的地方之一。标准的 java.util.Date以及后来的java.util.Calendar一点没有改善这种情况（可以这么说，它们一定程度上更加复杂）。</p><p>这种情况直接导致了Joda-Time——一个可替换标准日期/时间处理且功能非常强大的Java API的诞生。Java 8新的Date-Time API (JSR 310)在很大程度上受到Joda-Time的影响，并且吸取了其精髓。新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。在设计新版API时，十分注重与旧版API的兼容性：不允许有任何的改变（从java.util.Calendar中得到的深刻教训）。如果需要修改，会返回这个类的一个新实例。</p><p>让我们用例子来看一下新版API主要类的使用方法。第一个是Clock类，它通过指定一个时区，然后就可以获取到当前的时刻，日期与时间。Clock可以替换System.currentTimeMillis()与TimeZone.getDefault()。</p><pre><code>// Get the system clock as UTC offset final Clock clock = Clock.systemUTC();System.out.println( clock.instant() );System.out.println( clock.millis() );</code></pre><p>下面是程序在控制台上的输出：</p><p>2014-04-12T15:19:29.282Z<br>1397315969360</p><p>我们需要关注的其他类是LocaleDate与LocalTime。LocaleDate只持有ISO-8601格式且无时区信息的日期部分。相应的，LocaleTime只持有ISO-8601格式且无时区信息的时间部分。LocaleDate与LocalTime都可以从Clock中得到。</p><pre><code>// Get the local date and local timefinal LocalDate date = LocalDate.now();final LocalDate dateFromClock = LocalDate.now( clock );System.out.println( date );System.out.println( dateFromClock );// Get the local date and local timefinal LocalTime time = LocalTime.now();final LocalTime timeFromClock = LocalTime.now( clock );System.out.println( time );System.out.println( timeFromClock );</code></pre><p>下面是程序在控制台上的输出：</p><p>2014-04-12<br>2014-04-12<br>11:25:54.568<br>15:25:54.568</p><p>下面是程序在控制台上的输出：</p><p>2014-04-12T11:47:01.017-04:00[America/New_York]<br>2014-04-12T15:47:01.017Z<br>2014-04-12T08:47:01.017-07:00[America/Los_Angeles]<br>最后，让我们看一下Duration类：在秒与纳秒级别上的一段时间。Duration使计算两个日期间的不同变的十分简单。下面让我们看一个这方面的例子。</p><pre><code>// Get duration between two datesfinal LocalDateTime from = LocalDateTime.of( 2014, Month.APRIL, 16, 0, 0, 0 );final LocalDateTime to = LocalDateTime.of( 2015, Month.APRIL, 16, 23, 59, 59 );final Duration duration = Duration.between( from, to );System.out.println( &quot;Duration in days: &quot; + duration.toDays() );System.out.println( &quot;Duration in hours: &quot; + duration.toHours() );</code></pre><p>上面的例子计算了两个日期2014年4月16号与2014年4月16号之间的过程。下面是程序在控制台上的输出：</p><p>Duration in days: 365<br>Duration in hours: 8783<br>对Java 8在日期/时间API的改进整体印象是非常非常好的。一部分原因是因为它建立在“久战杀场”的Joda-Time基础上，另一方面是因为用来大量的时间来设计它，并且这次程序员的声音得到了认可。更多详情请参考官方文档。</p><h2 id="并行（parallel）数组"><a href="#并行（parallel）数组" class="headerlink" title="并行（parallel）数组"></a>并行（parallel）数组</h2><p>Java 8增加了大量的新方法来对数组进行并行处理。可以说，最重要的是parallelSort()方法，因为它可以在多核机器上极大提高数组排序的速度。下面的例子展示了新方法（parallelXxx）的使用。</p><pre><code>package com.javacodegeeks.java8.parallel.arrays;import java.util.Arrays;import java.util.concurrent.ThreadLocalRandom;public class ParallelArrays {    public static void main( String[] args ) {        long[] arrayOfLong = new long [ 20000 ];                Arrays.parallelSetAll( arrayOfLong,             index -&gt; ThreadLocalRandom.current().nextInt( 1000000 ) );        Arrays.stream( arrayOfLong ).limit( 10 ).forEach(             i -&gt; System.out.print( i + &quot; &quot; ) );        System.out.println();        Arrays.parallelSort( arrayOfLong );             Arrays.stream( arrayOfLong ).limit( 10 ).forEach(             i -&gt; System.out.print( i + &quot; &quot; ) );        System.out.println();    }}</code></pre><p>上面的代码片段使用了parallelSetAll()方法来对一个有20000个元素的数组进行随机赋值。然后，调用parallelSort方法。这个程序首先打印出前10个元素的值，之后对整个数组排序。这个程序在控制台上的输出如下（请注意数组元素是随机生产的）：</p><p>Unsorted: 591217 891976 443951 424479 766825 351964 242997 642839 119108 552378<br>Sorted: 39 220 263 268 325 607 655 678 723 793</p><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p>在Java8之前，我们会使用JDK提供的Future接口来进行一些异步的操作，其实CompletableFuture也是实现了Future接口， 并且基于ForkJoinPool来执行任务，因此本质上来讲，CompletableFuture只是对原有API的封装， 而使用CompletableFuture与原来的Future的不同之处在于可以将两个Future组合起来，或者如果两个Future是有依赖关系的，可以等第一个执行完毕后再实行第二个等特性。</p><p><strong>先来看看基本的使用方式：</strong></p><pre><code>public Future&lt;Double&gt; getPriceAsync(final String product) {    final CompletableFuture&lt;Double&gt; futurePrice = new CompletableFuture&lt;&gt;();    new Thread(() -&gt; {        double price = calculatePrice(product);        futurePrice.complete(price);  //完成后使用complete方法，设置future的返回值    }).start();    return futurePrice;}</code></pre><p>得到Future之后就可以使用get方法来获取结果，CompletableFuture提供了一些工厂方法来简化这些API，并且使用函数式编程的方式来使用这些API，例如：</p><p>Fufure<double> price = CompletableFuture.supplyAsync(() -&gt; calculatePrice(product));<br>代码是不是一下子简洁了许多呢。之前说了，CompletableFuture可以组合多个Future，不管是Future之间有依赖的，还是没有依赖的。 </double></p><p><strong>如果第二个请求依赖于第一个请求的结果，那么可以使用thenCompose方法来组合两个Future</strong></p><pre><code>public List&lt;String&gt; findPriceAsync(String product) {    List&lt;CompletableFutute&lt;String&gt;&gt; priceFutures = tasks.stream()    .map(task -&gt; CompletableFuture.supplyAsync(() -&gt; task.getPrice(product),executor))    .map(future -&gt; future.thenApply(Work::parse))    .map(future -&gt; future.thenCompose(work -&gt; CompletableFuture.supplyAsync(() -&gt; Count.applyCount(work), executor)))    .collect(Collectors.toList());    return priceFutures.stream().map(CompletableFuture::join).collect(Collectors.toList());}</code></pre><p>上面这段代码使用了thenCompose来组合两个CompletableFuture。supplyAsync方法第二个参数接受一个自定义的Executor。 首先使用CompletableFuture执行一个任务，调用getPrice方法，得到一个Future，之后使用thenApply方法，将Future的结果应用parse方法， 之后再使用执行完parse之后的结果作为参数再执行一个applyCount方法，然后收集成一个CompletableFuture<string>的List， 最后再使用一个流，调用CompletableFuture的join方法，这是为了等待所有的异步任务执行完毕，获得最后的结果。</string></p><p>注意，这里必须使用两个流，如果在一个流里调用join方法，那么由于Stream的延迟特性，所有的操作还是会串行的执行，并不是异步的。</p><p><strong>再来看一个两个Future之间没有依赖关系的例子：</strong></p><pre><code>Future&lt;String&gt; futurePriceInUsd = CompletableFuture.supplyAsync(() -&gt; shop.getPrice(“price1”))                                    .thenCombine(CompletableFuture.supplyAsync(() -&gt; shop.getPrice(“price2”)), (s1, s2) -&gt; s1 + s2);</code></pre><p>这里有两个异步的任务，使用thenCombine方法来组合两个Future，thenCombine方法的第二个参数就是用来合并两个Future方法返回值的操作函数。</p><p>有时候，我们并不需要等待所有的异步任务结束，只需要其中的一个完成就可以了，CompletableFuture也提供了这样的方法：</p><pre><code>//假设getStream方法返回一个Stream&lt;CompletableFuture&lt;String&gt;&gt;CompletableFuture[] futures = getStream(“listen”).map(f -&gt; f.thenAccept(System.out::println)).toArray(CompletableFuture[]::new);//等待其中的一个执行完毕CompletableFuture.anyOf(futures).join();使用anyOf方法来响应CompletableFuture的completion事件。</code></pre><h1 id="Java虚拟机（JVM）的新特性"><a href="#Java虚拟机（JVM）的新特性" class="headerlink" title="Java虚拟机（JVM）的新特性"></a>Java虚拟机（JVM）的新特性</h1><p>PermGen空间被移除了，取而代之的是Metaspace（JEP 122）。JVM选项-XX:PermSize与-XX:MaxPermSize分别被-XX:MetaSpaceSize与-XX:MaxMetaspaceSize所代替。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>更多展望：Java 8通过发布一些可以增加程序员生产力的特性来推进这个伟大的平台的进步。现在把生产环境迁移到Java 8还为时尚早，但是在接下来的几个月里，它会被大众慢慢的接受。毫无疑问，现在是时候让你的代码与Java 8兼容，并且在Java 8足够安全稳定的时候迁移到Java 8。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;毫无疑问，Java 8发行版是自Java 5（发行于2004，已经过了相当一段时间了）以来最具革命性的版本。Java 8 为Java语言、编译器、类库、开发工具与JVM（Java虚拟机）带来了大量新特性。在这篇教程中，我们将一一探索这些变化，并用真实的例子说明它们适用的场景。&lt;/p&gt;
&lt;p&gt;本文由以下几部分组成，它们分别涉及到Java平台某一特定方面的内容：&lt;/p&gt;
&lt;p&gt;Java语言&lt;br&gt;编译器&lt;br&gt;类库&lt;br&gt;工具&lt;br&gt;Java运行时（JVM）&lt;/p&gt;
&lt;p&gt;本文参考&lt;a href=&quot;http://www.importnew.com/11908.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.importnew.com/11908.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点一下星哈谢谢。&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/05/06/javase20&quot;&gt;https://h2pl.github.io/2018/05/06/javase20&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java基础" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java8" scheme="http://h2pl.github.io/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>Java基础19：Java集合框架梳理</title>
    <link href="http://h2pl.github.io/2018/05/06/javase19/"/>
    <id>http://h2pl.github.io/2018/05/06/javase19/</id>
    <published>2018-05-06T08:30:15.000Z</published>
    <updated>2018-06-01T03:51:29.463Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了Java集合类的基本框架，接口结构以及部分源码分析，并且通过自己实现一些集合类来更好地剖析Java集合类的整体结构。</p><p>本文只是对集合类框架进行一个大概的梳理，毕竟集合框架中包含的类太多了，一篇文章不可能讲完，这里先开一个头，对整体框架有一个清晰认识之后，再去探索各个接口实现类的奥秘。</p><p>后面会专门地写几篇关于集合类的文章，分别介绍一下List，Map，Set以及Stack等等这些接口的实现类，敬请期待。</p><p>具体代码在我的GitHub中可以找到</p><blockquote><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p></blockquote><p>喜欢的话麻烦点一下星哈谢谢。</p><p>文章首发于我的个人博客：</p><blockquote><p><a href="https://h2pl.github.io/2018/05/06/javase19">https://h2pl.github.io/2018/05/06/javase19</a></p></blockquote><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：</p><blockquote><p><a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a></p></blockquote><a id="more"></a><p>在编写java程序中，我们最常用的除了八种基本数据类型，String对象外还有一个集合类，在我们的的程序中到处充斥着集合类的身影！</p><p>java中集合大家族的成员实在是太丰富了，有常用的ArrayList、HashMap、HashSet，也有不常用的Stack、Queue，有线程安全的Vector、HashTable，也有线程不安全的LinkedList、TreeMap等等！</p><p><img src="https://images0.cnblogs.com/blog/381060/201312/28124707-3a873160808e457686d67c118af6fa70.png" alt="image"></p><p>上面的图展示了整个集合大家族的成员以及他们之间的关系。下面就上面的各个接口、基类做一些简单的介绍(主要介绍各个集合的特点。区别)。</p><p>下面几张图更清晰地介绍了结合类接口间的关系：</p><blockquote><p>Collections和Collection。<br>Arrays和Collections。</p></blockquote><p><img src="https://www.programcreek.com/wp-content/uploads/2009/02/CollectionVsCollections.jpeg" alt="image"></p><blockquote><p>Collection的子接口</p></blockquote><p><img src="https://www.programcreek.com/wp-content/uploads/2009/02/java-collection-hierarchy.jpeg" alt="image"></p><blockquote><p>map的实现类</p></blockquote><p><img src="https://www.programcreek.com/wp-content/uploads/2009/02/MapClassHierarchy-600x354.jpg" alt="image"></p><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><p>  Collection接口是最基本的集合接口，它不提供直接的实现，Java SDK提供的类都是继承自Collection的“子接口”如List和Set。Collection所代表的是一种规则，它所包含的元素都必须遵循一条或者多条规则。如有些允许重复而有些则不能重复、有些必须要按照顺序插入而有些则是散列，有些支持排序但是有些则不支持。</p><p>  在Java中所有实现了Collection接口的类都必须提供两套标准的构造函数，一个是无参，用于创建一个空的Collection，一个是带有Collection参数的有参构造函数，用于创建一个新的Collection，这个新的Collection与传入进来的Collection具备相同的元素。<br>//要求实现基本的增删改查方法，并且需要能够转换为数组类型</p><pre><code>public class Collection接口 {    class collect implements Collection {        @Override        public int size() {            return 0;        }        @Override        public boolean isEmpty() {            return false;        }        @Override        public boolean contains(Object o) {            return false;        }        @Override        public Iterator iterator() {            return null;        }        @Override        public Object[] toArray() {            return new Object[0];        }        @Override        public boolean add(Object o) {            return false;        }        @Override        public boolean remove(Object o) {            return false;        }        @Override        public boolean addAll(Collection c) {            return false;        }        @Override        public void clear() {        }//省略部分代码          @Override        public Object[] toArray(Object[] a) {            return new Object[0];        }    }}</code></pre><h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><blockquote><p>  List接口为Collection直接接口。List所代表的是有序的Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。</p></blockquote><p>2.1、ArrayList</p><blockquote><p>  ArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。</p><p>  size、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。</p><p>  ArrayList擅长于随机访问。同时ArrayList是非同步的。</p></blockquote><p>2.2、LinkedList</p><blockquote><p>  同样实现List接口的LinkedList与ArrayList不同，ArrayList是一个动态数组，而LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。</p><p>  由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。</p><p>  与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：<br>List list = Collections.synchronizedList(new LinkedList(…));</p></blockquote><blockquote><p>2.3、Vector<br>      与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。</p><p>2.4、Stack<br>      Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。。</p></blockquote><pre><code>public class List接口 {    //下面是List的继承关系，由于List接口规定了包括诸如索引查询，迭代器的实现，所以实现List接口的类都会有这些方法。    //所以不管是ArrayList和LinkedList底层都可以使用数组操作，但一般不提供这样外部调用方法。    //    public interface Iterable&lt;T&gt;//    public interface Collection&lt;E&gt; extends Iterable&lt;E&gt;//    public interface List&lt;E&gt; extends Collection&lt;E&gt;    class MyList implements List {        @Override        public int size() {            return 0;        }        @Override        public boolean isEmpty() {            return false;        }        @Override        public boolean contains(Object o) {            return false;        }        @Override        public Iterator iterator() {            return null;        }        @Override        public Object[] toArray() {            return new Object[0];        }        @Override        public boolean add(Object o) {            return false;        }        @Override        public boolean remove(Object o) {            return false;        }        @Override        public void clear() {        }       //省略部分代码        @Override        public Object get(int index) {            return null;        }        @Override        public ListIterator listIterator() {            return null;        }        @Override        public ListIterator listIterator(int index) {            return null;        }        @Override        public List subList(int fromIndex, int toIndex) {            return null;        }        @Override        public Object[] toArray(Object[] a) {            return new Object[0];        }    }}</code></pre><h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><blockquote><p>Set是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样运行null的存在但是仅有一个。由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)==true，则必定会产生某些问题。实现了Set接口的集合有：EnumSet、HashSet、TreeSet。</p><p>3.1、EnumSet<br>      是枚举的专用Set。所有的元素都是枚举类型。</p><p>3.2、HashSet<br>      HashSet堪称查询速度最快的集合，因为其内部是以HashCode来实现的。它内部元素的顺序是由哈希码来决定的，所以它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。</p></blockquote><pre><code>public class Set接口 {    // Set接口规定将set看成一个集合，并且使用和数组类似的增删改查方式，同时提供iterator迭代器    //    public interface Set&lt;E&gt; extends Collection&lt;E&gt;    //    public interface Collection&lt;E&gt; extends Iterable&lt;E&gt;    //    public interface Iterable&lt;T&gt;    class MySet implements Set {        @Override        public int size() {            return 0;        }        @Override        public boolean isEmpty() {            return false;        }        @Override        public boolean contains(Object o) {            return false;        }        @Override        public Iterator iterator() {            return null;        }        @Override        public Object[] toArray() {            return new Object[0];        }        @Override        public boolean add(Object o) {            return false;        }        @Override        public boolean remove(Object o) {            return false;        }        @Override        public boolean addAll(Collection c) {            return false;        }        @Override        public void clear() {        }        @Override        public boolean removeAll(Collection c) {            return false;        }        @Override        public boolean retainAll(Collection c) {            return false;        }        @Override        public boolean containsAll(Collection c) {            return false;        }        @Override        public Object[] toArray(Object[] a) {            return new Object[0];        }    }}</code></pre><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><blockquote><p>  Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。实现map的有：HashMap、TreeMap、HashTable、Properties、EnumMap。</p></blockquote><blockquote><p>4.1、HashMap<br>      以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。</p><p>4.2、TreeMap<br>      键以某种排序规则排序，内部以red-black（红-黑）树数据结构实现，实现了SortedMap接口</p><p>4.3、HashTable<br>      也是以哈希表数据结构实现的，解决冲突时与HashMap也一样也是采用了散列链表的形式，不过性能比HashMap要低</p></blockquote><pre><code>public class Map接口 {    //Map接口是最上层接口，Map接口实现类必须实现put和get等哈希操作。    //并且要提供keyset和values，以及entryset等查询结构。    //public interface Map&lt;K,V&gt;    class MyMap implements Map {        @Override        public int size() {            return 0;        }        @Override        public boolean isEmpty() {            return false;        }        @Override        public boolean containsKey(Object key) {            return false;        }        @Override        public boolean containsValue(Object value) {            return false;        }        @Override        public Object get(Object key) {            return null;        }        @Override        public Object put(Object key, Object value) {            return null;        }        @Override        public Object remove(Object key) {            return null;        }        @Override        public void putAll(Map m) {        }        @Override        public void clear() {        }        @Override        public Set keySet() {            return null;        }        @Override        public Collection values() {            return null;        }        @Override        public Set&lt;Entry&gt; entrySet() {            return null;        }    }}</code></pre><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><blockquote><p>  队列，它主要分为两大类，一类是阻塞式队列，队列满了以后再插入元素则会抛出异常，主要包括ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue。另一种队列则是双端队列，支持在头、尾两端插入和移除元素，主要包括：ArrayDeque、LinkedBlockingDeque、LinkedList。</p></blockquote><pre><code>public class Queue接口 {    //queue接口是对队列的一个实现，需要提供队列的进队出队等方法。一般使用linkedlist作为实现类    class MyQueue implements Queue {        @Override        public int size() {            return 0;        }        @Override        public boolean isEmpty() {            return false;        }        @Override        public boolean contains(Object o) {            return false;        }        @Override        public Iterator iterator() {            return null;        }        @Override        public Object[] toArray() {            return new Object[0];        }        @Override        public Object[] toArray(Object[] a) {            return new Object[0];        }        @Override        public boolean add(Object o) {            return false;        }        @Override        public boolean remove(Object o) {            return false;        }        //省略部分代码        @Override        public boolean offer(Object o) {            return false;        }        @Override        public Object remove() {            return null;        }        @Override        public Object poll() {            return null;        }        @Override        public Object element() {            return null;        }        @Override        public Object peek() {            return null;        }    }}</code></pre><h2 id="关于Java集合的小抄"><a href="#关于Java集合的小抄" class="headerlink" title="关于Java集合的小抄"></a>关于Java集合的小抄</h2><p>这部分内容转自我偶像 江南白衣 的博客：<a href="http://calvin1978.blogcn.com/articles/collection.html" target="_blank" rel="noopener">http://calvin1978.blogcn.com/articles/collection.html</a><br>在尽可能短的篇幅里，将所有集合与并发集合的特征、实现方式、性能捋一遍。适合所有”精通Java”，其实还不那么自信的人阅读。</p><p>期望能不止用于面试时，平时选择数据结构，也能考虑一下其成本与效率，不要看着API合适就用了。</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>1.1 ArrayList<br>以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy（）复制到新的数组。因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。</p><p>按数组下标访问元素－get（i）、set（i,e） 的性能很高，这是数组的基本优势。</p><p>如果按下标插入元素、删除元素－add（i,e）、 remove（i）、remove（e），则要用System.arraycopy（）来复制移动部分受影响的元素，性能就变差了。</p><p>越是前面的元素，修改时要移动的元素越多。直接在数组末尾加入元素－常用的add（e），删除最后一个元素则无影响。</p><p>1.2 LinkedList<br>以双向链表实现。链表无容量限制，但双向链表本身使用了更多空间，每插入一个元素都要构造一个额外的Node对象，也需要额外的链表指针操作。</p><p>按下标访问元素－get（i）、set（i,e） 要悲剧的部分遍历链表将指针移动到位 （如果i&gt;数组大小的一半，会从末尾移起）。</p><p>插入、删除元素时修改前后节点的指针即可，不再需要复制移动。但还是要部分遍历链表的指针才能移动到下标所指的位置。</p><p>只有在链表两头的操作－add（）、addFirst（）、removeLast（）或用iterator（）上的remove（）倒能省掉指针的移动。</p><p>Apache Commons 有个TreeNodeList，里面是棵二叉树，可以快速移动指针到位。</p><p>1.3 CopyOnWriteArrayList<br>并发优化的ArrayList。基于不可变对象策略，在修改时先复制出一个数组快照来修改，改好了，再让内部指针指向新数组。</p><p>因为对快照的修改对读操作来说不可见，所以读读之间不互斥，读写之间也不互斥，只有写写之间要加锁互斥。但复制快照的成本昂贵，典型的适合读多写少的场景。</p><p>虽然增加了addIfAbsent（e）方法，会遍历数组来检查元素是否已存在，性能可想像的不会太好。</p><p>1.4 遗憾<br>无论哪种实现，按值返回下标contains（e）, indexOf（e）, remove（e） 都需遍历所有元素进行比较，性能可想像的不会太好。</p><p>没有按元素值排序的SortedList。</p><p>除了CopyOnWriteArrayList，再没有其他线程安全又并发优化的实现如ConcurrentLinkedList。凑合着用Set与Queue中的等价类时，会缺少一些List特有的方法如get（i）。如果更新频率较高，或数组较大时，还是得用Collections.synchronizedList（list），对所有操作用同一把锁来保证线程安全。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>2.1 HashMap</p><p>以Entry[]数组实现的哈希桶数组，用Key的哈希值取模桶数组的大小可得到数组下标。</p><p>插入元素时，如果两条Key落在同一个桶（比如哈希值1和17取模16后都属于第一个哈希桶），我们称之为哈希冲突。</p><p>JDK的做法是链表法，Entry用一个next属性实现多个Entry以单向链表存放。查找哈希值为17的key时，先定位到哈希桶，然后链表遍历桶里所有元素，逐个比较其Hash值然后key值。</p><p>在JDK8里，新增默认为8的阈值，当一个桶里的Entry超过閥值，就不以单向链表而以红黑树来存放以加快Key的查找速度。</p><p>当然，最好还是桶里只有一个元素，不用去比较。所以默认当Entry数量达到桶数量的75%时，哈希冲突已比较严重，就会成倍扩容桶数组，并重新分配所有原来的Entry。扩容成本不低，所以也最好有个预估值。</p><p>取模用与操作（hash &amp; （arrayLength-1））会比较快，所以数组的大小永远是2的N次方， 你随便给一个初始值比如17会转为32。默认第一次放入元素时的初始值是16。</p><p>iterator（）时顺着哈希桶数组来遍历，看起来是个乱序。</p><p>2.2 LinkedHashMap<br>扩展HashMap，每个Entry增加双向链表，号称是最占内存的数据结构。</p><p>支持iterator（）时按Entry的插入顺序来排序（如果设置accessOrder属性为true，则所有读写访问都排序）。</p><p>插入时，Entry把自己加到Header Entry的前面去。如果所有读写访问都要排序，还要把前后Entry的before/after拼接起来以在链表中删除掉自己，所以此时读操作也是线程不安全的了。</p><p>2.3 TreeMap<br>以红黑树实现，红黑树又叫自平衡二叉树：</p><p>对于任一节点而言，其到叶节点的每一条路径都包含相同数目的黑结点。<br>上面的规定，使得树的层数不会差的太远，使得所有操作的复杂度不超过 O（lgn），但也使得插入，修改时要复杂的左旋右旋来保持树的平衡。</p><p>支持iterator（）时按Key值排序，可按实现了Comparable接口的Key的升序排序，或由传入的Comparator控制。可想象的，在树上插入/删除元素的代价一定比HashMap的大。</p><p>支持SortedMap接口，如firstKey（），lastKey（）取得最大最小的key，或sub（fromKey, toKey）, tailMap（fromKey）剪取Map的某一段。</p><p>2.4 EnumMap<br>EnumMap的原理是，在构造函数里要传入枚举类，那它就构建一个与枚举的所有值等大的数组，按Enum. ordinal（）下标来访问数组。性能与内存占用俱佳。</p><p>美中不足的是，因为要实现Map接口，而 V get（Object key）中key是Object而不是泛型K，所以安全起见，EnumMap每次访问都要先对Key进行类型判断，在JMC里录得不低的采样命中频率。</p><p>2.5 ConcurrentHashMap<br>并发优化的HashMap。</p><p>在JDK5里的经典设计，默认16把写锁（可以设置更多），有效分散了阻塞的概率。数据结构为Segment[]，每个Segment一把锁。Segment里面才是哈希桶数组。Key先算出它在哪个Segment里，再去算它在哪个哈希桶里。</p><p>也没有读锁，因为put/remove动作是个原子动作（比如put的整个过程是一个对数组元素/Entry 指针的赋值操作），读操作不会看到一个更新动作的中间状态。</p><p>但在JDK8里，Segment[]的设计被抛弃了，改为精心设计的，只在需要锁的时候加锁。</p><p>支持ConcurrentMap接口，如putIfAbsent（key，value）与相反的replace（key，value）与以及实现CAS的replace（key, oldValue, newValue）。</p><p>2.6 ConcurrentSkipListMap<br>JDK6新增的并发优化的SortedMap，以SkipList结构实现。Concurrent包选用它是因为它支持基于CAS的无锁算法，而红黑树则没有好的无锁算法。</p><p>原理上，可以想象为多个链表组成的N层楼，其中的元素从稀疏到密集，每个元素有往右与往下的指针。从第一层楼开始遍历，如果右端的值比期望的大，那就往下走一层，继续往前走。</p><p>典型的空间换时间。每次插入，都要决定在哪几层插入，同时，要决定要不要多盖一层楼。</p><p>它的size（）同样不能随便调，会遍历来统计。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>所有Set几乎都是内部用一个Map来实现, 因为Map里的KeySet就是一个Set，而value是假值，全部使用同一个Object即可。</p><p>Set的特征也继承了那些内部的Map实现的特征。</p><p>HashSet：内部是HashMap。</p><p>LinkedHashSet：内部是LinkedHashMap。</p><p>TreeSet：内部是TreeMap的SortedSet。</p><p>ConcurrentSkipListSet：内部是ConcurrentSkipListMap的并发优化的SortedSet。</p><p>CopyOnWriteArraySet：内部是CopyOnWriteArrayList的并发优化的Set，利用其addIfAbsent（）方法实现元素去重，如前所述该方法的性能很一般。</p><p>好像少了个ConcurrentHashSet，本来也该有一个内部用ConcurrentHashMap的简单实现，但JDK偏偏没提供。Jetty就自己简单封了一个，Guava则直接用java.util.Collections.newSetFromMap（new ConcurrentHashMap（）） 实现。</p><h3 id="Queue-1"><a href="#Queue-1" class="headerlink" title="Queue"></a>Queue</h3><p>Queue是在两端出入的List，所以也可以用数组或链表来实现。</p><p>4.1 普通队列<br>4.1.1 LinkedList<br>是的，以双向链表实现的LinkedList既是List，也是Queue。</p><p>4.1.2 ArrayDeque<br>以循环数组实现的双向Queue。大小是2的倍数，默认是16。</p><p>为了支持FIFO，即从数组尾压入元素（快），从数组头取出元素（超慢），就不能再使用普通ArrayList的实现了，改为使用循环数组。</p><p>有队头队尾两个下标：弹出元素时，队头下标递增；加入元素时，队尾下标递增。如果加入元素时已到数组空间的末尾，则将元素赋值到数组[0]，同时队尾下标指向0，再插入下一个元素则赋值到数组[1]，队尾下标指向1。如果队尾的下标追上队头，说明数组所有空间已用完，进行双倍的数组扩容。</p><p>4.1.3 PriorityQueue<br>用平衡二叉最小堆实现的优先级队列，不再是FIFO，而是按元素实现的Comparable接口或传入Comparator的比较结果来出队，数值越小，优先级越高，越先出队。但是注意其iterator（）的返回不会排序。</p><p>平衡最小二叉堆，用一个简单的数组即可表达，可以快速寻址，没有指针什么的。最小的在queue[0] ，比如queue[4]的两个孩子，会在queue[2<em>4+1] 和 queue[2</em>（4+1）]，即queue[9]和queue[10]。</p><p>入队时，插入queue[size]，然后二叉地往上比较调整堆。</p><p>出队时，弹出queue[0]，然后把queque[size]拿出来二叉地往下比较调整堆。</p><p>初始大小为11，空间不够时自动50%扩容。</p><p>4.2 线程安全的队列<br>4.2.1 ConcurrentLinkedQueue/Deque<br>无界的并发优化的Queue，基于链表，实现了依赖于CAS的无锁算法。</p><p>ConcurrentLinkedQueue的结构是单向链表和head/tail两个指针，因为入队时需要修改队尾元素的next指针，以及修改tail指向新入队的元素两个CAS动作无法原子，所以需要的特殊的算法。</p><p>4.3 线程安全的阻塞队列<br>BlockingQueue，一来如果队列已空不用重复的查看是否有新数据而会阻塞在那里，二来队列的长度受限，用以保证生产者与消费者的速度不会相差太远。当入队时队列已满，或出队时队列已空，不同函数的效果见下表：</p><p>立刻报异常    立刻返回布尔    阻塞等待    可设定等待时间<br>入队    add（e）    offer（e）    put（e）    offer（e, timeout, unit）<br>出队    remove（）    poll（）    take（）    poll（timeout, unit）<br>查看    element（）    peek（）    无    无</p><p>4.3.1 ArrayBlockingQueue<br>定长的并发优化的BlockingQueue，也是基于循环数组实现。有一把公共的锁与notFull、notEmpty两个Condition管理队列满或空时的阻塞状态。</p><p>4.3.2 LinkedBlockingQueue/Deque<br>可选定长的并发优化的BlockingQueue，基于链表实现，所以可以把长度设为Integer.MAX_VALUE成为无界无等待的。</p><p>利用链表的特征，分离了takeLock与putLock两把锁，继续用notEmpty、notFull管理队列满或空时的阻塞状态。</p><p>4.3.3 PriorityBlockingQueue<br>无界的PriorityQueue，也是基于数组存储的二叉堆（见前）。一把公共的锁实现线程安全。因为无界，空间不够时会自动扩容，所以入列时不会锁，出列为空时才会锁。</p><p>4.3.4 DelayQueue<br>内部包含一个PriorityQueue，同样是无界的，同样是出列时才会锁。一把公共的锁实现线程安全。元素需实现Delayed接口，每次调用时需返回当前离触发时间还有多久，小于0表示该触发了。</p><p>pull（）时会用peek（）查看队头的元素，检查是否到达触发时间。ScheduledThreadPoolExecutor用了类似的结构。</p><p>​</p><p>4.4 同步队列<br>SynchronousQueue同步队列本身无容量，放入元素时，比如等待元素被另一条线程的消费者取走再返回。JDK线程池里用它。</p><p>JDK7还有个LinkedTransferQueue，在普通线程安全的BlockingQueue的基础上，增加一个transfer（e） 函数，效果与SynchronousQueue一样。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了Java集合类的基本框架，接口结构以及部分源码分析，并且通过自己实现一些集合类来更好地剖析Java集合类的整体结构。&lt;/p&gt;
&lt;p&gt;本文只是对集合类框架进行一个大概的梳理，毕竟集合框架中包含的类太多了，一篇文章不可能讲完，这里先开一个头，对整体框架有一个清晰认识之后，再去探索各个接口实现类的奥秘。&lt;/p&gt;
&lt;p&gt;后面会专门地写几篇关于集合类的文章，分别介绍一下List，Map，Set以及Stack等等这些接口的实现类，敬请期待。&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点一下星哈谢谢。&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/05/06/javase19&quot;&gt;https://h2pl.github.io/2018/05/06/javase19&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java基础" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java集合" scheme="http://h2pl.github.io/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java基础18：Java序列化与反序列化</title>
    <link href="http://h2pl.github.io/2018/05/05/javase18/"/>
    <id>http://h2pl.github.io/2018/05/05/javase18/</id>
    <published>2018-05-05T13:58:45.000Z</published>
    <updated>2018-06-11T12:43:20.343Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了Java序列化的基本概念，序列化和反序列化的使用方法，以及实现原理等，比较全面地总结序列化相关知识点，并且使用具体例子来加以佐证。</p><p>具体代码在我的GitHub中可以找到</p><blockquote><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p></blockquote><p>喜欢的话麻烦点一下星哈谢谢。</p><p>文章首发于我的个人博客：</p><blockquote><p><a href="https://h2pl.github.io/2018/05/05/javase18">https://h2pl.github.io/2018/05/05/javase18</a></p></blockquote><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：</p><blockquote><p><a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a></p></blockquote><p>本文参考 <a href="http://www.importnew.com/17964.html和" target="_blank" rel="noopener">http://www.importnew.com/17964.html和</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-serial/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-serial/</a></p><a id="more"></a><h2 id="序列化与反序列化概念"><a href="#序列化与反序列化概念" class="headerlink" title="序列化与反序列化概念"></a>序列化与反序列化概念</h2><p>序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。一般将一个对象存储至一个储存媒介，例如档案或是记亿体缓冲等。在网络传输过程中，可以是字节或是XML等格式。而字节的或XML编码格式可以还原完全相等的对象。这个相反的过程又称为反序列化。</p><p><strong>Java对象的序列化与反序列化</strong></p><p>在Java中，我们可以通过多种方式来创建对象，并且只要对象没有被回收我们都可以复用该对象。但是，我们创建出来的这些Java对象都是存在于JVM的堆内存中的。</p><p>只有JVM处于运行状态的时候，这些对象才可能存在。一旦JVM停止运行，这些对象的状态也就随之而丢失了。</p><p>但是在真实的应用场景中，我们需要将这些对象持久化下来，并且能够在需要的时候把对象重新读取出来。Java的对象序列化可以帮助我们实现该功能。</p><blockquote><p>对象序列化机制（object serialization）是Java语言内建的一种对象持久化方式，通过对象序列化，可以把对象的状态保存为字节数组，并且可以在有需要的时候将这个字节数组通过反序列化的方式再转换成对象。</p></blockquote><p>对象序列化可以很容易的在JVM中的活动对象和字节数组（流）之间进行转换。</p><p>在Java中，对象的序列化与反序列化被广泛应用到RMI(远程方法调用)及网络传输中。</p><h2 id="相关接口及类"><a href="#相关接口及类" class="headerlink" title="相关接口及类"></a>相关接口及类</h2><p>Java为了方便开发人员将Java对象进行序列化及反序列化提供了一套方便的API来支持。其中包括以下接口和类：</p><pre><code>java.io.Serializablejava.io.ExternalizableObjectOutputObjectInputObjectOutputStreamObjectInputStreamSerializable 接口</code></pre><p><strong>类通过实现 java.io.Serializable 接口以启用其序列化功能。</strong></p><p>未实现此接口的类将无法使其任何状态序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或字段，仅用于标识可序列化的语义。 (该接口并没有方法和字段，为什么只有实现了该接口的类的对象才能被序列化呢？)</p><p>当试图对一个对象进行序列化的时候，如果遇到不支持 Serializable 接口的对象。在此情况下，将抛出NotSerializableException。</p><p>如果要序列化的类有父类，要想同时将在父类中定义过的变量持久化下来，那么父类也应该集成java.io.Serializable接口。</p><p>下面是一个实现了java.io.Serializable接口的类</p><pre><code>public class 序列化和反序列化 {    public static void main(String[] args) {    }    //注意，内部类不能进行序列化，因为它依赖于外部类    @Test    public void test() throws IOException {        A a = new A();        a.i = 1;        a.s = &quot;a&quot;;        FileOutputStream fileOutputStream = null;        FileInputStream fileInputStream = null;        try {            //将obj写入文件            fileOutputStream = new FileOutputStream(&quot;temp&quot;);            ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);            objectOutputStream.writeObject(a);            fileOutputStream.close();            //通过文件读取obj            fileInputStream = new FileInputStream(&quot;temp&quot;);            ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);            A a2 = (A) objectInputStream.readObject();            fileInputStream.close();            System.out.println(a2.i);            System.out.println(a2.s);            //打印结果和序列化之前相同        } catch (IOException e) {            e.printStackTrace();        } catch (ClassNotFoundException e) {            e.printStackTrace();        }    }}class A implements Serializable {    int i;    String s;}</code></pre><p><strong>Externalizable接口</strong></p><p>除了Serializable 之外，java中还提供了另一个序列化接口Externalizable</p><p>为了了解Externalizable接口和Serializable接口的区别，先来看代码，我们把上面的代码改成使用Externalizable的形式。</p><pre><code>class B implements Externalizable {    //必须要有公开无参构造函数。否则报错    public B() {    }    int i;    String s;    @Override    public void writeExternal(ObjectOutput out) throws IOException {    }    @Override    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {    }}@Test    public void test2() throws IOException, ClassNotFoundException {        B b = new B();        b.i = 1;        b.s = &quot;a&quot;;        //将obj写入文件        FileOutputStream fileOutputStream = new FileOutputStream(&quot;temp&quot;);        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);        objectOutputStream.writeObject(b);        fileOutputStream.close();        //通过文件读取obj        FileInputStream fileInputStream = new FileInputStream(&quot;temp&quot;);        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);        B b2 = (B) objectInputStream.readObject();        fileInputStream.close();        System.out.println(b2.i);        System.out.println(b2.s);        //打印结果为0和null，即初始值，没有被赋值        //0        //null    }</code></pre><p>通过上面的实例可以发现，对B类进行序列化及反序列化之后得到的对象的所有属性的值都变成了默认值。也就是说，之前的那个对象的状态并没有被持久化下来。这就是Externalizable接口和Serializable接口的区别：</p><p>Externalizable继承了Serializable，该接口中定义了两个抽象方法：writeExternal()与readExternal()。</p><p>当使用Externalizable接口来进行序列化与反序列化的时候需要开发人员重写writeExternal()与readExternal()方法。由于上面的代码中，并没有在这两个方法中定义序列化实现细节，所以输出的内容为空。</p><blockquote><p>还有一点值得注意：在使用Externalizable进行序列化的时候，在读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。所以，实现Externalizable接口的类必须要提供一个public的无参的构造器。</p></blockquote><pre><code>class C implements Externalizable {    int i;    int j;    String s;    public C() {    }    //实现下面两个方法可以选择序列化中需要被复制的成员。    //并且，写入顺序和读取顺序要一致，否则报错。    //可以写入多个同类型变量，顺序保持一致即可。    @Override    public void writeExternal(ObjectOutput out) throws IOException {        out.writeInt(i);        out.writeInt(j);        out.writeObject(s);    }    @Override    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {        i = in.readInt();        j = in.readInt();        s = (String) in.readObject();    }}@Test    public void test3() throws IOException, ClassNotFoundException {        C c = new C();        c.i = 1;        c.j = 2;        c.s = &quot;a&quot;;        //将obj写入文件        FileOutputStream fileOutputStream = new FileOutputStream(&quot;temp&quot;);        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);        objectOutputStream.writeObject(c);        fileOutputStream.close();        //通过文件读取obj        FileInputStream fileInputStream = new FileInputStream(&quot;temp&quot;);        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);        C c2 = (C) objectInputStream.readObject();        fileInputStream.close();        System.out.println(c2.i);        System.out.println(c2.j);        System.out.println(c2.s);        //打印结果为0和null，即初始值，没有被赋值        //0        //null    }</code></pre><h2 id="序列化ID"><a href="#序列化ID" class="headerlink" title="序列化ID"></a>序列化ID</h2><p>序列化 ID 问题<br>情境：两个客户端 A 和 B 试图通过网络传递对象数据，A 端将对象 C 序列化为二进制数据再传给 B，B 反序列化得到 C。</p><p>问题：C 对象的全类路径假设为 com.inout.Test，在 A 和 B 端都有这么一个类文件，功能代码完全一致。也都实现了 Serializable 接口，但是反序列化时总是提示不成功。</p><p>解决：虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID = 1L）。清单 1 中，虽然两个类的功能代码完全一致，但是序列化 ID 不同，他们无法相互序列化和反序列化。</p><pre><code>package com.inout; import java.io.Serializable; public class A implements Serializable {     private static final long serialVersionUID = 1L;     private String name;     public String getName()     {         return name;     }     public void setName(String name)     {         this.name = name;     } } package com.inout; import java.io.Serializable; public class A implements Serializable {     private static final long serialVersionUID = 2L;     private String name;     public String getName()     {         return name;     }     public void setName(String name)     {         this.name = name;     } }</code></pre><h2 id="静态变量不参与序列化"><a href="#静态变量不参与序列化" class="headerlink" title="静态变量不参与序列化"></a>静态变量不参与序列化</h2><p>清单 2 中的 main 方法，将对象序列化后，修改静态变量的数值，再将序列化对象读取出来，然后通过读取出来的对象获得静态变量的数值并打印出来。依照清单 2，这个 System.out.println(t.staticVar) 语句输出的是 10 还是 5 呢？</p><pre><code>public class Test implements Serializable {    private static final long serialVersionUID = 1L;    public static int staticVar = 5;    public static void main(String[] args) {        try {            //初始时staticVar为5            ObjectOutputStream out = new ObjectOutputStream(                    new FileOutputStream(&quot;result.obj&quot;));            out.writeObject(new Test());            out.close();            //序列化后修改为10            Test.staticVar = 10;            ObjectInputStream oin = new ObjectInputStream(new FileInputStream(                    &quot;result.obj&quot;));            Test t = (Test) oin.readObject();            oin.close();            //再读取，通过t.staticVar打印新的值            System.out.println(t.staticVar);        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        } catch (ClassNotFoundException e) {            e.printStackTrace();        }    }}</code></pre><p>最后的输出是 10，对于无法理解的读者认为，打印的 staticVar 是从读取的对象里获得的，应该是保存时的状态才对。之所以打印 10 的原因在于序列化时，并不保存静态变量，这其实比较容易理解，序列化保存的是对象的状态，静态变量属于类的状态，因此 序列化并不保存静态变量。</p><h2 id="探究ArrayList的序列化"><a href="#探究ArrayList的序列化" class="headerlink" title="探究ArrayList的序列化"></a>探究ArrayList的序列化</h2><p>ArrayList的序列化<br>在介绍ArrayList序列化之前，先来考虑一个问题：</p><p>如何自定义的序列化和反序列化策略</p><p>带着这个问题，我们来看java.util.ArrayList的源码</p><pre><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable{    private static final long serialVersionUID = 8683452581122892189L;    transient Object[] elementData; // non-private to simplify nested class access    private int size;}</code></pre><p>笔者省略了其他成员变量，从上面的代码中可以知道ArrayList实现了java.io.Serializable接口，那么我们就可以对它进行序列化及反序列化。</p><p>因为elementData是transient的（1.8好像改掉了这一点)，所以我们认为这个成员变量不会被序列化而保留下来。我们写一个Demo，验证一下我们的想法：</p><pre><code>public class ArrayList的序列化 {    public static void main(String[] args) throws IOException, ClassNotFoundException {        ArrayList list = new ArrayList();        list.add(&quot;a&quot;);        list.add(&quot;b&quot;);        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;arr&quot;));        objectOutputStream.writeObject(list);        objectOutputStream.close();        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;arr&quot;));        ArrayList list1 = (ArrayList) objectInputStream.readObject();        objectInputStream.close();        System.out.println(Arrays.toString(list.toArray()));        //序列化成功，里面的元素保持不变。    }</code></pre><p>了解ArrayList的人都知道，ArrayList底层是通过数组实现的。那么数组elementData其实就是用来保存列表中的元素的。通过该属性的声明方式我们知道，他是无法通过序列化持久化下来的。那么为什么code 4的结果却通过序列化和反序列化把List中的元素保留下来了呢？</p><p><strong>writeObject和readObject方法</strong></p><p>在ArrayList中定义了来个方法： writeObject和readObject。</p><p>这里先给出结论:</p><blockquote><p>在序列化过程中，如果被序列化的类中定义了writeObject 和 readObject 方法，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化。</p><p>如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。</p><p>用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。</p></blockquote><p>来看一下这两个方法的具体实现：</p><pre><code>private void readObject(java.io.ObjectInputStream s)        throws java.io.IOException, ClassNotFoundException {        elementData = EMPTY_ELEMENTDATA;        // Read in size, and any hidden stuff        s.defaultReadObject();        // Read in capacity        s.readInt(); // ignored        if (size &gt; 0) {            // be like clone(), allocate array based upon size not capacity            ensureCapacityInternal(size);            Object[] a = elementData;            // Read in all elements in the proper order.            for (int i=0; i&lt;size; i++) {                a[i] = s.readObject();            }        }    }private void writeObject(java.io.ObjectOutputStream s)        throws java.io.IOException{        // Write out element count, and any hidden stuff        int expectedModCount = modCount;        s.defaultWriteObject();        // Write out size as capacity for behavioural compatibility with clone()        s.writeInt(size);        // Write out all elements in the proper order.        for (int i=0; i&lt;size; i++) {            s.writeObject(elementData[i]);        }        if (modCount != expectedModCount) {            throw new ConcurrentModificationException();        }    }</code></pre><p>那么为什么ArrayList要用这种方式来实现序列化呢？</p><pre><code>why transientArrayList实际上是动态数组，每次在放满以后自动增长设定的长度值，如果数组自动增长长度设为100，而实际只放了一个元素，那就会序列化99个null元素。为了保证在序列化的时候不会将这么多null同时进行序列化，ArrayList把元素数组设置为transient。why writeObject and readObject前面说过，为了防止一个包含大量空对象的数组被序列化，为了优化存储，所以，ArrayList使用transient来声明elementData。 但是，作为一个集合，在序列化过程中还必须保证其中的元素可以被持久化下来，所以，通过重写writeObject 和 readObject方法的方式把其中的元素保留下来。writeObject方法把elementData数组中的元素遍历的保存到输出流（ObjectOutputStream）中。readObject方法从输入流（ObjectInputStream）中读出对象并保存赋值到elementData数组中。</code></pre><h2 id="如何自定义的序列化和反序列化策略"><a href="#如何自定义的序列化和反序列化策略" class="headerlink" title="如何自定义的序列化和反序列化策略"></a>如何自定义的序列化和反序列化策略</h2><p>延续上一部分，刚刚我们明白了ArrayList序列化数组元素的原理。</p><p>至此，我们先试着来回答刚刚提出的问题：</p><p>如何自定义的序列化和反序列化策略</p><p>答：可以通过在被序列化的类中增加writeObject 和 readObject方法。那么问题又来了：</p><blockquote><p>虽然ArrayList中写了writeObject 和 readObject 方法，但是这两个方法并没有显示的被调用啊。</p><p>那么如果一个类中包含writeObject 和 readObject 方法，那么这两个方法是怎么被调用的呢?</p></blockquote><p>ObjectOutputStream<br>从code 4中，我们可以看出，对象的序列化过程通过ObjectOutputStream和ObjectInputputStream来实现的，那么带着刚刚的问题，我们来分析一下ArrayList中的writeObject 和 readObject 方法到底是如何被调用的呢？</p><p>为了节省篇幅，这里给出ObjectOutputStream的writeObject的调用栈：</p><p>writeObject —&gt; writeObject0 —&gt;writeOrdinaryObject—&gt;writeSerialData—&gt;invokeWriteObject</p><p>这里看一下invokeWriteObject：</p><pre><code>void invokeWriteObject(Object obj, ObjectOutputStream out)        throws IOException, UnsupportedOperationException    {        if (writeObjectMethod != null) {            try {                writeObjectMethod.invoke(obj, new Object[]{ out });            } catch (InvocationTargetException ex) {                Throwable th = ex.getTargetException();                if (th instanceof IOException) {                    throw (IOException) th;                } else {                    throwMiscException(th);                }            } catch (IllegalAccessException ex) {                // should not occur, as access checks have been suppressed                throw new InternalError(ex);            }        } else {            throw new UnsupportedOperationException();        }    }</code></pre><p>其中writeObjectMethod.invoke(obj, new Object[]{ out });是关键，通过反射的方式调用writeObjectMethod方法。官方是这么解释这个writeObjectMethod的：</p><p>class-defined writeObject method, or null if none</p><p>在我们的例子中，这个方法就是我们在ArrayList中定义的writeObject方法。通过反射的方式被调用了。</p><p>至此，我们先试着来回答刚刚提出的问题：</p><pre><code>如果一个类中包含writeObject 和 readObject 方法，那么这两个方法是怎么被调用的?答：在使用ObjectOutputStream的writeObject方法和ObjectInputStream的readObject方法时，会通过反射的方式调用。</code></pre><h2 id="为什么要实现Serializable"><a href="#为什么要实现Serializable" class="headerlink" title="为什么要实现Serializable"></a>为什么要实现Serializable</h2><p>至此，我们已经介绍完了ArrayList的序列化方式。那么，不知道有没有人提出这样的疑问：</p><p>Serializable明明就是一个空的接口，它是怎么保证只有实现了该接口的方法才能进行序列化与反序列化的呢？</p><pre><code>Serializable接口的定义：public interface Serializable {}读者可以尝试把code 1中的继承Serializable的代码去掉，再执行code 2，会抛出java.io.NotSerializableException。</code></pre><p>其实这个问题也很好回答，我们再回到刚刚ObjectOutputStream的writeObject的调用栈：</p><pre><code>writeObject ---&gt; writeObject0 ---&gt;writeOrdinaryObject---&gt;writeSerialData---&gt;invokeWriteObject</code></pre><p>writeObject0方法中有这么一段代码：</p><pre><code>if (obj instanceof String) {                writeString((String) obj, unshared);            } else if (cl.isArray()) {                writeArray(obj, desc, unshared);            } else if (obj instanceof Enum) {                writeEnum((Enum&lt;?&gt;) obj, desc, unshared);            } else if (obj instanceof Serializable) {                writeOrdinaryObject(obj, desc, unshared);            } else {                if (extendedDebugInfo) {                    throw new NotSerializableException(                        cl.getName() + &quot;\n&quot; + debugInfoStack.toString());                } else {                    throw new NotSerializableException(cl.getName());                }            }</code></pre><p>在进行序列化操作时，会判断要被序列化的类是否是Enum、Array和Serializable类型，如果不是则直接抛出NotSerializableException。</p><h2 id="序列化知识点总结"><a href="#序列化知识点总结" class="headerlink" title="序列化知识点总结"></a>序列化知识点总结</h2><blockquote><p>1、如果一个类想被序列化，需要实现Serializable接口。否则将抛出NotSerializableException异常，这是因为，在序列化操作过程中会对类型进行检查，要求被序列化的类必须属于Enum、Array和Serializable类型其中的任何一种。</p><p>2、通过ObjectOutputStream和ObjectInputStream对对象进行序列化及反序列化</p><p>3、虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID）</p><p>序列化 ID 在 Eclipse 下提供了两种生成策略，一个是固定的 1L，一个是随机生成一个不重复的 long 类型数据（实际上是使用 JDK 工具生成），在这里有一个建议，如果没有特殊需求，就是用默认的 1L 就可以，这样可以确保代码一致时反序列化成功。那么随机生成的序列化 ID 有什么作用呢，有些时候，通过改变序列化 ID 可以用来限制某些用户的使用。</p><p>4、序列化并不保存静态变量。</p><p>5、要想将父类对象也序列化，就需要让父类也实现Serializable 接口。</p><p>6、Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</p><p>7、服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。</p><p>8、在类中增加writeObject 和 readObject 方法可以实现自定义序列化策略</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了Java序列化的基本概念，序列化和反序列化的使用方法，以及实现原理等，比较全面地总结序列化相关知识点，并且使用具体例子来加以佐证。&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点一下星哈谢谢。&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/05/05/javase18&quot;&gt;https://h2pl.github.io/2018/05/05/javase18&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文参考 &lt;a href=&quot;http://www.importnew.com/17964.html和&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.importnew.com/17964.html和&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/java/j-lo-serial/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.ibm.com/developerworks/cn/java/j-lo-serial/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java基础" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础17：Java IO流总结</title>
    <link href="http://h2pl.github.io/2018/05/04/javase17/"/>
    <id>http://h2pl.github.io/2018/05/04/javase17/</id>
    <published>2018-05-04T13:50:01.000Z</published>
    <updated>2018-06-11T13:43:19.411Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了Java IO流的基本概念，使用方法，以及使用的注意事项等。帮助你更好地理解和使用Java的IO流。</p><p>具体代码在我的GitHub中可以找到</p><blockquote><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p></blockquote><p>喜欢的话麻烦点一下星哈谢谢。</p><p>文章首发于我的个人博客：</p><blockquote><p><a href="https://h2pl.github.io/2018/05/04/javase17">https://h2pl.github.io/2018/05/04/javase17</a></p></blockquote><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：</p><blockquote><p><a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a></p></blockquote><p>本文参考</p><p>并发编程网 – ifeve.com</p><a id="more"></a><h2 id="IO流概述"><a href="#IO流概述" class="headerlink" title="IO流概述"></a>IO流概述</h2><blockquote><p>在这一小节，我会试着给出Java IO(java.io)包下所有类的概述。更具体地说，我会根据类的用途对类进行分组。这个分组将会使你在未来的工作中，进行类的用途判定时，或者是为某个特定用途选择类时变得更加容易。</p></blockquote><p><strong>输入和输出</strong></p><pre><code>术语“输入”和“输出”有时候会有一点让人疑惑。一个应用程序的输入往往是另外一个应用程序的输出那么OutputStream流到底是一个输出到目的地的流呢，还是一个产生输出的流？InputStream流到底会不会输出它的数据给读取数据的程序呢？就我个人而言，在第一天学习Java IO的时候我就感觉到了一丝疑惑。为了消除这个疑惑，我试着给输入和输出起一些不一样的别名，让它们从概念上与数据的来源和数据的流向相联系。</code></pre><p>Java的IO包主要关注的是从原始数据源的读取以及输出原始数据到目标媒介。以下是最典型的数据源和目标媒介：</p><pre><code>文件管道网络连接内存缓存System.in, System.out, System.error(注：Java标准输入、输出、错误输出)</code></pre><p>下面这张图描绘了一个程序从数据源读取数据，然后将数据输出到其他媒介的原理：</p><p><img src="http://ifeve.com/wp-content/uploads/2014/10/%E6%97%A0%E6%A0%87%E9%A2%981.png" alt="image"></p><p><strong>流</strong></p><pre><code>在Java IO中，流是一个核心的概念。流从概念上来说是一个连续的数据流。你既可以从流中读取数据，也可以往流中写数据。流与数据源或者数据流向的媒介相关联。在Java IO中流既可以是字节流(以字节为单位进行读写)，也可以是字符流(以字符为单位进行读写)。</code></pre><p>类InputStream, OutputStream, Reader 和Writer<br>一个程序需要InputStream或者Reader从数据源读取数据，需要OutputStream或者Writer将数据写入到目标媒介中。以下的图说明了这一点：</p><p><img src="http://ifeve.com/wp-content/uploads/2014/10/%E6%97%A0%E6%A0%87%E9%A2%982.png" alt="image"></p><p>InputStream和Reader与数据源相关联，OutputStream和writer与目标媒介相关联。</p><p><strong>Java IO的用途和特征</strong></p><p>Java IO中包含了许多InputStream、OutputStream、Reader、Writer的子类。这样设计的原因是让每一个类都负责不同的功能。这也就是为什么IO包中有这么多不同的类的缘故。各类用途汇总如下：</p><pre><code>文件访问网络访问内存缓存访问线程内部通信(管道)缓冲过滤解析读写文本 (Readers / Writers)读写基本类型数据 (long, int etc.)读写对象</code></pre><p>当通读过Java IO类的源代码之后，我们很容易就能了解这些用途。这些用途或多或少让我们更加容易地理解，不同的类用于针对不同业务场景。</p><p>Java IO类概述表<br>已经讨论了数据源、目标媒介、输入、输出和各类不同用途的Java IO类，接下来是一张通过输入、输出、基于字节或者字符、以及其他比如缓冲、解析之类的特定用途划分的大部分Java IO类的表格。</p><p><img src="http://ifeve.com/wp-content/uploads/2014/10/QQ%E6%88%AA%E5%9B%BE20141020174145.png" alt="image"></p><p>Java IO类图</p><p><img src="https://images.cnblogs.com/cnblogs_com/davidgu/java_io_hierarchy.jpg" alt="image"></p><h2 id="什么是Java-IO流"><a href="#什么是Java-IO流" class="headerlink" title="什么是Java IO流"></a>什么是Java IO流</h2><p>Java IO流是既可以从中读取，也可以写入到其中的数据流。正如这个系列教程之前提到过的，流通常会与数据源、数据流向目的地相关联，比如文件、网络等等。</p><p>流和数组不一样，不能通过索引读写数据。在流中，你也不能像数组那样前后移动读取数据，除非使用RandomAccessFile 处理文件。流仅仅只是一个连续的数据流。</p><p>某些类似PushbackInputStream 流的实现允许你将数据重新推回到流中，以便重新读取。然而你只能把有限的数据推回流中，并且你不能像操作数组那样随意读取数据。流中的数据只能够顺序访问。</p><blockquote><p>Java IO流通常是基于字节或者基于字符的。字节流通常以“stream”命名，比如InputStream和OutputStream。除了DataInputStream 和DataOutputStream 还能够读写int, long, float和double类型的值以外，其他流在一个操作时间内只能读取或者写入一个原始字节。</p><p>字符流通常以“Reader”或者“Writer”命名。字符流能够读写字符(比如Latin1或者Unicode字符)。可以浏览Java Readers and Writers获取更多关于字符流输入输出的信息。</p></blockquote><p><strong>InputStream</strong></p><p>java.io.InputStream类是所有Java IO输入流的基类。如果你正在开发一个从流中读取数据的组件，请尝试用InputStream替代任何它的子类(比如FileInputStream)进行开发。这么做能够让你的代码兼容任何类型而非某种确定类型的输入流。</p><p><strong>组合流</strong></p><p>你可以将流整合起来以便实现更高级的输入和输出操作。比如，一次读取一个字节是很慢的，所以可以从磁盘中一次读取一大块数据，然后从读到的数据块中获取字节。为了实现缓冲，可以把InputStream包装到BufferedInputStream中。</p><p>代码示例<br>    InputStream input = new BufferedInputStream(new FileInputStream(“c:\data\input-file.txt”));</p><blockquote><p>缓冲同样可以应用到OutputStream中。你可以实现将大块数据批量地写入到磁盘(或者相应的流)中，这个功能由BufferedOutputStream实现。</p><p>缓冲只是通过流整合实现的其中一个效果。你可以把InputStream包装到PushbackInputStream中，之后可以将读取过的数据推回到流中重新读取，在解析过程中有时候这样做很方便。或者，你可以将两个InputStream整合成一个SequenceInputStream。</p><p>将不同的流整合到一个链中，可以实现更多种高级操作。通过编写包装了标准流的类，可以实现你想要的效果和过滤器。</p></blockquote><h2 id="IO文件"><a href="#IO文件" class="headerlink" title="IO文件"></a>IO文件</h2><p>在Java应用程序中，文件是一种常用的数据源或者存储数据的媒介。所以这一小节将会对Java中文件的使用做一个简短的概述。这篇文章不会对每一个技术细节都做出解释，而是会针对文件存取的方法提供给你一些必要的知识点。在之后的文章中，将会更加详细地描述这些方法或者类，包括方法示例等等。</p><p><strong>通过Java IO读文件</strong></p><pre><code>如果你需要在不同端之间读取文件，你可以根据该文件是二进制文件还是文本文件来选择使用FileInputStream或者FileReader。这两个类允许你从文件开始到文件末尾一次读取一个字节或者字符，或者将读取到的字节写入到字节数组或者字符数组。你不必一次性读取整个文件，相反你可以按顺序地读取文件中的字节和字符。</code></pre><p>如果你需要跳跃式地读取文件其中的某些部分，可以使用RandomAccessFile。</p><p><strong>通过Java IO写文件</strong></p><pre><code>如果你需要在不同端之间进行文件的写入，你可以根据你要写入的数据是二进制型数据还是字符型数据选用FileOutputStream或者FileWriter。你可以一次写入一个字节或者字符到文件中，也可以直接写入一个字节数组或者字符数据。数据按照写入的顺序存储在文件当中。</code></pre><p><strong>通过Java IO随机存取文件</strong></p><p>正如我所提到的，你可以通过RandomAccessFile对文件进行随机存取。</p><pre><code>随机存取并不意味着你可以在真正随机的位置进行读写操作，它只是意味着你可以跳过文件中某些部分进行操作，并且支持同时读写，不要求特定的存取顺序。这使得RandomAccessFile可以覆盖一个文件的某些部分、或者追加内容到它的末尾、或者删除它的某些内容，当然它也可以从文件的任何位置开始读取文件。</code></pre><p>下面是具体例子：</p><pre><code>@Test    //文件流范例，打开一个文件的输入流，读取到字节数组，再写入另一个文件的输出流    public void test1() {        try {            FileInputStream fileInputStream = new FileInputStream(new File(&quot;a.txt&quot;));            FileOutputStream fileOutputStream = new FileOutputStream(new File(&quot;b.txt&quot;));            byte []buffer = new byte[128];            while (fileInputStream.read(buffer) != -1) {                fileOutputStream.write(buffer);            }            //随机读写，通过mode参数来决定读或者写            RandomAccessFile randomAccessFile = new RandomAccessFile(new File(&quot;c.txt&quot;), &quot;rw&quot;);        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }    }</code></pre><h2 id="字符流和字节流"><a href="#字符流和字节流" class="headerlink" title="字符流和字节流"></a>字符流和字节流</h2><p>Java IO的Reader和Writer除了基于字符之外，其他方面都与InputStream和OutputStream非常类似。他们被用于读写文本。InputStream和OutputStream是基于字节的，还记得吗？</p><p>Reader<br>Reader类是Java IO中所有Reader的基类。子类包括BufferedReader，PushbackReader，InputStreamReader，StringReader和其他Reader。</p><p>Writer<br>Writer类是Java IO中所有Writer的基类。子类包括BufferedWriter和PrintWriter等等。</p><p>这是一个简单的Java IO Reader的例子：</p><pre><code>Reader reader = new FileReader(&quot;c:\\data\\myfile.txt&quot;);int data = reader.read();while(data != -1){    char dataChar = (char) data;    data = reader.read();}</code></pre><p>你通常会使用Reader的子类，而不会直接使用Reader。Reader的子类包括InputStreamReader，CharArrayReader，FileReader等等。可以查看Java IO概述浏览完整的Reader表格。</p><p><strong>整合Reader与InputStream</strong></p><p>一个Reader可以和一个InputStream相结合。如果你有一个InputStream输入流，并且想从其中读取字符，可以把这个InputStream包装到InputStreamReader中。把InputStream传递到InputStreamReader的构造函数中：</p><pre><code>Reader reader = new InputStreamReader(inputStream);</code></pre><p>在构造函数中可以指定解码方式。</p><p><strong>Writer</strong></p><p>Writer类是Java IO中所有Writer的基类。子类包括BufferedWriter和PrintWriter等等。这是一个Java IO Writer的例子：</p><pre><code>Writer writer = new FileWriter(&quot;c:\\data\\file-output.txt&quot;); writer.write(&quot;Hello World Writer&quot;); writer.close();</code></pre><p>同样，你最好使用Writer的子类，不需要直接使用Writer，因为子类的实现更加明确，更能表现你的意图。常用子类包括OutputStreamWriter，CharArrayWriter，FileWriter等。Writer的write(int c)方法，会将传入参数的低16位写入到Writer中，忽略高16位的数据。</p><p><strong>整合Writer和OutputStream</strong></p><p>与Reader和InputStream类似，一个Writer可以和一个OutputStream相结合。把OutputStream包装到OutputStreamWriter中，所有写入到OutputStreamWriter的字符都将会传递给OutputStream。这是一个OutputStreamWriter的例子：</p><pre><code>Writer writer = new OutputStreamWriter(outputStream);</code></pre><h2 id="IO管道"><a href="#IO管道" class="headerlink" title="IO管道"></a>IO管道</h2><p>Java IO中的管道为运行在同一个JVM中的两个线程提供了通信的能力。所以管道也可以作为数据源以及目标媒介。</p><p>你不能利用管道与不同的JVM中的线程通信(不同的进程)。在概念上，Java的管道不同于Unix/Linux系统中的管道。在Unix/Linux中，运行在不同地址空间的两个进程可以通过管道通信。在Java中，通信的双方应该是运行在同一进程中的不同线程。</p><p>通过Java IO创建管道</p><pre><code>可以通过Java IO中的PipedOutputStream和PipedInputStream创建管道。一个PipedInputStream流应该和一个PipedOutputStream流相关联。一个线程通过PipedOutputStream写入的数据可以被另一个线程通过相关联的PipedInputStream读取出来。</code></pre><p>Java IO管道示例<br>这是一个如何将PipedInputStream和PipedOutputStream关联起来的简单例子：</p><pre><code>//使用管道来完成两个线程间的数据点对点传递    @Test    public void test2() throws IOException {        PipedInputStream pipedInputStream = new PipedInputStream();        PipedOutputStream pipedOutputStream = new PipedOutputStream(pipedInputStream);        new Thread(new Runnable() {            @Override            public void run() {                try {                    pipedOutputStream.write(&quot;hello input&quot;.getBytes());                    pipedOutputStream.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }).start();        new Thread(new Runnable() {            @Override            public void run() {                try {                    byte []arr = new byte[128];                    while (pipedInputStream.read(arr) != -1) {                        System.out.println(Arrays.toString(arr));                    }                    pipedInputStream.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }).start();</code></pre><p>管道和线程<br>请记得，当使用两个相关联的管道流时，务必将它们分配给不同的线程。read()方法和write()方法调用时会导致流阻塞，这意味着如果你尝试在一个线程中同时进行读和写，可能会导致线程死锁。</p><p>管道的替代<br>除了管道之外，一个JVM中不同线程之间还有许多通信的方式。实际上，线程在大多数情况下会传递完整的对象信息而非原始的字节数据。但是，如果你需要在线程之间传递字节数据，Java IO的管道是一个不错的选择。</p><h2 id="Java-IO：网络"><a href="#Java-IO：网络" class="headerlink" title="Java IO：网络"></a>Java IO：网络</h2><p>Java中网络的内容或多或少的超出了Java IO的范畴。关于Java网络更多的是在我的Java网络教程中探讨。但是既然网络是一个常见的数据来源以及数据流目的地，并且因为你使用Java IO的API通过网络连接进行通信，所以本文将简要的涉及网络应用。</p><p>当两个进程之间建立了网络连接之后，他们通信的方式如同操作文件一样：利用InputStream读取数据，利用OutputStream写入数据。换句话来说，Java网络API用来在不同进程之间建立网络连接，而Java IO则用来在建立了连接之后的进程之间交换数据。</p><p>基本上意味着如果你有一份能够对文件进行写入某些数据的代码，那么这些数据也可以很容易地写入到网络连接中去。你所需要做的仅仅只是在代码中利用OutputStream替代FileOutputStream进行数据的写入。因为FileOutputStream是OuputStream的子类，所以这么做并没有什么问题。</p><pre><code>//从网络中读取字节流也可以直接使用OutputStreampublic void test3() {    //读取网络进程的输出流    OutputStream outputStream = new OutputStream() {        @Override        public void write(int b) throws IOException {        }    };}public void process(OutputStream ouput) throws IOException {    //处理网络信息    //do something with the OutputStream}</code></pre><h2 id="字节和字符数组"><a href="#字节和字符数组" class="headerlink" title="字节和字符数组"></a>字节和字符数组</h2><p>从InputStream或者Reader中读入数组</p><p>从OutputStream或者Writer中写数组</p><p>在java中常用字节和字符数组在应用中临时存储数据。而这些数组又是通常的数据读取来源或者写入目的地。如果你需要在程序运行时需要大量读取文件里的内容，那么你也可以把一个文件加载到数组中。</p><p>前面的例子中，字符数组或字节数组是用来缓存数据的临时存储空间，不过它们同时也可以作为数据来源或者写入目的地。<br>举个例子：</p><pre><code>//字符数组和字节数组在io过程中的作用    public void test4() {        //arr和brr分别作为数据源        char []arr = {&apos;a&apos;,&apos;c&apos;,&apos;d&apos;};        CharArrayReader charArrayReader = new CharArrayReader(arr);        byte []brr = {1,2,3,4,5};        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(brr);    }</code></pre><h2 id="System-in-System-out-System-err"><a href="#System-in-System-out-System-err" class="headerlink" title="System.in, System.out, System.err"></a>System.in, System.out, System.err</h2><p>System.in, System.out, System.err这3个流同样是常见的数据来源和数据流目的地。使用最多的可能是在控制台程序里利用System.out将输出打印到控制台上。</p><p>JVM启动的时候通过Java运行时初始化这3个流，所以你不需要初始化它们(尽管你可以在运行时替换掉它们)。</p><pre><code>System.inSystem.in是一个典型的连接控制台程序和键盘输入的InputStream流。通常当数据通过命令行参数或者配置文件传递给命令行Java程序的时候，System.in并不是很常用。图形界面程序通过界面传递参数给程序，这是一块单独的Java IO输入机制。System.outSystem.out是一个PrintStream流。System.out一般会把你写到其中的数据输出到控制台上。System.out通常仅用在类似命令行工具的控制台程序上。System.out也经常用于打印程序的调试信息(尽管它可能并不是获取程序调试信息的最佳方式)。System.errSystem.err是一个PrintStream流。System.err与System.out的运行方式类似，但它更多的是用于打印错误文本。一些类似Eclipse的程序，为了让错误信息更加显眼，会将错误信息以红色文本的形式通过System.err输出到控制台上。</code></pre><p>System.out和System.err的简单例子：<br>这是一个System.out和System.err结合使用的简单示例：</p><pre><code> //测试System.in, System.out, System.err        public static void main(String[] args) {        int in = new Scanner(System.in).nextInt();        System.out.println(in);        System.out.println(&quot;out&quot;);        System.err.println(&quot;err&quot;);        //输入10，结果是//        err（红色）//        10//        out    }</code></pre><h2 id="字符流的Buffered和Filter"><a href="#字符流的Buffered和Filter" class="headerlink" title="字符流的Buffered和Filter"></a>字符流的Buffered和Filter</h2><p>BufferedReader能为字符输入流提供缓冲区，可以提高许多IO处理的速度。你可以一次读取一大块的数据，而不需要每次从网络或者磁盘中一次读取一个字节。特别是在访问大量磁盘数据时，缓冲通常会让IO快上许多。</p><p>BufferedReader和BufferedInputStream的主要区别在于，BufferedReader操作字符，而BufferedInputStream操作原始字节。只需要把Reader包装到BufferedReader中，就可以为Reader添加缓冲区(译者注：默认缓冲区大小为8192字节，即8KB)。代码如下：</p><pre><code>Reader input = new BufferedReader(new FileReader(&quot;c:\\data\\input-file.txt&quot;));</code></pre><p>你也可以通过传递构造函数的第二个参数，指定缓冲区大小，代码如下：</p><pre><code>Reader input = new BufferedReader(new FileReader(&quot;c:\\data\\input-file.txt&quot;), 8 * 1024);</code></pre><p>这个例子设置了8KB的缓冲区。最好把缓冲区大小设置成1024字节的整数倍，这样能更高效地利用内置缓冲区的磁盘。</p><p>除了能够为输入流提供缓冲区以外，其余方面BufferedReader基本与Reader类似。BufferedReader还有一个额外readLine()方法，可以方便地一次性读取一整行字符。</p><p><strong>BufferedWriter</strong></p><p>与BufferedReader类似，BufferedWriter可以为输出流提供缓冲区。可以构造一个使用默认大小缓冲区的BufferedWriter(译者注：默认缓冲区大小8 * 1024B)，代码如下：</p><pre><code>Writer writer = new BufferedWriter(new FileWriter(&quot;c:\\data\\output-file.txt&quot;));</code></pre><p>也可以手动设置缓冲区大小，代码如下：</p><pre><code>Writer writer = new BufferedWriter(new FileWriter(&quot;c:\\data\\output-file.txt&quot;), 8 * 1024);</code></pre><p>为了更好地使用内置缓冲区的磁盘，同样建议把缓冲区大小设置成1024的整数倍。除了能够为输出流提供缓冲区以外，其余方面BufferedWriter基本与Writer类似。类似地，BufferedWriter也提供了writeLine()方法，能够把一行字符写入到底层的字符输出流中。</p><p><strong>值得注意是，你需要手动flush()方法确保写入到此输出流的数据真正写入到磁盘或者网络中。</strong></p><p><strong>FilterReader</strong></p><p>与FilterInputStream类似，FilterReader是实现自定义过滤输入字符流的基类，基本上它仅仅只是简单覆盖了Reader中的所有方法。</p><p>就我自己而言，我没发现这个类明显的用途。除了构造函数取一个Reader变量作为参数之外，我没看到FilterReader任何对Reader新增或者修改的地方。如果你选择继承FilterReader实现自定义的类，同样也可以直接继承自Reader从而避免额外的类层级结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了Java IO流的基本概念，使用方法，以及使用的注意事项等。帮助你更好地理解和使用Java的IO流。&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点一下星哈谢谢。&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/05/04/javase17&quot;&gt;https://h2pl.github.io/2018/05/04/javase17&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文参考&lt;/p&gt;
&lt;p&gt;并发编程网 – ifeve.com&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java基础" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础16：Java多线程基础最全总结</title>
    <link href="http://h2pl.github.io/2018/05/04/javase16/"/>
    <id>http://h2pl.github.io/2018/05/04/javase16/</id>
    <published>2018-05-03T16:14:12.000Z</published>
    <updated>2018-06-11T13:43:18.858Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了Java多线程的基本概念，使用方法，以及底层实现原理。帮助你更好地使用Java的多线程。</p><p>具体代码在我的GitHub中可以找到</p><blockquote><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p></blockquote><p>喜欢的话麻烦点一下星哈谢谢。</p><p>文章首发于我的个人博客：</p><blockquote><p><a href="https://h2pl.github.io/2018/05/04/javase16">https://h2pl.github.io/2018/05/04/javase16</a></p></blockquote><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：</p><blockquote><p><a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a></p></blockquote><a id="more"></a><h2 id="Java中的线程"><a href="#Java中的线程" class="headerlink" title="Java中的线程"></a>Java中的线程</h2><p>Java之父对线程的定义是：</p><blockquote><p>线程是一个独立执行的调用序列，同一个进程的线程在同一时刻共享一些系统资源（比如文件句柄等）也能访问同一个进程所创建的对象资源（内存资源）。java.lang.Thread对象负责统计和控制这种行为。</p></blockquote><blockquote><p>每个程序都至少拥有一个线程-即作为Java虚拟机(JVM)启动参数运行在主类main方法的线程。在Java虚拟机初始化过程中也可能启动其他的后台线程。这种线程的数目和种类因JVM的实现而异。然而所有用户级线程都是显式被构造并在主线程或者是其他用户线程中被启动。</p></blockquote><pre><code>  本文主要讲了java中多线程的使用方法、线程同步、线程数据传递、线程状态及相应的一些线程函数用法、概述等。在这之前，首先让我们来了解下在操作系统中进程和线程的区别：　　进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。（进程是资源分配的最小单位）　　线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）　　线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。　　多进程是指操作系统能同时运行多个任务（程序）。　　多线程是指在同一程序中有多个顺序流在执行。在java中要想实现多线程，有两种手段，一种是继续Thread类，另外一种是实现Runable接口.(其实准确来讲，应该有三种，还有一种是实现Callable接口，并与Future、线程池结合使用</code></pre><h2 id="Java线程内存模型"><a href="#Java线程内存模型" class="headerlink" title="Java线程内存模型"></a>Java线程内存模型</h2><p>下面的图大致介绍了Java线程的调用过程，每个线程使用一个独立的调用栈进行线程执行，栈中的数据不共享，堆区和方法区的数据是共享的。<br><img src="http://incdn1.b0.upaiyun.com/2017/10/0daf3c6197b0a14eef74a013a154024a.png" alt="image"></p><p><img src="http://incdn1.b0.upaiyun.com/2017/10/0daf3c6197b0a14eef74a013a154024a.png" alt="image"></p><p><img src="http://incdn1.b0.upaiyun.com/2017/10/3d9d0af74829fa666dc137ef89a7b332.png" alt="image"></p><h2 id="构造方法和守护线程"><a href="#构造方法和守护线程" class="headerlink" title="构造方法和守护线程"></a>构造方法和守护线程</h2><pre><code>构造方法Thread类中不同的构造方法接受如下参数的不同组合：一个Runnable对象，这种情况下，Thread.start方法将会调用对应Runnable对象的run方法。如果没有提供Runnable对象，那么就会立即得到一个Thread.run的默认实现。一个作为线程标识名的String字符串，该标识在跟踪和调试过程中会非常有用，除此别无它用。线程组（ThreadGroup），用来放置新创建的线程，如果提供的ThreadGroup不允许被访问，那么就会抛出一个SecurityException 。Thread对象拥有一个守护(daemon)标识属性，这个属性无法在构造方法中被赋值，但是可以在线程启动之前设置该属性(通过setDaemon方法)。当程序中所有的非守护线程都已经终止，调用setDaemon方法可能会导致虚拟机粗暴的终止线程并退出。isDaemon方法能够返回该属性的值。守护状态的作用非常有限，即使是后台线程在程序退出的时候也经常需要做一些清理工作。（daemon的发音为”day-mon”,这是系统编程传统的遗留，系统守护进程是一个持续运行的进程，比如打印机队列管理，它总是在系统中运行。）</code></pre><h2 id="启动线程的方式和isAlive方法"><a href="#启动线程的方式和isAlive方法" class="headerlink" title="启动线程的方式和isAlive方法"></a>启动线程的方式和isAlive方法</h2><p>启动线程<br>调用start方法会触发Thread实例以一个新的线程启动其run方法。新线程不会持有调用线程的任何同步锁。</p><p>当一个线程正常地运行结束或者抛出某种未检测的异常（比如，运行时异常(RuntimeException)，错误(ERROR) 或者其子类）线程就会终止。</p><p><strong>当线程终止之后，是不能被重新启动的。在同一个Thread上调用多次start方法会抛出InvalidThreadStateException异常。</strong></p><p>如果线程已经启动但是还没有终止，那么调用isAlive方法就会返回true.即使线程由于某些原因处于阻塞(Blocked)状态该方法依然返回true。</p><p>如果线程已经被取消(cancelled),那么调用其isAlive在什么时候返回false就因各Java虚拟机的实现而异了。没有方法可以得知一个处于非活动状态的线程是否已经被启动过了。</p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p><strong>Java的线程实现基本上都是内核级线程的实现，所以Java线程的具体执行还取决于操作系统的特性。</strong></p><p>Java虚拟机为了实现跨平台(不同的硬件平台和各种操作系统)的特性，Java语言在线程调度与调度公平性上未作出任何的承诺，甚至都不会严格保证线程会被执行。但是Java线程却支持优先级的方法，这些方法会影响线程的调度：</p><p>每个线程都有一个优先级，分布在Thread.MIN_PRIORITY和Thread.MAX_PRIORITY之间（分别为1和10）<br>默认情况下，新创建的线程都拥有和创建它的线程相同的优先级。main方法所关联的初始化线程拥有一个默认的优先级，这个优先级是Thread.NORM_PRIORITY (5).</p><p>线程的当前优先级可以通过getPriority方法获得。<br>线程的优先级可以通过setPriority方法来动态的修改，一个线程的最高优先级由其所在的线程组限定。</p><h2 id="线程的控制方法"><a href="#线程的控制方法" class="headerlink" title="线程的控制方法"></a>线程的控制方法</h2><p>只有很少几个方法可以用于跨线程交流：</p><pre><code>每个线程都有一个相关的Boolean类型的中断标识。在线程t上调用t.interrupt会将该线程的中断标识设为true，除非线程t正处于Object.wait,Thread.sleep,或者Thread.join,这些情况下interrupt调用会导致t上的这些操作抛出InterruptedException异常，但是t的中断标识会被设为false。任何一个线程的中断状态都可以通过调用isInterrupted方法来得到。如果线程已经通过interrupt方法被中断，这个方法将会返回true。但是如果调用了Thread.interrupted方法且中断标识还没有被重置，或者是线程处于wait，sleep，join过程中，调用isInterrupted方法将会抛出InterruptedException异常。调用t.join()方法将会暂停执行调用线程，直到线程t执行完毕：当t.isAlive()方法返回false的时候调用t.join()将会直接返回(return)。另一个带参数毫秒(millisecond)的join方法在被调用时，如果线程没能够在指定的时间内完成，调用线程将重新得到控制权。因为isAlive方法的实现原理，所以在一个还没有启动的线程上调用join方法是没有任何意义的。同样的，试图在一个还没有创建的线程上调用join方法也是不明智的。起初，Thread类还支持一些另外一些控制方法：suspend,resume,stop以及destroy。这几个方法已经被声明过期。其中destroy方法从来没有被实现，估计以后也不会。而通过使用等待/唤醒机制增加suspend和resume方法在安全性和可靠性的效果有所欠缺</code></pre><h2 id="Thread的静态方法"><a href="#Thread的静态方法" class="headerlink" title="Thread的静态方法"></a>Thread的静态方法</h2><pre><code>静态方法Thread类中的部分方法被设计为只适用于当前正在运行的线程（即调用Thread方法的线程）。为强调这点，这些方法都被声明为静态的。Thread.currentThread方法会返回当前线程的引用，得到这个引用可以用来调用其他的非静态方法，比如Thread.currentThread().getPriority()会返回调用线程的优先级。Thread.interrupted方法会清除当前线程的中断状态并返回前一个状态。（一个线程的中断状态是不允许被其他线程清除的）Thread.sleep(long msecs)方法会使得当前线程暂停执行至少msecs毫秒。Thread.yield方法纯粹只是建议Java虚拟机对其他已经处于就绪状态的线程（如果有的话）调度执行，而不是当前线程。最终Java虚拟机如何去实现这种行为就完全看其喜好了。</code></pre><h2 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h2><pre><code>每一个线程都是一个线程组中的成员。默认情况下，新建线程和创建它的线程属于同一个线程组。线程组是以树状分布的。当创建一个新的线程组，这个线程组成为当前线程组的子组。getThreadGroup方法会返回当前线程所属的线程组，对应地，ThreadGroup类也有方法可以得到哪些线程目前属于这个线程组，比如enumerate方法。ThreadGroup类存在的一个目的是支持安全策略来动态的限制对该组的线程操作。比如对不属于同一组的线程调用interrupt是不合法的。这是为避免某些问题(比如，一个applet线程尝试杀掉主屏幕的刷新线程)所采取的措施。ThreadGroup也可以为该组所有线程设置一个最大的线程优先级。线程组往往不会直接在程序中被使用。在大多数的应用中，如果仅仅是为在程序中跟踪线程对象的分组，那么普通的集合类（比如java.util.Vector）应是更好的选择。</code></pre><h2 id="多线程的实现"><a href="#多线程的实现" class="headerlink" title="多线程的实现"></a>多线程的实现</h2><pre><code>public class 多线程实例 {    //继承thread    @Test    public void test1() {        class A extends Thread {            @Override            public void run() {                System.out.println(&quot;A run&quot;);            }        }        A a = new A();        a.start();    }    //实现Runnable    @Test    public void test2() {        class B implements Runnable {            @Override            public void run() {                System.out.println(&quot;B run&quot;);            }        }        B b = new B();        //Runable实现类需要由Thread类包装后才能执行        new Thread(b).start();    }    //有返回值的线程    @Test    public void test3() {        Callable callable = new Callable() {            int sum = 0;            @Override            public Object call() throws Exception {                for (int i = 0;i &lt; 5;i ++) {                    sum += i;                }                return sum;            }        };        //这里要用FutureTask，否则不能加入Thread构造方法        FutureTask futureTask = new FutureTask(callable);        new Thread(futureTask).start();        try {            System.out.println(futureTask.get());        } catch (InterruptedException e) {            e.printStackTrace();        } catch (ExecutionException e) {            e.printStackTrace();        }    }    //线程池实现    @Test    public void test4() {        ExecutorService executorService = Executors.newFixedThreadPool(5);        //execute直接执行线程        executorService.execute(new Thread());        executorService.execute(new Runnable() {            @Override            public void run() {                System.out.println(&quot;runnable&quot;);            }        });        //submit提交有返回结果的任务，运行完后返回结果。        Future future = executorService.submit(new Callable&lt;String&gt;() {            @Override            public String call() throws Exception {                return &quot;a&quot;;            }        });        try {            System.out.println(future.get());        } catch (InterruptedException e) {            e.printStackTrace();        } catch (ExecutionException e) {            e.printStackTrace();        }        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();        //有返回值的线程组将返回值存进集合        for (int i = 0;i &lt; 5;i ++ ) {            int finalI = i;            Future future1 = executorService.submit(new Callable&lt;String&gt;() {                @Override                public String call() throws Exception {                    return &quot;res&quot; + finalI;                }            });            try {                list.add((String) future1.get());            } catch (InterruptedException e) {                e.printStackTrace();            } catch (ExecutionException e) {                e.printStackTrace();            }        }        for (String s : list) {            System.out.println(s);        }    }}</code></pre><h2 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h2><pre><code>public class 线程的状态转换 {//一开始线程是init状态，结束时是terminated状态class t implements Runnable {    private String name;    public t(String name) {        this.name = name;    }    @Override    public void run() {        System.out.println(name + &quot;run&quot;);    }}//测试join，父线程在子线程运行时进入waiting状态@Testpublic void test1() throws InterruptedException {    Thread dad = new Thread(new Runnable() {        Thread son = new Thread(new t(&quot;son&quot;));        @Override        public void run() {            System.out.println(&quot;dad init&quot;);            son.start();            try {                //保证子线程运行完再运行父线程                son.join();                System.out.println(&quot;dad run&quot;);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    });    //调用start，线程进入runnable状态，等待系统调度    dad.start();    //在父线程中对子线程实例使用join，保证子线程在父线程之前执行完}//测试sleep@Testpublic void test2(){    Thread t1 = new Thread(new Runnable() {        @Override        public void run() {            System.out.println(&quot;t1 run&quot;);            try {                Thread.sleep(3000);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    });    //主线程休眠。进入time waiting状态    try {        Thread.sleep(3000);    } catch (InterruptedException e) {        e.printStackTrace();    }    t1.start();}//线程2进入blocked状态。public static void main(String[] args) {    test4();    Thread.yield();//进入runnable状态}//测试blocked状态public static void test4() {    class A {        //线程1获得实例锁以后线程2无法获得实例锁，所以进入blocked状态        synchronized void run() {            while (true) {                System.out.println(&quot;run&quot;);            }        }    }    A a = new A();    new Thread(new Runnable() {        @Override        public void run() {            System.out.println(&quot;t1 get lock&quot;);            a.run();        }    }).start();    new Thread(new Runnable() {        @Override        public void run() {            System.out.println(&quot;t2 get lock&quot;);            a.run();        }    }).start();}//volatile保证线程可见性volatile static int flag = 1;//object作为锁对象，用于线程使用wait和notify方法volatile static Object o = new Object();//测试wait和notify//wait后进入waiting状态，被notify进入blocked（阻塞等待锁释放）或者runnable状态（获取到锁）public void test5() {    new Thread(new Runnable() {        @Override        public void run() {            //wait和notify只能在同步代码块内使用            synchronized (o) {                while (true) {                    if (flag == 0) {                        try {                            Thread.sleep(2000);                            System.out.println(&quot;thread1 wait&quot;);                            //释放锁，线程挂起进入object的等待队列，后续代码运行                            o.wait();                        } catch (InterruptedException e) {                            e.printStackTrace();                        }                    }                    System.out.println(&quot;thread1 run&quot;);                    System.out.println(&quot;notify t2&quot;);                    flag = 0;                    //通知等待队列的一个线程获取锁                    o.notify();                }            }        }    }).start();    //解释同上    new Thread(new Runnable() {        @Override        public void run() {            while (true) {                synchronized (o) {                    if (flag == 1) {                        try {                            Thread.sleep(2000);                            System.out.println(&quot;thread2 wait&quot;);                            o.wait();                        } catch (InterruptedException e) {                            e.printStackTrace();                        }                    }                    System.out.println(&quot;thread2 run&quot;);                    System.out.println(&quot;notify t1&quot;);                    flag = 1;                    o.notify();                }            }        }    }).start();}//输出结果是//    thread1 run//    notify t2//    thread1 wait//    thread2 run//    notify t1//    thread2 wait//    thread1 run//    notify t2//不断循环}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了Java多线程的基本概念，使用方法，以及底层实现原理。帮助你更好地使用Java的多线程。&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点一下星哈谢谢。&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/05/04/javase16&quot;&gt;https://h2pl.github.io/2018/05/04/javase16&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java基础" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java核心技术学习总结</title>
    <link href="http://h2pl.github.io/2018/05/02/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    <id>http://h2pl.github.io/2018/05/02/Java核心技术总结/</id>
    <published>2018-05-02T14:37:47.000Z</published>
    <updated>2018-07-08T15:18:52.201Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是我最近复习Java基础原理过程中写的Java基础学习总结。Java的知识点其实非常多，并且有些知识点比较难以理解，有时候我们自以为理解了某些内容，其实可能只是停留在表面上，没有理解其底层实现原理。</p><p>纸上得来终觉浅，绝知此事要躬行。笔者之前对每部分的内容<br>对做了比较深入的学习以及代码实现，基本上比较全面地讲述了每一个Java基础知识点，当然可能有些遗漏和错误，还请读者指正。</p><a id="more"></a><p><strong>这里先把整体的学习大纲列出来，让大家对知识框架有个基本轮廓，具体每个部分的内容，笔者都对应写了一篇博文来加以讲解和剖析，并且发表在我的个人博客和csdn技术专栏里，下面给出地址</strong></p><p>专栏：深入理解Java原理</p><p><a href="https://blog.csdn.net/column/details/21930.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21930.html</a></p><p>相关代码实现在我的GitHub里：</p><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p><p><strong>喜欢的话麻烦star一下哈</strong></p><p>本系列技术文章首发于我的个人博客：</p><p><a href="https://h2pl.github.io">https://h2pl.github.io</a></p><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：</p><p><a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a></p><h2 id="Java基础学习总结"><a href="#Java基础学习总结" class="headerlink" title="Java基础学习总结"></a>Java基础学习总结</h2><p>每部分内容会重点写一些常见知识点，方便复习和记忆，但是并不是全部内容，详细的内容请参见具体的文章地址。</p><h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h3><pre><code>继承：一般类只能单继承，内部类实现多继承，接口可以多继承封装：访问权限控制public &gt; protected &gt; 包 &gt; private 内部类也是一种封装多态：编译时多态，体现在向上转型和向下转型，通过引用类型判断调用哪个方法（静态分派）。运行时多态，体现在同名函数通过不同参数实现多种方法（动态分派）。</code></pre><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><pre><code>基本类型位数，自动装箱，常量池例如byte类型是1byte也就是8位，可以表示的数字是-128到127，因为还有一个0，加起来一共是256，也就是2的八次方。32位和64位机器的int是4个字节也就是32位，char是1个字节就是8位，float是4个字节，double是8个字节，long是8个字节。所以它们占有字节数是相同的，这样的话两个版本才可以更好地兼容。（应该）基本数据类型的包装类只在数字范围-128到127中用到常量池，会自动拆箱装箱，其余数字范围的包装类则会新建实例</code></pre><h3 id="String及包装类"><a href="#String及包装类" class="headerlink" title="String及包装类"></a>String及包装类</h3><pre><code>String类型是final类型，在堆中分配空间后内存地址不可变。底层是final修饰的char[]数组，数组的内存地址同样不可变。但实际上可以通过修改char[n] = &apos;a&apos;来进行修改，不会改变String实例的内存值，不过在jdk中，用户无法直接获取char[]，也没有方法能操作该数组。所以String类型的不可变实际上也是理论上的不可变。所以我们在分配String对象以后，如果将其 = &quot;abc&quot;，那也只是改变了引用的指向，实际上没有改变原来的对象。StringBuffer和StringBuilder底层是可变的char[]数组，继承父类AbstractStringBuilder的各种成员和方法，实际上的操作都是由父类方法来完成的。</code></pre><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><pre><code>final修饰基本数据类型保证不可变final修饰引用保证引用不能指向别的对象，否则会报错。final修饰类，类的实例分配空间后地址不可变，子类不能重写所有父类方法。因此在cglib动态代理中，不能为一个类的final修饰的函数做代理，因为cglib要将被代理的类设置为父类，然后再生成字节码。final修饰方法，子类不能重写该方法。</code></pre><h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><pre><code>1 抽象类可以有方法实现。抽象类可以有非final成员变量。抽象方法要用abstract修饰。抽象类可以有构造方法，但是只能由子类进行实例化。2 接口可以用extends加多个接口实现多继承。接口只能有public final类型的成员变量。接口只能有抽象方法，不能有方法体、接口不能实例化，但是可以作为引用类型。</code></pre><h3 id="代码块和加载顺序"><a href="#代码块和加载顺序" class="headerlink" title="代码块和加载顺序"></a>代码块和加载顺序</h3><pre><code>假设该类是第一次进行实例化。那么有如下加载顺序静态总是比非静态优先，从早到晚的顺序是：1 静态代码块 和 静态成员变量的顺序根据代码位置前后来决定。2 代码块和成员变量的顺序也根据代码位置来决定3 最后才调用构造方法构造方法</code></pre><h3 id="包、内部类、外部类"><a href="#包、内部类、外部类" class="headerlink" title="包、内部类、外部类"></a>包、内部类、外部类</h3><pre><code>1 Java项目一般从src目录开始有com.*.*.A.java这样的目录结构。这就是包结构。所以一般编译后的结构是跟包结构一模一样的，这样的结构保证了import时能找到正确的class引用包访问权限就是指同包下的类可见。import 一般加上全路径，并且使用.*时只包含当前目录的所有类文件，不包括子目录。2 外部类只有public和default两种修饰，要么全局可访问，要么包内可访问。3 内部类可以有全部访问权限，因为它的概念就是一个成员变量，所以访问权限设置与一般的成员变量相同。非静态内部类是外部类的一个成员变量，只跟外部类的实例有关。静态内部类是独立于外部类存在的一个类，与外部类实例无关，可以通过外部类.内部类直接获取Class类型。</code></pre><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><pre><code>1 异常体系的最上层是Throwable类子类有Error和ExceptionException的子类又有RuntimeException和其他具体的可检查异常。2 Error是jvm完全无法处理的系统错误，只能终止运行。运行时异常指的是编译正确但运行错误的异常，如数组越界异常，一般是人为失误导致的，这种异常不用try catch，而是需要程序员自己检查。可检查异常一般是jvm处理不了的一些异常，但是又经常会发生，比如Ioexception，Sqlexception等，是外部实现带来的异常。3 多线程的异常流程是独立的，互不影响。大型模块的子模块异常一般需要重新封装成外部异常再次抛出，否则只能看到最外层异常信息，难以进行调试。日志框架是异常报告的最好帮手，log4j，slf4j中，在工作中必不可少。</code></pre><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><pre><code>Java中的泛型是伪泛型，只在编译期生效，运行期自动进行泛型擦除，将泛型替换为实际上传入的类型。泛型类用class &lt;T&gt; A {}这样的形式表示，里面的方法和成员变量都可以用T来表示类型。泛型接口也是类似的，不过泛型类实现泛型接口时可以选择注入实际类型或者是继续使用泛型。泛型方法可以自带泛型比如void &lt;E&gt; E go();泛型可以使用?通配符进行泛化 Object&lt;?&gt;可以接受任何类型也可以使用 &lt;? extends Number&gt; &lt;? super Integer&gt;这种方式进行上下边界的限制。</code></pre><h3 id="Class类和Object类"><a href="#Class类和Object类" class="headerlink" title="Class类和Object类"></a>Class类和Object类</h3><pre><code>Java反射的基础是Class类，该类封装所有其他类的类型信息，并且在每个类加载后在堆区生成每个类的一个Class&lt;类名&gt;实例，用于该类的实例化。Java中可以通过多种方式获取Class类型，比如A.class,new A().getClass()方法以及Class.forName(&quot;com.?.?.A&quot;)方法。Object是所有类的父类，有着自己的一些私有方法，以及被所有类继承的9大方法。有人讨论Object和Class类型谁先加载谁后加载，因为每个类都要继承Object，但是又得先被加载到堆区，事实上，这个问题在JVM初始化时就解决了，没必要多想。</code></pre><h3 id="javac和java"><a href="#javac和java" class="headerlink" title="javac和java"></a>javac和java</h3><pre><code>javac 是编译一个java文件的基本命令，通过不同参数可以完成各种配置，比如导入其他类，指定编译路径等。java是执行一个java文件的基本命令，通过参数配置可以以不同方式执行一个java程序或者是一个jar包。javap是一个class文件的反编译程序，可以获取class文件的反编译结果，甚至是jvm执行程序的每一步代码实现。</code></pre><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><pre><code>Java反射包reflection提供对Class，Method，field，constructor等信息的封装类型。通过这些api可以轻易获得一个类的各种信息并且可以进行实例化，方法调用等。类中的private参数可以通过setaccessible方法强制获取。反射的作用可谓是博大精深，JDK动态代理生成代理类的字节码后，首先把这个类通过defineclass定义成一个类，然后用class.for(name)会把该类加载到jvm，之后我们就可以通过，A.class.GetMethod()获取其方法，然后通过invoke调用其方法，在调用这个方法时，实际上会通过被代理类的引用再去调用原方法。</code></pre><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><pre><code>枚举类继承Enum并且每个枚举类的实例都是唯一的。枚举类可以用于封装一组常量，取值从这组常量中取，比如一周的七天，一年的十二个月。枚举类的底层实现其实是语法糖，每个实例可以被转化成内部类。并且使用静态代码块进行初始化，同时保证内部成员变量不可变。</code></pre><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><pre><code>序列化的类要实现serializable接口transient修饰符可以保证某个成员变量不被序列化readObject和writeOject来实现实例的写入和读取。待更新。事实上，一些拥有数组变量的类都会把数组设为transient修饰，这样的话不会对整个数组进行序列化，而是利用专门的方法将有数据的数组范围进行序列化，以便节省空间。</code></pre><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><pre><code>jdk自带的动态代理可以代理一个已经实现接口的类。cglib代理可以代理一个普通的类。动态代理的基本实现原理都是通过字节码框架动态生成字节码，并且在用defineclass加载类后，获取代理类的实例。一般需要实现一个代理处理器，用来处理被代理类的前置操作和后置操作。在JDK动态代理中，这个类叫做invocationHandler。JDK动态代理首先获取被代理类的方法，并且只获取在接口中声明的方法，生成代理类的字节码后，首先把这个类通过defineclass定义成一个类，然后把该类加载到jvm，之后我们就可以通过，A.class.GetMethod()获取其方法，然后通过invoke调用其方法，在调用这个方法时，实际上会通过被代理类的引用再去调用原方法。而对于cglib动态代理，一般会把被代理类设为代理类的父类，然后获取被代理类中所有非final的方法，通过asm字节码框架生成代理类的字节码，这个代理类很神奇，他会保留原来的方法以及代理后的方法，通过方法数组的形式保存。cglib的动态代理需要实现一个enhancer和一个interceptor，在interceptor中配置我们需要的代理内容。如果没有配置interceptor，那么代理类会调用被代理类自己的方法，如果配置了interceptor，则会使用代理类修饰过的方法。</code></pre><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><pre><code>这里先不讲juc包里的多线程类。juc相关内容会在Java并发专题讲解。线程的实现可以通过继承Thread类和实现Runable接口也可以使用线程池。callable配合future可以实现线程中的数据获取。Java中的线程有7种状态，new runable running blocked waiting time_waiting terminateblocked是线程等待其他线程锁释放。waiting是wait以后线程无限等待其他线程使用notify唤醒time_wating是有限时间地等待被唤醒，也可能是sleep固定时间。Thread的join是实例方法，比如a.join(b),则说明a线程要等b线程运行完才会运行。o.wait方法会让持有该对象o的线程释放锁并且进入阻塞状态，notify则是持有o锁对象的线程通知其他等待锁的线程获取锁。notify方法并不会释放锁。注意这两个方法都只能在synchronized同步方法或同步块里使用。synchronized方法底层使用系统调用的mutex锁，开销较大，jvm会为每个锁对象维护一个等待队列，让等待该对象锁的线程在这个队列中等待。当线程获取不到锁时则让线程阻塞，而其他检查notify以后则会通知任意一个线程，所以这个锁时非公平锁。Thread.sleep()，Thread.interrupt()等方法都是类方法，表示当前调用该方法的线程的操作。一个线程实例连续start两次会抛异常,这是因为线程start后会设置标识，如果再次start则判断为错误。</code></pre><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><pre><code>IO流也是Java中比较重要的一块，Java中主要有字节流，字符流，文件等。其中文件也是通过流的方式打开，读取和写入的。IO流的很多接口都使用了装饰者模式，即将原类型通过传入装饰类构造函数的方式，增强原类型，以此获得像带有缓冲区的字节流，或者将字节流封装成字符流等等，其中需要注意的是编码问题，后者打印出来的结果可能是乱码哦。IO流与网络编程息息相关，一个socket接入后，我们可以获取它的输入流和输出流，以获取TCP数据包的内容，并且可以往数据报里写入内容，因为TCP协议也是按照流的方式进行传输的，实际上TCP会将这些数据进行分包处理，并且通过差错检验，超时重传，滑动窗口协议等方式，保证了TCP数据包的高效和可靠传输。</code></pre><h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><pre><code>承接IO流的内容IO流与网络编程息息相关，一个socket接入后，我们可以获取它的输入流和输出流，以获取TCP数据包的内容，并且可以往数据报里写入内容，因为TCP协议也是按照流的方式进行传输的，实际上TCP会将这些数据进行分包处理，并且通过差错检验，超时重传，滑动窗口协议等方式，保证了TCP数据包的高效和可靠传输。除了使用socket来获取TCP数据包外，还可以使用UDP的DatagramPacket来封装UDP数据包，因为UDP数据包的大小是确定的，所以不是使用流方式处理，而是需要事先定义他的长度，源端口和目标端口等信息。为了方便网络编程，Java提供了一系列类型来支持网络编程的api，比如URL类，InetAddress类等。后续文章会带来NIO相关的内容，敬请期待。</code></pre><h3 id="Java8"><a href="#Java8" class="headerlink" title="Java8"></a>Java8</h3><pre><code>接口中的默认方法，接口终于可以有方法实现了，使用注解即可标识出默认方法。lambda表达式实现了函数式编程，通过注解可以声明一个函数式接口，该接口中只能有一个方法，这个方法正是使用lambda表达式时会调用到的接口。Option类实现了非空检验新的日期API各种api的更新，包括chm，hashmap的实现等Stream流概念，实现了集合类的流式访问，可以基于此使用map和reduce并行计算。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是我最近复习Java基础原理过程中写的Java基础学习总结。Java的知识点其实非常多，并且有些知识点比较难以理解，有时候我们自以为理解了某些内容，其实可能只是停留在表面上，没有理解其底层实现原理。&lt;/p&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行。笔者之前对每部分的内容&lt;br&gt;对做了比较深入的学习以及代码实现，基本上比较全面地讲述了每一个Java基础知识点，当然可能有些遗漏和错误，还请读者指正。&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java基础" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="http://h2pl.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java基础15：深入剖析Java枚举类</title>
    <link href="http://h2pl.github.io/2018/05/02/javase15/"/>
    <id>http://h2pl.github.io/2018/05/02/javase15/</id>
    <published>2018-05-02T13:04:04.000Z</published>
    <updated>2018-06-01T03:50:55.382Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了枚举类的基本概念，使用方法，以及底层实现原理。帮助你更好地使用枚举类并且理解枚举类的内部实现细节。</p><p>具体代码在我的GitHub中可以找到</p><blockquote><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p></blockquote><p>喜欢的话麻烦点一下星哈谢谢。</p><p>文章首发于我的个人博客：</p><blockquote><p><a href="https://h2pl.github.io/2018/05/02/javase15">https://h2pl.github.io/2018/05/02/javase15</a></p></blockquote><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：</p><blockquote><p><a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a></p></blockquote><a id="more"></a><p>枚举（enum）类型是Java 5新增的特性，它是一种新的类型，允许用常量来表示特定的数据片断，而且全部都以类型安全的形式来表示。</p><h2 id="初探枚举类"><a href="#初探枚举类" class="headerlink" title="初探枚举类"></a>初探枚举类</h2><blockquote><p> 在程序设计中，有时会用到由若干个有限数据元素组成的集合，如一周内的星期一到星期日七个数据元素组成的集合，由三种颜色红、黄、绿组成的集合，一个工作班组内十个职工组成的集合等等，程序中某个变量取值仅限于集合中的元素。此时，可将这些数据集合定义为枚举类型。</p></blockquote><blockquote><p>因此，枚举类型是某类数据可能取值的集合，如一周内星期可能取值的集合为：<br>　　{ Sun,Mon,Tue,Wed,Thu,Fri,Sat}<br>　　该集合可定义为描述星期的枚举类型，该枚举类型共有七个元素，因而用枚举类型定义的枚举变量只能取集合中的某一元素值。由于枚举类型是导出数据类型，因此，必须先定义枚举类型，然后再用枚举类型定义枚举型变量。　</p></blockquote><pre><code>enum &lt;枚举类型名&gt; 　　{ &lt;枚举元素表&gt; };　　　　其中：关键词enum表示定义的是枚举类型，枚举类型名由标识符组成，而枚举元素表由枚举元素或枚举常量组成。例如： 　　enum weekdays 　　{ Sun,Mon,Tue,Wed,Thu,Fri,Sat };　　定义了一个名为 weekdays的枚举类型，它包含七个元素：Sun、Mon、Tue、Wed、Thu、Fri、Sat。　　</code></pre><blockquote><p>在编译器编译程序时，给枚举类型中的每一个元素指定一个整型常量值(也称为序号值)。若枚举类型定义中没有指定元素的整型常量值，则整型常量值从0开始依次递增，因此，weekdays枚举类型的七个元素Sun、Mon、Tue、Wed、Thu、Fri、Sat对应的整型常量值分别为0、1、2、3、4、5、6。<br>　　注意：在定义枚举类型时，也可指定元素对应的整型常量值。</p></blockquote><pre><code>例如，描述逻辑值集合{TRUE、FALSE}的枚举类型boolean可定义如下：enum boolean 　　{ TRUE=1 ,FALSE=0 };该定义规定：TRUE的值为1，而FALSE的值为0。　　而描述颜色集合{red,blue,green,black,white,yellow}的枚举类型colors可定义如下：enum colors 　　{red=5,blue=1,green,black,white,yellow};　　该定义规定red为5 ，blue为1，其后元素值从2 开始递增加1。green、black、white、yellow的值依次为2、3、4、5。　　</code></pre><p>　　此时，整数5将用于表示二种颜色red与yellow。通常两个不同元素取相同的整数值是没有意义的。枚举类型的定义只是定义了一个新的数据类型，只有用枚举类型定义枚举变量才能使用这种数据类型。 </p><h2 id="枚举类-语法"><a href="#枚举类-语法" class="headerlink" title="枚举类-语法"></a>枚举类-语法</h2><blockquote><p>enum 与 class、interface 具有相同地位；<br>可以继承多个接口；<br>可以拥有构造器、成员方法、成员变量；<br>1.2 枚举类与普通类不同之处</p><p>默认继承 java.lang.Enum 类，所以不能继承其他父类；其中 java.lang.Enum 类实现了 java.lang.Serializable 和 java.lang.Comparable 接口；</p></blockquote><blockquote><p>使用 enum 定义，默认使用 final 修饰，因此不能派生子类；</p></blockquote><blockquote><p>构造器默认使用 private 修饰，且只能使用 private 修饰；</p></blockquote><blockquote><p>枚举类所有实例必须在第一行给出，默认添加 public static final 修饰，否则无法产生实例；</p></blockquote><h2 id="枚举类的具体使用"><a href="#枚举类的具体使用" class="headerlink" title="枚举类的具体使用"></a>枚举类的具体使用</h2><p>这部分内容参考<a href="https://blog.csdn.net/qq_27093465/article/details/52180865" target="_blank" rel="noopener">https://blog.csdn.net/qq_27093465/article/details/52180865</a></p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><pre><code>public class 常量 {}enum Color {    Red, Green, Blue, Yellow}</code></pre><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>JDK1.6之前的switch语句只支持int,char,enum类型，使用枚举，能让我们的代码可读性更强。</p><pre><code>public static void showColor(Color color) {        switch (color) {            case Red:                System.out.println(color);                break;            case Blue:                System.out.println(color);                break;            case Yellow:                System.out.println(color);                break;            case Green:                System.out.println(color);                break;        }    }</code></pre><h3 id="向枚举中添加新方法"><a href="#向枚举中添加新方法" class="headerlink" title="向枚举中添加新方法"></a>向枚举中添加新方法</h3><p>如果打算自定义自己的方法，那么必须在enum实例序列的最后添加一个分号。而且 Java 要求必须先定义 enum 实例。</p><pre><code>enum Color {    //每个颜色都是枚举类的一个实例，并且构造方法要和枚举类的格式相符合。    //如果实例后面有其他内容，实例序列结束时要加分号。    Red(&quot;红色&quot;, 1), Green(&quot;绿色&quot;, 2), Blue(&quot;蓝色&quot;, 3), Yellow(&quot;黄色&quot;, 4);    String name;    int index;    Color(String name, int index) {        this.name = name;        this.index = index;    }    public void showAllColors() {        //values是Color实例的数组，在通过index和name可以获取对应的值。        for (Color color : Color.values()) {            System.out.println(color.index + &quot;:&quot; + color.name);        }    }}</code></pre><h3 id="覆盖枚举的方法"><a href="#覆盖枚举的方法" class="headerlink" title="覆盖枚举的方法"></a>覆盖枚举的方法</h3><p>所有枚举类都继承自Enum类，所以可以重写该类的方法<br>下面给出一个toString()方法覆盖的例子。 </p><pre><code>@Overridepublic String toString() {    return this.index + &quot;:&quot; + this.name;}</code></pre><h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>所有的枚举都继承自java.lang.Enum类。由于Java 不支持多继承，所以枚举对象不能再继承其他类。</p><pre><code>enum Color implements Print{    @Override    public void print() {        System.out.println(this.name);    }}</code></pre><h3 id="使用接口组织枚举"><a href="#使用接口组织枚举" class="headerlink" title="使用接口组织枚举"></a>使用接口组织枚举</h3><p> 搞个实现接口，来组织枚举，简单讲，就是分类吧。如果大量使用枚举的话，这么干，在写代码的时候，就很方便调用啦。  </p><pre><code>public class 用接口组织枚举 {    public static void main(String[] args) {        Food cf = chineseFood.dumpling;        Food jf = Food.JapaneseFood.fishpiece;        for (Food food : chineseFood.values()) {            System.out.println(food);        }        for (Food food : Food.JapaneseFood.values()) {            System.out.println(food);        }    }}interface Food {    enum JapaneseFood implements Food {        suse, fishpiece    }}enum chineseFood implements Food {    dumpling, tofu}</code></pre><h3 id="枚举类集合"><a href="#枚举类集合" class="headerlink" title="枚举类集合"></a>枚举类集合</h3><p>java.util.EnumSet和java.util.EnumMap是两个枚举集合。EnumSet保证集合中的元素不重复；EnumMap中的 key是enum类型，而value则可以是任意类型。</p><p>EnumSet在JDK中没有找到实现类，这里写一个EnumMap的例子</p><pre><code>public class 枚举类集合 {    public static void main(String[] args) {        EnumMap&lt;Color, String&gt; map = new EnumMap&lt;Color, String&gt;(Color.class);        map.put(Color.Blue, &quot;Blue&quot;);        map.put(Color.Yellow, &quot;Yellow&quot;);        map.put(Color.Red, &quot;Red&quot;);        System.out.println(map.get(Color.Red));    }}</code></pre><h2 id="使用枚举类的注意事项"><a href="#使用枚举类的注意事项" class="headerlink" title="使用枚举类的注意事项"></a>使用枚举类的注意事项</h2><p><img src="https://img-blog.csdn.net/20170112172420090" alt="image"></p><p>枚举类型对象之间的值比较，是可以使用==，直接来比较值，是否相等的，不是必须使用equals方法的哟。</p><p>因为枚举类Enum已经重写了equals方法</p><pre><code>/** * Returns true if the specified object is equal to this * enum constant. * * @param other the object to be compared for equality with this object. * @return  true if the specified object is equal to this *          enum constant. */public final boolean equals(Object other) {    return this==other;}</code></pre><h2 id="枚举类的底层原理"><a href="#枚举类的底层原理" class="headerlink" title="枚举类的底层原理"></a>枚举类的底层原理</h2><p>这部分参考<a href="https://blog.csdn.net/mhmyqn/article/details/48087247" target="_blank" rel="noopener">https://blog.csdn.net/mhmyqn/article/details/48087247</a></p><blockquote><p>Java从JDK1.5开始支持枚举，也就是说，Java一开始是不支持枚举的，就像泛型一样，都是JDK1.5才加入的新特性。通常一个特性如果在一开始没有提供，在语言发展后期才添加，会遇到一个问题，就是向后兼容性的问题。</p><p>像Java在1.5中引入的很多特性，为了向后兼容，编译器会帮我们写的源代码做很多事情，比如泛型为什么会擦除类型，为什么会生成桥接方法，foreach迭代，自动装箱/拆箱等，这有个术语叫“语法糖”，而编译器的特殊处理叫“解语法糖”。那么像枚举也是在JDK1.5中才引入的，又是怎么实现的呢？</p></blockquote><blockquote><p>Java在1.5中添加了java.lang.Enum抽象类，它是所有枚举类型基类。提供了一些基础属性和基础方法。同时，对把枚举用作Set和Map也提供了支持，即java.util.EnumSet和java.util.EnumMap。</p></blockquote><p>接下来定义一个简单的枚举类</p><pre><code>public enum Day {    MONDAY {        @Override        void say() {            System.out.println(&quot;MONDAY&quot;);        }    }    , TUESDAY {        @Override        void say() {            System.out.println(&quot;TUESDAY&quot;);        }    }, FRIDAY(&quot;work&quot;){        @Override        void say() {            System.out.println(&quot;FRIDAY&quot;);        }    }, SUNDAY(&quot;free&quot;){        @Override        void say() {            System.out.println(&quot;SUNDAY&quot;);        }    };    String work;    //没有构造参数时，每个实例可以看做常量。    //使用构造参数时，每个实例都会变得不一样，可以看做不同的类型，所以编译后会生成实例个数对应的class。    private Day(String work) {        this.work = work;    }    private Day() {    }    //枚举实例必须实现枚举类中的抽象方法    abstract void say ();}</code></pre><p>反编译结果</p><pre><code>D:\MyTech\out\production\MyTech\com\javase\枚举类&gt;javap Day.classCompiled from &quot;Day.java&quot;public abstract class com.javase.枚举类.Day extends java.lang.Enum&lt;com.javase.枚举类.Day&gt; {  public static final com.javase.枚举类.Day MONDAY;  public static final com.javase.枚举类.Day TUESDAY;  public static final com.javase.枚举类.Day FRIDAY;  public static final com.javase.枚举类.Day SUNDAY;  java.lang.String work;  public static com.javase.枚举类.Day[] values();  public static com.javase.枚举类.Day valueOf(java.lang.String);  abstract void say();  com.javase.枚举类.Day(java.lang.String, int, com.javase.枚举类.Day$1);  com.javase.枚举类.Day(java.lang.String, int, java.lang.String, com.javase.枚举类.Day$1);  static {};}</code></pre><blockquote><p>可以看到，一个枚举在经过编译器编译过后，变成了一个抽象类，它继承了java.lang.Enum；而枚举中定义的枚举常量，变成了相应的public static final属性，而且其类型就抽象类的类型，名字就是枚举常量的名字.</p><p>同时我们可以在Operator.class的相同路径下看到四个内部类的.class文件com/mikan/Day$1.class、com/mikan/Day$2.class、com/mikan/Day$3.class、com/mikan/Day$4.class，也就是说这四个命名字段分别使用了内部类来实现的；同时添加了两个方法values()和valueOf(String)；我们定义的构造方法本来只有一个参数，但却变成了三个参数；同时还生成了一个静态代码块。这些具体的内容接下来仔细看看。</p></blockquote><p>下面分析一下字节码中的各部分，其中：</p><pre><code>InnerClasses:     static #23; //class com/javase/枚举类/Day$4     static #18; //class com/javase/枚举类/Day$3     static #14; //class com/javase/枚举类/Day$2     static #10; //class com/javase/枚举类/Day$1</code></pre><p>从中可以看到它有4个内部类，这四个内部类的详细信息后面会分析。</p><pre><code>static {};    descriptor: ()V    flags: ACC_STATIC    Code:      stack=5, locals=0, args_size=0         0: new           #10                 // class com/javase/枚举类/Day$1         3: dup         4: ldc           #11                 // String MONDAY         6: iconst_0         7: invokespecial #12                 // Method com/javase/枚举类/Day$1.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V        10: putstatic     #13                 // Field MONDAY:Lcom/javase/枚举类/Day;        13: new           #14                 // class com/javase/枚举类/Day$2        16: dup        17: ldc           #15                 // String TUESDAY        19: iconst_1        20: invokespecial #16                 // Method com/javase/枚举类/Day$2.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V        //后面类似，这里省略}</code></pre><p>其实编译器生成的这个静态代码块做了如下工作：分别设置生成的四个公共静态常量字段的值，同时编译器还生成了一个静态字段$VALUES，保存的是枚举类型定义的所有枚举常量<br>编译器添加的values方法：</p><pre><code>public static com.javase.Day[] values();    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=1, locals=0, args_size=0         0: getstatic     #2                  // Field $VALUES:[Lcom/javase/Day;         3: invokevirtual #3                  // Method &quot;[Lcom/mikan/Day;&quot;.clone:()Ljava/lang/Object;         6: checkcast     #4                  // class &quot;[Lcom/javase/Day;&quot;         9: areturn  这个方法是一个公共的静态方法，所以我们可以直接调用该方法（Day.values()）,返回这个枚举值的数组，另外，这个方法的实现是，克隆在静态代码块中初始化的$VALUES字段的值，并把类型强转成Day[]类型返回。</code></pre><p>造方法为什么增加了两个参数？</p><p>有一个问题，构造方法我们明明只定义了一个参数，为什么生成的构造方法是三个参数呢？</p><pre><code>从Enum类中我们可以看到，为每个枚举都定义了两个属性，name和ordinal，name表示我们定义的枚举常量的名称，如FRIDAY、TUESDAY，而ordinal是一个顺序号，根据定义的顺序分别赋予一个整形值，从0开始。在枚举常量初始化时，会自动为初始化这两个字段，设置相应的值，所以才在构造方法中添加了两个参数。即：另外三个枚举常量生成的内部类基本上差不多，这里就不重复说明了。</code></pre><blockquote><p>我们可以从Enum类的代码中看到，定义的name和ordinal属性都是final的，而且大部分方法也都是final的，特别是clone、readObject、writeObject这三个方法，这三个方法和枚举通过静态代码块来进行初始化一起。</p></blockquote><blockquote><p>它保证了枚举类型的不可变性，不能通过克隆，不能通过序列化和反序列化来复制枚举，这能保证一个枚举常量只是一个实例，即是单例的，所以在effective java中推荐使用枚举来实现单例。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>枚举本质上是通过普通的类来实现的，只是编译器为我们进行了处理。<strong>每个枚举类型都继承自java.lang.Enum，并自动添加了values和valueOf方法。</strong></p><p>而每个枚举常量是一个静态常量字段，<strong>使用内部类实现</strong>，该内部类继承了枚举类。<strong>所有枚举常量都通过静态代码块来进行初始化，即在类加载期间就初始化</strong>。</p><p>另外通过把clone、readObject、writeObject这三个方法定义为final的，同时实现是抛出相应的异常。这样保证了每个枚举类型及枚举常量都是不可变的。<strong>可以利用枚举的这两个特性来实现线程安全的单例。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了枚举类的基本概念，使用方法，以及底层实现原理。帮助你更好地使用枚举类并且理解枚举类的内部实现细节。&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点一下星哈谢谢。&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/05/02/javase15&quot;&gt;https://h2pl.github.io/2018/05/02/javase15&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java基础" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java枚举类" scheme="http://h2pl.github.io/tags/Java%E6%9E%9A%E4%B8%BE%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java基础14：离开IDE，使用java和javac构建项目</title>
    <link href="http://h2pl.github.io/2018/05/01/javase14/"/>
    <id>http://h2pl.github.io/2018/05/01/javase14/</id>
    <published>2018-05-01T14:27:46.000Z</published>
    <updated>2018-06-01T03:50:49.445Z</updated>
    
    <content type="html"><![CDATA[<p>前言：本文教你怎么用javac和java命令，讲解了classpath的原理，以及如何利用脚本（shell或bat）进行项目部署，离开ide，还原最本质的Java编译运行过程，并用简单的实例展示这些用法。 </p><p>具体代码在我的GitHub中可以找到</p><blockquote><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p></blockquote><p>文章首发于我的个人博客：</p><blockquote><p><a href="https://h2pl.github.io/2018/05/01/javase14">https://h2pl.github.io/2018/05/01/javase14</a></p></blockquote><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：</p><blockquote><p><a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a></p></blockquote><a id="more"></a><blockquote><p>IDE是把双刃剑，它可以什么都帮你做了，你只要敲几行代码，点几下鼠标，程序就跑起来了，用起来相当方便。</p><p>你不用去关心它后面做了些什么，执行了哪些命令，基于什么原理。然而也是这种过分的依赖往往让人散失了最基本的技能，当到了一个没有IDE的地方，你便觉得无从下手，给你个代码都不知道怎么去跑。好比给你瓶水，你不知道怎么打开去喝，然后活活给渴死。</p><p>之前用惯了idea，Java文件编译运行的命令基本忘得一干二净。</p><p>现在项目出了原型，放到服务器上去测试，SSH一登陆上服务器就傻眼了，都是命令行，以前程序图标什么的都成了浮云，程序放上去了不知道怎么去编译运行，只能补补课了，下面做下补课笔记。</p></blockquote><h2 id="javac命令初窥"><a href="#javac命令初窥" class="headerlink" title="javac命令初窥"></a>javac命令初窥</h2><p>注：以下红色标记的参数在下文中有所讲解。</p><p>本部分参考<a href="https://www.cnblogs.com/xiazdong/p/3216220.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiazdong/p/3216220.html</a></p><p>用法: javac <options> <source files=""></options></p><p>其中, 可能的选项包括:</p><blockquote><p>  -g                         生成所有调试信息</p><p>  -g:none                    不生成任何调试信息</p><p>  -g:{lines,vars,source}     只生成某些调试信息</p><p>  -nowarn                    不生成任何警告</p><p>  -verbose                   输出有关编译器正在执行的操作的消息</p><p>  -deprecation               输出使用已过时的 API 的源位置</p><p>  -classpath &lt;路径&gt;            指定查找用户类文件和注释处理程序的位置</p><p>  -cp &lt;路径&gt;                   指定查找用户类文件和注释处理程序的位置</p><p>  -sourcepath &lt;路径&gt;           指定查找输入源文件的位置</p><p>  -bootclasspath &lt;路径&gt;        覆盖引导类文件的位置</p><p>  -extdirs &lt;目录&gt;              覆盖所安装扩展的位置</p><p>  -endorseddirs &lt;目录&gt;         覆盖签名的标准路径的位置</p><p>  -proc:{none,only}          控制是否执行注释处理和/或编译。</p><p>  -processor <class1>[,<class2>,<class3>…] 要运行的注释处理程序的名称; 绕过默认的搜索进程</class3></class2></class1></p><p>  -processorpath &lt;路径&gt;        指定查找注释处理程序的位置</p><p>  -d &lt;目录&gt;                    指定放置生成的类文件的位置</p><p>  -s &lt;目录&gt;                    指定放置生成的源文件的位置</p><p>  -implicit:{none,class}     指定是否为隐式引用文件生成类文件</p><p>  -encoding &lt;编码&gt;             指定源文件使用的字符编码</p><p>  -source &lt;发行版&gt;              提供与指定发行版的源兼容性</p><p>  -target &lt;发行版&gt;              生成特定 VM 版本的类文件</p><p>  -version                   版本信息</p><p>  -help                      输出标准选项的提要</p><p>  -A关键字[=值]                  传递给注释处理程序的选项</p><p>  -X                         输出非标准选项的提要</p><p>  -J&lt;标记&gt;                     直接将 &lt;标记&gt; 传递给运行时系统</p><p>  -Werror                    出现警告时终止编译</p><p>  @&lt;文件名&gt;                     从文件读取选项和文件名</p></blockquote><p>在详细介绍javac命令之前，先看看这个classpath是什么</p><h2 id="classpath是什么"><a href="#classpath是什么" class="headerlink" title="classpath是什么"></a>classpath是什么</h2><p>在dos下编译java程序，就要用到classpath这个概念，尤其是在没有设置环境变量的时候。classpath就是存放.class等编译后文件的路径。</p><p>javac：如果当前你要编译的java文件中引用了其它的类(比如说：继承)，但该引用类的.class文件不在当前目录下，这种情况下就需要在javac命令后面加上-classpath参数，通过使用以下三种类型的方法 来指导编译器在编译的时候去指定的路径下查找引用类。</p><blockquote><p>(1).绝对路径：javac -classpath c:/junit3.8.1/junit.jar   Xxx.java</p><p>(2).相对路径：javac -classpath ../junit3.8.1/Junit.javr  Xxx.java</p><p>(3).系统变量：javac -classpath %CLASSPATH% Xxx.java (注意：%CLASSPATH%表示使用系统变量CLASSPATH的值进行查找，这里假设Junit.jar的路径就包含在CLASSPATH系统变量中)</p></blockquote><h2 id="IDE中的classpath"><a href="#IDE中的classpath" class="headerlink" title="IDE中的classpath"></a>IDE中的classpath</h2><p>对于一个普通的Javaweb项目，一般有这样的配置：</p><blockquote><p>1 WEB-INF/classes,lib才是classpath，WEB-INF/ 是资源目录, 客户端不能直接访问。</p><p>2、WEB-INF/classes目录存放src目录java文件编译之后的class文件，xml、properties等资源配置文件，这是一个定位资源的入口。</p><p>3、引用classpath路径下的文件，只需在文件名前加classpath:</p><p><param-value>classpath:applicationContext-*.xml</param-value><br><!-- 引用其子目录下的文件,如 --></p><p><param-value>classpath:context/conf/controller.xml</param-value></p><p>4、lib和classes同属classpath，两者的访问优先级为: lib&gt;classes。</p><p>5、classpath 和 classpath* 区别：</p><p>classpath：只会到你的class路径中查找找文件;<br>classpath*：不仅包含class路径，还包括jar文件中(class路径)进行查找。</p></blockquote><p>总结：</p><p>(1).何时需要使用-classpath：当你要编译或执行的类引用了其它的类，但被引用类的.class文件不在当前目录下时，就需要通过-classpath来引入类</p><p>(2).何时需要指定路径：当你要编译的类所在的目录和你执行javac命令的目录不是同一个目录时，就需要指定源文件的路径(CLASSPATH是用来指定.class路径的，不是用来指定.java文件的路径的) </p><h2 id="Java项目和Java-web项目的本质区别"><a href="#Java项目和Java-web项目的本质区别" class="headerlink" title="Java项目和Java web项目的本质区别"></a>Java项目和Java web项目的本质区别</h2><p>（看清IDE及classpath本质）</p><blockquote><p>现在只是说说Java Project和Web Project，那么二者有区别么？回答：没有！都是Java语言的应用，只是应用场合不同罢了，那么他们的本质到底是什么？</p></blockquote><blockquote><p>回答：编译后路径！虚拟机执行的是class文件而不是java文件，那么我们不管是何种项目都是写的java文件，怎么就不一样了呢？分成java和web两种了呢？</p></blockquote><blockquote><p>从.classpath文件入手来看，这个文件在每个项目目录下都是存在的，很少有人打开看吧，那么我们就来一起看吧。这是一个XML文件，使用文本编辑器打开即可。</p></blockquote><p>这里展示一个web项目的.classpath</p><p>Xml代码</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;classpath&gt;&lt;classpathentry kind=&quot;src&quot; path=&quot;src&quot;/&gt;&lt;classpathentry kind=&quot;src&quot; path=&quot;resources&quot;/&gt;&lt;classpathentry kind=&quot;src&quot; path=&quot;test&quot;/&gt;&lt;classpathentry kind=&quot;con&quot; path=&quot;org.eclipse.jdt.launching.JRE_CONTAINER&quot;/&gt;&lt;classpathentry kind=&quot;lib&quot; path=&quot;lib/servlet-api.jar&quot;/&gt;&lt;classpathentry kind=&quot;lib&quot; path=&quot;webapp/WEB-INF/lib/struts2-core-2.1.8.1.jar&quot;/&gt;     ……&lt;classpathentry kind=&quot;output&quot; path=&quot;webapp/WEB-INF/classes&quot;/&gt;&lt;/classpath&gt;</code></pre><blockquote><p>XML文档包含一个根元素，就是classpath，类路径，那么这里面包含了什么信息呢？子元素是classpathentry，kind属性区别了种 类信息，src源码，con你看看后面的path就知道是JRE容器的信息。lib是项目依赖的第三方类库，output是src编译后的位置。</p></blockquote><blockquote><p>既然是web项目，那么就是WEB-INF/classes目录，可能用MyEclipse的同学会说他们那里是WebRoot或者是WebContext而不是webapp，有区别么？回答：完全没有！</p></blockquote><blockquote><p>既然看到了编译路径的本来面目后，还区分什么java项目和web项目么？回答:不区分！普通的java 项目你这样写就行了：<classpathentry kind="output" path="bin">，看看Eclipse是不是这样生成的？这个问题解决了吧。</classpathentry></p></blockquote><blockquote><p>再说说webapp目录命名的问题，这个无所谓啊，web项目是要发布到服务器上的对吧，那么服务器读取的是类文件和页面文件吧，它不管源文件，它也无法去理解源文件。那么webapp目录的命名有何关系呢？只要让服务器找到不就行了。</p></blockquote><h2 id="Javac命令详解"><a href="#Javac命令详解" class="headerlink" title="Javac命令详解"></a>Javac命令详解</h2><h3 id="g、-g-none、-g-lines-vars-source"><a href="#g、-g-none、-g-lines-vars-source" class="headerlink" title="-g、-g:none、-g:{lines,vars,source}"></a>-g、-g:none、-g:{lines,vars,source}</h3><blockquote><p>•-g：在生成的class文件中包含所有调试信息（行号、变量、源文件）<br>•-g:none ：在生成的class文件中不包含任何调试信息。</p><p>这个参数在javac编译中是看不到什么作用的，因为调试信息都在class文件中，而我们看不懂这个class文件。</p><p>为了看出这个参数的作用，我们在eclipse中进行实验。在eclipse中，我们经常做的事就是“debug”，而在debug的时候，我们会<br>•加入“断点”，这个是靠-g:lines起作用，如果不记录行号，则不能加断点。<br>•在“variables”窗口中查看当前的变量，如下图所示，这是靠-g:vars起作用，否则不能查看变量信息。<br>•在多个文件之间来回调用，比如 A.java的main()方法中调用了B.java的fun()函数，而我想看看程序进入fun()后的状态，这是靠-g:source，如果没有这个参数，则不能查看B.java的源代码。</p></blockquote><h3 id="bootclasspath、-extdirs"><a href="#bootclasspath、-extdirs" class="headerlink" title="-bootclasspath、-extdirs"></a>-bootclasspath、-extdirs</h3><blockquote><p>-bootclasspath和-extdirs 几乎不需要用的，因为他是用来改变 “引导类”和“扩展类”。<br>•引导类(组成Java平台的类)：Java\jdk1.7.0_25\jre\lib\rt.jar等，用-bootclasspath设置。<br>•扩展类：Java\jdk1.7.0_25\jre\lib\ext目录中的文件，用-extdirs设置。<br>•用户自定义类：用-classpath设置。</p><p>我们用-verbose编译后出现的“类文件的搜索路径”，就是由上面三个路径组成，如下：</p></blockquote><pre><code>[类文件的搜索路径: C:\Java\jdk1.7.0_25\jre\lib\resources.jar,C:\Java\jdk1.7.0_25\jre\lib\rt.jar,C:\Java\jdk1.7.0_25\jre\lib\sunrsasign.jar,C:\Java\jdk1.7.0_25\jre\lib\jsse.jar,C:\Java\jdk1.7.0_25\jre\lib\jce.jar,C:\Java\jdk1.7.0_25\jre\lib\charsets.jar,C:\Java\jdk1.7.0_25\jre\lib\jfr.jar,C:\Java\jdk1.7.0_25\jre\classes,C:\Java\jdk1.7.0_25\jre\lib\ext\access-bridge-32.jar,C:\Java\jdk1.7.0_25\jre\lib\ext\dnsns.jar,C:\Java\jdk1.7.0_25\jre\lib\ext\jaccess.jar,C:\Java\jdk1.7.0_25\jre\lib\ext\localedata.jar,C:\Java\jdk1.7.0_25\jre\lib\ext\sunec.jar,C:\Java\jdk1.7.0_25\jre\lib\ext\sunjce_provider.jar,C:\Java\jdk1.7.0_25\jre\lib\ext\sunmscapi.jar,C:\Java\jdk1.7.0_25\jre\lib\ext\sunpkcs11.jar,C:\Java\jdk1.7.0_25\jre\lib\ext\zipfs.jar,..\bin]             </code></pre><p>如果利用 -bootclasspath 重新定义： javac -bootclasspath src Xxx.java，则会出现下面错误：</p><p>致命错误: 在类路径或引导类路径中找不到程序包 java.lang</p><h3 id="sourcepath和-classpath（-cp）"><a href="#sourcepath和-classpath（-cp）" class="headerlink" title="-sourcepath和-classpath（-cp）"></a>-sourcepath和-classpath（-cp）</h3><p>•-classpath(-cp)指定你依赖的类的class文件的查找位置。在Linux中，用“:”分隔classpath，而在windows中，用“;”分隔。<br>•-sourcepath指定你依赖的类的java文件的查找位置。</p><p>举个例子，</p><pre><code>public class A{    public static void main(String[] args) {        B b = new B();        b.print();    }}public class B{    public void print()    {        System.out.println(&quot;old&quot;);    }}</code></pre><p>目录结构如下：</p><p>sourcepath          //此处为当前目录</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">|-src</span></span><br><span class="line">　　　　<span class="string">|-com</span></span><br><span class="line">　　　　　　<span class="string">|- B.java</span></span><br><span class="line">　　　　<span class="string">|- A.java</span></span><br><span class="line">　　<span class="string">|-bin</span></span><br><span class="line">　　　　<span class="string">|- B.class               //是 B.java</span></span><br></pre></td></tr></table></figure><p> 编译后的类文件</p><p>如果要编译 A.java，则必须要让编译器找到类B的位置，你可以指定B.class的位置，也可以是B.java的位置，也可以同时都存在。</p><pre><code>javac -classpath bin src/A.java                            //查找到B.classjavac -sourcepath src/com src/A.java                   //查找到B.javajavac -sourcepath src/com -classpath bin src/A.java    //同时查找到B.class和B.java</code></pre><p>如果同时找到了B.class和B.java，则：<br>•如果B.class和B.java内容一致，则遵循B.class。<br>•如果B.class和B.java内容不一致，则遵循B.java，并编译B.java。</p><p>以上规则可以通过 -verbose选项看出。</p><h3 id="d"><a href="#d" class="headerlink" title="-d"></a>-d</h3><p>•d就是 destination，用于指定.class文件的生成目录，在eclipse中，源文件都在src中，编译的class文件都是在bin目录中。</p><p>这里我用来实现一下这个功能，假设项目名称为project，此目录为当前目录，且在src/com目录中有一个Main.java文件。‘</p><pre><code>package com;public class Main{    public static void main(String[] args) {        System.out.println(&quot;Hello&quot;);    }}javac -d bin src/com/Main.java</code></pre><p>上面的语句将Main.class生成在bin/com目录下。</p><h3 id="implicit-none-class"><a href="#implicit-none-class" class="headerlink" title="-implicit:{none,class}"></a>-implicit:{none,class}</h3><p>•如果有文件为A.java（其中有类A），且在类A中使用了类B，类B在B.java中，则编译A.java时，默认会自动编译B.java，且生成B.class。<br>•implicit:none：不自动生成隐式引用的类文件。<br>•implicit:class（默认）：自动生成隐式引用的类文件。</p><pre><code>public class A{    public static void main(String[] args) {        B b = new B();    }}public class B{}如果使用： javac -implicit:none A.java</code></pre><p>则不会生成 B.class。</p><h3 id="source和-target"><a href="#source和-target" class="headerlink" title="-source和-target"></a>-source和-target</h3><p>•-source：使用指定版本的JDK编译，比如：-source 1.4表示用JDK1.4的标准编译，如果在源文件中使用了泛型，则用JDK1.4是不能编译通过的。<br>•-target：指定生成的class文件要运行在哪个JVM版本，以后实际运行的JVM版本必须要高于这个指定的版本。</p><p>javac -source 1.4 Xxx.java</p><p>javac -target 1.4 Xxx.java</p><h2 id="encoding"><a href="#encoding" class="headerlink" title="-encoding"></a>-encoding</h2><p>默认会使用系统环境的编码，比如我们一般用的中文windows就是GBK编码，所以直接javac时会用GBK编码，而Java文件一般要使用utf-8，如果用GBK就会出现乱码。 </p><p>•指定源文件的编码格式，如果源文件是UTF-8编码的，而-encoding GBK，则源文件就变成了乱码（特别是有中文时）。</p><p>javac -encoding UTF-8 Xxx.java</p><h3 id="verbose"><a href="#verbose" class="headerlink" title="-verbose"></a>-verbose</h3><p>输出详细的编译信息，包括：classpath、加载的类文件信息。</p><p>比如，我写了一个最简单的HelloWorld程序，在命令行中输入：</p><p>D:\Java&gt;javac -verbose -encoding UTF-8 HelloWorld01.java</p><p>输出：</p><pre><code>[语法分析开始时间 RegularFileObject[HelloWorld01.java]][语法分析已完成, 用时 21 毫秒][源文件的搜索路径: .,D:\大三下\编译原理\cup\java-cup-11a.jar,E:\java\jflex\lib\J           //-sourcepathFlex.jar][类文件的搜索路径: C:\Java\jdk1.7.0_25\jre\lib\resources.jar,C:\Java\jdk1.7.0_25      //-classpath、-bootclasspath、-extdirs省略............................................[正在加载ZipFileIndexFileObject[C:\Java\jdk1.7.0_25\lib\ct.sym(META-INF/sym/rt.jar/java/lang/Object.class)]][正在加载ZipFileIndexFileObject[C:\Java\jdk1.7.0_25\lib\ct.sym(META-INF/sym/rt.jar/java/lang/String.class)]][正在检查Demo]省略............................................[已写入RegularFileObject[Demo.class]][共 447 毫秒]</code></pre><p>编写一个程序时，比如写了一句：System.out.println(“hello”)，实际上还需要加载：Object、PrintStream、String等类文件，而上面就显示了加载的全部类文件。</p><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p>-J &lt;标记&gt;<br>•传递一些信息给 Java Launcher.</p><pre><code>javac -J-Xms48m   Xxx.java          //set the startup memory to 48M.</code></pre><p>-@&lt;文件名&gt;</p><blockquote><p>如果同时需要编译数量较多的源文件(比如1000个)，一个一个编译是不现实的（当然你可以直接 javac *.java ），比较好的方法是：将你想要编译的源文件名都写在一个文件中（比如sourcefiles.txt），其中每行写一个文件名，如下所示：</p><p>HelloWorld01.java<br>HelloWorld02.java<br>HelloWorld03.java</p></blockquote><p>则使用下面的命令：</p><p>javac @sourcefiles.txt</p><p>编译这三个源文件。</p><h2 id="使用javac构建项目"><a href="#使用javac构建项目" class="headerlink" title="使用javac构建项目"></a>使用javac构建项目</h2><p>这部分参考：<br><a href="https://blog.csdn.net/mingover/article/details/57083176" target="_blank" rel="noopener">https://blog.csdn.net/mingover/article/details/57083176</a></p><p>一个简单的javac编译</p><p>新建两个文件夹,src和 build<br>src/com/yp/test/HelloWorld.java<br>build/</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├─<span class="keyword">build</span></span><br><span class="line"><span class="keyword">└─src</span></span><br><span class="line"><span class="keyword"> </span>   └─com</span><br><span class="line">        └─yp</span><br><span class="line">            └─test</span><br><span class="line">                    HelloWorld.java</span><br></pre></td></tr></table></figure><p>java文件非常简单</p><pre><code>package com.yp.test;public class HelloWorld {    public static void main(String[] args) {        System.out.println(&quot;helloWorld&quot;);    }}</code></pre><p>编译:<br>javac src/com/yp/test/HelloWorld.java -d build</p><p>-d 表示编译到 build文件夹下</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">查看build文件夹</span><br><span class="line">├─build</span><br><span class="line">│  └─com</span><br><span class="line">│      └─yp</span><br><span class="line">│          └─<span class="keyword">test</span></span><br><span class="line">│                  HelloWorld.<span class="keyword">class</span></span><br><span class="line">│</span><br><span class="line">└─src</span><br><span class="line">    └─com</span><br><span class="line">        └─yp</span><br><span class="line">            └─<span class="keyword">test</span></span><br><span class="line">                    HelloWorld.java</span><br></pre></td></tr></table></figure><p>运行文件</p><blockquote><p>E:\codeplace\n_learn\java\javacmd&gt; java com/yp/test/HelloWorld.class<br>错误: 找不到或无法加载主类 build.com.yp.test.HelloWorld.class</p><p>运行时要指定main<br>E:\codeplace\n_learn\java\javacmd\build&gt; java com.yp.test.HelloWorld<br>helloWorld</p></blockquote><p>如果引用到多个其他的类，应该怎么做呢 ？</p><blockquote><p>编译</p><p>E:\codeplace\n_learn\java\javacmd&gt;javac src/com/yp/test/HelloWorld.java -sourcepath src -d build -g<br>1<br>-sourcepath 表示 从指定的源文件目录中找到需要的.java文件并进行编译。<br>也可以用-cp指定编译好的class的路径<br>运行,注意:运行在build目录下</p><p>E:\codeplace\n_learn\java\javacmd\build&gt;java com.yp.test.HelloWorld</p></blockquote><p>怎么打成jar包?</p><blockquote><p>生成:<br>E:\codeplace\n_learn\java\javacmd\build&gt;jar cvf h.jar *<br>运行:<br>E:\codeplace\n_learn\java\javacmd\build&gt;java h.jar<br>错误: 找不到或无法加载主类 h.jar</p></blockquote><blockquote><p>这个错误是没有指定main类，所以类似这样来指定:<br>E:\codeplace\n_learn\java\javacmd\build&gt;java -cp h.jar com.yp.test.HelloWorld</p></blockquote><p>生成可以运行的jar包</p><p>需要指定jar包的应用程序入口点，用-e选项：</p><pre><code>E:\codeplace\n_learn\java\javacmd\build&gt; jar cvfe h.jar com.yp.test.HelloWorld *已添加清单正在添加: com/(输入 = 0) (输出 = 0)(存储了 0%)正在添加: com/yp/(输入 = 0) (输出 = 0)(存储了 0%)正在添加: com/yp/test/(输入 = 0) (输出 = 0)(存储了 0%)正在添加: com/yp/test/entity/(输入 = 0) (输出 = 0)(存储了 0%)正在添加: com/yp/test/entity/Cat.class(输入 = 545) (输出 = 319)(压缩了 41%)正在添加: com/yp/test/HelloWorld.class(输入 = 844) (输出 = 487)(压缩了 42%)</code></pre><p>直接运行</p><pre><code>java -jar h.jar额外发现 指定了Main类后，jar包里面的 META-INF/MANIFEST.MF 是这样的， 比原来多了一行Main-Class….Manifest-Version: 1.0Created-By: 1.8.0 (Oracle Corporation)Main-Class: com.yp.test.HelloWorld</code></pre><p>如果类里有引用jar包呢?</p><p>先下一个jar包 这里直接下 log4j </p><pre><code>* main函数改成import com.yp.test.entity.Cat;import org.apache.log4j.Logger;public class HelloWorld {    static Logger log = Logger.getLogger(HelloWorld.class);    public static void main(String[] args) {        Cat c = new Cat(&quot;keyboard&quot;);        log.info(&quot;这是log4j&quot;);        System.out.println(&quot;hello,&quot; + c.getName());    }}</code></pre><p>现的文件是这样的</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├─build</span><br><span class="line">├─<span class="class"><span class="keyword">lib</span></span></span><br><span class="line">│      log4j-<span class="number">1.2</span>.<span class="number">17</span>.jar</span><br><span class="line">│</span><br><span class="line">└─src</span><br><span class="line">    └─com</span><br><span class="line">        └─yp</span><br><span class="line">            └─test</span><br><span class="line">                │  HelloWorld.java</span><br><span class="line">                │</span><br><span class="line">                └─entity</span><br><span class="line">                        Cat.java</span><br></pre></td></tr></table></figure><pre><code>这个时候 javac命令要接上 -cp ./lib/*.jarE:\codeplace\n_learn\java\javacmd&gt;javac -encoding &quot;utf8&quot; src/com/yp/test/HelloWorld.java -sourcepath src -d build -g -cp ./lib/*.jar运行要加上-cp, -cp 选项貌似会把工作目录给换了， 所以要加上 ;../buildE:\codeplace\n_learn\java\javacmd\build&gt;java -cp ../lib/log4j-1.2.17.jar;../build com.yp.test.HelloWorld</code></pre><p>结果:</p><pre><code>log4j:WARN No appenders could be found for logger(com.yp.test.HelloWorld).log4j:WARN Please initialize the log4j system properly.log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.hello,keyboard</code></pre><p>由于没有 log4j的配置文件，所以提示上面的问题,往 build 里面加上 log4j.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt;&lt;log4j:configuration xmlns:log4j=&apos;http://jakarta.apache.org/log4j/&apos;&gt;    &lt;appender name=&quot;stdout&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt;        &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;            &lt;param name=&quot;ConversionPattern&quot; value=&quot;%d{ABSOLUTE} %-5p [%c{1}] %m%n&quot; /&gt;        &lt;/layout&gt;    &lt;/appender&gt;    &lt;root&gt;        &lt;level value=&quot;info&quot; /&gt;        &lt;appender-ref ref=&quot;stdout&quot; /&gt;    &lt;/root&gt;&lt;/log4j:configuration&gt;</code></pre><p>再运行</p><pre><code>E:\codeplace\n_learn\java\javacmd&gt;java -cp lib/log4j-1.2.17.jar;build com.yp.tes t.HelloWorld15:19:57,359 INFO  [HelloWorld] 这是log4jhello,keyboard</code></pre><p>说明:<br>这个log4j配置文件，习惯的做法是放在src目录下, 在编译过程中 copy到build中的,但根据ant的做法，不是用javac的，而是用来处理,我猜测javac是不能copy的，如果想在命令行直接 使用，应该是用cp命令主动去执行 copy操作</p><p>ok 一个简单的java 工程就运行完了<br>但是  貌似有些繁琐,  需要手动键入 java文件 以及相应的jar包 很是麻烦,<br>so 可以用 shell 来脚本来简化相关操作<br>shell 文件整理如下:</p><pre><code>#!/bin/bash  echo &quot;build start&quot;  JAR_PATH=libs  BIN_PATH=bin  SRC_PATH=src  # java文件列表目录  SRC_FILE_LIST_PATH=src/sources.list  #生所有的java文件列表 放入列表文件中 rm -f $SRC_PATH/sources  find $SRC_PATH/ -name *.java &gt; $SRC_FILE_LIST_PATH  #删除旧的编译文件 生成bin目录  rm -rf $BIN_PATH/  mkdir $BIN_PATH/  #生成依赖jar包 列表  for file in  ${JAR_PATH}/*.jar;  do  jarfile=${jarfile}:${file}  done  echo &quot;jarfile = &quot;$jarfile  #编译 通过-cp指定所有的引用jar包，将src下的所有java文件进行编译javac -d $BIN_PATH/ -cp $jarfile @$SRC_FILE_LIST_PATH  #运行 通过-cp指定所有的引用jar包，指定入口函数运行java -cp $BIN_PATH$jarfile com.zuiapps.danmaku.server.Main  </code></pre><blockquote><p>有一点需要注意的是,  javac -d $BIN_PATH/ -cp $jarfile @$SRC_FILE_LIST_PATH<br>在要编译的文件很多时候，一个个敲命令会显得很长，也不方便修改，</p></blockquote><blockquote><p>可以把要编译的源文件列在文件中，在文件名前加@，这样就可以对多个文件进行编译，</p></blockquote><blockquote><p>以上就是吧java文件放到 $SRC_FILE_LIST_PATH 中去了</p></blockquote><pre><code>编译 :     1. 需要编译所有的java文件     2. 依赖的java 包都需要加入到 classpath 中去     3. 最后设置 编译后的 class 文件存放目录  即 -d bin/     4. java文件过多是可以使用  @$SRC_FILE_LIST_PATH 把他们放到一个文件中去运行:   1.需要吧 编译时设置的bin目录和 所有jar包加入到 classpath 中去</code></pre><h2 id="javap"><a href="#javap" class="headerlink" title="javap"></a>javap</h2><blockquote><p>javap是jdk自带的一个工具，可以对代码反编译，也可以查看java编译器生成的字节码。</p><p>情况下，很少有人使用javap对class文件进行反编译，因为有很多成熟的反编译工具可以使用，比如jad。但是，javap还可以查看java编译器为我们生成的字节码。通过它，可以对照源代码和字节码，从而了解很多编译器内部的工作。</p><p>javap命令分解一个class文件，它根据options来决定到底输出什么。如果没有使用options,那么javap将会输出包，类里的protected和public域以及类里的所有方法。javap将会把它们输出在标准输出上。来看这个例子，先编译(javac)下面这个类。</p></blockquote><pre><code>import java.awt.*;import java.applet.*;public class DocFooter extends Applet {        String date;        String email;        public void init() {                resize(500,100);                date = getParameter(&quot;LAST_UPDATED&quot;);                email = getParameter(&quot;EMAIL&quot;);        }}</code></pre><p>在命令行上键入javap DocFooter后，输出结果如下</p><p>Compiled from “DocFooter.java”</p><pre><code>public class DocFooter extends java.applet.Applet {  java.lang.String date;  java.lang.String email;  public DocFooter();  public void init();}</code></pre><p>如果加入了-c，即javap -c DocFooter，那么输出结果如下</p><p>Compiled from “DocFooter.java”</p><pre><code>public class DocFooter extends java.applet.Applet {  java.lang.String date;  java.lang.String email;  public DocFooter();    Code:       0: aload_0              1: invokespecial #1                  // Method java/applet/Applet.&quot;&lt;init&gt;&quot;:()V       4: return         public void init();    Code:       0: aload_0              1: sipush        500       4: bipush        100       6: invokevirtual #2                  // Method resize:(II)V       9: aload_0             10: aload_0             11: ldc           #3                  // String LAST_UPDATED      13: invokevirtual #4                  // Method getParameter:(Ljava/lang/String;)Ljava/lang/String;      16: putfield      #5                  // Field date:Ljava/lang/String;      19: aload_0             20: aload_0             21: ldc           #6                  // String EMAIL      23: invokevirtual #4                  // Method getParameter:(Ljava/lang/String;)Ljava/lang/String;      26: putfield      #7                  // Field email:Ljava/lang/String;      29: return       }</code></pre><p>上面输出的内容就是字节码。</p><p>用法摘要</p><p>-help 帮助<br>-l 输出行和变量的表<br>-public 只输出public方法和域<br>-protected 只输出public和protected类和成员<br>-package 只输出包，public和protected类和成员，这是默认的<br>-p -private 输出所有类和成员<br>-s 输出内部类型签名<br>-c 输出分解后的代码，例如，类中每一个方法内，包含java字节码的指令，<br>-verbose 输出栈大小，方法参数的个数<br>-constants 输出静态final常量<br>总结</p><p>javap可以用于反编译和查看编译器编译后的字节码。平时一般用javap -c比较多，该命令用于列出每个方法所执行的JVM指令，并显示每个方法的字节码的实际作用。可以通过字节码和源代码的对比，深入分析java的编译原理，了解和解决各种Java原理级别的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言：本文教你怎么用javac和java命令，讲解了classpath的原理，以及如何利用脚本（shell或bat）进行项目部署，离开ide，还原最本质的Java编译运行过程，并用简单的实例展示这些用法。 &lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/05/01/javase14&quot;&gt;https://h2pl.github.io/2018/05/01/javase14&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java基础" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础13：反射详解</title>
    <link href="http://h2pl.github.io/2018/05/01/javase13/"/>
    <id>http://h2pl.github.io/2018/05/01/javase13/</id>
    <published>2018-05-01T14:26:21.000Z</published>
    <updated>2018-06-01T03:50:42.452Z</updated>
    
    <content type="html"><![CDATA[<p>本节主要介绍Java反射的原理，使用方法以及相关的技术细节，并且介绍了关于Class类，注解等内容。</p><p>具体代码在我的GitHub中可以找到</p><blockquote><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p></blockquote><p>文章首发于我的个人博客：</p><blockquote><p><a href="https://h2pl.github.io/2018/05/01/javase13">https://h2pl.github.io/2018/05/01/javase13</a></p></blockquote><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：</p><blockquote><p><a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a></p></blockquote><a id="more"></a><h2 id="回顾：什么是反射？"><a href="#回顾：什么是反射？" class="headerlink" title="回顾：什么是反射？"></a>回顾：什么是反射？</h2><p>反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。<br>Oracle官方对反射的解释是</p><blockquote><p>Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.</p></blockquote><blockquote><p>The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control.</p><p> 简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。</p><p>程序中一般的对象的类型都是在编译期就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</p><p> 反射的核心是JVM在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p></blockquote><p>Java反射框架主要提供以下功能：</p><blockquote><p>1.在运行时判断任意一个对象所属的类；</p></blockquote><blockquote><p>2.在运行时构造任意一个类的对象；</p></blockquote><blockquote><p>3.在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；</p></blockquote><blockquote><p>4.在运行时调用任意一个对象的方法</p></blockquote><blockquote><p>重点：是运行时而不是编译时</p></blockquote><h2 id="反射的主要用途"><a href="#反射的主要用途" class="headerlink" title="反射的主要用途"></a>反射的主要用途</h2><blockquote><p> 很多人都认为反射在实际的Java开发应用中并不广泛，其实不然。</p></blockquote><blockquote><p> 当我们在使用IDE(如Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。</p></blockquote><blockquote><p> 反射最重要的用途就是开发各种通用框架。</p></blockquote><blockquote><p> 很多框架（比如Spring）都是配置化的（比如通过XML文件配置JavaBean,Action之类的），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。</p></blockquote><blockquote><p> 举一个例子，在运用Struts 2框架的开发中我们一般会在struts.xml里去配置Action，比如：</p></blockquote><pre><code>&lt;action name=&quot;login&quot;               class=&quot;org.ScZyhSoft.test.action.SimpleLoginAction&quot;               method=&quot;execute&quot;&gt;           &lt;result&gt;/shop/shop-index.jsp&lt;/result&gt;           &lt;result name=&quot;error&quot;&gt;login.jsp&lt;/result&gt;       &lt;/action&gt;</code></pre><p>配置文件与Action建立了一种映射关系，当View层发出请求时，请求会被StrutsPrepareAndExecuteFilter拦截，然后StrutsPrepareAndExecuteFilter会去动态地创建Action实例。</p><p>——比如我们请求login.action，那么StrutsPrepareAndExecuteFilter就会去解析struts.xml文件，检索action中name为login的Action，并根据class属性创建SimpleLoginAction实例，并用invoke方法来调用execute方法，这个过程离不开反射。</p><blockquote><p>对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。而对于一般的开发者来说，不深入框架开发则用反射用的就会少一点，不过了解一下框架的底层机制有助于丰富自己的编程思想，也是很有益的。</p></blockquote><h2 id="反射的基础：关于Class类"><a href="#反射的基础：关于Class类" class="headerlink" title="反射的基础：关于Class类"></a>反射的基础：关于Class类</h2><p>更多关于Class类和Object类的原理和介绍请见上一节</p><blockquote><p>1、Class是一个类，一个描述类的类（也就是描述类本身），封装了描述方法的Method，描述字段的Filed，描述构造器的Constructor等属性</p><p>2、对象照镜子后（反射）可以得到的信息：某个类的数据成员名、方法和构造器、某个类到底实现了哪些接口。</p><p>3、对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个Class对象包含了特定某个类的有关信息。</p><p>4、Class 对象只能由系统建立对象</p><p>5、一个类在 JVM 中只会有一个Class实例</p></blockquote><pre><code>//总结一下就是，JDK有一个类叫做Class，这个类用来封装所有Java类型，包括这些类的所有信息，JVM中类信息是放在方法区的。//所有类在加载后，JVM会为其在堆中创建一个Class&lt;类名称&gt;的对象，并且每个类只会有一个Class对象，这个类的所有对象都要通过Class&lt;类名称&gt;来进行实例化。//上面说的是JVM进行实例化的原理，当然实际上在Java写代码时只需要用 类名称就可以进行实例化了。public final class Class&lt;T&gt; implements java.io.Serializable,                          GenericDeclaration,                          Type,                          AnnotatedElement {虚拟机会保持唯一一            //通过类名.class获得唯一的Class对象。            Class&lt;UserBean&gt; cls = UserBean.class;            //通过integer.TYPEl来获取Class对象            Class&lt;Integer&gt; inti = Integer.TYPE;          //接口本质也是一个类，一样可以通过.class获取            Class&lt;User&gt; userClass = User.class;</code></pre><h2 id="反射的基本运用"><a href="#反射的基本运用" class="headerlink" title="反射的基本运用"></a>反射的基本运用</h2><p>上面我们提到了反射可以用于判断任意对象所属的类，获得Class对象，构造任意一个对象以及调用一个对象。这里我们介绍一下基本反射功能的实现(反射相关的类一般都在java.lang.relfect包里)。</p><p>1、获得Class对象方法有三种</p><p>(1)使用Class类的forName静态方法:</p><pre><code> public static Class&lt;?&gt; forName(String className)``` 在JDBC开发中常用此方法加载数据库驱动:要使用全类名来加载这个类，一般数据库驱动的配置信息会写在配置文件中。加载这个驱动前要先导入jar包```java Class.forName(driver);</code></pre><p>(2)直接获取某一个对象的class，比如:</p><pre><code>//Class&lt;?&gt;是一个泛型表示，用于获取一个类的类型。Class&lt;?&gt; klass = int.class;Class&lt;?&gt; classInt = Integer.TYPE;</code></pre><p>(3)调用某个对象的getClass()方法,比如:</p><pre><code>StringBuilder str = new StringBuilder(&quot;123&quot;);Class&lt;?&gt; klass = str.getClass();</code></pre><h2 id="判断是否为某个类的实例"><a href="#判断是否为某个类的实例" class="headerlink" title="判断是否为某个类的实例"></a>判断是否为某个类的实例</h2><p>一般地，我们用instanceof关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的isInstance()方法来判断是否为某个类的实例，它是一个Native方法：</p><p>==public native boolean isInstance(Object obj);==</p><h2 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h2><p>通过反射来生成对象主要有两种方式。</p><p>（1）使用Class对象的newInstance()方法来创建Class对象对应类的实例。</p><p>注意：利用newInstance创建对象：调用的类必须有无参的构造器</p><pre><code>//Class&lt;?&gt;代表任何类的一个类对象。//使用这个类对象可以为其他类进行实例化//因为jvm加载类以后自动在堆区生成一个对应的*.Class对象//该对象用于让JVM对进行所有*对象实例化。Class&lt;?&gt; c = String.class;//Class&lt;?&gt; 中的 ? 是通配符，其实就是表示任意符合泛类定义条件的类，和直接使用 Class//效果基本一致，但是这样写更加规范，在某些类型转换时可以避免不必要的 unchecked 错误。Object str = c.newInstance();</code></pre><p>（2）先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。</p><pre><code>//获取String所对应的Class对象Class&lt;?&gt; c = String.class;//获取String类带一个String参数的构造器Constructor constructor = c.getConstructor(String.class);//根据构造器创建实例Object obj = constructor.newInstance(&quot;23333&quot;);System.out.println(obj);</code></pre><h2 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h2><p>获取某个Class对象的方法集合，主要有以下几个方法：</p><p>getDeclaredMethods()方法返回类或接口声明的所有方法，==包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法==。</p><pre><code>public Method[] getDeclaredMethods() throws SecurityException</code></pre><p>getMethods()方法返回某个类的所有公用（public）方法，==包括其继承类的公用方法。==</p><pre><code>public Method[] getMethods() throws SecurityException</code></pre><p>getMethod方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象</p><pre><code>public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code></pre><p>只是这样描述的话可能难以理解，我们用例子来理解这三个方法：<br>本文中的例子用到了以下这些类，用于反射的测试。</p><pre><code>//注解类，可可用于表示方法，可以通过反射获取注解的内容。    //Java注解的实现是很多注框架实现注解配置的基础@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Invoke {}</code></pre><p>userbean的父类personbean</p><pre><code>public class PersonBean {private String name;int id;public String getName() {    return name;}public void setName(String name) {    this.name = name;}</code></pre><p>}</p><p>接口user</p><pre><code>public interface User {    public void login ();}</code></pre><p>userBean实现user接口，继承personbean</p><pre><code>public class UserBean extends PersonBean implements User{    @Override    public void login() {    }    class B {    }    public String userName;    protected int i;    static int j;    private int l;    private long userId;    public UserBean(String userName, long userId) {        this.userName = userName;        this.userId = userId;    }    public String getName() {        return userName;    }    public long getId() {        return userId;    }    @Invoke    public static void staticMethod(String devName,int a) {        System.out.printf(&quot;Hi %s, I&apos;m a static method&quot;, devName);    }    @Invoke    public void publicMethod() {        System.out.println(&quot;I&apos;m a public method&quot;);    }    @Invoke    private void privateMethod() {        System.out.println(&quot;I&apos;m a private method&quot;);    }}</code></pre><p>1 getMethods和getDeclaredMethods的区别</p><pre><code>public class 动态加载类的反射 {    public static void main(String[] args) {        try {            Class clazz = Class.forName(&quot;com.javase.反射.UserBean&quot;);            for (Field field : clazz.getDeclaredFields()) {//                field.setAccessible(true);                System.out.println(field);            }            //getDeclaredMethod*()获取的是类自身声明的所有方法，包含public、protected和private方法。            System.out.println(&quot;------共有方法------&quot;);//        getDeclaredMethod*()获取的是类自身声明的所有方法，包含public、protected和private方法。//            getMethod*()获取的是类的所有共有方法，这就包括自身的所有public方法，和从基类继承的、从接口实现的所有public方法。            for (Method method : clazz.getMethods()) {                String name = method.getName();                System.out.println(name);                //打印出了UserBean.java的所有方法以及父类的方法            }            System.out.println(&quot;------独占方法------&quot;);            for (Method method : clazz.getDeclaredMethods()) {                String name = method.getName();                System.out.println(name);            }        } catch (ClassNotFoundException e) {            e.printStackTrace();        }    }}</code></pre><p>2 打印一个类的所有方法及详细信息：</p><pre><code>public class 打印所有方法 {    public static void main(String[] args) {        Class userBeanClass = UserBean.class;        Field[] fields = userBeanClass.getDeclaredFields();        //注意，打印方法时无法得到局部变量的名称，因为jvm只知道它的类型        Method[] methods = userBeanClass.getDeclaredMethods();        for (Method method : methods) {            //依次获得方法的修饰符，返回类型和名称，外加方法中的参数            String methodString = Modifier.toString(method.getModifiers()) + &quot; &quot; ; // private static            methodString += method.getReturnType().getSimpleName() + &quot; &quot;; // void            methodString += method.getName() + &quot;(&quot;; // staticMethod            Class[] parameters = method.getParameterTypes();            Parameter[] p = method.getParameters();            for (Class parameter : parameters) {                methodString += parameter.getSimpleName() + &quot; &quot; ; // String            }            methodString += &quot;)&quot;;            System.out.println(methodString);        }        //注意方法只能获取到其类型，拿不到变量名/*        public String getName()        public long getId()        public static void staticMethod(String int )        public void publicMethod()        private void privateMethod()*/    }}</code></pre><h2 id="获取构造器信息"><a href="#获取构造器信息" class="headerlink" title="获取构造器信息"></a>获取构造器信息</h2><p>获取类构造器的用法与上述获取方法的用法类似。主要是通过Class类的getConstructor方法得到Constructor类的一个实例，而Constructor类有一个newInstance方法可以创建一个对象实例:</p><pre><code>public class 打印构造方法 {    public static void main(String[] args) {        // constructors        Class&lt;?&gt; clazz = UserBean.class;        Class userBeanClass = UserBean.class;        //获得所有的构造方法        Constructor[] constructors = userBeanClass.getDeclaredConstructors();        for (Constructor constructor : constructors) {            String s = Modifier.toString(constructor.getModifiers()) + &quot; &quot;;            s += constructor.getName() + &quot;(&quot;;            //构造方法的参数类型            Class[] parameters = constructor.getParameterTypes();            for (Class parameter : parameters) {                s += parameter.getSimpleName() + &quot;, &quot;;            }            s += &quot;)&quot;;            System.out.println(s);            //打印结果//public com.javase.反射.UserBean(String, long, )        }    }}</code></pre><h2 id="获取类的成员变量（字段）信息"><a href="#获取类的成员变量（字段）信息" class="headerlink" title="获取类的成员变量（字段）信息"></a>获取类的成员变量（字段）信息</h2><p>主要是这几个方法，在此不再赘述：</p><p>getFiled: 访问公有的成员变量<br>getDeclaredField：所有已声明的成员变量。但不能得到其父类的成员变量<br>getFileds和getDeclaredFields用法同上（参照Method）</p><pre><code>public class 打印成员变量 {    public static void main(String[] args) {        Class userBeanClass = UserBean.class;        //获得该类的所有成员变量，包括static private        Field[] fields = userBeanClass.getDeclaredFields();        for(Field field : fields) {            //private属性即使不用下面这个语句也可以访问//            field.setAccessible(true);            //因为类的私有域在反射中默认可访问，所以flag默认为true。            String fieldString = &quot;&quot;;            fieldString += Modifier.toString(field.getModifiers()) + &quot; &quot;; // `private`            fieldString += field.getType().getSimpleName() + &quot; &quot;; // `String`            fieldString += field.getName(); // `userName`            fieldString += &quot;;&quot;;            System.out.println(fieldString);            //打印结果//            public String userName;//            protected int i;//            static int j;//            private int l;//            private long userId;        }    }}</code></pre><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>当我们从类中获取了一个方法后，我们就可以用invoke()方法来调用这个方法。invoke方法的原型为:</p><pre><code>public Object invoke(Object obj, Object... args)        throws IllegalAccessException, IllegalArgumentException,           InvocationTargetExceptionpublic class 使用反射调用方法 {    public static void main(String[] args) throws InvocationTargetException, IllegalAccessException, InstantiationException, NoSuchMethodException {        Class userBeanClass = UserBean.class;        //获取该类所有的方法，包括静态方法，实例方法。        //此处也包括了私有方法，只不过私有方法在用invoke访问之前要设置访问权限        //也就是使用setAccessible使方法可访问，否则会抛出异常//       // IllegalAccessException的解释是//        * An IllegalAccessException is thrown when an application tries// * to reflectively create an instance (other than an array),// * set or get a field, or invoke a method, but the currently// * executing method does not have access to the definition of// * the specified class, field, method or constructor.//        getDeclaredMethod*()获取的是类自身声明的所有方法，包含public、protected和private方法。//            getMethod*()获取的是类的所有共有方法，这就包括自身的所有public方法，和从基类继承的、从接口实现的所有public方法。        //就是说，当这个类，域或者方法被设为私有访问，使用反射调用但是却没有权限时会抛出异常。        Method[] methods = userBeanClass.getDeclaredMethods(); // 获取所有成员方法        for (Method method : methods) {            //反射可以获取方法上的注解，通过注解来进行判断            if (method.isAnnotationPresent(Invoke.class)) { // 判断是否被 @Invoke 修饰                //判断方法的修饰符是是static                if (Modifier.isStatic(method.getModifiers())) { // 如果是 static 方法                    //反射调用该方法                    //类方法可以直接调用，不必先实例化                    method.invoke(null, &quot;wingjay&quot;,2); // 直接调用，并传入需要的参数 devName                } else {                    //如果不是类方法，需要先获得一个实例再调用方法                    //传入构造方法需要的变量类型                    Class[] params = {String.class, long.class};                    //获取该类指定类型的构造方法                    //如果没有这种类型的方法会报错                    Constructor constructor = userBeanClass.getDeclaredConstructor(params); // 获取参数格式为 String,long 的构造函数                    //通过构造方法的实例来进行实例化                    Object userBean = constructor.newInstance(&quot;wingjay&quot;, 11); // 利用构造函数进行实例化，得到 Object                    if (Modifier.isPrivate(method.getModifiers())) {                        method.setAccessible(true); // 如果是 private 的方法，需要获取其调用权限//                        Set the {@code accessible} flag for this object to//     * the indicated boolean value.  A value of {@code true} indicates that//     * the reflected object should suppress Java language access//     * checking when it is used.  A value of {@code false} indicates//                                * that the reflected object should enforce Java language access checks.                        //通过该方法可以设置其可见或者不可见，不仅可以用于方法                        //后面例子会介绍将其用于成员变量                                            //打印结果//            I&apos;m a public method// Hi wingjay, I&apos;m a static methodI&apos;m a private method                    }                    method.invoke(userBean); // 调用 method，无须参数                }            }        }    }}</code></pre><h2 id="利用反射创建数组"><a href="#利用反射创建数组" class="headerlink" title="利用反射创建数组"></a>利用反射创建数组</h2><p>数组在Java里是比较特殊的一种类型，它可以赋值给一个Object Reference。下面我们看一看利用反射创建数组的例子：</p><pre><code>public class 用反射创建数组 {    public static void main(String[] args) {        Class&lt;?&gt; cls = null;        try {            cls = Class.forName(&quot;java.lang.String&quot;);        } catch (ClassNotFoundException e) {            e.printStackTrace();        }        Object array = Array.newInstance(cls,25);        //往数组里添加内容        Array.set(array,0,&quot;hello&quot;);        Array.set(array,1,&quot;Java&quot;);        Array.set(array,2,&quot;fuck&quot;);        Array.set(array,3,&quot;Scala&quot;);        Array.set(array,4,&quot;Clojure&quot;);        //获取某一项的内容        System.out.println(Array.get(array,3));        //Scala    }}</code></pre><p>其中的Array类为java.lang.reflect.Array类。我们通过Array.newInstance()创建数组对象，它的原型是:</p><pre><code>public static Object newInstance(Class&lt;?&gt; componentType, int length)        throws NegativeArraySizeException {        return newArray(componentType, length);    }</code></pre><p>而newArray()方法是一个Native方法，它在Hotspot JVM里的具体实现我们后边再研究，这里先把源码贴出来</p><pre><code>private static native Object newArray(Class&lt;?&gt; componentType, int length)        throws NegativeArraySizeException;</code></pre><h2 id="Java的注解"><a href="#Java的注解" class="headerlink" title="Java的注解"></a>Java的注解</h2><p>9、注解(Annotation)</p><p>Java提供的注解，实际上可以通过反射的方式得到注解的内容 </p><blockquote><p>•从 JDK5.0 开始,Java 增加了对元数据(MetaData)的支持,也就是Annotation(注释)</p></blockquote><blockquote><p>•Annotation其实就是代码里的特殊标记,这些标记可以在编译,类加载, 运行时被读取,并执行相应的处理.通过使用Annotation,程序员可以在不改变原有逻辑的情况下,在源文件中嵌入一些补充信息.</p></blockquote><blockquote><p>•Annotation 可以像修饰符一样被使用,可用于修饰包,类,构造器, 方法,成员变量, 参数,局部变量的声明,这些信息被保存在Annotation的 “name=value”对中.</p></blockquote><blockquote><p>•Annotation能被用来为程序元素(类,方法,成员变量等)设置元数据</p></blockquote><p>基本的 Annotation</p><pre><code>•使用 Annotation时要在其前面增加@符号,并把该Annotation 当成一个修饰符使用.用于修饰它支持的程序元素•三个基本的Annotation:    –@Override:限定重写父类方法,该注释只能用于方法    –@Deprecated:用于表示某个程序元素(类,方法等)已过时    –@SuppressWarnings:抑制编译器警告.</code></pre><p>自定义 Annotation</p><blockquote><p>•定义新的 Annotation类型使用@interface关键字</p><p>•Annotation 的成员变量在Annotation</p><p>定义中以无参数方法的形式来声明.其方法名和返回值定义了该成员的名字和类型.</p><p>•可以在定义Annotation的成员变量时为其指定初始值,指定成员变量的初始值可使用default关键字</p><p>•没有成员定义的Annotation称为标记;包含成员变量的Annotation称为元数据Annotation</p></blockquote><pre><code>@Retention(RetentionPolicy.RUNTIME) //运行时检验  @Target(value = {ElementType.METHOD})  //作用在方法上  public @interface AgeValidator {      int min();      int max();  </code></pre><p>注解的获取方法</p><pre><code>/**  * 通过反射才能获取注解  */  @Test  public void testAnnotation() throws Exception {      //这样的方式不能使用注解      Person3 person3 = new Person3();      person3.setAge(10);*/      String className = &quot;com.java.reflection.Person3&quot;;      Class clazz = Class.forName(className);      Object obj = clazz.newInstance();      Method method = clazz.getDeclaredMethod(&quot;setAge&quot;,Integer.class);      int val =40;      //获取注解      Annotation annotation = method.getAnnotation(AgeValidator.class);      if (annotation != null){          if (annotation instanceof AgeValidator){              AgeValidator ageValidator = (AgeValidator) annotation;              if (val&lt; ageValidator.min() || val&gt;ageValidator.max()){                  throw new RuntimeException(&quot;数值超出范围&quot;);              }          }      }      method.invoke(obj, val);      System.out.println(obj);  }  </code></pre><p>提取 Annotation信息</p><pre><code>•JDK5.0 在 java.lang.reflect包下新增了 AnnotatedElement接口,该接口代表程序中可以接受注释的程序元素•当一个 Annotation类型被定义为运行时Annotation后,该注释才是运行时可见,当 class文件被载入时保存在 class文件中的 Annotation才会被虚拟机读取•程序可以调用AnnotationElement对象的如下方法来访问 Annotation信息–获取 Annotation实例：•getAnnotation(Class&lt;T&gt; annotationClass)•getDeclaredAnnotations()•getParameterAnnotations()JDK 的元Annotation•JDK 的元Annotation 用于修饰其他Annotation 定义•@Retention:只能用于修饰一个 Annotation定义,用于指定该 Annotation可以保留多长时间,@Rentention包含一个RetentionPolicy类型的成员变量,使用 @Rentention时必须为该 value成员变量指定值:    –RetentionPolicy.CLASS:编译器将把注释记录在 class文件中.当运行 Java程序时,JVM 不会保留注释.这是默认值    –RetentionPolicy.RUNTIME:编译器将把注释记录在class文件中. 当运行 Java 程序时, JVM 会保留注释. 程序可以通过反射获取该注释    –RetentionPolicy.SOURCE:编译器直接丢弃这种策略的注释•@Target: 用于修饰Annotation 定义,用于指定被修饰的 Annotation能用于修饰哪些程序元素.@Target 也包含一个名为 value的成员变量.•@Documented:用于指定被该元 Annotation修饰的 Annotation类将被 javadoc工具提取成文档.•@Inherited:被它修饰的 Annotation将具有继承性.如果某个类使用了被@Inherited 修饰的Annotation, 则其子类将自动具有该注释</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节主要介绍Java反射的原理，使用方法以及相关的技术细节，并且介绍了关于Class类，注解等内容。&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/05/01/javase13&quot;&gt;https://h2pl.github.io/2018/05/01/javase13&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java基础" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java反射" scheme="http://h2pl.github.io/tags/Java%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Java基础12：深入理解Class类和Object类</title>
    <link href="http://h2pl.github.io/2018/04/30/javase12/"/>
    <id>http://h2pl.github.io/2018/04/30/javase12/</id>
    <published>2018-04-30T14:34:51.000Z</published>
    <updated>2018-06-01T03:50:34.974Z</updated>
    
    <content type="html"><![CDATA[<p>本文对java的Class类和Object类的概念和原理做了详尽的介绍，并且详细介绍了Object的各种方法，以及这两个类之间的关系。</p><p>Class类和Object类是Java中最根本最重要的两个类，理解它们是理解Java面向对象技术的基础，也是学习所有进阶Java技术的基石。</p><p>具体代码在我的GitHub中可以找到</p><blockquote><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p></blockquote><p>文章首发于我的个人博客：</p><blockquote><p><a href="https://h2pl.github.io/2018/04/30/javase12">https://h2pl.github.io/2018/04/30/javase12</a></p></blockquote><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：</p><blockquote><p><a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a></p></blockquote><a id="more"></a><blockquote><p>注意这里说的Class是Java中的java.lang.Class类。这个类用于记录Java中每个类的类型信息，并且jvm在类加载时会为每个类生成一个Class<a>的Class对象在Java堆中，每个A类型的实例都要通过这个Class对象来进行实例化。</a></p></blockquote><p>这部分参考<a href="https://blog.csdn.net/s10461/article/details/53941091" target="_blank" rel="noopener">https://blog.csdn.net/s10461/article/details/53941091</a></p><h2 id="Java中Class类及用法"><a href="#Java中Class类及用法" class="headerlink" title="Java中Class类及用法"></a>Java中Class类及用法</h2><p>Java程序在运行时，Java运行时系统一直对所有的对象进行所谓的运行时类型标识，即所谓的RTTI。</p><blockquote><p>这项信息纪录了每个对象所属的类。虚拟机通常使用运行时类型信息选准正确方法去执行，用来保存这些类型信息的类是Class类。Class类封装一个对象和接口运行时的状态，当装载类时，Class类型的对象自动创建。</p></blockquote><p>说白了就是：</p><blockquote><p>Class类也是类的一种，只是名字和class关键字高度相似。Java是大小写敏感的语言。</p></blockquote><blockquote><p>Class类的对象内容是你创建的类的类型信息，比如你创建一个shapes类，那么，Java会生成一个内容是shapes的Class类的对象</p></blockquote><blockquote><p>Class类的对象不能像普通类一样，以 new shapes() 的方式创建，它的对象只能由JVM创建，因为这个类没有public构造函数</p></blockquote><pre><code>/* * Private constructor. Only the Java Virtual Machine creates Class objects. * This constructor is not used and prevents the default constructor being * generated. */ //私有构造方法，只能由jvm进行实例化private Class(ClassLoader loader) {    // Initialize final field for classLoader.  The initialization value of non-null    // prevents future JIT optimizations from assuming this final field is null.    classLoader = loader;}</code></pre><blockquote><p>Class类的作用是运行时提供或获得某个对象的类型信息，和C++中的typeid()函数类似。这些信息也可用于反射。</p></blockquote><h3 id="Class类原理"><a href="#Class类原理" class="headerlink" title="Class类原理"></a>Class类原理</h3><p>看一下Class类的部分源码</p><pre><code>//Class类中封装了类型的各种信息。在jvm中就是通过Class类的实例来获取每个Java类的所有信息的。public class Class类 {    Class aClass = null;//    private EnclosingMethodInfo getEnclosingMethodInfo() {//        Object[] enclosingInfo = getEnclosingMethod0();//        if (enclosingInfo == null)//            return null;//        else {//            return new EnclosingMethodInfo(enclosingInfo);//        }//    }    /**提供原子类操作     * Atomic operations support.     *///    private static class Atomic {//        // initialize Unsafe machinery here, since we need to call Class.class instance method//        // and have to avoid calling it in the static initializer of the Class class...//        private static final Unsafe unsafe = Unsafe.getUnsafe();//        // offset of Class.reflectionData instance field//        private static final long reflectionDataOffset;//        // offset of Class.annotationType instance field//        private static final long annotationTypeOffset;//        // offset of Class.annotationData instance field//        private static final long annotationDataOffset;////        static {//            Field[] fields = Class.class.getDeclaredFields0(false); // bypass caches//            reflectionDataOffset = objectFieldOffset(fields, &quot;reflectionData&quot;);//            annotationTypeOffset = objectFieldOffset(fields, &quot;annotationType&quot;);//            annotationDataOffset = objectFieldOffset(fields, &quot;annotationData&quot;);//        }        //提供反射信息    // reflection data that might get invalidated when JVM TI RedefineClasses() is called//    private static class ReflectionData&lt;T&gt; {//        volatile Field[] declaredFields;//        volatile Field[] publicFields;//        volatile Method[] declaredMethods;//        volatile Method[] publicMethods;//        volatile Constructor&lt;T&gt;[] declaredConstructors;//        volatile Constructor&lt;T&gt;[] publicConstructors;//        // Intermediate results for getFields and getMethods//        volatile Field[] declaredPublicFields;//        volatile Method[] declaredPublicMethods;//        volatile Class&lt;?&gt;[] interfaces;////        // Value of classRedefinedCount when we created this ReflectionData instance//        final int redefinedCount;////        ReflectionData(int redefinedCount) {//            this.redefinedCount = redefinedCount;//        }//    }        //方法数组//    static class MethodArray {//        // Don&apos;t add or remove methods except by add() or remove() calls.//        private Method[] methods;//        private int length;//        private int defaults;////        MethodArray() {//            this(20);//        }////        MethodArray(int initialSize) {//            if (initialSize &lt; 2)//                throw new IllegalArgumentException(&quot;Size should be 2 or more&quot;);////            methods = new Method[initialSize];//            length = 0;//            defaults = 0;//        }    //注解信息    // annotation data that might get invalidated when JVM TI RedefineClasses() is called//    private static class AnnotationData {//        final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations;//        final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;////        // Value of classRedefinedCount when we created this AnnotationData instance//        final int redefinedCount;////        AnnotationData(Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations,//                       Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations,//                       int redefinedCount) {//            this.annotations = annotations;//            this.declaredAnnotations = declaredAnnotations;//            this.redefinedCount = redefinedCount;//        }//    }}</code></pre><blockquote><p>我们都知道所有的java类都是继承了object这个类，在object这个类中有一个方法：getclass().这个方法是用来取得该类已经被实例化了的对象的该类的引用，这个引用指向的是Class类的对象。</p><p>我们自己无法生成一个Class对象（构造函数为private)，而 这个Class类的对象是在当各类被调入时，由 Java 虚拟机自动创建 Class 对象，或通过类装载器中的 defineClass 方法生成。</p></blockquote><pre><code>//通过该方法可以动态地将字节码转为一个Class类对象protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)    throws ClassFormatError{    return defineClass(name, b, off, len, null);}</code></pre><blockquote><p>我们生成的对象都会有个字段记录该对象所属类在CLass类的对象的所在位置。如下图所示：</p></blockquote><p><img src="http://dl.iteye.com/upload/picture/pic/101542/0047a6e9-6608-3c3c-a67c-d8ee95e7fcb8.jpg" alt="image"></p><h3 id="如何获得一个Class类对象"><a href="#如何获得一个Class类对象" class="headerlink" title="如何获得一个Class类对象"></a>如何获得一个Class类对象</h3><p>请注意，以下这些方法都是值、指某个类对应的Class对象已经在堆中生成以后，我们通过不同方式获取对这个Class对象的引用。而上面说的DefineClass才是真正将字节码加载到虚拟机的方法，会在堆中生成新的一个Class对象。</p><p>第一种办法，Class类的forName函数</p><blockquote><p>public class shapes{}<br>Class obj= Class.forName(“shapes”);<br>第二种办法，使用对象的getClass()函数</p></blockquote><blockquote><p>public class shapes{}<br>shapes s1=new shapes();<br>Class obj=s1.getClass();<br>Class obj1=s1.getSuperclass();//这个函数作用是获取shapes类的父类的类型</p></blockquote><p>第三种办法，使用类字面常量</p><blockquote><p>Class obj=String.class;<br>Class obj1=int.class;<br>注意，使用这种办法生成Class类对象时，不会使JVM自动加载该类（如String类）。==而其他办法会使得JVM初始化该类。==</p></blockquote><h3 id="使用Class类的对象来生成目标类的实例"><a href="#使用Class类的对象来生成目标类的实例" class="headerlink" title="使用Class类的对象来生成目标类的实例"></a>使用Class类的对象来生成目标类的实例</h3><blockquote><p>生成不精确的object实例</p></blockquote><p>==获取一个Class类的对象后，可以用 newInstance() 函数来生成目标类的一个实例。然而，该函数并不能直接生成目标类的实例，只能生成object类的实例==</p><blockquote><p>Class obj=Class.forName(“shapes”);<br>Object ShapesInstance=obj.newInstance();<br>使用泛化Class引用生成带类型的目标实例</p></blockquote><blockquote><p>Class<shapes> obj=shapes.class;<br>shapes newShape=obj.newInstance();<br>因为有了类型限制，所以使用泛化Class语法的对象引用不能指向别的类。</shapes></p></blockquote><pre><code>Class obj1=int.class;Class&lt;Integer&gt; obj2=int.class;obj1=double.class;//obj2=double.class; 这一行代码是非法的，obj2不能改指向别的类然而，有个灵活的用法，使得你可以用Class的对象指向基类的任何子类。Class&lt;? extends Number&gt; obj=int.class;obj=Number.class;obj=double.class;因此，以下语法生成的Class对象可以指向任何类。Class&lt;?&gt; obj=int.class;obj=double.class;obj=shapes.class;最后一个奇怪的用法是，当你使用这种泛型语法来构建你手头有的一个Class类的对象的基类对象时，必须采用以下的特殊语法public class shapes{}class round extends shapes{}Class&lt;round&gt; rclass=round.class;Class&lt;? super round&gt; sclass= rclass.getSuperClass();//Class&lt;shapes&gt; sclass=rclass.getSuperClass();我们明知道，round的基类就是shapes，但是却不能直接声明 Class &lt; shapes &gt;，必须使用特殊语法Class &lt; ? super round &gt;</code></pre><p>这个记住就可以啦。</p><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>这部分主要参考<a href="http://ihenu.iteye.com/blog/2233249" target="_blank" rel="noopener">http://ihenu.iteye.com/blog/2233249</a></p><p>Object类是Java中其他所有类的祖先，没有Object类Java面向对象无从谈起。作为其他所有类的基类，Object具有哪些属性和行为，是Java语言设计背后的思维体现。</p><p>Object类位于java.lang包中，java.lang包包含着Java最基础和核心的类，在编译时会自动导入。Object类没有定义属性，一共有13个方法，13个方法之中并不是所有方法都是子类可访问的，一共有9个方法是所有子类都继承了的。</p><p>先大概介绍一下这些方法</p><pre><code>1．clone方法保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。2．getClass方法final方法，获得运行时类型。3．toString方法该方法用得比较多，一般子类都有覆盖。4．finalize方法该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。5．equals方法该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。6．hashCode方法该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。7．wait方法wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。调用该方法后当前线程进入睡眠状态，直到以下事件发生。（1）其他线程调用了该对象的notify方法。（2）其他线程调用了该对象的notifyAll方法。（3）其他线程调用了interrupt中断该线程。（4）时间间隔到了。此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。8．notify方法该方法唤醒在该对象上等待的某个线程。9．notifyAll方法该方法唤醒在该对象上等待的所有线程。</code></pre><h3 id="类构造器public-Object"><a href="#类构造器public-Object" class="headerlink" title="类构造器public Object();"></a>类构造器public Object();</h3><blockquote><p>大部分情况下，Java中通过形如 new A(args..)形式创建一个属于该类型的对象。其中A即是类名，A(args..)即此类定义中相对应的构造函数。通过此种形式创建的对象都是通过类中的构造函数完成。</p></blockquote><blockquote><p>为体现此特性，Java中规定：在类定义过程中，对于未定义构造函数的类，默认会有一个无参数的构造函数，作为所有类的基类，Object类自然要反映出此特性，在源码中，未给出Object类构造函数定义，但实际上，此构造函数是存在的。</p><p>当然，并不是所有的类都是通过此种方式去构建，也自然的，并不是所有的类构造函数都是public。</p></blockquote><h3 id="registerNatives-方法"><a href="#registerNatives-方法" class="headerlink" title="registerNatives()方法;"></a>registerNatives()方法;</h3><p>private static native void registerNatives();</p><blockquote><p>registerNatives函数前面有native关键字修饰，Java中，用native关键字修饰的函数表明该方法的实现并不是在Java中去完成，而是由C/C++去完成，并被编译成了.dll，由Java去调用。</p><p>方法的具体实现体在dll文件中，对于不同平台，其具体实现应该有所不同。用native修饰，即表示操作系统，需要提供此方法，Java本身需要使用。</p><p>具体到registerNatives()方法本身，其主要作用是将C/C++中的方法映射到Java中的native方法，实现方法命名的解耦。</p><p>既然如此，可能有人会问，registerNatives()修饰符为private，且并没有执行，作用何以达到？其实，在Java源码中，此方法的声明后有紧接着一段静态代码块：</p></blockquote><pre><code>private static native void registerNatives();  static {       registerNatives();  }  </code></pre><h3 id="Clone-方法实现浅拷贝"><a href="#Clone-方法实现浅拷贝" class="headerlink" title="Clone()方法实现浅拷贝"></a>Clone()方法实现浅拷贝</h3><pre><code>protected native Object clone() throwsCloneNotSupportedException;</code></pre><blockquote><p>看，clode()方法又是一个被声明为native的方法，因此，我们知道了clone()方法并不是Java的原生方法，具体的实现是有C/C++完成的。clone英文翻译为”克隆”，其目的是创建并返回此对象的一个副本。</p></blockquote><blockquote><p>形象点理解，这有一辆科鲁兹，你看着不错，想要个一模一样的。你调用此方法即可像变魔术一样变出一辆一模一样的科鲁兹出来。配置一样，长相一样。但从此刻起，原来的那辆科鲁兹如果进行了新的装饰，与你克隆出来的这辆科鲁兹没有任何关系了。</p><p>你克隆出来的对象变不变完全在于你对克隆出来的科鲁兹有没有进行过什么操作了。Java术语表述为：clone函数返回的是一个引用，指向的是新的clone出来的对象，此对象与原对象分别占用不同的堆空间。</p></blockquote><p>明白了clone的含义后，接下来看看如果调用clone()函数对象进行此克隆操作。</p><p>首先看一下下面的这个例子：</p><pre><code>package com.corn.objectsummary;  import com.corn.Person;  public class ObjectTest {      public static void main(String[] args) {          Object o1 = new Object();          // The method clone() from the type Object is not visible          Object clone = o1.clone();      }  }  </code></pre><blockquote><p>例子很简单，在main()方法中，new一个Oject对象后，想直接调用此对象的clone方法克隆一个对象，但是出现错误提示：”The method clone() from the type Object is not visible”</p><p>why? 根据提示，第一反应是ObjectTest类中定义的Oject对象无法访问其clone()方法。回到Object类中clone()方法的定义，可以看到其被声明为protected，估计问题就在这上面了，protected修饰的属性或方法表示：在同一个包内或者不同包的子类可以访问。</p><p>显然，Object类与ObjectTest类在不同的包中，但是ObjectTest继承自Object，是Object类的子类，于是，现在却出现子类中通过Object引用不能访问protected方法，原因在于对”不同包中的子类可以访问”没有正确理解。</p><p>“不同包中的子类可以访问”，是指当两个类不在同一个包中的时候，继承自父类的子类内部且主调（调用者）为子类的引用时才能访问父类用protected修饰的成员（属性/方法）。 在子类内部，主调为父类的引用时并不能访问此protected修饰的成员。！（super关键字除外）</p></blockquote><p>于是，上例改成如下形式，我们发现，可以正常编译：</p><pre><code>    public class clone方法 {    public static void main(String[] args) {    }    public void test1() {        User user = new User();//        User copy = user.clone();    }    public void test2() {        User user = new User();//        User copy = (User)user.clone();    }}</code></pre><p>是的，因为此时的主调已经是子类的引用了。</p><blockquote><p>上述代码在运行过程中会抛出”java.lang.CloneNotSupportedException”,表明clone()方法并未正确执行完毕，问题的原因在与Java中的语法规定：</p><p>clone()的正确调用是需要实现Cloneable接口，如果没有实现Cloneable接口，并且子类直接调用Object类的clone()方法，则会抛出CloneNotSupportedException异常。</p><p>Cloneable接口仅是一个表示接口，接口本身不包含任何方法，用来指示Object.clone()可以合法的被子类引用所调用。</p><p>于是，上述代码改成如下形式，即可正确指定clone()方法以实现克隆。</p></blockquote><pre><code>public class User implements Cloneable{public int id;public String name;public UserInfo userInfo;public static void main(String[] args) {    User user = new User();    UserInfo userInfo = new UserInfo();    user.userInfo = userInfo;    System.out.println(user);    System.out.println(user.userInfo);    try {        User copy = (User) user.clone();        System.out.println(copy);        System.out.println(copy.userInfo);    } catch (CloneNotSupportedException e) {        e.printStackTrace();    }}//拷贝的User实例与原来不一样，是两个对象。//    com.javase.Class和Object.Object方法.用到的类.User@4dc63996//    com.javase.Class和Object.Object方法.用到的类.UserInfo@d716361        //而拷贝后对象的userinfo引用对象是同一个。    //所以这是浅拷贝//    com.javase.Class和Object.Object方法.用到的类.User@6ff3c5b5//    com.javase.Class和Object.Object方法.用到的类.UserInfo@d716361}</code></pre><p>总结：<br>clone方法实现的是浅拷贝，只拷贝当前对象，并且在堆中分配新的空间，放这个复制的对象。但是对象如果里面有其他类的子对象，那么就不会拷贝到新的对象中。</p><p>==深拷贝和浅拷贝的区别==</p><blockquote><p>浅拷贝<br>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。</p><p>深拷贝<br>深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。<br>现在为了要在clone对象时进行深拷贝， 那么就要Clonable接口，覆盖并实现clone方法，除了调用父类中的clone方法得到新的对象， 还要将该类中的引用变量也clone出来。如果只是用Object中默认的clone方法，是浅拷贝的。</p></blockquote><p>那么这两种方式有什么相同和不同呢？</p><blockquote><p>new操作符的本意是分配内存。程序执行到new操作符时， 首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。</p><p>分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。</p><p>而clone在第一步是和new相似的， 都是分配内存，调用clone方法时，分配的内存和源对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域，</p><p>填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。</p></blockquote><p>==也就是说，一个对象在浅拷贝以后，只是把对象复制了一份放在堆空间的另一个地方，但是成员变量如果有引用指向其他对象，这个引用指向的对象和被拷贝的对象中引用指向的对象是一样的。当然，基本数据类型还是会重新拷贝一份的。==</p><h3 id="getClass-方法"><a href="#getClass-方法" class="headerlink" title="getClass()方法"></a>getClass()方法</h3><p>4.public final native Class&lt;?&gt; getClass();</p><blockquote><p>getClass()也是一个native方法，返回的是此Object对象的类对象/运行时类对象Class&lt;?&gt;。效果与Object.class相同。</p><p>首先解释下”类对象”的概念：在Java中，类是是对具有一组相同特征或行为的实例的抽象并进行描述，对象则是此类所描述的特征或行为的具体实例。</p><p>作为概念层次的类，其本身也具有某些共同的特性，如都具有类名称、由类加载器去加载，都具有包，具有父类，属性和方法等。</p><p>于是，Java中有专门定义了一个类，Class，去描述其他类所具有的这些特性，因此，从此角度去看，类本身也都是属于Class类的对象。为与经常意义上的对象相区分，在此称之为”类对象”。</p></blockquote><pre><code>public class getClass方法 {    public static void main(String[] args) {        User user = new User();        //getclass方法是native方法，可以取到堆区唯一的Class&lt;User&gt;对象        Class&lt;?&gt; aClass = user.getClass();        Class bClass = User.class;        try {            Class cClass = Class.forName(&quot;com.javase.Class和Object.Object方法.用到的类.User&quot;);        } catch (ClassNotFoundException e) {            e.printStackTrace();        }        System.out.println(aClass);        System.out.println(bClass);//        class com.javase.Class和Object.Object方法.用到的类.User//        class com.javase.Class和Object.Object方法.用到的类.User        try {            User a = (User) aClass.newInstance();        } catch (InstantiationException e) {            e.printStackTrace();        } catch (IllegalAccessException e) {            e.printStackTrace();        }    }} </code></pre><p>此处主要大量涉及到Java中的反射知识</p><h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h3><p>5.public boolean equals(Object obj);</p><blockquote><p>与equals在Java中经常被使用，大家也都知道与equals的区别：</p><p>==表示的是变量值完成相同（对于基础类型，地址中存储的是值，引用类型则存储指向实际对象的地址）；</p><p>equals表示的是对象的内容完全相同，此处的内容多指对象的特征/属性。</p></blockquote><p>实际上，上面说法是不严谨的，更多的只是常见于String类中。首先看一下Object类中关于equals()方法的定义：</p><pre><code>public boolean equals(Object obj) {       return (this == obj);  }  </code></pre><blockquote><p>由此可见，Object原生的equals()方法内部调用的正是==，与==具有相同的含义。既然如此，为什么还要定义此equals()方法？</p><p>equals()方法的正确理解应该是：判断两个对象是否相等。那么判断对象相等的标尺又是什么？</p><p>如上，在object类中，此标尺即为==。当然，这个标尺不是固定的，其他类中可以按照实际的需要对此标尺含义进行重定义。如String类中则是依据字符串内容是否相等来重定义了此标尺含义。如此可以增加类的功能型和实际编码的灵活性。当然了，如果自定义的类没有重写equals()方法来重新定义此标尺，那么默认的将是其父类的equals()，直到object基类。</p><p>如下场景的实际业务需求，对于User bean，由实际的业务需求可知当属性uid相同时，表示的是同一个User，即两个User对象相等。则可以重写equals以重定义User对象相等的标尺。</p></blockquote><p>ObjectTest中打印出true，因为User类定义中重写了equals()方法，这很好理解，很可能张三是一个人小名，张三丰才是其大名，判断这两个人是不是同一个人，这时只用判断uid是否相同即可。</p><blockquote><p>如上重写equals方法表面上看上去是可以了，实则不然。因为它破坏了Java中的约定：重写equals()方法必须重写hasCode()方法。</p></blockquote><h3 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode()方法;"></a>hashCode()方法;</h3><ol start="6"><li>public native int hashCode()</li></ol><p>hashCode()方法返回一个整形数值，表示该对象的哈希码值。</p><p>hashCode()具有如下约定：</p><blockquote><p>1).在Java应用程序程序执行期间，对于同一对象多次调用hashCode()方法时，其返回的哈希码是相同的，前提是将对象进行equals比较时所用的标尺信息未做修改。在Java应用程序的一次执行到另外一次执行，同一对象的hashCode()返回的哈希码无须保持一致；</p><p>2).如果两个对象相等（依据：调用equals()方法），那么这两个对象调用hashCode()返回的哈希码也必须相等；</p><p>3).反之，两个对象调用hasCode()返回的哈希码相等，这两个对象不一定相等。</p></blockquote><pre><code>即严格的数学逻辑表示为： 两个对象相等 &lt;=&gt;  equals()相等  =&gt; hashCode()相等。因此，重写equlas()方法必须重写hashCode()方法，以保证此逻辑严格成立，同时可以推理出：hasCode()不相等 =&gt; equals（）不相等 &lt;=&gt; 两个对象不相等。可能有人在此产生疑问：既然比较两个对象是否相等的唯一条件（也是冲要条件）是equals，那么为什么还要弄出一个hashCode()，并且进行如此约定，弄得这么麻烦？其实，这主要体现在hashCode()方法的作用上，其主要用于增强哈希表的性能。以集合类中，以Set为例，当新加一个对象时，需要判断现有集合中是否已经存在与此对象相等的对象，如果没有hashCode()方法，需要将Set进行一次遍历，并逐一用equals()方法判断两个对象是否相等，此种算法时间复杂度为o(n)。通过借助于hasCode方法，先计算出即将新加入对象的哈希码，然后根据哈希算法计算出此对象的位置，直接判断此位置上是否已有对象即可。（注：Set的底层用的是Map的原理实现）</code></pre><blockquote><p>在此需要纠正一个理解上的误区：对象的hashCode()返回的不是对象所在的物理内存地址。甚至也不一定是对象的逻辑地址，hashCode()相同的两个对象，不一定相等，换言之，不相等的两个对象，hashCode()返回的哈希码可能相同。</p><p>因此，在上述代码中，重写了equals()方法后，需要重写hashCode()方法。</p></blockquote><pre><code>public class equals和hashcode方法 {    @Override    //修改equals时必须同时修改hashcode方法，否则在作为key时会出问题    public boolean equals(Object obj) {        return (this == obj);    }    @Override    //相同的对象必须有相同hashcode，不同对象可能有相同hashcode    public int hashCode() {        return hashCode() &gt;&gt; 2;    }}</code></pre><h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h3><p>7.public String toString();</p><pre><code>toString()方法返回该对象的字符串表示。先看一下Object中的具体方法体： public String toString() {      return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());  }  </code></pre><blockquote><p>toString()方法相信大家都经常用到，即使没有显式调用，但当我们使用System.out.println(obj)时，其内部也是通过toString()来实现的。</p><p>getClass()返回对象的类对象，getClassName()以String形式返回类对象的名称（含包名）。Integer.toHexString(hashCode())则是以对象的哈希码为实参，以16进制无符号整数形式返回此哈希码的字符串表示形式。</p><p>如上例中的u1的哈希码是638，则对应的16进制为27e，调用toString()方法返回的结果为：com.corn.objectsummary.User@27e。</p><p>因此：toString()是由对象的类型和其哈希码唯一确定，同一类型但不相等的两个对象分别调用toString()方法返回的结果可能相同。</p></blockquote><h3 id="wait-notify-notifAll"><a href="#wait-notify-notifAll" class="headerlink" title="wait() notify() notifAll()"></a>wait() notify() notifAll()</h3><p>8/9/10/11/12. wait(…) / notify() / notifyAll()</p><blockquote><p>一说到wait(…) / notify() | notifyAll()几个方法，首先想到的是线程。确实，这几个方法主要用于java多线程之间的协作。先具体看下这几个方法的主要含义：</p><p>wait()：调用此方法所在的当前线程等待，直到在其他线程上调用此方法的主调（某一对象）的notify()/notifyAll()方法。</p><p>wait(long timeout)/wait(long timeout, int nanos)：调用此方法所在的当前线程等待，直到在其他线程上调用此方法的主调（某一对象）的notisfy()/notisfyAll()方法，或超过指定的超时时间量。</p><p>notify()/notifyAll()：唤醒在此对象监视器上等待的单个线程/所有线程。</p><p>wait(…) / notify() | notifyAll()一般情况下都是配套使用。下面来看一个简单的例子：</p></blockquote><p>这是一个生产者消费者的模型，只不过这里只用flag来标识哪个线程需要工作</p><pre><code>public class wait和notify {    //volatile保证线程可见性    volatile static int flag = 1;    //object作为锁对象，用于线程使用wait和notify方法    volatile static Object o = new Object();    public static void main(String[] args) {        new Thread(new Runnable() {            @Override            public void run() {                //wait和notify只能在同步代码块内使用                synchronized (o) {                    while (true) {                        if (flag == 0) {                            try {                                Thread.sleep(2000);                                System.out.println(&quot;thread1 wait&quot;);                                //释放锁，线程挂起进入object的等待队列，后续代码运行                                o.wait();                            } catch (InterruptedException e) {                                e.printStackTrace();                            }                        }                        System.out.println(&quot;thread1 run&quot;);                        System.out.println(&quot;notify t2&quot;);                        flag = 0;                        //通知等待队列的一个线程获取锁                        o.notify();                    }                }            }        }).start();        //解释同上        new Thread(new Runnable() {            @Override            public void run() {                while (true) {                    synchronized (o) {                        if (flag == 1) {                            try {                                Thread.sleep(2000);                                System.out.println(&quot;thread2 wait&quot;);                                o.wait();                            } catch (InterruptedException e) {                                e.printStackTrace();                            }                        }                        System.out.println(&quot;thread2 run&quot;);                        System.out.println(&quot;notify t1&quot;);                        flag = 1;                        o.notify();                    }                }            }        }).start();    }    //输出结果是//    thread1 run//    notify t2//    thread1 wait//    thread2 run//    notify t1//    thread2 wait//    thread1 run//    notify t2//不断循环}</code></pre><blockquote><p> 从上述例子的输出结果中可以得出如下结论：</p><p>1、wait(…)方法调用后当前线程将立即阻塞，且适当其所持有的同步代码块中的锁，直到被唤醒或超时或打断后且重新获取到锁后才能继续执行；</p><p>2、notify()/notifyAll()方法调用后，其所在线程不会立即释放所持有的锁，直到其所在同步代码块中的代码执行完毕，此时释放锁，因此，如果其同步代码块后还有代码，其执行则依赖于JVM的线程调度。</p></blockquote><p>在Java源码中，可以看到wait()具体定义如下：</p><pre><code>public final void wait() throws InterruptedException {       wait(0);  }  </code></pre><blockquote><p>且wait(long timeout, int nanos)方法定义内部实质上也是通过调用wait(long timeout)完成。而wait(long timeout)是一个native方法。因此，wait(…)方法本质上都是native方式实现。</p></blockquote><p>notify()/notifyAll()方法也都是native方法。</p><p>Java中线程具有较多的知识点，是一块比较大且重要的知识点。后期会有博文专门针对Java多线程作出详细总结。此处不再细述。</p><h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h3><ol start="13"><li>protected void finalize();</li></ol><p>finalize方法主要与Java垃圾回收机制有关。首先我们看一下finalized方法在Object中的具体定义：</p><pre><code>protected void finalize() throws Throwable { }  </code></pre><blockquote><p>我们发现Object类中finalize方法被定义成一个空方法，为什么要如此定义呢？finalize方法的调用时机是怎么样的呢？</p><p>首先，Object中定义finalize方法表明Java中每一个对象都将具有finalize这种行为，其具体调用时机在：JVM准备对此对形象所占用的内存空间进行垃圾回收前，将被调用。由此可以看出，此方法并不是由我们主动去调用的（虽然可以主动去调用，此时与其他自定义方法无异）。</p></blockquote><h2 id="CLass类和Object类的关系"><a href="#CLass类和Object类的关系" class="headerlink" title="CLass类和Object类的关系"></a>CLass类和Object类的关系</h2><blockquote><p>Object类和Class类没有直接的关系。</p><p>Object类是一切java类的父类，对于普通的java类，即便不声明，也是默认继承了Object类。典型的，可以使用Object类中的toString()方法。</p><p>Class类是用于java反射机制的，一切java类，都有一个对应的Class对象，他是一个final类。Class 类的实例表示，正在运行的 Java 应用程序中的类和接口。</p></blockquote><p>转一个知乎很有趣的问题<br><a href="https://www.zhihu.com/question/30301819" target="_blank" rel="noopener">https://www.zhihu.com/question/30301819</a></p><pre><code>Java的对象模型中：1 所有的类都是Class类的实例，Object是类，那么Object也是Class类的一个实例。2 所有的类都最终继承自Object类，Class是类，那么Class也继承自Object。3 这就像是先有鸡还是先有蛋的问题，请问实际中JVM是怎么处理的？</code></pre><blockquote><p>这个问题中，第1个假设是错的：java.lang.Object是一个Java类，但并不是java.lang.Class的一个实例。后者只是一个用于描述Java类与接口的、用于支持反射操作的类型。这点上Java跟其它一些更纯粹的面向对象语言（例如Python和Ruby）不同。</p><p>而第2个假设是对的：java.lang.Class是java.lang.Object的派生类，前者继承自后者。虽然第1个假设不对，但“鸡蛋问题”仍然存在：在一个已经启动完毕、可以使用的Java对象系统里，必须要有一个java.lang.Class实例对应java.lang.Object这个类；而java.lang.Class是java.lang.Object的派生类，按“一般思维”前者应该要在后者完成初始化之后才可以初始化…</p><p>事实是：这些相互依赖的核心类型完全可以在“混沌”中一口气都初始化好，然后对象系统的状态才叫做完成了“bootstrap”，后面就可以按照Java对象系统的一般规则去运行。JVM、JavaScript、Python、Ruby等的运行时都有这样的bootstrap过程。</p><p>在“混沌”（boostrap过程）里，JVM可以为对象系统中最重要的一些核心类型先分配好内存空间，让它们进入[已分配空间]但[尚未完全初始化]状态。此时这些对象虽然已经分配了空间，但因为状态还不完整所以尚不可使用。</p><p>然后，通过这些分配好的空间把这些核心类型之间的引用关系串好。到此为止所有动作都由JVM完成，尚未执行任何Java字节码。然后这些核心类型就进入了[完全初始化]状态，对象系统就可以开始自我运行下去，也就是可以开始执行Java字节码来进一步完成Java系统的初始化了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文对java的Class类和Object类的概念和原理做了详尽的介绍，并且详细介绍了Object的各种方法，以及这两个类之间的关系。&lt;/p&gt;
&lt;p&gt;Class类和Object类是Java中最根本最重要的两个类，理解它们是理解Java面向对象技术的基础，也是学习所有进阶Java技术的基石。&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/04/30/javase12&quot;&gt;https://h2pl.github.io/2018/04/30/javase12&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java基础" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础11：Java泛型详解</title>
    <link href="http://h2pl.github.io/2018/04/29/javase11/"/>
    <id>http://h2pl.github.io/2018/04/29/javase11/</id>
    <published>2018-04-29T12:13:10.000Z</published>
    <updated>2018-06-01T03:49:38.285Z</updated>
    
    <content type="html"><![CDATA[<p>本文对java的泛型的概念和使用做了详尽的介绍。</p><p>具体代码在我的GitHub中可以找到</p><blockquote><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p></blockquote><p>喜欢的话麻烦点下星哈</p><p>文章首发于我的个人博客：</p><blockquote><p><a href="https://h2pl.github.io/2018/04/29/javase11">https://h2pl.github.io/2018/04/29/javase11</a></p></blockquote><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：</p><blockquote><p><a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a></p></blockquote><a id="more"></a><p>本文参考<a href="https://blog.csdn.net/s10461/article/details/53941091" target="_blank" rel="noopener">https://blog.csdn.net/s10461/article/details/53941091</a></p><h2 id="泛型概述"><a href="#泛型概述" class="headerlink" title="泛型概述"></a>泛型概述</h2><p>泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。</p><p>什么是泛型？为什么要使用泛型？</p><blockquote><p>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p><p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p></blockquote><h2 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h2><p>一个被举了无数次的例子：</p><pre><code>List arrayList = new ArrayList();arrayList.add(&quot;aaaa&quot;);arrayList.add(100);for(int i = 0; i&lt; arrayList.size();i++){    String item = (String)arrayList.get(i);    Log.d(&quot;泛型测试&quot;,&quot;item = &quot; + item);}</code></pre><p>毫无疑问，程序的运行结果会以崩溃结束：</p><p>java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</p><p>ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。</p><p>我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。</p><p>List<string> arrayList = new ArrayList<string>();<br>…<br>//arrayList.add(100); 在编译阶段，编译器就会报错</string></string></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>泛型只在编译阶段有效。看下面的代码：</p><pre><code>List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;();List&lt;Integer&gt; integerArrayList = new ArrayList&lt;Integer&gt;();Class classStringArrayList = stringArrayList.getClass();Class classIntegerArrayList = integerArrayList.getClass();if(classStringArrayList.equals(classIntegerArrayList)){    Log.d(&quot;泛型测试&quot;,&quot;类型相同&quot;);}</code></pre><blockquote><p>通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p></blockquote><p>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</p><p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法</p><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><blockquote><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。</p><p>泛型类的最基本写法（这么看可能会有点晕，会在下面的例子中详解）：</p></blockquote><pre><code>class 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;{  private 泛型标识 /*（成员变量类型）*/ var;   .....  }</code></pre><p>一个最普通的泛型类：</p><p>//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</p><pre><code>//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt;{    //在类中声明的泛型整个类里面都可以用，除了静态部分，因为泛型是实例化时声明的。    //静态区域的代码在编译时就已经确定，只与类相关    class A &lt;E&gt;{        T t;    }    //类里面的方法或类中再次声明同名泛型是允许的，并且该泛型会覆盖掉父类的同名泛型T    class B &lt;T&gt;{        T t;    }    //静态内部类也可以使用泛型，实例化时赋予泛型实际类型    static class C &lt;T&gt; {        T t;    }    public static void main(String[] args) {        //报错，不能使用T泛型，因为泛型T属于实例不属于类//        T t = null;    }    //key这个成员变量的类型为T,T的类型由外部指定    private T key;    public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定        this.key = key;    }    public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定        return key;    }}</code></pre><blockquote><p>12-27 09:20:04.432 13063-13063/? D/泛型测试: key is 123456</p></blockquote><blockquote><p>12-27 09:20:04.432 13063-13063/? D/泛型测试: key is key_vlaue</p></blockquote><blockquote><p>定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</p></blockquote><p>看一个例子：</p><pre><code>Generic generic = new Generic(&quot;111111&quot;);Generic generic1 = new Generic(4444);Generic generic2 = new Generic(55.55);Generic generic3 = new Generic(false);Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic.getKey());Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic1.getKey());Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic2.getKey());Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic3.getKey());D/泛型测试: key is 111111D/泛型测试: key is 4444D/泛型测试: key is 55.55D/泛型测试: key is false</code></pre><p>注意：<br>泛型的类型参数只能是类类型，不能是简单类型。<br>不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。<br>        if(ex_num instanceof Generic<number>){<br>        } </number></p><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子：</p><pre><code>//定义一个泛型接口public interface Generator&lt;T&gt; {    public T next();}</code></pre><p>当实现泛型接口的类，未传入泛型实参时：</p><pre><code>/** * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中 * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;{ * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot; */class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;{    @Override    public T next() {        return null;    }}</code></pre><p>当实现泛型接口的类，传入泛型实参时：</p><pre><code>/** * 传入泛型实参时： * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt; * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。 * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型 * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。 */public class FruitGenerator implements Generator&lt;String&gt; {    private String[] fruits = new String[]{&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;};    @Override    public String next() {        Random rand = new Random();        return fruits[rand.nextInt(3)];    }}</code></pre><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>我们知道Ingeter是Number的一个子类，同时在特性章节中我们也验证过Generic<ingeter>与Generic<number>实际上是相同的一种基本类型。那么问题来了，在使用Generic<number>作为形参的方法中，能否使用Generic<ingeter>的实例传入呢？在逻辑上类似于Generic<number>和Generic<ingeter>是否可以看成具有父子关系的泛型类型呢？</ingeter></number></ingeter></number></number></ingeter></p><p>为了弄清楚这个问题，我们使用Generic<t>这个泛型类继续看下面的例子：</t></p><pre><code>public void showKeyValue1(Generic&lt;Number&gt; obj){    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());}Generic&lt;Integer&gt; gInteger = new Generic&lt;Integer&gt;(123);Generic&lt;Number&gt; gNumber = new Generic&lt;Number&gt;(456);showKeyValue(gNumber);// showKeyValue这个方法编译器会为我们报错：Generic&lt;java.lang.Integer&gt; // cannot be applied to Generic&lt;java.lang.Number&gt;// showKeyValue(gInteger);</code></pre><p>通过提示信息我们可以看到Generic<integer>不能被看作为`Generic<number>的子类。由此可以看出:同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。</number></integer></p><p>回到上面的例子，如何解决上面的问题？总不能为了定义一个新的方法来处理Generic<integer>类型的类，这显然与java中的多台理念相违背。因此我们需要一个在逻辑上可以表示同时是Generic<integer>和Generic<number>父类的引用类型。由此类型通配符应运而生。</number></integer></integer></p><p>我们可以将上面的方法改一下：</p><pre><code>public void showKeyValue1(Generic&lt;?&gt; obj){    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</code></pre><p>类型通配符一般是使用？代替具体的类型实参，注意， 此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。</p><p>可以解决当具体类型不确定的时候，这个通配符就是 ?  ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型</p><p>public void showKeyValue(Generic<number> obj){<br>        System.out.println(obj);<br>    }</number></p><pre><code>Generic&lt;Integer&gt; gInteger = new Generic&lt;Integer&gt;(123);Generic&lt;Number&gt; gNumber = new Generic&lt;Number&gt;(456);public void test () {//        showKeyValue(gInteger);该方法会报错    showKeyValue1(gInteger);}public void showKeyValue1(Generic&lt;?&gt; obj) {    System.out.println(obj);}// showKeyValue这个方法编译器会为我们报错：Generic&lt;java.lang.Integer&gt;// cannot be applied to Generic&lt;java.lang.Number&gt;// showKeyValue(gInteger);</code></pre><p>。</p><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>在java中,泛型类的定义非常简单，但是泛型方法就比较复杂了。</p><p>尤其是我们见到的大多数泛型类中的成员方法也都使用了泛型，有的甚至泛型类中也包含着泛型方法，这样在初学者中非常容易将泛型方法理解错了。<br>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。</p><pre><code>/** * 泛型方法的基本介绍 * @param tClass 传入的泛型实参 * @return T 返回值为T类型 * 说明： *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。 *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。 *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。 *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。 */    public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException ,      IllegalAccessException{            T instance = tClass.newInstance();            return instance;    }Object obj = genericMethod(Class.forName(&quot;com.test.test&quot;));</code></pre><h2 id="泛型方法的基本用法"><a href="#泛型方法的基本用法" class="headerlink" title="泛型方法的基本用法"></a>泛型方法的基本用法</h2><p>光看上面的例子有的同学可能依然会非常迷糊，我们再通过一个例子，把我泛型方法再总结一下。</p><pre><code>/**  * 这才是一个真正的泛型方法。 * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T * 这个T可以出现在这个泛型方法的任意位置. * 泛型的数量也可以为任意多个  *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container){ *        ... *        } */    public class 泛型方法 {    @Test    public void test() {        test1();        test2(new Integer(2));        test3(new int[3],new Object());        //打印结果//        null//        2//        [I@3d8c7aca//        java.lang.Object@5ebec15    }    //该方法使用泛型T    public &lt;T&gt; void test1() {        T t = null;        System.out.println(t);    }    //该方法使用泛型T    //并且参数和返回值都是T类型    public &lt;T&gt; T test2(T t) {        System.out.println(t);        return t;    }    //该方法使用泛型T,E    //参数包括T,E    public &lt;T, E&gt; void test3(T t, E e) {        System.out.println(t);        System.out.println(e);    }}</code></pre><h2 id="类中的泛型方法"><a href="#类中的泛型方法" class="headerlink" title="类中的泛型方法"></a>类中的泛型方法</h2><p>当然这并不是泛型方法的全部，泛型方法可以出现杂任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，我们再通过一个例子看一下</p><pre><code>//注意泛型类先写类名再写泛型，泛型方法先写泛型再写方法名//类中声明的泛型在成员和方法中可用class A &lt;T, E&gt;{    {        T t1 ;    }    A (T t){        this.t = t;    }    T t;    public void test1() {        System.out.println(this.t);    }    public void test2(T t,E e) {        System.out.println(t);        System.out.println(e);    }}@Testpublic void run () {    A &lt;Integer,String &gt; a = new A&lt;&gt;(1);    a.test1();    a.test2(2,&quot;ds&quot;);//        1//        2//        ds}static class B &lt;T&gt;{    T t;    public void go () {        System.out.println(t);    }}</code></pre><h2 id="泛型方法与可变参数"><a href="#泛型方法与可变参数" class="headerlink" title="泛型方法与可变参数"></a>泛型方法与可变参数</h2><p>再看一个泛型方法和可变参数的例子：</p><pre><code>public class 泛型和可变参数 {    @Test    public void test () {        printMsg(&quot;dasd&quot;,1,&quot;dasd&quot;,2.0,false);        print(&quot;dasdas&quot;,&quot;dasdas&quot;, &quot;aa&quot;);    }    //普通可变参数只能适配一种类型    public void print(String ... args) {        for(String t : args){            System.out.println(t);        }    }    //泛型的可变参数可以匹配所有类型的参数。。有点无敌    public &lt;T&gt; void printMsg( T... args){        for(T t : args){            System.out.println(t);        }    }        //打印结果：    //dasd    //1    //dasd    //2.0    //false}</code></pre><h2 id="静态方法与泛型"><a href="#静态方法与泛型" class="headerlink" title="静态方法与泛型"></a>静态方法与泛型</h2><p>静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。</p><p>即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。</p><pre><code>public class StaticGenerator&lt;T&gt; {    ....    ....    /**     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。     * 如：public static void show(T t){..},此时编译器会提示错误信息：          &quot;StaticGenerator cannot be refrenced from static context&quot;     */    public static &lt;T&gt; void show(T t){    }}</code></pre><h2 id="泛型方法总结"><a href="#泛型方法总结" class="headerlink" title="泛型方法总结"></a>泛型方法总结</h2><p>泛型方法能使方法独立于类而产生变化，以下是一个基本的指导原则：</p><p>无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。所以如果static方法要使用泛型能力，就必须使其成为泛型方法。</p><h2 id="泛型上下边界"><a href="#泛型上下边界" class="headerlink" title="泛型上下边界"></a>泛型上下边界</h2><p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。</p><p>为泛型添加上边界，即传入的类型实参必须是指定类型的子类型</p><pre><code>public class 泛型通配符与边界 {    public void showKeyValue(Generic&lt;Number&gt; obj){        System.out.println(&quot;key value is &quot; + obj.getKey());    }    @Test    public void main() {        Generic&lt;Integer&gt; gInteger = new Generic&lt;Integer&gt;(123);        Generic&lt;Number&gt; gNumber = new Generic&lt;Number&gt;(456);        showKeyValue(gNumber);        //泛型中的子类也无法作为父类引用传入//        showKeyValue(gInteger);    }    //直接使用？通配符可以接受任何类型作为泛型传入    public void showKeyValueYeah(Generic&lt;?&gt; obj) {        System.out.println(obj);    }    //只能传入number的子类或者number    public void showKeyValue1(Generic&lt;? extends Number&gt; obj){        System.out.println(obj);    }    //只能传入Integer的父类或者Integer    public void showKeyValue2(Generic&lt;? super Integer&gt; obj){        System.out.println(obj);    }    @Test    public void testup () {        //这一行代码编译器会提示错误，因为String类型并不是Number类型的子类        //showKeyValue1(generic1);        Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;(&quot;11111&quot;);        Generic&lt;Integer&gt; generic2 = new Generic&lt;Integer&gt;(2222);        Generic&lt;Float&gt; generic3 = new Generic&lt;Float&gt;(2.4f);        Generic&lt;Double&gt; generic4 = new Generic&lt;Double&gt;(2.56);        showKeyValue1(generic2);        showKeyValue1(generic3);        showKeyValue1(generic4);    }    @Test    public void testdown () {        Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;(&quot;11111&quot;);        Generic&lt;Integer&gt; generic2 = new Generic&lt;Integer&gt;(2222);        Generic&lt;Number&gt; generic3 = new Generic&lt;Number&gt;(2);//        showKeyValue2(generic1);本行报错，因为String并不是Integer的父类        showKeyValue2(generic2);        showKeyValue2(generic3);    }}</code></pre><p>== 关于泛型数组要提一下 ==</p><p>看到了很多文章中都会提起泛型数组，经过查看sun的说明文档，在java中是”不能创建一个确切的泛型类型的数组”的。</p><pre><code>也就是说下面的这个例子是不可以的：List&lt;String&gt;[] ls = new ArrayList&lt;String&gt;[10];  而使用通配符创建泛型数组是可以的，如下面这个例子：List&lt;?&gt;[] ls = new ArrayList&lt;?&gt;[10];  这样也是可以的：List&lt;String&gt;[] ls = new ArrayList[10];</code></pre><p>下面使用Sun的一篇文档的一个例子来说明这个问题：</p><pre><code>List&lt;String&gt;[] lsa = new List&lt;String&gt;[10]; // Not really allowed.    Object o = lsa;    Object[] oa = (Object[]) o;    List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;();    li.add(new Integer(3));    oa[1] = li; // Unsound, but passes run time store check    String s = lsa[1].get(0); // Run-time error: ClassCastException.</code></pre><blockquote><p>这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。</p><p>而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。<br>下面采用通配符的方式是被允许的:数组的类型不可以是类型变量，除非是采用通配符的方式，因为对于通配符的方式，最后取出数据是要做显式的类型转换的。</p></blockquote><pre><code>List&lt;?&gt;[] lsa = new List&lt;?&gt;[10]; // OK, array of unbounded wildcard type.    Object o = lsa;    Object[] oa = (Object[]) o;    List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;();    li.add(new Integer(3));    oa[1] = li; // Correct.    Integer i = (Integer) lsa[1].get(0); // OK </code></pre><p>最后</p><p>本文中的例子主要是为了阐述泛型中的一些思想而简单举出的，并不一定有着实际的可用性。另外，一提到泛型，相信大家用到最多的就是在集合中，其实，在实际的编程过程中，自己可以使用泛型去简化开发，且能很好的保证代码质量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文对java的泛型的概念和使用做了详尽的介绍。&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下星哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/04/29/javase11&quot;&gt;https://h2pl.github.io/2018/04/29/javase11&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java基础" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java泛型" scheme="http://h2pl.github.io/tags/Java%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java基础10：全面解读Java异常</title>
    <link href="http://h2pl.github.io/2018/04/27/javase10/"/>
    <id>http://h2pl.github.io/2018/04/27/javase10/</id>
    <published>2018-04-27T15:07:26.000Z</published>
    <updated>2018-06-01T03:49:31.797Z</updated>
    
    <content type="html"><![CDATA[<p>本文非常详尽地介绍了Java中的异常，几乎360度无死角。</p><p>从异常的概念，分类，使用方法，注意事项和设计等方面全面地介绍了Java异常。</p><p>具体代码在我的GitHub中可以找到</p><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p><p>喜欢的话麻烦点下星哈</p><p>文章首发于我的个人博客：</p><p><a href="https://h2pl.github.io/2018/04/27/javase10">https://h2pl.github.io/2018/04/27/javase10</a></p><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：<a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a></p><a id="more"></a><h2 id="为什么要使用异常"><a href="#为什么要使用异常" class="headerlink" title="为什么要使用异常"></a>为什么要使用异常</h2><blockquote><p>  首先我们可以明确一点就是异常的处理机制可以确保我们程序的健壮性，提高系统可用率。虽然我们不是特别喜欢看到它，但是我们不能不承认它的地位，作用。</p></blockquote><p>在没有异常机制的时候我们是这样处理的：通过函数的返回值来判断是否发生了异常（这个返回值通常是已经约定好了的），调用该函数的程序负责检查并且分析返回值。虽然可以解决异常问题，但是这样做存在几个缺陷：</p><blockquote><p>  1、 容易混淆。如果约定返回值为-11111时表示出现异常，那么当程序最后的计算结果真的为-1111呢？</p><p>  2、 代码可读性差。将异常处理代码和程序代码混淆在一起将会降低代码的可读性。</p><p>  3、 由调用函数来分析异常，这要求程序员对库函数有很深的了解。</p></blockquote><p> 在OO中提供的异常处理机制是提供代码健壮的强有力的方式。使用异常机制它能够降低错误处理代码的复杂度，如果不使用异常，那么就必须检查特定的错误，并在程序中的许多地方去处理它。</p><p>而如果使用异常，那就不必在方法调用处进行检查，因为异常机制将保证能够捕获这个错误，并且，只需在一个地方处理错误，即所谓的异常处理程序中。</p><p>这种方式不仅节约代码，而且把“概述在正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离。总之，与以前的错误处理方法相比，异常机制使代码的阅读、编写和调试工作更加井井有条。（摘自《Think in java 》）。</p><p>该部分内容选自<a href="http://www.cnblogs.com/chenssy/p/3438130.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenssy/p/3438130.html</a></p><h2 id="异常基本定义"><a href="#异常基本定义" class="headerlink" title="异常基本定义"></a>异常基本定义</h2><blockquote><p>  在《Think in java》中是这样定义异常的：异常情形是指阻止当前方法或者作用域继续执行的问题。在这里一定要明确一点：异常代码某种程度的错误，尽管Java有异常处理机制，但是我们不能以“正常”的眼光来看待异常，异常处理机制的原因就是告诉你：这里可能会或者已经产生了错误，您的程序出现了不正常的情况，可能会导致程序失败！</p></blockquote><blockquote><p>  那么什么时候才会出现异常呢？只有在你当前的环境下程序无法正常运行下去，也就是说程序已经无法来正确解决问题了，这时它所就会从当前环境中跳出，并抛出异常。抛出异常后，它首先会做几件事。</p></blockquote><blockquote><p>首先，它会使用new创建一个异常对象，然后在产生异常的位置终止程序，并且从当前环境中弹出对异常对象的引用，这时。异常处理机制就会接管程序，并开始寻找一个恰当的地方来继续执行程序，这个恰当的地方就是异常处理程序。</p></blockquote><blockquote><p> 总的来说异常处理机制就是当程序发生异常时，它强制终止程序运行，记录异常信息并将这些信息反馈给我们，由我们来确定是否处理异常。</p></blockquote><h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><p><img src="https://images0.cnblogs.com/blog/381060/201311/22185952-834d92bc2bfe498f9a33414cc7a2c8a4.png" alt="image"></p><p>从上面这幅图可以看出，Throwable是java语言中所有错误和异常的超类（万物即可抛）。它有两个子类：Error、Exception。</p><p>Java标准库内建了一些通用的异常，这些类以Throwable为顶层父类。</p><p>Throwable又派生出Error类和Exception类。</p><p>错误：Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。因此，程序员应该关注Exception为父类的分支下的各种异常类。</p><p>异常：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。</p><p>总体上我们根据Javac对异常的处理要求，将异常类分为2类。</p><blockquote><p>非检查异常（unckecked exception）：Error 和 RuntimeException 以及他们的子类。javac在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用try…catch…finally）这样的异常，也可以不处理。</p></blockquote><blockquote><p>对于这些异常，我们应该修正代码，而不是去通过异常处理器处理 。这样的异常发生的原因多半是代码写的有问题。如除0错误ArithmeticException，错误的强制类型转换错误ClassCastException，数组索引越界ArrayIndexOutOfBoundsException，使用了空对象NullPointerException等等。</p></blockquote><blockquote><p>检查异常（checked exception）：除了Error 和 RuntimeException的其它异常。javac强制要求程序员为这样的异常做预备处理工作（使用try…catch…finally或者throws）。在方法中要么用try-catch语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。</p></blockquote><blockquote><p>这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。如SQLException , IOException,ClassNotFoundException 等。</p></blockquote><p>需要明确的是：检查和非检查是对于javac来说的，这样就很好理解和区分了。</p><p>这部分内容摘自<a href="http://www.importnew.com/26613.html" target="_blank" rel="noopener">http://www.importnew.com/26613.html</a></p><h2 id="初识异常"><a href="#初识异常" class="headerlink" title="初识异常"></a>初识异常</h2><p>异常是在执行某个函数时引发的，而函数又是层级调用，形成调用栈的，因为，只要一个函数发生了异常，那么他的所有的caller都会被异常影响。当这些被影响的函数以异常信息输出时，就形成的了异常追踪栈。</p><p>异常最先发生的地方，叫做异常抛出点。</p><pre><code>public class 异常 {    public static void main (String [] args )    {        System . out. println( &quot;----欢迎使用命令行除法计算器----&quot; ) ;        CMDCalculate ();    }    public static void CMDCalculate ()    {        Scanner scan = new Scanner ( System. in );        int num1 = scan .nextInt () ;        int num2 = scan .nextInt () ;        int result = devide (num1 , num2 ) ;        System . out. println( &quot;result:&quot; + result) ;        scan .close () ;    }    public static int devide (int num1, int num2 ){        return num1 / num2 ;    }//    ----欢迎使用命令行除法计算器----//            1//            0//    Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero//    at com.javase.异常.异常.devide(异常.java:24)//    at com.javase.异常.异常.CMDCalculate(异常.java:19)//    at com.javase.异常.异常.main(异常.java:12)//  ----欢迎使用命令行除法计算器----//    r//    Exception in thread &quot;main&quot; java.util.InputMismatchException//    at java.util.Scanner.throwFor(Scanner.java:864)//    at java.util.Scanner.next(Scanner.java:1485)//    at java.util.Scanner.nextInt(Scanner.java:2117)//    at java.util.Scanner.nextInt(Scanner.java:2076)//    at com.javase.异常.异常.CMDCalculate(异常.java:17)//    at com.javase.异常.异常.main(异常.java:12)</code></pre><p><img src="http://incdn1.b0.upaiyun.com/2017/09/0b3e4ca2f4cf8d7116c7ad354940601f.png" alt="image"></p><p>从上面的例子可以看出，当devide函数发生除0异常时，devide函数将抛出ArithmeticException异常，因此调用他的CMDCalculate函数也无法正常完成，因此也发送异常，而CMDCalculate的caller——main 因为CMDCalculate抛出异常，也发生了异常，这样一直向调用栈的栈底回溯。</p><p>这种行为叫做异常的冒泡，异常的冒泡是为了在当前发生异常的函数或者这个函数的caller中找到最近的异常处理程序。由于这个例子中没有使用任何异常处理机制，因此异常最终由main函数抛给JRE，导致程序终止。</p><blockquote><p>上面的代码不使用异常处理机制，也可以顺利编译，因为2个异常都是非检查异常。但是下面的例子就必须使用异常处理机制，因为异常是检查异常。</p></blockquote><p>代码中我选择使用throws声明异常，让函数的调用者去处理可能发生的异常。但是为什么只throws了IOException呢？因为FileNotFoundException是IOException的子类，在处理范围内。</p><h2 id="异常和错误"><a href="#异常和错误" class="headerlink" title="异常和错误"></a>异常和错误</h2><p>下面看一个例子</p><pre><code>//错误即error一般指jvm无法处理的错误//异常是Java定义的用于简化错误处理流程和定位错误的一种工具。public class 错误和错误 {    Error error = new Error();    public static void main(String[] args) {        throw new Error();    }    //下面这四个异常或者错误有着不同的处理方法    public void error1 (){        //编译期要求必须处理，因为这个异常是最顶层异常，包括了检查异常，必须要处理        try {            throw new Throwable();        } catch (Throwable throwable) {            throwable.printStackTrace();        }    }    //Exception也必须处理。否则报错，因为检查异常都继承自exception，所以默认需要捕捉。    public void error2 (){        try {            throw new Exception();        } catch (Exception e) {            e.printStackTrace();        }    }    //error可以不处理，编译不报错,原因是虚拟机根本无法处理，所以啥都不用做    public void error3 (){        throw new Error();    }    //runtimeexception众所周知编译不会报错    public void error4 (){        throw new RuntimeException();    }//    Exception in thread &quot;main&quot; java.lang.Error//    at com.javase.异常.错误.main(错误.java:11)}</code></pre><h2 id="异常的处理方式"><a href="#异常的处理方式" class="headerlink" title="异常的处理方式"></a>异常的处理方式</h2><p>在编写代码处理异常时，对于检查异常，有2种不同的处理方式：</p><blockquote><p>使用try…catch…finally语句块处理它。</p></blockquote><blockquote><p>或者，在函数签名中使用throws 声明交给函数调用者caller去解决。</p></blockquote><p>下面看几个具体的例子，包括error，exception和throwable</p><p>上面的例子是运行时异常，不需要显示捕获。<br>下面这个例子是可检查异常需，要显示捕获或者抛出。</p><pre><code>@Testpublic void testException() throws IOException{    //FileInputStream的构造函数会抛出FileNotFoundException    FileInputStream fileIn = new FileInputStream(&quot;E:\\a.txt&quot;);    int word;    //read方法会抛出IOException    while((word =  fileIn.read())!=-1)    {        System.out.print((char)word);    }    //close方法会抛出IOException    fileIn.close();}</code></pre><p>一般情况下的处理方式 try catch finally</p><pre><code>public class 异常处理方式 {@Testpublic void main() {    try{        //try块中放可能发生异常的代码。        InputStream inputStream = new FileInputStream(&quot;a.txt&quot;);        //如果执行完try且不发生异常，则接着去执行finally块和finally后面的代码（如果有的话）。        int i = 1/0;        //如果发生异常，则尝试去匹配catch块。        throw new SQLException();        //使用1.8jdk同时捕获多个异常，runtimeexception也可以捕获。只是捕获后虚拟机也无法处理，所以不建议捕获。    }catch(SQLException | IOException | ArrayIndexOutOfBoundsException exception){        System.out.println(exception.getMessage());        //每一个catch块用于捕获并处理一个特定的异常，或者这异常类型的子类。Java7中可以将多个异常声明在一个catch中。        //catch后面的括号定义了异常类型和异常参数。如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个catch块来处理异常。        //在catch块中可以使用这个块的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问。        //如果当前try块中发生的异常在后续的所有catch中都没捕获到，则先去执行finally，然后到这个函数的外部caller中去匹配异常处理器。        //如果try中没有发生异常，则所有的catch块将被忽略。    }catch(Exception exception){        System.out.println(exception.getMessage());        //...    }finally{        //finally块通常是可选的。        //无论异常是否发生，异常是否匹配被处理，finally都会执行。        //finally主要做一些清理工作，如流的关闭，数据库连接的关闭等。    }</code></pre><p>一个try至少要跟一个catch或者finally</p><pre><code>    try {        int i = 1;    }finally {        //一个try至少要有一个catch块，否则， 至少要有1个finally块。但是finally不是用来处理异常的，finally不会捕获异常。    }}</code></pre><p>异常出现时该方法后面的代码不会运行，即使异常已经被捕获。这里举出一个奇特的例子，在catch里再次使用try catch finally</p><pre><code>@Testpublic void test() {    try {        throwE();        System.out.println(&quot;我前面抛出异常了&quot;);        System.out.println(&quot;我不会执行了&quot;);    } catch (StringIndexOutOfBoundsException e) {        System.out.println(e.getCause());    }catch (Exception ex) {    //在catch块中仍然可以使用try catch finally        try {            throw new Exception();        }catch (Exception ee) {        }finally {            System.out.println(&quot;我所在的catch块没有执行，我也不会执行的&quot;);        }    }}//在方法声明中抛出的异常必须由调用方法处理或者继续往上抛，// 当抛到jre时由于无法处理终止程序public void throwE (){//        Socket socket = new Socket(&quot;127.0.0.1&quot;, 80);        //手动抛出异常时，不会报错，但是调用该方法的方法需要处理这个异常，否则会出错。//        java.lang.StringIndexOutOfBoundsException//        at com.javase.异常.异常处理方式.throwE(异常处理方式.java:75)//        at com.javase.异常.异常处理方式.test(异常处理方式.java:62)        throw new StringIndexOutOfBoundsException();    }</code></pre><p>其实有的语言在遇到异常后仍然可以继续运行</p><blockquote><p>有的编程语言当异常被处理后，控制流会恢复到异常抛出点接着执行，这种策略叫做：resumption model of exception handling（恢复式异常处理模式 ）</p><p>而Java则是让执行流恢复到处理了异常的catch块后接着执行，这种策略叫做：termination model of exception handling（终结式异常处理模式）</p></blockquote><h2 id="“不负责任”的throws"><a href="#“不负责任”的throws" class="headerlink" title="“不负责任”的throws"></a>“不负责任”的throws</h2><p>throws是另一种处理异常的方式，它不同于try…catch…finally，throws仅仅是将函数中可能出现的异常向调用者声明，而自己则不具体处理。</p><p>采取这种异常处理的原因可能是：方法本身不知道如何处理这样的异常，或者说让调用者处理更好，调用者需要为可能发生的异常负责。</p><pre><code>public void foo() throws ExceptionType1 , ExceptionType2 ,ExceptionTypeN{      //foo内部可以抛出 ExceptionType1 , ExceptionType2 ,ExceptionTypeN 类的异常，或者他们的子类的异常对象。}</code></pre><h2 id="纠结的finally"><a href="#纠结的finally" class="headerlink" title="纠结的finally"></a>纠结的finally</h2><p>finally块不管异常是否发生，只要对应的try执行了，则它一定也执行。只有一种方法让finally块不执行：System.exit()。因此finally块通常用来做资源释放操作：关闭文件，关闭数据库连接等等。</p><p>良好的编程习惯是：在try块中打开资源，在finally块中清理释放这些资源。</p><p>需要注意的地方:</p><p>1、finally块没有处理异常的能力。处理异常的只能是catch块。</p><p>2、在同一try…catch…finally块中 ，如果try中抛出异常，且有匹配的catch块，则先执行catch块，再执行finally块。如果没有catch块匹配，则先执行finally，然后去外面的调用者中寻找合适的catch块。</p><p>3、在同一try…catch…finally块中 ，try发生异常，且匹配的catch块中处理异常时也抛出异常，那么后面的finally也会执行：首先执行finally块，然后去外围调用者中寻找合适的catch块。</p><pre><code>public class finally使用 {    public static void main(String[] args) {        try {            throw new IllegalAccessException();        }catch (IllegalAccessException e) {            // throw new Throwable();            //此时如果再抛异常，finally无法执行，只能报错。            //finally无论何时都会执行            //除非我显示调用。此时finally才不会执行            System.exit(0);        }finally {            System.out.println(&quot;算你狠&quot;);        }    }}</code></pre><h2 id="throw-JRE也使用的关键字"><a href="#throw-JRE也使用的关键字" class="headerlink" title="throw : JRE也使用的关键字"></a>throw : JRE也使用的关键字</h2><p>throw exceptionObject</p><p>程序员也可以通过throw语句手动显式的抛出一个异常。throw语句的后面必须是一个异常对象。</p><p>throw 语句必须写在函数中，执行throw 语句的地方就是一个异常抛出点，==它和由JRE自动形成的异常抛出点没有任何差别。==</p><pre><code>public void save(User user){      if(user  == null)           throw new IllegalArgumentException(&quot;User对象为空&quot;);      //......}</code></pre><p>后面开始的大部分内容都摘自<a href="http://www.cnblogs.com/lulipro/p/7504267.html" target="_blank" rel="noopener">http://www.cnblogs.com/lulipro/p/7504267.html</a></p><p>该文章写的十分细致到位，令人钦佩，是我目前为之看到关于异常最详尽的文章，可以说是站在巨人的肩膀上了。</p><h2 id="异常调用链"><a href="#异常调用链" class="headerlink" title="异常调用链"></a>异常调用链</h2><p>异常的链化</p><p>在一些大型的，模块化的软件开发中，一旦一个地方发生异常，则如骨牌效应一样，将导致一连串的异常。假设B模块完成自己的逻辑需要调用A模块的方法，如果A模块发生异常，则B也将不能完成而发生异常。</p><p>==但是B在抛出异常时，会将A的异常信息掩盖掉，这将使得异常的根源信息丢失。异常的链化可以将多个模块的异常串联起来，使得异常信息不会丢失。==</p><blockquote><p>异常链化:以一个异常对象为参数构造新的异常对象。新的异对象将包含先前异常的信息。这项技术主要是异常类的一个带Throwable参数的函数来实现的。这个当做参数的异常，我们叫他根源异常（cause）。</p></blockquote><p>查看Throwable类源码，可以发现里面有一个Throwable字段cause，就是它保存了构造时传递的根源异常参数。这种设计和链表的结点类设计如出一辙，因此形成链也是自然的了。</p><pre><code>public class Throwable implements Serializable {    private Throwable cause = this;    public Throwable(String message, Throwable cause) {        fillInStackTrace();        detailMessage = message;        this.cause = cause;    }     public Throwable(Throwable cause) {        fillInStackTrace();        detailMessage = (cause==null ? null : cause.toString());        this.cause = cause;    }    //........}</code></pre><p>下面看一个比较实在的异常链例子哈</p><pre><code>public class 异常链 {    @Test    public void test() {        C();    }    public void A () throws Exception {        try {            int i = 1;            i = i / 0;            //当我注释掉这行代码并使用B方法抛出一个error时，运行结果如下//            四月 27, 2018 10:12:30 下午 org.junit.platform.launcher.core.ServiceLoaderTestEngineRegistry loadTestEngines//            信息: Discovered TestEngines with IDs: [junit-jupiter]//            java.lang.Error: B也犯了个错误//            at com.javase.异常.异常链.B(异常链.java:33)//            at com.javase.异常.异常链.C(异常链.java:38)//            at com.javase.异常.异常链.test(异常链.java:13)//            at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)//            Caused by: java.lang.Error//            at com.javase.异常.异常链.B(异常链.java:29)        }catch (ArithmeticException e) {            //这里通过throwable类的构造方法将最底层的异常重新包装并抛出，此时注入了A方法的信息。最后打印栈信息时可以看到caused by            A方法的异常。            //如果直接抛出，栈信息打印结果只能看到上层方法的错误信息，不能看到其实是A发生了错误。            //所以需要包装并抛出            throw new Exception(&quot;A方法计算错误&quot;, e);        }    }    public void B () throws Exception,Error {        try {            //接收到A的异常，            A();            throw new Error();        }catch (Exception e) {            throw e;        }catch (Error error) {            throw new Error(&quot;B也犯了个错误&quot;, error);        }    }    public void C () {        try {            B();        }catch (Exception | Error e) {            e.printStackTrace();        }    }    //最后结果//    java.lang.Exception: A方法计算错误//    at com.javase.异常.异常链.A(异常链.java:18)//    at com.javase.异常.异常链.B(异常链.java:24)//    at com.javase.异常.异常链.C(异常链.java:31)//    at com.javase.异常.异常链.test(异常链.java:11)//    省略//    Caused by: java.lang.ArithmeticException: / by zero//    at com.javase.异常.异常链.A(异常链.java:16)//            ... 31 more}</code></pre><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>如果要自定义异常类，则扩展Exception类即可，因此这样的自定义异常都属于检查异常（checked exception）。如果要自定义非检查异常，则扩展自RuntimeException。</p><p>按照国际惯例，自定义的异常应该总是包含如下的构造函数：</p><p>一个无参构造函数<br>一个带有String参数的构造函数，并传递给父类的构造函数。<br>一个带有String参数和Throwable参数，并都传递给父类构造函数<br>一个带有Throwable 参数的构造函数，并传递给父类的构造函数。<br>下面是IOException类的完整源代码，可以借鉴。</p><pre><code>public class IOException extends Exception{    static final long serialVersionUID = 7818375828146090155L;    public IOException()    {        super();    }    public IOException(String message)    {        super(message);    }    public IOException(String message, Throwable cause)    {        super(message, cause);    }    public IOException(Throwable cause)    {        super(cause);    }}</code></pre><h2 id="异常的注意事项"><a href="#异常的注意事项" class="headerlink" title="异常的注意事项"></a>异常的注意事项</h2><p>异常的注意事项</p><blockquote><p>当子类重写父类的带有 throws声明的函数时，其throws声明的异常必须在父类异常的可控范围内——用于处理父类的throws方法的异常处理器，必须也适用于子类的这个带throws方法 。这是为了支持多态。</p><p>例如，父类方法throws 的是2个异常，子类就不能throws 3个及以上的异常。父类throws IOException，子类就必须throws IOException或者IOException的子类。</p></blockquote><p>至于为什么？我想，也许下面的例子可以说明。</p><pre><code>class Father{    public void start() throws IOException    {        throw new IOException();    }}class Son extends Father{    public void start() throws Exception    {        throw new SQLException();    }}</code></pre><p>/<strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong>假设上面的代码是允许的（实质是错误的）<strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong>/</p><pre><code>class Test{    public static void main(String[] args)    {        Father[] objs = new Father[2];        objs[0] = new Father();        objs[1] = new Son();        for(Father obj:objs)        {        //因为Son类抛出的实质是SQLException，而IOException无法处理它。        //那么这里的try。。catch就不能处理Son中的异常。        //多态就不能实现了。            try {                 obj.start();            }catch(IOException)            {                 //处理IOException            }         }   }}</code></pre><p>==Java的异常执行流程是线程独立的，线程之间没有影响==</p><blockquote><p>Java程序可以是多线程的。每一个线程都是一个独立的执行流，独立的函数调用栈。如果程序只有一个线程，那么没有被任何代码处理的异常 会导致程序终止。如果是多线程的，那么没有被任何代码处理的异常仅仅会导致异常所在的线程结束。</p><p>也就是说，Java中的异常是线程独立的，线程的问题应该由线程自己来解决，而不要委托到外部，也不会直接影响到其它线程的执行。</p></blockquote><p>下面看一个例子</p><pre><code>public class 多线程的异常 {    @Test    public void test() {        go();    }    public void go () {        ExecutorService executorService = Executors.newFixedThreadPool(3);        for (int i = 0;i &lt;= 2;i ++) {            int finalI = i;            try {                Thread.sleep(2000);            } catch (InterruptedException e) {                e.printStackTrace();            }            executorService.execute(new Runnable() {                @Override                //每个线程抛出异常时并不会影响其他线程的继续执行                public void run() {                    try {                        System.out.println(&quot;start thread&quot; + finalI);                        throw new Exception();                    }catch (Exception e) {                        System.out.println(&quot;thread&quot; + finalI + &quot; go wrong&quot;);                    }                }            });        }//        结果：//        start thread0//        thread0 go wrong//        start thread1//        thread1 go wrong//        start thread2//        thread2 go wrong    }}</code></pre><h2 id="当finally遇上return"><a href="#当finally遇上return" class="headerlink" title="当finally遇上return"></a>当finally遇上return</h2><p>首先一个不容易理解的事实：</p><p>在 try块中即便有return，break，continue等改变执行流的语句，finally也会执行。</p><pre><code>public static void main(String[] args){    int re = bar();    System.out.println(re);}private static int bar() {    try{        return 5;    } finally{        System.out.println(&quot;finally&quot;);    }}/*输出：finally*/</code></pre><p>很多人面对这个问题时，总是在归纳执行的顺序和规律，不过我觉得还是很难理解。我自己总结了一个方法。用如下GIF图说明。</p><p><img src="http://incdn1.b0.upaiyun.com/2017/09/0471c2805ebd5a463211ced478eaf7f8.gif" alt="image"></p><p>也就是说：try…catch…finally中的return 只要能执行，就都执行了，他们共同向同一个内存地址（假设地址是0×80）写入返回值，后执行的将覆盖先执行的数据，而真正被调用者取的返回值就是最后一次写入的。那么，按照这个思想，下面的这个例子也就不难理解了。</p><p>finally中的return 会覆盖 try 或者catch中的返回值。</p><pre><code>public static void main(String[] args)    {        int result;        result  =  foo();        System.out.println(result);     /////////2        result = bar();        System.out.println(result);    /////////2    }    @SuppressWarnings(&quot;finally&quot;)    public static int foo()    {        trz{            int a = 5 / 0;        } catch (Exception e){            return 1;        } finally{            return 2;        }    }    @SuppressWarnings(&quot;finally&quot;)    public static int bar()    {        try {            return 1;        }finally {            return 2;        }    }</code></pre><p>finally中的return会抑制（消灭）前面try或者catch块中的异常</p><pre><code>class TestException{    public static void main(String[] args)    {        int result;        try{            result = foo();            System.out.println(result);           //输出100        } catch (Exception e){            System.out.println(e.getMessage());    //没有捕获到异常        }        try{            result  = bar();            System.out.println(result);           //输出100        } catch (Exception e){            System.out.println(e.getMessage());    //没有捕获到异常        }    }    //catch中的异常被抑制    @SuppressWarnings(&quot;finally&quot;)    public static int foo() throws Exception    {        try {            int a = 5/0;            return 1;        }catch(ArithmeticException amExp) {            throw new Exception(&quot;我将被忽略，因为下面的finally中使用了return&quot;);        }finally {            return 100;        }    }    //try中的异常被抑制    @SuppressWarnings(&quot;finally&quot;)    public static int bar() throws Exception    {        try {            int a = 5/0;            return 1;        }finally {            return 100;        }    }}</code></pre><p>finally中的异常会覆盖（消灭）前面try或者catch中的异常</p><pre><code>class TestException{    public static void main(String[] args)    {        int result;        try{            result = foo();        } catch (Exception e){            System.out.println(e.getMessage());    //输出：我是finaly中的Exception        }        try{            result  = bar();        } catch (Exception e){            System.out.println(e.getMessage());    //输出：我是finaly中的Exception        }    }    //catch中的异常被抑制    @SuppressWarnings(&quot;finally&quot;)    public static int foo() throws Exception    {        try {            int a = 5/0;            return 1;        }catch(ArithmeticException amExp) {            throw new Exception(&quot;我将被忽略，因为下面的finally中抛出了新的异常&quot;);        }finally {            throw new Exception(&quot;我是finaly中的Exception&quot;);        }    }    //try中的异常被抑制    @SuppressWarnings(&quot;finally&quot;)    public static int bar() throws Exception    {        try {            int a = 5/0;            return 1;        }finally {            throw new Exception(&quot;我是finaly中的Exception&quot;);        }    }}</code></pre><p>上面的3个例子都异于常人的编码思维，因此我建议：</p><blockquote><p>不要在fianlly中使用return。</p></blockquote><blockquote><p>不要在finally中抛出异常。</p></blockquote><blockquote><p>减轻finally的任务，不要在finally中做一些其它的事情，finally块仅仅用来释放资源是最合适的。</p></blockquote><blockquote><p>将尽量将所有的return写在函数的最后面，而不是try … catch … finally中。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文非常详尽地介绍了Java中的异常，几乎360度无死角。&lt;/p&gt;
&lt;p&gt;从异常的概念，分类，使用方法，注意事项和设计等方面全面地介绍了Java异常。&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;喜欢的话麻烦点下星哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/04/27/javase10&quot;&gt;https://h2pl.github.io/2018/04/27/javase10&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java基础" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java异常" scheme="http://h2pl.github.io/tags/Java%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Java基础9：解读Java回调机制</title>
    <link href="http://h2pl.github.io/2018/04/26/javase9/"/>
    <id>http://h2pl.github.io/2018/04/26/javase9/</id>
    <published>2018-04-26T13:23:20.000Z</published>
    <updated>2018-06-01T03:49:29.365Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了Java中的回调机制，以及Java多线程中类似回调的机制。</p><p>具体代码在我的GitHub中可以找到</p><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p><p>喜欢的话麻烦点下星哈</p><p>文章首发于我的个人博客：</p><p><a href="https://h2pl.github.io/2018/04/26/javase9">https://h2pl.github.io/2018/04/26/javase9</a></p><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：<a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a></p><a id="more"></a><h2 id="模块间的调用"><a href="#模块间的调用" class="headerlink" title="模块间的调用"></a>模块间的调用</h2><p>本部分摘自<a href="https://www.cnblogs.com/xrq730/p/6424471.html" target="_blank" rel="noopener">https://www.cnblogs.com/xrq730/p/6424471.html</a></p><p>在一个应用系统中，无论使用何种语言开发，必然存在模块之间的调用，调用的方式分为几种：</p><p>（1）同步调用</p><blockquote><p>同步调用是最基本并且最简单的一种调用方式，类A的方法a()调用类B的方法b()，一直等待b()方法执行完毕，a()方法继续往下走。这种调用方式适用于方法b()执行时间不长的情况，因为b()方法执行时间一长或者直接阻塞的话，a()方法的余下代码是无法执行下去的，这样会造成整个流程的阻塞。</p></blockquote><p><img src="https://images2015.cnblogs.com/blog/801753/201702/801753-20170221201001413-1766758208.png" alt="image"></p><p>（2）异步调用</p><p><img src="https://images2015.cnblogs.com/blog/801753/201702/801753-20170221201512429-1532730453.png" alt="image"></p><blockquote><p>异步调用是为了解决同步调用可能出现阻塞，导致整个流程卡住而产生的一种调用方式。类A的方法方法a()通过新起线程的方式调用类B的方法b()，代码接着直接往下执行，这样无论方法b()执行时间多久，都不会阻塞住方法a()的执行。</p><p>但是这种方式，由于方法a()不等待方法b()的执行完成，在方法a()需要方法b()执行结果的情况下（视具体业务而定，有些业务比如启异步线程发个微信通知、刷新一个缓存这种就没必要），必须通过一定的方式对方法b()的执行结果进行监听。</p><p>在Java中，可以使用Future+Callable的方式做到这一点，具体做法可以参见我的这篇文章Java多线程21：多线程下其他组件之CyclicBarrier、Callable、Future和FutureTask。</p></blockquote><p>（3）回调</p><p><img src="https://images2015.cnblogs.com/blog/801753/201702/801753-20170221205712070-824897248.png" alt="image"></p><p>最后是回调，回调的思想是：  </p><p>类A的a()方法调用类B的b()方法<br>类B的b()方法执行完毕主动调用类A的callback()方法<br>这样一种调用方式组成了上图，也就是一种双向的调用方式。</p><h2 id="回调实例：Tom做题"><a href="#回调实例：Tom做题" class="headerlink" title="回调实例：Tom做题"></a>回调实例：Tom做题</h2><p>数学老师让Tom做一道题，并且Tom做题期间数学老师不用盯着Tom，而是在玩手机，等Tom把题目做完后再把答案告诉老师。</p><blockquote><p>1 数学老师需要Tom的一个引用，然后才能将题目发给Tom。</p><p>2 数学老师需要提供一个方法以便Tom做完题目以后能够将答案告诉他。</p><p>3 Tom需要数学老师的一个引用，以便Tom把答案给这位老师，而不是隔壁的体育老师。</p></blockquote><p>回调接口，可以理解为老师接口</p><pre><code>//回调指的是A调用B来做一件事，B做完以后将结果告诉给A，这期间A可以做别的事情。//这个接口中有一个方法，意为B做完题目后告诉A时使用的方法。//所以我们必须提供这个接口以便让B来回调。//回调接口，public interface CallBack {    void tellAnswer(int res);}</code></pre><p>数学老师类</p><pre><code>    //老师类实例化回调接口，即学生写完题目之后通过老师的提供的方法进行回调。    //那么学生如何调用到老师的方法呢，只要在学生类的方法中传入老师的引用即可。    //而老师需要指定学生答题，所以也要传入学生的实例。public class Teacher implements CallBack{    private Student student;    Teacher(Student student) {        this.student = student;    }    void askProblem (Student student, Teacher teacher) {        //main方法是主线程运行，为了实现异步回调，这里开启一个线程来操作        new Thread(new Runnable() {            @Override            public void run() {                student.resolveProblem(teacher);            }        }).start();        //老师让学生做题以后，等待学生回答的这段时间，可以做别的事，比如玩手机.\        //而不需要同步等待，这就是回调的好处。        //当然你可以说开启一个线程让学生做题就行了，但是这样无法让学生通知老师。        //需要另外的机制去实现通知过程。        // 当然，多线程中的future和callable也可以实现数据获取的功能。        for (int i = 1;i &lt; 4;i ++) {            System.out.println(&quot;等学生回答问题的时候老师玩了 &quot; + i + &quot;秒的手机&quot;);        }    }    @Override    public void tellAnswer(int res) {        System.out.println(&quot;the answer is &quot; + res);    }}</code></pre><p>学生接口</p><pre><code>    //学生的接口，解决问题的方法中要传入老师的引用，否则无法完成对具体实例的回调。    //写为接口的好处就是，很多个学生都可以实现这个接口，并且老师在提问题时可以通过    //传入List&lt;Student&gt;来聚合学生，十分方便。public interface Student {    void resolveProblem (Teacher teacher);}</code></pre><p>学生Tom</p><pre><code>public class Tom implements Student{    @Override    public void resolveProblem(Teacher teacher) {        try {            //学生思考了3秒后得到了答案，通过老师提供的回调方法告诉老师。            Thread.sleep(3000);            System.out.println(&quot;work out&quot;);            teacher.tellAnswer(111);        } catch (InterruptedException e) {            e.printStackTrace();        }    }</code></pre><p>测试类</p><pre><code>public class Test {    public static void main(String[] args) {        //测试        Student tom = new Tom();        Teacher lee = new Teacher(tom);        lee.askProblem(tom, lee);        //结果//        等学生回答问题的时候老师玩了 1秒的手机//        等学生回答问题的时候老师玩了 2秒的手机//        等学生回答问题的时候老师玩了 3秒的手机//        work out//        the answer is 111    }}</code></pre><h2 id="多线程中的“回调”"><a href="#多线程中的“回调”" class="headerlink" title="多线程中的“回调”"></a>多线程中的“回调”</h2><p>Java多线程中可以通过callable和future或futuretask结合来获取线程执行后的返回值。实现方法是通过get方法来调用callable的call方法获取返回值。</p><p>其实这种方法本质上不是回调，回调要求的是任务完成以后被调用者主动回调调用者的接口。而这里是调用者主动使用get方法阻塞获取返回值。</p><pre><code>public class 多线程中的回调 {    //这里简单地使用future和callable实现了线程执行完后    public static void main(String[] args) throws ExecutionException, InterruptedException {        ExecutorService executor = Executors.newCachedThreadPool();        Future&lt;String&gt; future = executor.submit(new Callable&lt;String&gt;() {            @Override            public String call() throws Exception {                System.out.println(&quot;call&quot;);                TimeUnit.SECONDS.sleep(1);                return &quot;str&quot;;            }        });        //手动阻塞调用get通过call方法获得返回值。        System.out.println(future.get());        //需要手动关闭，不然线程池的线程会继续执行。        executor.shutdown();    //使用futuretask同时作为线程执行单元和数据请求单元。    FutureTask&lt;Integer&gt; futureTask = new FutureTask(new Callable&lt;Integer&gt;() {        @Override        public Integer call() throws Exception {            System.out.println(&quot;dasds&quot;);            return new Random().nextInt();        }    });    new Thread(futureTask).start();    //阻塞获取返回值    System.out.println(futureTask.get());}@Testpublic void test () {    Callable callable = new Callable() {        @Override        public Object call() throws Exception {            return null;        }    };    FutureTask futureTask = new FutureTask(callable);}}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了Java中的回调机制，以及Java多线程中类似回调的机制。&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;喜欢的话麻烦点下星哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/04/26/javase9&quot;&gt;https://h2pl.github.io/2018/04/26/javase9&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java基础" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础8：深入理解内部类</title>
    <link href="http://h2pl.github.io/2018/04/25/javase8/"/>
    <id>http://h2pl.github.io/2018/04/25/javase8/</id>
    <published>2018-04-25T14:47:39.000Z</published>
    <updated>2018-06-01T03:49:24.293Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了Java内部类的基本原理，使用方法和各种细节。</p><p>有关内部类实现回调，事件驱动和委托机制的文章将在后面发布。</p><p>具体代码在我的GitHub中可以找到</p><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p><p>喜欢的话麻烦点下星哈</p><p>文章首发于我的个人博客：</p><p><a href="https://h2pl.github.io/2018/04/25/javase8">https://h2pl.github.io/2018/04/25/javase8</a></p><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：</p><p><a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a><br><a id="more"></a></p><h2 id="内部类初探"><a href="#内部类初探" class="headerlink" title="内部类初探"></a>内部类初探</h2><p>一、什么是内部类？</p><p>　　内部类是指在一个外部类的内部再定义一个类。内部类作为外部类的一个成员，并且依附于外部类而存在的。内部类可为静态，可用protected和private修饰（而外部类只能使用public和缺省的包访问权限）。内部类主要有以下几类：成员内部类、局部内部类、静态内部类、匿名内部类</p><p>二、内部类的共性</p><blockquote><p>(1)内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号 。</p><p>(2)内部类不能用普通的方式访问。</p><p>(3)内部类声明成静态的，就不能随便的访问外部类的成员变量了，此时内部类只能访问外部类的静态成员变量 。</p><p>(4)外部类不能直接访问内部类的的成员，但可以通过内部类对象来访问</p></blockquote><p>　　内部类是外部类的一个成员，因此内部类可以自由地访问外部类的成员变量，无论是否是private的。</p><p>　　因为当某个外围类的对象创建内部类的对象时，此内部类会捕获一个隐式引用，它引用了实例化该内部对象的外围类对象。通过这个指针，可以访问外围类对象的全部状态。</p><p>通过反编译内部类的字节码，分析之后主要是通过以下几步做到的： </p><blockquote><p>　　1 编译器自动为内部类添加一个成员变量， 这个成员变量的类型和外部类的类型相同， 这个成员变量就是指向外部类对象的引用； </p></blockquote><blockquote><p>　　2 编译器自动为内部类的构造方法添加一个参数， 参数的类型是外部类的类型， 在构造方法内部使用这个参数为1中添加的成员变量赋值；</p></blockquote><blockquote><p>　　3 在调用内部类的构造函数初始化内部类对象时， 会默认传入外部类的引用。</p></blockquote><p>二、使用内部类的好处：</p><blockquote><p>静态内部类的作用：</p></blockquote><blockquote><p>1 只是为了降低包的深度，方便类的使用，静态内部类适用于包含类当中，但又不依赖与外在的类。</p><p>2 由于Java规定静态内部类不能用使用外在类的非静态属性和方法，所以只是为了方便管理类结构而定义。于是我们在创建静态内部类的时候，不需要外部类对象的引用。</p></blockquote><blockquote><p>非静态内部类的作用：</p></blockquote><blockquote><p>1 内部类继承自某个类或实现某个接口，内部类的代码操作创建其他外围类的对象。所以你可以认为内部类提供了某种进入其外围类的窗口。</p><p>2 使用内部类最吸引人的原因是:每个内部类都能独立地继承自一个(接口的)实现，所以无论外围类是否已经继承了某个(接口的)实现，对于内部类都没有影响</p></blockquote><blockquote><p>3 如果没有内部类提供的可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决。<br> 从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了”多重继承”。</p></blockquote><p>三、<br>那静态内部类与普通内部类有什么区别呢？问得好，区别如下：</p><blockquote><p>（1）静态内部类不持有外部类的引用<br>在普通内部类中，我们可以直接访问外部类的属性、方法，即使是private类型也可以访问，这是因为内部类持有一个外部类的引用，可以自由访问。而静态内部类，则只可以访问外部类的静态方法和静态属性（如果是private权限也能访问，这是由其代码位置所决定的），其他则不能访问。</p><p>（2）静态内部类不依赖外部类<br>普通内部类与外部类之间是相互依赖的关系，内部类实例不能脱离外部类实例，也就是说它们会同生同死，一起声明，一起被垃圾回收器回收。而静态内部类是可以独立存在的，即使外部类消亡了，静态内部类还是可以存在的。</p><p>（3）普通内部类不能声明static的方法和变量<br>普通内部类不能声明static的方法和变量，注意这里说的是变量，常量（也就是final static修饰的属性）还是可以的，而静态内部类形似外部类，没有任何限制。</p></blockquote><p>==为什么普通内部类不能有静态变量呢？==</p><blockquote><p>1 成员内部类 之所以叫做成员 就是说他是类实例的一部分 而不是类的一部分 </p></blockquote><blockquote><p>2 结构上来说 他和你声明的成员变量是一样的地位 一个特殊的成员变量 而静态的变量是类的一部分和实例无关</p></blockquote><blockquote><p>3 你若声明一个成员内部类 让他成为主类的实例一部分 然后又想在内部类声明和实例无关的静态的东西 你让JVM情何以堪啊</p></blockquote><blockquote><p>4 若想在内部类内声明静态字段 就必须将其内部类本身声明为静态 </p></blockquote><p>非静态内部类有一个很大的优点：可以自由使用外部类的所有变量和方法</p><p>下面的例子大概地介绍了</p><p>1 非静态内部类和静态内部类的区别。</p><p>2 不同访问权限的内部类的使用。</p><p>3 外部类和它的内部类之间的关系</p><pre><code>//本节讨论内部类以及不同访问权限的控制//内部类只有在使用时才会被加载。//外部类Bpublic class B{    int i = 1;    int j = 1;    static int s = 1;    static int ss = 1;    A a;    AA aa;    AAA aaa;    //内部类A    public class A {//        static void go () {////        }//        static {////        }//      static int b = 1;//非静态内部类不能有静态成员变量和静态代码块和静态方法，        // 因为内部类在外部类加载时并不会被加载和初始化。        //所以不会进行静态代码的调用        int i = 2;//外部类无法读取内部类的成员，而内部类可以直接访问外部类成员        public void test() {            System.out.println(j);            j = 2;            System.out.println(j);            System.out.println(s);//可以访问类的静态成员变量        }        public void test2() {            AA aa = new AA();            AAA aaa = new AAA();        }    }    //静态内部类S，可以被外部访问    public static class S {        int i = 1;//访问不到非静态变量。        static int s = 0;//可以有静态变量        public static void main(String[] args) {            System.out.println(s);        }        @Test        public void test () {//            System.out.println(j);//报错，静态内部类不能读取外部类的非静态变量            System.out.println(s);            System.out.println(ss);            s = 2;            ss = 2;            System.out.println(s);            System.out.println(ss);        }    }    //内部类AA，其实这里加protected相当于default    //因为外部类要调用内部类只能通过B。并且无法直接继承AA，所以必须在同包    //的类中才能调用到(这里不考虑静态内部类)，那么就和default一样了。    protected class AA{        int i = 2;//内部类之间不共享变量        public void test (){            A a = new A();            AAA aaa = new AAA();            //内部类之间可以互相访问。        }    }    //包外部依然无法访问，因为包没有继承关系，所以找不到这个类    protected static class SS{        int i = 2;//内部类之间不共享变量        public void test (){            //内部类之间可以互相访问。        }    }    //私有内部类A，对外不可见，但对内部类和父类可见    private class AAA {        int i = 2;//内部类之间不共享变量        public void test() {            A a = new A();            AA aa = new AA();            //内部类之间可以互相访问。        }    }    @Test    public void test(){        A a = new A();        a.test();        //内部类可以修改外部类的成员变量        //打印出 1 2        B b = new B();    }}//另一个外部类class C {    @Test    public void test() {        //首先，其他类内部类只能通过外部类来获取其实例。        B.S s = new B.S();        //静态内部类可以直接通过B类直接获取，不需要B的实例，和静态成员变量类似。        //B.A a = new B.A();        //当A不是静态类时这行代码会报错。        //需要使用B的实例来获取A的实例        B b = new B();        B.A a = b.new A();        B.AA aa = b.new AA();//B和C同包，所以可以访问到AA//      B.AAA aaa = b.new AAA();AAA为私有内部类，外部类不可见        //当A使用private修饰时，使用B的实例也无法获取A的实例，这一点和私有变量是一样的。        //所有普通的内部类与类中的一个变量是类似的。静态内部类则与静态成员类似。    }}</code></pre><h2 id="内部类的加载"><a href="#内部类的加载" class="headerlink" title="内部类的加载"></a>内部类的加载</h2><p>可能刚才的例子中没办法直观地看到内部类是如何加载的，接下来用例子展示一下内部类加载的过程。</p><blockquote><p>1  内部类是延时加载的，也就是说只会在第一次使用时加载。不使用就不加载，所以可以很好的实现单例模式。</p><p>2 不论是静态内部类还是非静态内部类都是在第一次使用时才会被加载。</p><p>3 对于非静态内部类是不能出现静态模块（包含静态块，静态属性，静态方法等）</p><p>4 非静态类的使用需要依赖于外部类的对象，详见上述对象innerClass 的初始化。</p></blockquote><p>简单来说，类的加载都是发生在类要被用到的时候。内部类也是一样</p><blockquote><p>1 普通内部类在第一次用到时加载，并且每次实例化时都会执行内部成员变量的初始化，以及代码块和构造方法。</p></blockquote><blockquote><p>2 静态内部类也是在第一次用到时被加载。但是当它加载完以后就会将静态成员变量初始化，运行静态代码块，并且只执行一次。当然，非静态成员和代码块每次实例化时也会执行。</p></blockquote><p>总结一下Java类代码加载的顺序，万变不离其宗。</p><blockquote><p>规律一、初始化构造时，先父后子；只有在父类所有都构造完后子类才被初始化</p><p>规律二、类加载先是静态、后非静态、最后是构造函数。</p><p>静态构造块、静态类属性按出现在类定义里面的先后顺序初始化，同理非静态的也是一样的，只是静态的只在加载字节码时执行一次，不管你new多少次，非静态会在new多少次就执行多少次</p><p>规律三、java中的类只有在被用到的时候才会被加载</p><p>规律四、java类只有在类字节码被加载后才可以被构造成对象实例</p></blockquote><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>在方法中定义的内部类称为局部内部类。与局部变量类似，局部内部类不能有访问说明符，因为它不是外围类的一部分，但是它可以访问当前代码块内的常量，和此外围类所有的成员。</p><p>需要注意的是：<br>局部内部类只能在定义该内部类的方法内实例化，不可以在此方法外对其实例化。</p><pre><code>public class 局部内部类 {    class A {//局部内部类就是写在方法里的类，只在方法执行时加载，一次性使用。        public void test() {            class B {                public void test () {                    class C {                    }                }            }        }    }    @Test    public void test () {        int i = 1;        final int j = 2;        class A {            @Test            public void test () {                System.out.println(i);                System.out.println(j);            }        }        A a = new A();        System.out.println(a);    }    static class B {        public static void test () {            //static class A报错，方法里不能定义静态内部类。            //因为只有在方法调用时才能进行类加载和初始化。        }    }}</code></pre><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>简单地说：匿名内部类就是没有名字的内部类，并且，匿名内部类是局部内部类的一种特殊形式。什么情况下需要使用匿名内部类？如果满足下面的一些条件，使用匿名内部类是比较合适的：<br>只用到类的一个实例。<br>类在定义后马上用到。<br>类非常小（SUN推荐是在4行代码以下）<br>给类命名并不会导致你的代码更容易被理解。<br>在使用匿名内部类时，要记住以下几个原则：</p><blockquote><p>1 　匿名内部类不能有构造方法。</p><p>2 　匿名内部类不能定义任何静态成员、方法和类。</p><p>3 　匿名内部类不能是public,protected,private,static。</p><p>4 　只能创建匿名内部类的一个实例。</p><p>5   一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。</p><p>6 　因匿名内部类为局部内部类，所以局部内部类的所有限制都对其生效。</p></blockquote><p>一个匿名内部类的例子：</p><pre><code>    public class 匿名内部类 {}interface D{    void run ();}abstract class E{    E (){    }    abstract void work();}class A {        @Test        public void test (int k) {            //利用接口写出一个实现该接口的类的实例。            //有且仅有一个实例，这个类无法重用。            new Runnable() {                @Override                public void run() {//                    k = 1;报错，当外部方法中的局部变量在内部类使用中必须改为final类型。                    //因为方外部法中即使改变了这个变量也不会反映到内部类中。                    //所以对于内部类来讲这只是一个常量。                    System.out.println(100);                    System.out.println(k);                }            };            new D(){                //实现接口的匿名类                int i =1;                @Override                public void run() {                    System.out.println(&quot;run&quot;);                    System.out.println(i);                    System.out.println(k);                }            }.run();            new E(){                //继承抽象类的匿名类                int i = 1;                void run (int j) {                    j = 1;                }                @Override                void work() {                }            };        }}</code></pre><h2 id="匿名内部类里的final"><a href="#匿名内部类里的final" class="headerlink" title="匿名内部类里的final"></a>匿名内部类里的final</h2><p>使用的形参为何要为final</p><p>参考文件：<a href="http://android.blog.51cto.com/268543/384844" target="_blank" rel="noopener">http://android.blog.51cto.com/268543/384844</a></p><blockquote><p>我们给匿名内部类传递参数的时候，若该形参在内部类中需要被使用，那么该形参必须要为final。也就是说：当所在的方法的形参需要被内部类里面使用时，该形参必须为final。</p><p>为什么必须要为final呢？</p><p>首先我们知道在内部类编译成功后，它会产生一个class文件，该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用。当外部类传入的参数需要被内部类调用时，从java程序的角度来看是直接被调用：</p></blockquote><pre><code>public class OuterClass {    public void display(final String name,String age){        class InnerClass{            void display(){                System.out.println(name);            }        }    }}</code></pre><p>从上面代码中看好像name参数应该是被内部类直接调用？其实不然，在java编译之后实际的操作如下：</p><pre><code>public class OuterClass$InnerClass {    public InnerClass(String name,String age){        this.InnerClass$name = name;        this.InnerClass$age = age;    }    public void display(){        System.out.println(this.InnerClass$name + &quot;----&quot; + this.InnerClass$age );    }}</code></pre><p>  所以从上面代码来看，内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份，自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数。</p><blockquote><p>  直到这里还没有解释为什么是final</p></blockquote><blockquote><p>在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的。</p><p>毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用final来避免形参的不改变。</p></blockquote><p>  简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变。</p><p>  故如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是final的。</p><h2 id="内部类初始化"><a href="#内部类初始化" class="headerlink" title="内部类初始化"></a>内部类初始化</h2><p>我们一般都是利用构造器来完成某个实例的初始化工作的，但是匿名内部类是没有构造器的！那怎么来初始化匿名内部类呢？使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果。</p><pre><code>public class OutClass {    public InnerClass getInnerClass(final int age,final String name){        return new InnerClass() {            int age_ ;            String name_;            //构造代码块完成初始化工作            {                if(0 &lt; age &amp;&amp; age &lt; 200){                    age_ = age;                    name_ = name;                }            }            public String getName() {                return name_;            }            public int getAge() {                return age_;            }        };    }</code></pre><h2 id="内部类的重载"><a href="#内部类的重载" class="headerlink" title="内部类的重载"></a>内部类的重载</h2><p>　　如果你创建了一个内部类，然后继承其外围类并重新定义此内部类时，会发生什么呢？也就是说，内部类可以被重载吗？这看起来似乎是个很有用的点子，但是“重载”内部类就好像它是外围类的一个方法，其实并不起什么作用：</p><pre><code>class Egg {       private Yolk y;       protected class Yolk {              public Yolk() {                     System.out.println(&quot;Egg.Yolk()&quot;);              }       }       public Egg() {              System.out.println(&quot;New Egg()&quot;);              y = new Yolk();       }}public class BigEgg extends Egg {       public class Yolk {              public Yolk() {                     System.out.println(&quot;BigEgg.Yolk()&quot;);              }       }       public static void main(String[] args) {              new BigEgg();       }}复制代码输出结果为：New Egg()Egg.Yolk()</code></pre><p>缺省的构造器是编译器自动生成的，这里是调用基类的缺省构造器。你可能认为既然创建了BigEgg 的对象，那么所使用的应该是被“重载”过的Yolk，但你可以从输出中看到实际情况并不是这样的。<br>这个例子说明，当你继承了某个外围类的时候，内部类并没有发生什么特别神奇的变化。这两个内部类是完全独立的两个实体，各自在自己的命名空间内。</p><h2 id="内部类的继承"><a href="#内部类的继承" class="headerlink" title="内部类的继承"></a>内部类的继承</h2><p>因为内部类的构造器要用到其外围类对象的引用，所以在你继承一个内部类的时候，事情变得有点复杂。问题在于，那个“秘密的”外围类对象的引用必须被初始化，而在被继承的类中并不存在要联接的缺省对象。要解决这个问题，需使用专门的语法来明确说清它们之间的关联：</p><pre><code>class WithInner {        class Inner {                Inner(){                        System.out.println(&quot;this is a constructor in WithInner.Inner&quot;);                };        }}public class InheritInner extends WithInner.Inner {        // ! InheritInner() {} // Won&apos;t compile        InheritInner(WithInner wi) {                wi.super();                System.out.println(&quot;this is a constructor in InheritInner&quot;);        }        public static void main(String[] args) {                WithInner wi = new WithInner();                InheritInner ii = new InheritInner(wi);        }}</code></pre><p>输出结果为：<br>this is a constructor in WithInner.Inner<br>this is a constructor in InheritInner</p><p>可以看到，InheritInner 只继承自内部类，而不是外围类。但是当要生成一个构造器时，缺省的构造器并不算好，而且你不能只是传递一个指向外围类对象的引用。此外，你必须在构造器内使用如下语法：<br>enclosingClassReference.super();<br>这样才提供了必要的引用，然后程序才能编译通过。</p><p>有关匿名内部类实现回调，事件驱动，委托等机制的文章将在下一节讲述。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了Java内部类的基本原理，使用方法和各种细节。&lt;/p&gt;
&lt;p&gt;有关内部类实现回调，事件驱动和委托机制的文章将在后面发布。&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;喜欢的话麻烦点下星哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/04/25/javase8&quot;&gt;https://h2pl.github.io/2018/04/25/javase8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java基础" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础7：关于Java类和包的那些事</title>
    <link href="http://h2pl.github.io/2018/04/24/javase7/"/>
    <id>http://h2pl.github.io/2018/04/24/javase7/</id>
    <published>2018-04-24T09:03:51.000Z</published>
    <updated>2018-06-02T07:56:18.937Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了Java外部类和包的一些基本知识</p><p>内部类与匿名内部类的文章将在后面发布。</p><p>具体代码在我的GitHub中可以找到</p><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p><p>喜欢的话麻烦点下星哈</p><p>文章首发于我的个人博客：</p><p><a href="https://h2pl.github.io/2018/04/24/javase7">https://h2pl.github.io/2018/04/24/javase7</a></p><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：</p><p><a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a><br><a id="more"></a></p><h2 id="Java文件"><a href="#Java文件" class="headerlink" title="*.Java文件"></a>*.Java文件</h2><p>问题：一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？</p><blockquote><p>　　答案：可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。一个文件中可以只有非public类，如果只有一个非public类，此类可以跟文件名不同。</p></blockquote><p>为什么一个java源文件中只能有一个public类？</p><p>　　在java编程思想（第四版）一书中有这样3段话（6.4 类的访问权限）：</p><blockquote><p>　　1.每个编译单元（文件）都只能有一个public类，这表示，每个编译单元都有单一的公共接口，用public类来表现。该接口可以按要求包含众多的支持包访问权限的类。如果在某个编译单元内有一个以上的public类，编译器就会给出错误信息。</p><p>　　2.public类的名称必须完全与含有该编译单元的文件名相同，包含大小写。如果不匹配，同样将得到编译错误。</p><p>　　3.虽然不是很常用，但编译单元内完全不带public类也是可能的。在这种情况下，可以随意对文件命名。</p></blockquote><p>总结相关的几个问题：</p><p>1、一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？</p><blockquote><p>  答：可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。</p></blockquote><p>2、为什么一个文件中只能有一个public的类</p><blockquote><p>  答：编译器在编译时，针对一个java源代码文件（也称为“编译单元”）只会接受一个public类。否则报错。</p></blockquote><p>3、在java文件中是否可以没有public类</p><blockquote><p>  答：public类不是必须的，java文件中可以没有public类。</p></blockquote><p>4、为什么这个public的类的类名必须和文件名相同</p><blockquote><p>  答： 是为了方便虚拟机在相应的路径中找到相应的类所对应的字节码文件。</p></blockquote><h2 id="Main方法"><a href="#Main方法" class="headerlink" title="Main方法"></a>Main方法</h2><p>主函数：是一个特殊的函数，作为程序的入口，可以被JVM调用</p><p>主函数的定义：</p><blockquote><p>public：代表着该函数访问权限是最大的</p></blockquote><blockquote><p>static：代表主函数随着类的加载就已经存在了</p></blockquote><blockquote><p>void：主函数没有具体的返回值</p></blockquote><blockquote><p>main：不是关键字，但是一个特殊的单词，能够被JVM识别</p></blockquote><blockquote><p>（String[] args）：函数的参数，参数类型是一个数组，该数组中的元素师字符串，字符串数组。main(String[] args) 字符串数组的 此时空数组的长度是0，但也可以在 运行的时候向其中传入参数。</p></blockquote><p>主函数时固定格式的，JVM识别</p><p>主函数可以被重载，但是JVM只识别main（String[] args），其他都是作为一般函数。这里面的args知识数组变量可以更改，其他都不能更改。</p><p>一个java文件中可以包含很多个类，每个类中有且仅有一个主函数，但是每个java文件中可以包含多个主函数，在运行时，需要指定JVM入口是哪个。例如一个类的主函数可以调用另一个类的主函数。不一定会使用public类的主函数。</p><h2 id="外部类的访问权限"><a href="#外部类的访问权限" class="headerlink" title="外部类的访问权限"></a>外部类的访问权限</h2><p>外部类只能用public和default修饰。</p><p>为什么要对外部类或类做修饰呢？</p><blockquote><p>1.存在包概念：public 和 default 能区分这个外部类能对不同包作一个划分                       （default修饰的类，其他包中引入不了这个类，public修饰的类才能被import）   </p><p>2.protected是包内可见并且子类可见，但是当一个外部类想要继承一个protected修饰的非同包类时，压根找不到这个类，更别提几层了</p><p>3.private修饰的外部类，其他任何外部类都无法导入它。</p></blockquote><pre><code>//Java中的文件名要和public修饰的类名相同，否则会报错//如果没有public修饰的类，则文件可以随意命名public class Java中的类文件 {}//非公共开类的访问权限默认是包访问权限，不能用private和protected//一个外部类的访问权限只有两种，一种是包内可见，一种是包外可见。//如果用private修饰，其他类根本无法看到这个类，也就没有意义了。//如果用protected，虽然也是包内可见，但是如果有子类想要继承该类但是不同包时，//压根找不到这个类，也不可能继承它了，所以干脆用default代替。class A{}</code></pre><h2 id="Java包的命名规则"><a href="#Java包的命名规则" class="headerlink" title="Java包的命名规则"></a>Java包的命名规则</h2><blockquote><p>以 java.* 开头的是Java的核心包，所有程序都会使用这些包中的类；</p></blockquote><blockquote><p>以 javax.<em> 开头的是扩展包，x 是 extension 的意思，也就是扩展。虽然 javax.</em> 是对 java.<em> 的优化和扩展，但是由于 javax.</em> 使用的越来越多，很多程序都依赖于 javax.<em>，所以 javax.</em> 也是核心的一部分了，也随JDK一起发布。</p></blockquote><blockquote><p>以 org.* 开头的是各个机构或组织发布的包，因为这些组织很有影响力，它们的代码质量很高，所以也将它们开发的部分常用的类随JDK一起发布。</p></blockquote><blockquote><p>在包的命名方面，为了防止重名，有一个惯例：大家都以自己域名的倒写形式作为开头来为自己开发的包命名，例如百度发布的包会以 com.baidu.<em> 开头，w3c组织发布的包会以 org.w3c.</em> 开头，微学苑发布的包会以 net.weixueyuan.* 开头……</p></blockquote><blockquote><p>组织机构的域名后缀一般为 org，公司的域名后缀一般为 com，可以认为 org.<em> 开头的包为非盈利组织机构发布的包，它们一般是开源的，可以免费使用在自己的产品中，不用考虑侵权问题，而以 com.</em> 开头的包往往由盈利性的公司发布，可能会有版权问题，使用时要注意。</p></blockquote><h2 id="import的使用"><a href="#import的使用" class="headerlink" title="import的使用"></a>import的使用</h2><p>Java import以及Java类的搜索路径<br>如果你希望使用Java包中的类，就必须先使用import语句导入<br>语法为：</p><pre><code>import package1[.package2…].classname;package 为包名，classname 为类名。例如：import java.util.Date; // 导入 java.util 包下的 Date 类import java.util.Scanner; // 导入 java.util 包下的 Scanner 类import javax.swing.*; // 导入 javax.swing 包下的所有类，* 表示所有类</code></pre><p>注意：</p><blockquote><p>import 只能导入包所包含的类，而不能导入包。<br>为方便起见，我们一般不导入单独的类，而是导入包下所有的类，例如 import java.util.*;。</p></blockquote><blockquote><p>Java 编译器默认为所有的 Java 程序导入了 JDK 的 java.lang 包中所有的类（import java.lang.*;），其中定义了一些常用类，如 System、String、Object、Math 等，因此我们可以直接使用这些类而不必显式导入。但是使用其他类必须先导入。</p></blockquote><blockquote><p>前面讲到的”Hello World“程序使用了System.out.println(); 语句，System 类位于 java.lang 包，虽然我们没有显式导入这个包中的类，但是Java 编译器默认已经为我们导入了，否则程序会执行失败。</p></blockquote><p>java类的搜索路径<br>Java程序运行时要导入相应的类，也就是加载 .class 文件的过程。<br>假设有如下的 import 语句：</p><p>import p1.Test;</p><blockquote><p>该语句表明要导入 p1 包中的 Test 类。<br>安装JDK时，我们已经设置了环境变量 CLASSPATH 来指明类库的路径，它的值为 .;%JAVA_HOME%\lib，而 JAVA_HOME 又为 D:\Program Files\jdk1.7.0_71，所以 CLASSPATH 等价于 .;D:\Program Files\jdk1.7.0_71\lib。</p></blockquote><blockquote><p>如果在第一个路径下找到了所需的类文件，则停止搜索，否则继续搜索后面的路径，如果在所有的路径下都未能找到所需的类文件，则编译或运行出错。</p><p>你可以在CLASSPATH变量中增加搜索路径，例如 .;%JAVA_HOME%\lib;C:\javalib，那么你就可以将类文件放在 C:\javalib 目录下，Java运行环境一样会找到。</p></blockquote><blockquote><p>用户自己写的类可以通过IDE指定编译后的class文件的输出目录，appclassloader会到指定目录进行类的加载</p></blockquote><p>下面是一个import两种访问权限的类的实例：</p><pre><code>package com.javase.Java中的类.一个包;public class 全局访问 {}package com.javase.Java中的类.一个包;class 包访问权限 {}package com.javase.Java中的类;//import可以导入基础包以及公开的类，需要使用类名的全路径//并且在导入某个包.*时，是不会把子包的类给导进来的，这样可以避免导入错误。//注意//import com.javase.Java中的类.一个包.包访问权限;//这个导入会报错，因为这个类没有用public修饰，无法用import导入。import com.javase.Java中的类.一个包.全局访问;//可以导入。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了Java外部类和包的一些基本知识&lt;/p&gt;
&lt;p&gt;内部类与匿名内部类的文章将在后面发布。&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;喜欢的话麻烦点下星哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/04/24/javase7&quot;&gt;https://h2pl.github.io/2018/04/24/javase7&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java基础" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础6：代码块与代码加载顺序</title>
    <link href="http://h2pl.github.io/2018/04/24/javase6/"/>
    <id>http://h2pl.github.io/2018/04/24/javase6/</id>
    <published>2018-04-24T03:31:00.000Z</published>
    <updated>2018-06-02T07:56:19.252Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了三种代码块的特性和使用方法。</p><p>具体代码在我的GitHub中可以找到</p><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p><p>喜欢的话麻烦点下星哈</p><p>文章首发于我的个人博客：</p><p><a href="https://h2pl.github.io/2018/04/24/javase6">https://h2pl.github.io/2018/04/24/javase6</a></p><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：</p><p><a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a><br><a id="more"></a></p><p>代码块：用{}包围的代码</p><p>java中的代码块按其位置划分为四种：</p><h2 id="局部代码块"><a href="#局部代码块" class="headerlink" title="局部代码块"></a>局部代码块</h2><blockquote><p>位置：局部位置（方法内部）</p></blockquote><blockquote><p>作用：限定变量的生命周期，尽早释放，节约内存</p></blockquote><blockquote><p>调用：调用其所在的方法时执行</p></blockquote><pre><code> public class 局部代码块 {@Testpublic void test (){    B b = new B();    b.go();}}class B {    B(){}    public void go() {        //方法中的局部代码块，一般进行一次性地调用，调用完立刻释放空间，避免在接下来的调用过程中占用栈空间        //因为栈空间内存是有限的，方法调用可能会会生成很多局部变量导致栈内存不足。        //使用局部代码块可以避免这样的情况发生。        {            int i = 1;            ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();            while (i &lt; 1000) {                list.add(i ++);            }            for (Integer j : list) {                System.out.println(j);            }            System.out.println(&quot;gogogo&quot;);        }        System.out.println(&quot;hello&quot;);    }}</code></pre><h2 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h2><blockquote><p>位置：类成员的位置，就是类中方法之外的位置</p></blockquote><blockquote><p>作用：把多个构造方法共同的部分提取出来，共用构造代码块</p></blockquote><blockquote><p>调用：每次调用构造方法时，都会优先于构造方法执行，也就是每次new一个对象时自动调用，对  对象的初始化</p></blockquote><pre><code>class A{    int i = 1;    int initValue;//成员变量的初始化交给代码块来完成    {        //代码块的作用体现于此：在调用构造方法之前，用某段代码对成员变量进行初始化。        //而不是在构造方法调用时再进行。一般用于将构造方法的相同部分提取出来。        //        for (int i = 0;i &lt; 100;i ++) {            initValue += i;        }    }    {        System.out.println(initValue);        System.out.println(i);//此时会打印1        int i = 2;//代码块里的变量和成员变量不冲突，但会优先使用代码块的变量        System.out.println(i);//此时打印2        //System.out.println(j);//提示非法向后引用，因为此时j的的初始化还没开始。        //    }    {        System.out.println(&quot;代码块运行&quot;);    }    int j = 2;    {        System.out.println(j);        System.out.println(i);//代码块中的变量运行后自动释放，不会影响代码块之外的代码    }    A(){        System.out.println(&quot;构造方法运行&quot;);    }}public class 构造代码块 {    @Test    public void test() {        A a = new A();    }}</code></pre><h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><pre><code> 位置：类成员位置，用static修饰的代码块 作用：对类进行一些初始化  只加载一次，当new多个对象时，只有第一次会调用静态代码块，因为，静态代码块                  是属于类的，所有对象共享一份 调用: new 一个对象时自动调用 public class 静态代码块 {@Testpublic void test() {    C c1 = new C();    C c2 = new C();    //结果,静态代码块只会调用一次，类的所有对象共享该代码块    //一般用于类的全局信息初始化    //静态代码块调用    //代码块调用    //构造方法调用    //代码块调用    //构造方法调用}}class C{    C(){        System.out.println(&quot;构造方法调用&quot;);    }    {        System.out.println(&quot;代码块调用&quot;);    }    static {        System.out.println(&quot;静态代码块调用&quot;);    }}</code></pre><p>执行顺序       静态代码块 —–&gt;   构造代码块 ——-&gt;   构造方法</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了三种代码块的特性和使用方法。&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;喜欢的话麻烦点下星哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/04/24/javase6&quot;&gt;https://h2pl.github.io/2018/04/24/javase6&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java基础" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础5：抽象类和接口</title>
    <link href="http://h2pl.github.io/2018/04/24/javase5/"/>
    <id>http://h2pl.github.io/2018/04/24/javase5/</id>
    <published>2018-04-23T16:30:14.000Z</published>
    <updated>2018-06-01T03:49:12.317Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了抽象类和接口的使用方法和区别</p><p>具体代码在我的GitHub中可以找到</p><blockquote><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p></blockquote><p>喜欢的话麻烦点下星哈</p><p>文章首发于我的个人博客：</p><blockquote><p><a href="https://h2pl.github.io/2018/04/24/javase5">https://h2pl.github.io/2018/04/24/javase5</a></p></blockquote><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：</p><p><a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a><br><a id="more"></a></p><blockquote><p>1 抽象类一般会实现一部分操作，并且留一些抽象方法让子类自己实现，比如Stringbuffer和Stringbuilder的父类abstractStringbuilder。</p></blockquote><blockquote><p>2 接口一般指一种规定，比如一个map接口中，可能需要实现增删改查等功能，如果你想实现一个具体map，这些方法就必须按照规定去实现。</p></blockquote><blockquote><p>3 另外，一个类可以实现多个接口，但是不能继承多个类。<br>然而接口却可以继承多个其他接口。这一点很神奇。</p></blockquote><p>下面看一下具体的例子，有一些小细节平时可能不会注意。</p><pre><code>class A {}interface M extends N,L{}interface N{}interface L{}interface 接口 {    public final int i = 1;//变量默认都为public final修饰    final A a = null;//基本数据类型和引用都一样    //protected void a();//报错    //private //报错    public abstract void a();// 方法都是public abstract修饰的。    //void b(){} 报错，接口里的方法不能有方法体，也不能有{}，只能有()；    // final void b();    // 注意，抽象方法不能加final。因为final方法不能被重写。    //但如果抽象方法不被重写那就没有意义了，因为他根本没有代码体。}abstract class 抽象类 {    public final int i = 1;//变量并没有被pulic和final修饰，只是一般的成员变量    public final A a = null;    private void A(){}//抽象类可以有具体方法    abstract void AA();//抽象方法没有方法体    //private abstract void B();//报错，组合非法    // 因为private修饰的方法无法被子类重写，所以和final一样，使抽象方法无法被实现。}//抽象类也可以被实例化，举例说明abstract class B{    B() {        System.out.println(&quot;b init&quot;);    }}class C extends B{    C(){        super();        System.out.println(&quot;c init&quot;);    }}public class 接口对比抽象类 {    @Test    public void test() {        C c = new C();        //结果先实例化B，再实例化C。        //因为会调用到父类的构造方法。    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了抽象类和接口的使用方法和区别&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下星哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/04/24/javase5&quot;&gt;https://h2pl.github.io/2018/04/24/javase5&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java基础" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>java基础4：深入理解final关键字</title>
    <link href="http://h2pl.github.io/2018/04/23/javase4/"/>
    <id>http://h2pl.github.io/2018/04/23/javase4/</id>
    <published>2018-04-23T03:41:32.000Z</published>
    <updated>2018-06-11T12:42:10.770Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了final关键字的使用方法及原理</p><p>具体代码在我的GitHub中可以找到</p><blockquote><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p></blockquote><p>喜欢的话麻烦点下星哈</p><p>文章首发于我的个人博客：</p><blockquote><p><a href="https://h2pl.github.io/2018/04/23/javase4">https://h2pl.github.io/2018/04/23/javase4</a></p></blockquote><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：</p><p><a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a><br><a id="more"></a></p><blockquote><p>final关键字可以修饰类、方法和引用。</p><p>修饰类，该类不能被继承。并且这个类的对象在堆中分配内存后地址不可变。</p><p>修饰方法，方法不能被子类重写。</p><p>修饰引用，引用无法改变，对于基本类型，无法修改值，对于引用，虽然不能修改地址值，但是可以对指向对象的内部进行修改。</p></blockquote><p>比如char[0] = ‘a’。不改变对象内存地址，只改变了值。</p><p>具体看一下下面的栗子：</p><p>final class Fi {<br>        int a;<br>        final int b = 0;<br>        Integer s;</p><pre><code>}class Si{    //一般情况下final修饰的变量一定要被初始化。    //只有下面这种情况例外，要求该变量必须在构造方法中被初始化。    //并且不能有空参数的构造方法。    //这样就可以让每个实例都有一个不同的变量，并且这个变量在每个实例中只会被初始化一次    //于是这个变量在单个实例里就是常量了。    final int s ;    Si(int s) {        this.s = s;    }}class Bi {    final int a = 1;    final void go() {        //final修饰方法无法被继承    }}class Ci extends Bi {    final int a = 1;//        void go() {//            //final修饰方法无法被继承//        }}final char[]a = {&apos;a&apos;};final int[]b = {1};</code></pre><h2 id="final修饰类"><a href="#final修饰类" class="headerlink" title="final修饰类"></a>final修饰类</h2><pre><code>@Testpublic void final修饰类() {    //引用没有被final修饰，所以是可变的。    //final只修饰了Fi类型，即Fi实例化的对象在堆中内存地址是不可变的。    //虽然内存地址不可变，但是可以对内部的数据做改变。    Fi f = new Fi();    f.a = 1;    System.out.println(f);    f.a = 2;    System.out.println(f);    //改变实例中的值并不改变内存地址。    Fi ff = f;    //让引用指向新的Fi对象，原来的f对象由新的引用ff持有。    //引用的指向改变也不会改变原来对象的地址    f = new Fi();    System.out.println(f);    System.out.println(ff);}</code></pre><h2 id="final修饰方法"><a href="#final修饰方法" class="headerlink" title="final修饰方法"></a>final修饰方法</h2><pre><code>@Testpublic void final修饰方法() {    Bi bi = new Bi();    bi.go();//该方法无法被子类Ci重写}</code></pre><h2 id="final修饰基本数据类型变量和引用"><a href="#final修饰基本数据类型变量和引用" class="headerlink" title="final修饰基本数据类型变量和引用"></a>final修饰基本数据类型变量和引用</h2><pre><code>@Testpublic void final修饰基本类型变量和引用() {    final int a = 1;    final int[] b = {1};    final int[] c = {1};//  b = c;报错    b[0] = 1;    final String aa = &quot;a&quot;;    final Fi f = new Fi();    //aa = &quot;b&quot;;报错    // f = null;//报错    f.a = 1;}</code></pre><p>关于字符串的内容可以在上一节查看：</p><p><a href="https://blog.csdn.net/a724888/article/details/80042298" target="_blank" rel="noopener">https://blog.csdn.net/a724888/article/details/80042298</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了final关键字的使用方法及原理&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下星哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/04/23/javase4&quot;&gt;https://h2pl.github.io/2018/04/23/javase4&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java基础" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础3：深入理解String及包装类</title>
    <link href="http://h2pl.github.io/2018/04/23/javase3/"/>
    <id>http://h2pl.github.io/2018/04/23/javase3/</id>
    <published>2018-04-23T03:35:30.000Z</published>
    <updated>2018-06-11T12:42:17.384Z</updated>
    
    <content type="html"><![CDATA[<p>本节主要介绍字符串类型和相关包装类的使用和原理。</p><p>具体代码在我的GitHub中可以找到</p><blockquote><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p></blockquote><p>喜欢的话麻烦点下星哈</p><p>文章首发于我的个人博客：</p><blockquote><p><a href="https://h2pl.github.io/2018/04/23/javase3">https://h2pl.github.io/2018/04/23/javase3</a></p></blockquote><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：</p><p><a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a><br><a id="more"></a></p><h2 id="String的连接"><a href="#String的连接" class="headerlink" title="String的连接"></a>String的连接</h2><pre><code>@Testpublic void contact () {    //1连接方式    String s1 = &quot;a&quot;;    String s2 = &quot;a&quot;;    String s3 = &quot;a&quot; + s2;    String s4 = &quot;a&quot; + &quot;a&quot;;    String s5 = s1 + s2;    //表达式只有常量时，编译期完成计算    //表达式有变量时，运行期才计算，所以地址不一样    System.out.println(s3 == s4); //f    System.out.println(s3 == s5); //f    System.out.println(s4 == &quot;aa&quot;); //t}</code></pre><h2 id="String类型的intern"><a href="#String类型的intern" class="headerlink" title="String类型的intern"></a>String类型的intern</h2><pre><code>public void intern () {    //2：string的intern使用    //s1是基本类型，比较值。s2是string实例，比较实例地址    //字符串类型用equals方法比较时只会比较值    String s1 = &quot;a&quot;;    String s2 = new String(&quot;a&quot;);    //调用intern时,如果s2中的字符不在常量池，则加入常量池并返回常量的引用    String s3 = s2.intern();    System.out.println(s1 == s2);    System.out.println(s1 == s3);}</code></pre><h2 id="String类型的equals"><a href="#String类型的equals" class="headerlink" title="String类型的equals"></a>String类型的equals</h2><pre><code>//字符串的equals方法//    public boolean equals(Object anObject) {//            if (this == anObject) {//                return true;//            }//            if (anObject instanceof String) {//                String anotherString = (String)anObject;//                int n = value.length;//                if (n == anotherString.value.length) {//                    char v1[] = value;//                    char v2[] = anotherString.value;//                    int i = 0;//                    while (n-- != 0) {//                        if (v1[i] != v2[i])//                            return false;//                        i++;//                    }//                    return true;//                }//            }//            return false;//        }</code></pre><h2 id="StringBuffer和Stringbuilder"><a href="#StringBuffer和Stringbuilder" class="headerlink" title="StringBuffer和Stringbuilder"></a>StringBuffer和Stringbuilder</h2><p>底层是继承父类的可变字符数组value</p><pre><code>/** * The value is used for character storage. */char[] value;初始化容量为16/** * Constructs a string builder with no characters in it and an * initial capacity of 16 characters. */public StringBuilder() {    super(16);}这两个类的append方法都是来自父类AbstractStringBuilder的方法public AbstractStringBuilder append(String str) {    if (str == null)        return appendNull();    int len = str.length();    ensureCapacityInternal(count + len);    str.getChars(0, len, value, count);    count += len;    return this;}@Overridepublic StringBuilder append(String str) {    super.append(str);    return this;}@Overridepublic synchronized StringBuffer append(String str) {    toStringCache = null;    super.append(str);    return this;}</code></pre><h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><pre><code>Stringbuffer在大部分涉及字符串修改的操作上加了synchronized关键字来保证线程安全，效率较低。String类型在使用 + 运算符例如String a = &quot;a&quot;a = a + a;时，实际上先把a封装成stringbuilder，调用append方法后再用tostring返回，所以当大量使用字符串加法时，会大量地生成stringbuilder实例，这是十分浪费的，这种时候应该用stringbuilder来代替string。</code></pre><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><pre><code>#注意在append方法中调用到了一个函数ensureCapacityInternal(count + len);该方法是计算append之后的空间是否足够，不足的话需要进行扩容public void ensureCapacity(int minimumCapacity) {    if (minimumCapacity &gt; 0)        ensureCapacityInternal(minimumCapacity);}private void ensureCapacityInternal(int minimumCapacity) {    // overflow-conscious code    if (minimumCapacity - value.length &gt; 0) {        value = Arrays.copyOf(value,                newCapacity(minimumCapacity));    }}如果新字符串长度大于value数组长度则进行扩容扩容后的长度一般为原来的两倍 + 2；假如扩容后的长度超过了jvm支持的最大数组长度MAX_ARRAY_SIZE。考虑两种情况如果新的字符串长度超过int最大值，则抛出异常，否则直接使用数组最大长度作为新数组的长度。private int hugeCapacity(int minCapacity) {    if (Integer.MAX_VALUE - minCapacity &lt; 0) { // overflow        throw new OutOfMemoryError();    }    return (minCapacity &gt; MAX_ARRAY_SIZE)        ? minCapacity : MAX_ARRAY_SIZE;}</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><pre><code>这两个类型的删除操作：都是调用父类的delete方法进行删除public AbstractStringBuilder delete(int start, int end) {    if (start &lt; 0)        throw new StringIndexOutOfBoundsException(start);    if (end &gt; count)        end = count;    if (start &gt; end)        throw new StringIndexOutOfBoundsException();    int len = end - start;    if (len &gt; 0) {        System.arraycopy(value, start+len, value, start, count-end);        count -= len;    }    return this;}事实上是将剩余的字符重新拷贝到字符数组value。</code></pre><p>这里用到了system.arraycopy来拷贝数组，速度是比较快的</p><h2 id="system-arraycopy方法"><a href="#system-arraycopy方法" class="headerlink" title="system.arraycopy方法"></a>system.arraycopy方法</h2><pre><code>转自知乎：在主流高性能的JVM上（HotSpot VM系、IBM J9 VM系、JRockit系等等），可以认为System.arraycopy()在拷贝数组时是可靠高效的——如果发现不够高效的情况，请报告performance bug，肯定很快就会得到改进。java.lang.System.arraycopy()方法在Java代码里声明为一个native方法。所以最naïve的实现方式就是通过JNI调用JVM里的native代码来实现。</code></pre><h2 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h2><p>关于String的不可变性，这里转一个不错的回答</p><h3 id="什么是不可变？"><a href="#什么是不可变？" class="headerlink" title="什么是不可变？"></a>什么是不可变？</h3><p>String不可变很简单，如下图，给一个已有字符串”abcd”第二次赋值成”abcedl”，不是在原内存地址上修改数据，而是重新指向一个新对象，新地址。<br><img src="https://pic1.zhimg.com/80/46c03ae5abf6111879423f38375207cc_hd.jpg" alt="image">     </p><h3 id="String为什么不可变？"><a href="#String为什么不可变？" class="headerlink" title="String为什么不可变？"></a>String为什么不可变？</h3><p>翻开JDK源码，java.lang.String类起手前三行，是这样写的：</p><pre><code>public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {     /** String本质是个char数组. 而且用final关键字修饰.*/     private final char value[];  ...  ... } </code></pre><p>首先String类是用final关键字修饰，这说明String不可继承。再看下面，String类的主力成员字段value是个char[]数组，而且是用final修饰的。</p><p>final修饰的字段创建以后就不可改变。  有的人以为故事就这样完了，其实没有。因为虽然value是不可变，也只是value这个引用地址不可变。挡不住Array数组是可变的事实。</p><p>Array的数据结构看下图。<br><img src="https://pic2.zhimg.com/80/356d116d3fd43b622fc9721d399f5631_hd.jpg" alt="image">    </p><p>也就是说Array变量只是stack上的一个引用，数组的本体结构在heap堆。</p><p>String类里的value用final修饰，只是说stack里的这个叫value的引用地址不可变。没有说堆里array本身数据不可变。看下面这个例子，  </p><pre><code>final int[] value={1,2,3} ；int[] another={4,5,6}; value=another;    //编译器报错，final不可变 value用final修饰，编译器不允许我把value指向堆区另一个地址。但如果我直接对数组元素动手，分分钟搞定。 final int[] value={1,2,3}; value[2]=100;  //这时候数组里已经是{1,2,100}   所以String是不可变，关键是因为SUN公司的工程师。 在后面所有String的方法里很小心的没有去动Array里的元素，没有暴露内部成员字段。private final char value[]这一句里，private的私有访问权限的作用都比final大。而且设计师还很小心地把整个String设成final禁止继承，避免被其他人继承后破坏。所以String是不可变的关键都在底层的实现，而不是一个final。考验的是工程师构造数据类型，封装数据的功力。 </code></pre><h3 id="不可变有什么好处？"><a href="#不可变有什么好处？" class="headerlink" title="不可变有什么好处？"></a>不可变有什么好处？</h3><p>这个最简单地原因，就是为了安全。看下面这个场景（有评论反应例子不够清楚，现在完整地写出来），一个函数appendStr( )在不可变的String参数后面加上一段“bbb”后返回。appendSb( )负责在可变的StringBuilder后面加“bbb”。</p><p>总结以下String的不可变性。</p><blockquote><p>1 首先final修饰的类只保证不能被继承，并且该类的对象在堆内存中的地址不会被改变。</p><p>2 但是持有String对象的引用本身是可以改变的，比如他可以指向其他的对象。</p></blockquote><blockquote><p>3 final修饰的char数组保证了char数组的引用不可变。但是可以通过char[0] = ‘a’来修改值。不过String内部并不提供方法来完成这一操作，所以String的不可变也是基于代码封装和访问控制的。</p></blockquote><p>举个例子</p><pre><code>final class Fi {    int a;    final int b = 0;    Integer s;}final char[]a = {&apos;a&apos;};final int[]b = {1};@Testpublic void final修饰类() {    //引用没有被final修饰，所以是可变的。    //final只修饰了Fi类型，即Fi实例化的对象在堆中内存地址是不可变的。    //虽然内存地址不可变，但是可以对内部的数据做改变。    Fi f = new Fi();    f.a = 1;    System.out.println(f);    f.a = 2;    System.out.println(f);    //改变实例中的值并不改变内存地址。    Fi ff = f;    //让引用指向新的Fi对象，原来的f对象由新的引用ff持有。    //引用的指向改变也不会改变原来对象的地址    f = new Fi();    System.out.println(f);    System.out.println(ff);}这里的对f.a的修改可以理解为char[0] = &apos;a&apos;这样的操作。只改变数据值，不改变内存值。</code></pre><p>有关常量池和intern的内容在上一节讲到了。</p><p>具体参考：<a href="https://blog.csdn.net/a724888/article/details/80041698" target="_blank" rel="noopener">https://blog.csdn.net/a724888/article/details/80041698</a></p><p>下一节重讲一下final关键字。</p><p>具体参考：<a href="https://blog.csdn.net/a724888/article/details/80045107" target="_blank" rel="noopener">https://blog.csdn.net/a724888/article/details/80045107</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节主要介绍字符串类型和相关包装类的使用和原理。&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下星哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/04/23/javase3&quot;&gt;https://h2pl.github.io/2018/04/23/javase3&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java基础" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础2：基本数据类型与常量池</title>
    <link href="http://h2pl.github.io/2018/04/23/javase2/"/>
    <id>http://h2pl.github.io/2018/04/23/javase2/</id>
    <published>2018-04-23T03:05:07.000Z</published>
    <updated>2018-06-01T03:49:51.541Z</updated>
    
    <content type="html"><![CDATA[<p>本节主要介绍基本数据类型的大小，自动拆箱装箱，基本数据类型的存储方式，以及常量池的原理。</p><p>具体代码在我的GitHub中可以找到</p><blockquote><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p></blockquote><p>喜欢的话麻烦点下星哈</p><p>文章首发于我的个人博客：</p><blockquote><p><a href="https://h2pl.github.io/2018/04/23/javase2">https://h2pl.github.io/2018/04/23/javase2</a></p></blockquote><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：</p><p><a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a><br><a id="more"></a></p><h2 id="基本数据类型的大小"><a href="#基本数据类型的大小" class="headerlink" title="基本数据类型的大小"></a>基本数据类型的大小</h2><pre><code>int 32位 4字节  short 16位float 32位double 64位long 64位char 16位byte 8位boolean 1位自动拆箱和装箱的意思就是，计算数值时，integer会自动转为int进行计算。而当int传入类型为integer的引用时，int数值又会被包装为integer。</code></pre><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//8位</span></span><br><span class="line"><span class="keyword">byte</span> bx = <span class="keyword">Byte</span>.MAX_VALUE;</span><br><span class="line"><span class="keyword">byte</span> bn = <span class="keyword">Byte</span>.MIN_VALUE;</span><br><span class="line"><span class="comment">//16位</span></span><br><span class="line"><span class="keyword">short</span> sx = <span class="keyword">Short</span>.MAX_VALUE;</span><br><span class="line"><span class="keyword">short</span> sn = <span class="keyword">Short</span>.MIN_VALUE;</span><br><span class="line"><span class="comment">//32位</span></span><br><span class="line"><span class="keyword">int</span> ix = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">int</span> in = Integer.MIN_VALUE;</span><br><span class="line"><span class="comment">//64位</span></span><br><span class="line"><span class="keyword">long</span> lx = <span class="keyword">Long</span>.MAX_VALUE;</span><br><span class="line"><span class="keyword">long</span> ln = <span class="keyword">Long</span>.MIN_VALUE;</span><br><span class="line"><span class="comment">//32位</span></span><br><span class="line"><span class="keyword">float</span> fx = <span class="keyword">Float</span>.MAX_VALUE;</span><br><span class="line"><span class="keyword">float</span> fn = <span class="keyword">Float</span>.MIN_VALUE;</span><br><span class="line"><span class="comment">//64位</span></span><br><span class="line"><span class="keyword">double</span> dx = <span class="keyword">Double</span>.MAX_VALUE;</span><br><span class="line"><span class="keyword">double</span> dn = <span class="keyword">Double</span>.MIN_VALUE;</span><br><span class="line"><span class="comment">//16位</span></span><br><span class="line"><span class="keyword">char</span> cx = Character.MAX_VALUE;</span><br><span class="line"><span class="keyword">char</span> cn = Character.MIN_VALUE;</span><br><span class="line"><span class="comment">//1位</span></span><br><span class="line"><span class="keyword">boolean</span> bt = <span class="keyword">Boolean</span>.<span class="keyword">TRUE</span>;</span><br><span class="line"><span class="keyword">boolean</span> bf = <span class="keyword">Boolean</span>.<span class="keyword">FALSE</span>;</span><br></pre></td></tr></table></figure><h2 id="自动拆箱和装箱"><a href="#自动拆箱和装箱" class="headerlink" title="自动拆箱和装箱"></a>自动拆箱和装箱</h2><pre><code>//基本数据类型的常量池是-128到127之间。// 在这个范围中的基本数据类的包装类可以自动拆箱，比较时直接比较数值大小。public static void main(String[] args) {    //int的自动拆箱和装箱只在-128到127范围中进行，超过该范围的两个integer的 == 判断是会返回false的。    Integer a1 = 128;    Integer a2 = -128;    Integer a3 = -128;    Integer a4 = 128;    System.out.println(a1 == a4);    System.out.println(a2 == a3);    Byte b1 = 127;    Byte b2 = 127;    Byte b3 = -128;    Byte b4 = -128;    //byte都是相等的，因为范围就在-128到127之间    System.out.println(b1 == b2);    System.out.println(b3 == b4);    //    Long c1 = 128L;    Long c2 = 128L;    Long c3 = -128L;    Long c4 = -128L;    System.out.println(c1 == c2);    System.out.println(c3 == c4);    //char没有负值    //发现char也是在0到127之间自动拆箱    Character d1 = 128;    Character d2 = 128;    Character d3 = 127;    Character d4 = 127;    System.out.println(d1 == d2);    System.out.println(d3 == d4);    Integer i = 10;    Byte b = 10;    //比较Byte和Integer.两个对象无法直接比较，报错    //System.out.println(i == b);    System.out.println(&quot;i == b &quot; + i.equals(b));    //答案是false,因为包装类的比较时先比较是否是同一个类，不是的话直接返回false.    int ii = 128;    short ss = 128;    long ll = 128;    char cc = 128;    System.out.println(&quot;ii == bb &quot; + (ii == ss));    System.out.println(&quot;ii == ll &quot; + (ii == ll));    System.out.println(&quot;ii == cc &quot; + (ii == cc));    //这时候都是true，因为基本数据类型直接比较值，值一样就可以。</code></pre><p>总结：注意基本数据类型的拆箱装箱，以及对常量池的理解。</p><h2 id="基本数据类型的存储方式"><a href="#基本数据类型的存储方式" class="headerlink" title="基本数据类型的存储方式"></a>基本数据类型的存储方式</h2><pre><code>上面自动拆箱和装箱的原理其实与常量池有关。3.1存在栈中：public void(int a){int i = 1;int j = 1;}方法中的i 存在虚拟机栈的局部变量表里，i是一个引用，j也是一个引用，它们都指向局部变量表里的整型值 1.int a是传值引用，所以a也会存在局部变量表。3.2存在堆里：class A{int i = 1;A a = new A();}i是类的成员变量。类实例化的对象存在堆中，所以成员变量也存在堆中，引用a存的是对象的地址，引用i存的是值，这个值1也会存在堆中。可以理解为引用i指向了这个值1。也可以理解为i就是1.3.3包装类对象怎么存其实我们说的常量池也可以叫对象池。比如String a= new String(&quot;a&quot;).intern()时会先在常量池找是否有“a&quot;对象如果有的话直接返回“a&quot;对象在常量池的地址，即让引用a指向常量”a&quot;对象的内存地址。public native String intern();Integer也是同理。</code></pre><p>下图是Integer类型在常量池中查找同值对象的方法。</p><pre><code>public static Integer valueOf(int i) {    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)        return IntegerCache.cache[i + (-IntegerCache.low)];    return new Integer(i);}private static class IntegerCache {    static final int low = -128;    static final int high;    static final Integer cache[];    static {        // high value may be configured by property        int h = 127;        String integerCacheHighPropValue =            sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);        if (integerCacheHighPropValue != null) {            try {                int i = parseInt(integerCacheHighPropValue);                i = Math.max(i, 127);                // Maximum array size is Integer.MAX_VALUE                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);            } catch( NumberFormatException nfe) {                // If the property cannot be parsed into an int, ignore it.            }        }        high = h;        cache = new Integer[(high - low) + 1];        int j = low;        for(int k = 0; k &lt; cache.length; k++)            cache[k] = new Integer(j++);        // range [-128, 127] must be interned (JLS7 5.1.7)        assert IntegerCache.high &gt;= 127;    }    private IntegerCache() {}}</code></pre><p>所以基本数据类型的包装类型可以在常量池查找对应值的对象，找不到就会自动在常量池创建该值的对象。</p><p>而String类型可以通过intern来完成这个操作。</p><p>JDK1.7后，常量池被放入到堆空间中，这导致intern()函数的功能不同，具体怎么个不同法，且看看下面代码，这个例子是网上流传较广的一个例子，分析图也是直接粘贴过来的，这里我会用自己的理解去解释这个例子：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">java] </span>view plain copy</span><br><span class="line">String s = new String(<span class="string">"1"</span>)<span class="comment">;  </span></span><br><span class="line">s.intern()<span class="comment">;  </span></span><br><span class="line">String <span class="built_in">s2</span> = <span class="string">"1"</span><span class="comment">;  </span></span><br><span class="line">System.out.println(s == <span class="built_in">s2</span>)<span class="comment">;  </span></span><br><span class="line">  </span><br><span class="line">String <span class="built_in">s3</span> = new String(<span class="string">"1"</span>) + new String(<span class="string">"1"</span>)<span class="comment">;  </span></span><br><span class="line"><span class="built_in">s3</span>.intern()<span class="comment">;  </span></span><br><span class="line">String <span class="built_in">s4</span> = <span class="string">"11"</span><span class="comment">;  </span></span><br><span class="line">System.out.println(<span class="built_in">s3</span> == <span class="built_in">s4</span>)<span class="comment">;  </span></span><br><span class="line">输出结果为：</span><br><span class="line"></span><br><span class="line">[<span class="keyword">java] </span>view plain copy</span><br><span class="line"><span class="keyword">JDK1.6以及以下：false </span>false  </span><br><span class="line"><span class="keyword">JDK1.7以及以上：false </span>true</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180422231916788?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3MjQ4ODg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p><p><img src="https://img-blog.csdn.net/20180422231929413?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3MjQ4ODg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"><br>JDK1.6查找到常量池存在相同值的对象时会直接返回该对象的地址。</p><p>JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。</p><p>那么其他字符串在常量池找值时就会返回另一个堆中对象的地址。</p><p>下一节详细介绍String以及相关包装类。</p><p>具体请见：<a href="https://blog.csdn.net/a724888/article/details/80042298" target="_blank" rel="noopener">https://blog.csdn.net/a724888/article/details/80042298</a></p><p>关于Java面向对象三大特性，请参考：</p><p><a href="https://blog.csdn.net/a724888/article/details/80033043" target="_blank" rel="noopener">https://blog.csdn.net/a724888/article/details/80033043</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节主要介绍基本数据类型的大小，自动拆箱装箱，基本数据类型的存储方式，以及常量池的原理。&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下星哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/04/23/javase2&quot;&gt;https://h2pl.github.io/2018/04/23/javase2&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java基础" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础1：理解Java面向对象三大特性</title>
    <link href="http://h2pl.github.io/2018/04/22/javase1/"/>
    <id>http://h2pl.github.io/2018/04/22/javase1/</id>
    <published>2018-04-21T16:51:35.000Z</published>
    <updated>2018-06-11T12:42:23.969Z</updated>
    
    <content type="html"><![CDATA[<p>具体代码在我的GitHub中可以找到：</p><blockquote><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p></blockquote><p>喜欢的话麻烦点下星哈</p><p>文章首发于我的个人博客：</p><blockquote><p><a href="https://h2pl.github.io/2018/04/22/javase1">https://h2pl.github.io/2018/04/22/javase1</a></p></blockquote><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：</p><blockquote><p><a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a></p></blockquote><p>本节主要介绍Java面向对象三大特性：继承 封装 多态，以及其中的原理。</p><p>本文会结合虚拟机对引用和对象的不同处理来介绍三大特性的原理。</p><a id="more"></a><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>Java中的继承只能单继承，但是可以通过内部类继承其他类来实现多继承。</p><pre><code>public class Son extends Father{public void go () {System.out.println(&quot;son go&quot;);}public void eat () {System.out.println(&quot;son eat&quot;);}public void sleep() {System.out.println(&quot;zzzzzz&quot;);}public void cook() {//匿名内部类实现的多继承new Mother().cook();//内部类继承第二个父类来实现多继承Mom mom = new Mom();mom.cook();}private class Mom extends Mother {@Overridepublic void cook() {System.out.println(&quot;mom cook&quot;);}}}</code></pre><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装主要是因为Java有访问权限的控制。public &gt; protected &gt; package = default &gt; private。封装可以保护类中的信息，只提供想要被外界访问的信息。</p><p>类的访问范围</p><pre><code> A、public    包内、包外，所有类中可见B、protected    包内所有类可见，包外有继承关系的子类可见(子类对象可调用)C、(default)表示默认，不仅本类访问，而且是同包可。D、private    仅在同一类中可见 </code></pre><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态一般可以分为两种，一个是重写overwrite，一个是重载override。</p><pre><code>重写是由于继承关系中的子类有一个和父类同名同参数的方法，会覆盖掉父类的方法。重载是因为一个同名方法可以传入多个参数组合。注意，同名方法如果参数相同，即使返回值不同也是不能同时存在的，编译会出错。从jvm实现的角度来看，重写又叫运行时多态，编译时看不出子类调用的是哪个方法，但是运行时操作数栈会先根据子类的引用去子类的类信息中查找方法，找不到的话再到父类的类信息中查找方法。而重载则是编译时多态，因为编译期就可以确定传入的参数组合，决定调用的具体方法是哪一个了。</code></pre><h3 id="向上转型和向下转型："><a href="#向上转型和向下转型：" class="headerlink" title="向上转型和向下转型："></a>向上转型和向下转型：</h3><pre><code>public static void main(String[] args) {    Son son = new Son();    //首先先明确一点，转型指的是左侧引用的改变。    //father引用类型是Father，指向Son实例，就是向上转型，既可以使用子类的方法，也可以使用父类的方法。    //向上转型,此时运行father的方法    Father father = son;    father.smoke();    //不能使用子类独有的方法。    // father.play();编译会报错    father.drive();    //Son类型的引用指向Father的实例，所以是向下转型，不能使用子类非重写的方法，可以使用父类的方法。    //向下转型，此时运行了son的方法    Son son1 = (Son) father;    //转型后就是一个正常的Son实例    son1.play();    son1.drive();    son1.smoke();    //因为向下转型之前必须先经历向上转型。    //在向下转型过程中，分为两种情况：    //情况一：如果父类引用的对象如果引用的是指向的子类对象，    //那么在向下转型的过程中是安全的。也就是编译是不会出错误的。    //因为运行期Son实例确实有这些方法    Father f1 = new Son();    Son s1 = (Son) f1;    s1.smoke();    s1.drive();    s1.play();    //情况二：如果父类引用的对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错，    //但是运行时会出现java.lang.ClassCastException错误。它可以使用instanceof来避免出错此类错误。    //因为运行期Father实例并没有这些方法。        Father f2 = new Father();        Son s2 = (Son) f2;        s2.drive();        s2.smoke();        s2.play();    //向下转型和向上转型的应用，有些人觉得这个操作没意义，何必先向上转型再向下转型呢，不是多此一举么。其实可以用于方法参数中的类型聚合，然后具体操作再进行分解。    //比如add方法用List引用类型作为参数传入，传入具体类时经历了向下转型    add(new LinkedList());    add(new ArrayList());    //总结    //向上转型和向下转型都是针对引用的转型，是编译期进行的转型，根据引用类型来判断使用哪个方法    //并且在传入方法时会自动进行转型（有需要的话）。运行期将引用指向实例，如果是不安全的转型则会报错。    //若安全则继续执行方法。}public static void add(List list) {    System.out.println(list);    //在操作具体集合时又经历了向上转型//        ArrayList arr = (ArrayList) list;//        LinkedList link = (LinkedList) list;}</code></pre><p>总结：<br>向上转型和向下转型都是针对引用的转型，是编译期进行的转型，根据引用类型来判断使用哪个方法。并且在传入方法时会自动进行转型（有需要的话）。运行期将引用指向实例，如果是不安全的转型则会报错，若安全则继续执行方法。</p><h3 id="编译期的静态分派"><a href="#编译期的静态分派" class="headerlink" title="编译期的静态分派"></a>编译期的静态分派</h3><p>其实就是根据引用类型来调用对应方法。</p><pre><code>public static void main(String[] args) {    Father father  = new Son();    静态分派 a= new 静态分派();    //编译期确定引用类型为Father。    //所以调用的是第一个方法。    a.play(father);    //向下转型后，引用类型为Son，此时调用第二个方法。    //所以，编译期只确定了引用，运行期再进行实例化。    a.play((Son)father);    //当没有Son引用类型的方法时，会自动向上转型调用第一个方法。    a.smoke(father);    //}public void smoke(Father father) {    System.out.println(&quot;father smoke&quot;);}public void play (Father father) {    System.out.println(&quot;father&quot;);    //father.drive();}public void play (Son son) {    System.out.println(&quot;son&quot;);    //son.drive();}</code></pre><h3 id="方法重载优先级匹配"><a href="#方法重载优先级匹配" class="headerlink" title="方法重载优先级匹配"></a>方法重载优先级匹配</h3><pre><code>public static void main(String[] args) {    方法重载优先级匹配 a = new 方法重载优先级匹配();    //普通的重载一般就是同名方法不同参数。    //这里我们来讨论当同名方法只有一个参数时的情况。    //此时会调用char参数的方法。    //当没有char参数的方法。会调用int类型的方法，如果没有int就调用long    //即存在一个调用顺序char -&gt; int -&gt; long -&gt;double -&gt; ..。    //当没有基本类型对应的方法时，先自动装箱，调用包装类方法。    //如果没有包装类方法，则调用包装类实现的接口的方法。    //最后再调用持有多个参数的char...方法。    a.eat(&apos;a&apos;);    a.eat(&apos;a&apos;,&apos;c&apos;,&apos;b&apos;);}public void eat(short i) {    System.out.println(&quot;short&quot;);}public void eat(int i) {    System.out.println(&quot;int&quot;);}public void eat(double i) {    System.out.println(&quot;double&quot;);}public void eat(long i) {    System.out.println(&quot;long&quot;);}public void eat(Character c) {    System.out.println(&quot;Character&quot;);}public void eat(Comparable c) {    System.out.println(&quot;Comparable&quot;);}public void eat(char ... c) {    System.out.println(Arrays.toString(c));    System.out.println(&quot;...&quot;);}//    public void eat(char i) {//        System.out.println(&quot;char&quot;);//    }</code></pre><p>下一节具体介绍了基本数据类型以及常量池，具体请见：</p><p><a href="https://blog.csdn.net/a724888/article/details/80041698" target="_blank" rel="noopener">https://blog.csdn.net/a724888/article/details/80041698</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;具体代码在我的GitHub中可以找到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下星哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/04/22/javase1&quot;&gt;https://h2pl.github.io/2018/04/22/javase1&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本节主要介绍Java面向对象三大特性：继承 封装 多态，以及其中的原理。&lt;/p&gt;
&lt;p&gt;本文会结合虚拟机对引用和对象的不同处理来介绍三大特性的原理。&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java基础" scheme="http://h2pl.github.io/categories/%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>我和技术博客的这一年</title>
    <link href="http://h2pl.github.io/2018/04/20/blog/"/>
    <id>http://h2pl.github.io/2018/04/20/blog/</id>
    <published>2018-04-20T07:56:26.000Z</published>
    <updated>2018-06-15T09:59:17.652Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了我从Java初学者到专注于Java后端开发技术栈的成长历程，主要是与写博客相关的内容，其他内容还包括<br>实习历程，后端技术学习历程，校招计划等内容，我会陆续发表并且提供链接。</p><p>我的GitHub：</p><blockquote><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p></blockquote><p>喜欢的话麻烦点下星哈</p><p>文章首发于我的个人博客：</p><blockquote><p><a href="https://h2pl.github.io/2018/04/20/blog">https://h2pl.github.io/2018/04/20/blog</a></p></blockquote><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：</p><p><a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a></p><p>Java后端学习之路 <a href="https://blog.csdn.net/a724888/article/details/60879893" target="_blank" rel="noopener">https://blog.csdn.net/a724888/article/details/60879893</a></p><a id="more"></a><p>下面是正文：</p><h2 id="梦开始的地方"><a href="#梦开始的地方" class="headerlink" title="梦开始的地方"></a>梦开始的地方</h2><p>&emsp;&emsp;2017年初开了这个博客，转眼也一年多时间了。最早在博客园开的博客，后来感觉csdn生态更好一点，于是转移到csdn。恰逢这段时间在做学校的课题，于是最开始的时候记录了一些项目搭建以及开发中遇到的题以及解决方案。当时技术还比较稚嫩，属于刚刚入门Java web的阶段。所以博客内容也比较一般。</p><h2 id="博客记录我的成长"><a href="#博客记录我的成长" class="headerlink" title="博客记录我的成长"></a>博客记录我的成长</h2><p>&emsp;&emsp;去年的春天我投入到浩瀚的春招大军中去了，也是那个时候确定了做Java开发的方向，当时对后台技术还不是太了解，主要从Java以及Java web入手，开始了一系列的学习和准备。这篇文章主要讲博客的历程，如果对我的学习历程有兴趣的朋友可以查看最上方的链接。<br>&emsp;&emsp;项目结束以后，主要在复习Java基础，于是看了不少相关博客，记录了很多Java的基础知识点，比如异常，反射，序列化，集合类等等内容的一些总结，现在看来确实有点幼稚了。所以我最近也在删除一些低质量的文章，以便让大家能看到更好的内容。<br>&emsp;&emsp;在准备春招实习面试期间，我花了大量时间阅读技术书籍以及博客，并且总结了一部分面经，同时将一些比较好的总结发在了博客上，以便我在复习期间能够阅读和复习，所以有一段时间发了大量的博文，多得连我自己都怕。当然我并不推荐这种做法，在后来的日子里，基本上是定期地发一些有一定质量的文章，尽量自己理清文章内容后再进行发布，否则可能有会滥竽充数的情况。<br>&emsp;&emsp;除此之外也记录了一些工程方面的内容，例Maven，git，Tomcat，以及IDE的使用，以及MySQL的一些使用经验，由于有段时间在W厂实习，所以当时主要记录的是实习过程中用的技术栈以及相关开发tips。<br>&emsp;&emsp;离开W厂之后，我来到了B厂，部门做的主要是云计算，于是记录了一些云计算相关的文章，比如OpenStack，docker，kubenetes等内容。B厂是技术为主导的公司，内部经常举办技术交流会以及分享会，我通常都会报名参加，了解了一部分AI和大数据的应用以及实现原理。所以这段时间主要会发一些AI以及Hadoop的文章，让我更全面了解相关技术。</p><h2 id="最好的总结就是读书笔记"><a href="#最好的总结就是读书笔记" class="headerlink" title="最好的总结就是读书笔记"></a>最好的总结就是读书笔记</h2><p>&emsp;&emsp;在百度的这段时间里，我意识到了我的基础可能还是不够牢固。因为是非科班出身，虽然是硕士，但是基础还是有一些欠缺，这段时间我看了许多更加底层的东西，比如网络，操作系统，Linux内核，其中那一本《深入理解计算机系统》确实是不错的总结性书籍，基本可以带你概览计算机系统的全貌。<br>&emsp;&emsp;因此，在这段时间里我写了不少的读书笔记等总结性文章，主要囊括了操作系统，计算机网络，Linux等内容。我发现写读书笔记是加深对原书理解的很好的途径，于是我把以前看过的一些书拿出来又翻了几遍，例如JVM虚拟机，java并发实战，大型网站架构滴滴，所以我干脆把其他书的读书笔记也整理出来了，不过有一些书过于晦涩或者是太厚，也借鉴了一些博友的读书笔记。当然有很多文章还不够成熟。</p><h2 id="不积跬步无以至千里"><a href="#不积跬步无以至千里" class="headerlink" title="不积跬步无以至千里"></a>不积跬步无以至千里</h2><p>&emsp;&emsp;大公司面试时，会给你一种感觉，就是无孔不入，细节决定成败，往往粗浅的总结难以让你理解技术深层次的原理，缺乏实践或者是深入思考，可能会让你错过很多重要的知识点，而往往这些知识点是大厂面试官喜欢问的。<br>&emsp;&emsp;就拿Java来说，jvm虚拟机垃圾回收器的具体回收过程，可以问的很深入，问到gcRoots，停顿多少次，是否并发回收等，这些问题可能不是对gc的浅显总结可以概括的。<br>&emsp;&emsp;再比如，JUC中的Lock，平时可能只了解到lock的用法，condition，并发工具类的使用，但是Lock底层的AQS实现，可能很少去关注，AQS的相关源码晦涩难懂，推荐看大牛的解析，可以让你更好地理解lock类的实现。<br>&emsp;&emsp;其实这个想法也是前阵子我才想到的，因为看到阿里的实习面经，Java相关的原理问的特别深，没有深入到源码去理解的话，往往就会被问住。结果可想而知。所以这段时间主要的想法是只记录高质量的内容，并且尽量覆盖重要的知识点。</p><h2 id="纸上得来终觉浅，实践为王"><a href="#纸上得来终觉浅，实践为王" class="headerlink" title="纸上得来终觉浅，实践为王"></a>纸上得来终觉浅，实践为王</h2><p>&emsp;&emsp;文章写得再好，毕竟是纸面上的东西，一旦上手，可能又是另一种情况，我虽然看了不少书，也阅读了许多优质的博客，但是对于有些技术细节总觉得还是差了点，或者说，书上看来的东西，很快就忘了。其实记忆本身就是这种特点，只有实战可以让书上的知识变成你自己的。用过这个技术并且能了解其原理，才能对这个技术有发言权。所以在未来的计划里，我打算更多地写一些实战性的文章。</p><h2 id="回到原点，重新出发"><a href="#回到原点，重新出发" class="headerlink" title="回到原点，重新出发"></a>回到原点，重新出发</h2><p>&emsp;&emsp;从第一次写博客到现在，经历了很多事，有了诸多感悟，与君共勉，至于对我的观点认同与否，那就见仁见智了。脚踏实地也不要忘了仰望星空。建议做开发的朋友们都要写博客，写博客的好处很多，方便记忆，便于交流，也是打造个人品牌的一种方式，有时间自己搭博客，效果更好。<br>&emsp;&emsp;最近用b3log solo搭了博客，接下来打算用github pages + hexo来写博客。等到工作以后，可能会只用个人博客了。这可能也象征着学生时代的结束吧，新的博客不仅会有技术文章，还会分享人生感悟，csdn的话，还是主要发布技术文章。就说到这里了。希望有更多人看到。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了我从Java初学者到专注于Java后端开发技术栈的成长历程，主要是与写博客相关的内容，其他内容还包括&lt;br&gt;实习历程，后端技术学习历程，校招计划等内容，我会陆续发表并且提供链接。&lt;/p&gt;
&lt;p&gt;我的GitHub：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下星哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/04/20/blog&quot;&gt;https://h2pl.github.io/2018/04/20/blog&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Java后端学习之路 &lt;a href=&quot;https://blog.csdn.net/a724888/article/details/60879893&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888/article/details/60879893&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="个人总结" scheme="http://h2pl.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="心路历程" scheme="http://h2pl.github.io/tags/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JAVA后端开发学习之路</title>
    <link href="http://h2pl.github.io/2018/04/20/Java/"/>
    <id>http://h2pl.github.io/2018/04/20/Java/</id>
    <published>2018-04-20T07:56:26.000Z</published>
    <updated>2018-06-15T09:59:20.468Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录了我从Java初学者到专注于Java后端技术栈的开发者的学习历程。主要分享了学习过程中的一些经验和教训，让后来人看到，少走弯路，与君共勉，共同进步。如有错误，还请见谅。</p><p>我的GitHub：</p><blockquote><p><a href="https://github.com/h2pl/MyTech" target="_blank" rel="noopener">https://github.com/h2pl/MyTech</a></p></blockquote><p>喜欢的话麻烦点下星哈</p><p>文章首发于我的个人博客：</p><blockquote><p><a href="https://h2pl.github.io/2018/04/20/java">https://h2pl.github.io/2018/04/20/java</a></p></blockquote><p>更多关于Java后端学习的内容请到我的CSDN博客上查看：</p><p><a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">https://blog.csdn.net/a724888</a></p><p>相关链接：我和技术博客的这一年：<a href="https://blog.csdn.net/a724888/article/details/60879893" target="_blank" rel="noopener">https://blog.csdn.net/a724888/article/details/60879893</a></p><blockquote><p>&emsp;&emsp;不论你是不是网民，无论你远离互联网，还是沉浸其中；你的身影，都在这场伟大的迁徙洪流中。超越人类经验的大迁徙，温暖而无情地，开始了。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;—–《互联网时代》</p></blockquote><a id="more"></a><h2 id="选择方向"><a href="#选择方向" class="headerlink" title="选择方向"></a>选择方向</h2><p>&emsp;&emsp;0上大学前的那些事，让它们随风逝去吧。</p><p>&emsp;&emsp;1 个人对计算机和互联网有情怀，有兴趣，本科时在专业和学校里选择了学校，当时专业不是计算机，只能接触到一点点计算机专业课程，所以选择了考研，花半年时间复习考进了一个还不错的985，考研经历有空会发到博客上。</p><p>&emsp;&emsp;2 本科阶段接触过Java和Android，感觉app蛮有趣的，所以研一的时候想做Android，起初花大量时间看了计算机专业课的教材，效果很差。但也稍微了解了一些计算机基础，如网络，操作系统，组成原理，数据库，软工等。</p><p>&emsp;&emsp;3 在没确定方向的迷茫时期看了大量视频和科普性文章，帮助理清头绪和方向。期间了解了诸如游戏开发，c++开发，Android，Java甚至前端等方向，其中还包含游戏策划岗。</p><p>&emsp;&emsp;4 后来综合自身条件以及行业发展等因素，开始锁定自己的目标在Java后台方向。于是乎各种百度，知乎，查阅该学什么该怎么学如此类的问题，学习别人的经验。当然只靠搜索引擎很难找到精品内容，那段时间可谓是病急乱投医，走了不少弯路。</p><hr><h2 id="夯实基础"><a href="#夯实基础" class="headerlink" title="夯实基础"></a>夯实基础</h2><p>&emsp;&emsp;1 研一的工程实践课让我知道了我的基础不够扎实，由于并非科班，需要比别人更加勤奋，古语有云，天道酬勤，勤能补拙。赶上了17年的春招实习招聘，期间开始各种海投，各种大厂面试一问三不知，才知道自身差距很大，开始疯狂复习面试题，刷面经，看经验等。死记硬背，之乎者也，倒也是能应付一些小公司，可谓是临阵磨枪不快也光。</p><p>&emsp;&emsp;2 不过期间的屡屡受挫让我冷静思考了一段时间，我再度调研了岗位需求，学习方法，以及需要看的书等资料。再度开工时，我的桌上开始不断出现新的经典书籍。这还要归功于我的启蒙导师：江南白衣，在知乎上看到了他的一篇文章，我的Java后端书架。在这个书架里我找寻到了很多我想看的书，以及我需要学习的技术。</p><p>&emsp;&emsp;3 遥想研一我还在看的书：教材就不提了，脱离实际并且年代久远，而我选的入门书籍竟然还有Java web从入门到精通这种烂大街的书籍，然后就是什么Java编程思想啦，深入理解计算机系统，算法导论这种高深莫测的书，感觉有点高不成低不就的意思。要么太过难懂要么过于粗糙，这些书在当时基本上没能帮到我。</p><hr><h2 id="书籍选择"><a href="#书籍选择" class="headerlink" title="书籍选择"></a>书籍选择</h2><p>&emsp;&emsp;1 江南白衣的后端书架真是救我于水火。他的书架里收录了许多Java后端需要用到的技术书籍，并且十分经典，虽不说每本都适合入门，但是只要你用心去看都会有收获，高质量的书籍给人的启发要优于普通书籍。</p><p>&emsp;&emsp;2 每个门类的书我都挑了一些。比如网络的两本（《tcp ip卷一》以及《计算机网络自顶向下》），操作系统两本（一本《Linux内核设计与实现》，一本高级操作系统，推荐先看完《深入理解计算机系统》再来看这两本），算法看的是《数据结构与算法（Java版）》，Java的四大件（《深入理解jvm虚拟机》，《java并发编程艺术》，《深入java web技术内幕》，《Java核心技术 卷一》这本没看）。</p><p>&emsp;&emsp;3 当然还有像《Effective Java》，《Java编程思想》，《Java性能调优指南》这种，不过新手不推荐，太不友好。接着是spring的两本《Spring实战》和《Spring源码剖析》。当然也包括一些redis，mq之类的书，还有就是一些介绍分布式组件的书籍，如zk等。</p><p>&emsp;&emsp;4 接下来就是扩展的内容了，比如分布式的三大件，《大型网站架构设计与实践》，《分布式网站架构设计与实践》，《Java中间件设计与实践》，外加一本《分布式服务框架设计与实践》。这几本书一看，绝对让你打开新世界的大门，醍醐灌顶，三月不知肉味。</p><p>&emsp;&emsp;5 你以为看完这些书你就无敌了，就满足了？想得倒是挺美。这些书最多就是把我从悬崖边拉回正途，能让我在正确的道路上行走了。毕竟技术书籍这种东西还是有门槛的，没有一定的知识储备，看书的过程也绝对是十分痛苦的。</p><p>&emsp;&emsp;&emsp;&emsp;6 比如《深入理解jvm虚拟机》和《java并发编程艺术》这两本书，我看了好几遍，第一遍基本当天书来看，第二遍挑着章节看，第三遍能把全部章节都看了。所以有时候你觉得你看完了一本书，对，你确实看完了，但过段时间是你能记得多少呢。可以说是很少了。</p><hr><h2 id="谈一谈学习方法"><a href="#谈一谈学习方法" class="headerlink" title="谈一谈学习方法"></a>谈一谈学习方法</h2><p>&emsp;&emsp;1 人们在刚开始接触自己不熟悉的领域时，往往都会犯很多错误。刚开始学习Java时，就是摸着石头过河。从在极客学院慕课上看视频，到看书，再到看博客，再到工程实践，也是学习方式转变的一个过程。</p><p>&emsp;&emsp;2 看视频：适合0基础小白，视频给你构建一个世界观，让你对你要做的东西有个大概的了解，想要深入理解其中的技术原理，只看视频的话很难。</p><p>&emsp;&emsp;3 看书：就如上面一节所说，看书是一个很重要的环节。当你对技术只停留在大概的了解和基本会用的阶段时，经典书籍能够让你深入这些技术的原理，你可能会对书里的内容感到惊叹，也可能只是一知半解。所以第一遍的阅读一般读个大概就可以。一本书要吃透，不仅要看好几遍，还要多上手实践，才能变成自己的东西。</p><p>&emsp;&emsp;4 看博客，光看一些总结性的博客或者是科普性的博客可能还不够，一开始我也经常看这样的博客，后来只看这些东西，发现对技术的理解只能停留在表面。高质量的博客一般会把一个知识点讲得很透彻，比你看十篇总结都强，例如讲jdk源码的博文，可以很好地帮助你理解其原理，避免自己看的时候一脸懵逼。这里先推荐几个博客和网站，后面写复习计划的时候，会详细写出。<br>博客：江南白衣、酷壳、战小狼。<br>网站：并发编程网，importnew。</p><p>&emsp;&emsp;5 实践为王，Java后端毕竟还是工程方向，只是通过文字去理解技术点，可能有点纸上谈兵的感觉了。还有一个问题就是，没有进行上手实践的技术，一般很快就会忘了，做一些实践可以更好地巩固知识点。如果有项目中涉及不到的知识点，可以单独拿出来做一些demo，实在难以进行实践的技术点，可以参考别人的实践过程。</p><hr><h2 id="实习，提高工程能力的好机会"><a href="#实习，提高工程能力的好机会" class="headerlink" title="实习，提高工程能力的好机会"></a>实习，提高工程能力的好机会</h2><p>&emsp;&emsp;1 这段时间以后就是实习期了，三个月的W厂实习经历。半年的B厂实习，让我着实过了一把大厂的瘾。但是其中做的工作无非就是增删改查写写业务逻辑，很难接触到比较核心的部分。</p><p>&emsp;&emsp;2 于是乎我花了许多时间学习部门的核心技术。比如在W厂参与数据平台的工作时，我学习了hadoop以及数据仓库的架构，也写了一些博客，并且向负责后端架构的导师请教了许多知识，收获颇丰。</p><p>&emsp;&emsp;3 在B厂实习期间则接触了许多云计算相关的技术。因为部门做的是私有云，所以业务代码和底层的服务也是息息相关的，比如平时的业务代码也会涉及到底层的接口调用，比如新建一个虚拟机或者启动一台虚拟机，需要通过多级的服务调用，首先是HTTP服务调用，经过多级的服务调用，最终完成流程。在这期间我花了一些时间学习了OpenStack的架构以及部门的实际应用情况，同时也玩了一下docker，看了kubenetes的一些书籍，算是入门。</p><p>&emsp;&emsp;4 但是这些东西其实离后台开发还是有一定距离的，比如后台开发的主要问题就是高并发，分布式，Linux服务器开发等。而我做的东西，只能稍微接触到这一部门的内容，因为主要是to b的内部业务。所以这段时间其实我的进步有限，虽然扩大了知识面并且积累了开发经验，但是对于后台岗位来说还是有所欠缺的。</p><p>&emsp;&emsp;5 不过将近一年的实习也让我收获了很多东西，大厂的实习体验很好，工作高效，团队合作，版本的快速迭代，技术氛围很不错。特别是在B厂了可以解到很多前沿的技术，对自己的视野扩展很有帮助。</p><hr><h2 id="实习转正，还是准备秋招？"><a href="#实习转正，还是准备秋招？" class="headerlink" title="实习转正，还是准备秋招？"></a><strong>实习转正，还是准备秋招？</strong></h2><p>&emsp;&emsp;1 离职以后，在考虑是否还要找实习，因为有两份实习经历了，在考虑要不要静下心来刷刷题，复习一下基础，并且回顾一下实习时用到的技术。同一时期，我了解到腾讯和阿里等大厂的实习留用率不高，并且可能影响到秋招，所以当时的想法是直接复习等到秋招内推。因此，那段时间比较放松，没什么复习状态，也导致了我在今年春招内推的阶段比较艰难。</p><p>&emsp;&emsp;2 因为当时想着沉住气准备秋招，所以一开始对实习内推不太在意。但是由于AT招人的实习生转正比例较大，考虑到秋招的名额可能更少，所以还是不愿意错过这个机会。因为开始系统复习的时间比较晚，所以投的比较晚，担心准备不充分被刷。这次找实习主要是奔着转正去的，所以只投了bat和滴滴，京东，网易游戏等大厂。</p><p>&emsp;&emsp;3 由于投递时间原因，所以面试的流程特别慢。并且在笔试方面还是有所欠缺，刷题刷的比较少，在线编程的算法题还是屡屡受挫。这让我有点后悔实习结束后的那段时间没有好好刷题了。</p><hr><h2 id="调整心态，重新上路"><a href="#调整心态，重新上路" class="headerlink" title="调整心态，重新上路"></a><strong>调整心态，重新上路</strong></h2><p>&emsp;&emsp;1 目前的状态是，一边刷题，一边复习基础，投了几家大厂的实习内推，打算选一个心仪的公司准备转正，但是事情总是没那么顺利，微软，头条等公司的笔试难度超过了我的能力范围，没能接到面试电话。腾讯投了一个自己比较喜欢的部门，可惜岗位没有匹配上，后台开发被转成了运营开发，最终没能通过。阿里面试的也不顺利，当时投了一个牛客上的蚂蚁金服内推，由于投的太晚，部门已经招满，只面了一面就没了下文，前几天接到了菜鸟的面试，这个未完待续。</p><p>&emsp;&emsp;2 目前的想法是，因为我不怎么需要实习经历来加分了，所以想多花些时间复习基础，刷题，并且巩固之前的项目经历。当然如果有好的岗位并且转正机会比较大的话，也是会考虑去实习的，那样的话可能需要多挤点时间来复习基础和刷题了。</p><p>&emsp;&emsp;3 在这期间，我会重新梳理一下自己的复习框架，有针对性地看一些高质量的博文，同时多做些项目实践，加深对知识的理解。当然这方面还会通过写博客进行跟进，写博客，做项目。前阵子在牛客上看到一位牛友CyC2018做的名为interview notebook的GitHub仓库，内容非常好，十分精品，我全部看完了，并且参考其LeetCode题解进行刷题。</p><p>&emsp;&emsp;4 受到这位大佬的启发，我也打算做一个类似的代码仓库或者是博客专栏，尽量在秋招之前把总结做完，并且把好的文章都放进去。上述内容只是本人个人的心得体会，如果有错误或者说的不合理的地方，还请谅解和指正。希望与广大牛友共勉，一起进步。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录了我从Java初学者到专注于Java后端技术栈的开发者的学习历程。主要分享了学习过程中的一些经验和教训，让后来人看到，少走弯路，与君共勉，共同进步。如有错误，还请见谅。&lt;/p&gt;
&lt;p&gt;我的GitHub：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下星哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/04/20/java&quot;&gt;https://h2pl.github.io/2018/04/20/java&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关链接：我和技术博客的这一年：&lt;a href=&quot;https://blog.csdn.net/a724888/article/details/60879893&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a724888/article/details/60879893&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;不论你是不是网民，无论你远离互联网，还是沉浸其中；你的身影，都在这场伟大的迁徙洪流中。超越人类经验的大迁徙，温暖而无情地，开始了。&lt;br&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;—–《互联网时代》&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="个人总结" scheme="http://h2pl.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="心路历程" scheme="http://h2pl.github.io/tags/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
  </entry>
  
</feed>
